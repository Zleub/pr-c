{
  content = {
    [".DS_Store"] = {},
    ["AssertMacros.h"] = { "/*", " * Copyright (c) 2002-2008 by Apple Inc.. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "", "", "/*", "\tFile:       AssertMacros.h", " ", "\tContains:   This file defines structured error handling and assertion macros for", "\t\t\t\tprogramming in C. Originally used in QuickDraw GX and later enhanced.", "\t\t\t\tThese macros are used throughout Apple's software.", "\t", "\t\t\t\tNew code may not want to begin adopting these macros and instead use", "\t\t\t\texisting language functionality.", "\t", '\t\t\t\tSee "Living In an Exceptional World" by Sean Parent', "\t\t\t\t(develop, The Apple Technical Journal, Issue 11, August/September 1992)", "\t\t\t\t<http://developer.apple.com/dev/techsupport/develop/issue11toc.shtml> or", "\t\t\t\t<http://www.mactech.com/articles/develop/issue_11/Parent_final.html>", "\t\t\t\tfor the methodology behind these error handling and assertion macros.", "\t", "\tBugs?:      For bug reports, consult the following page on", "\t\t\t\tthe World Wide Web:", "", "\t http://developer.apple.com/bugreporter/ ", "*/", "#ifndef __ASSERTMACROS__", "#define __ASSERTMACROS__", "", "/*", " *  Macro overview:", " *  ", " *      check(assertion)", " *         In production builds, pre-processed away  ", " *         In debug builds, if assertion evaluates to false, calls DEBUG_ASSERT_MESSAGE", " *  ", " *      verify(assertion)", " *         In production builds, evaluates assertion and does nothing", " *         In debug builds, if assertion evaluates to false, calls DEBUG_ASSERT_MESSAGE", " *  ", " *      require(assertion, exceptionLabel)", " *         In production builds, if the assertion expression evaluates to false, goto exceptionLabel", " *         In debug builds, if the assertion expression evaluates to false, calls DEBUG_ASSERT_MESSAGE", " *                          and jumps to exceptionLabel", " *  ", " *      In addition the following suffixes are available:", " * ", ' *         _noerr     Adds "!= 0" to assertion.  Useful for asserting and OSStatus or OSErr is noErr (zero)', " *         _action    Adds statement to be executued if assertion fails", " *         _quiet     Suppress call to DEBUG_ASSERT_MESSAGE", " *         _string    Allows you to add explanitory message to DEBUG_ASSERT_MESSAGE", " *  ", " *        For instance, require_noerr_string(resultCode, label, msg) will do nothing if ", " *        resultCode is zero, otherwise it will call DEBUG_ASSERT_MESSAGE with msg", " *        and jump to label.", " *", " *  Configuration:", " *", ' *      By default all macros generate "production code" (i.e non-debug).  If  ', " *      DEBUG_ASSERT_PRODUCTION_CODE is defined to zero or DEBUG is defined to non-zero", " *      while this header is included, the macros will generated debug code.", " *", " *      If DEBUG_ASSERT_COMPONENT_NAME_STRING is defined, all debug messages will", " *      be prefixed with it.", " *", " *      By default, all messages write to stderr.  If you would like to write a custom", " *      error message formater, defined DEBUG_ASSERT_MESSAGE to your function name.", " *", " *      Each individual macro will only be defined if it is not already defined, so", " *      you can redefine their behavior singly by providing your own definition before", " *      this file is included.", " *", " *      If you define __ASSERTMACROS__ before this file is included, then nothing in", " *      this file will take effect.", " *", " *      Prior to Mac OS X 10.6 the macro names used in this file conflicted with some", " *      user code, including libraries in boost and the proposed C++ standards efforts,", " *      and there was no way for a client of this header to resolve this conflict. Because", " *      of this, most of the macros have been changed so that they are prefixed with ", " *      __ and contain at least one capital letter, which should alleviate the current", " *      and future conflicts.  However, to allow current sources to continue to compile,", " *      compatibility macros are defined at the end with the old names.  A tops script ", " *      at the end of this file will convert all of the old macro names used in a directory", " *      to the new names.  Clients are recommended to migrate over to these new macros as", " *      they update their sources because a future release of Mac OS X will remove the", " *      old macro definitions ( without the double-underscore prefix ).  Clients who", " *      want to compile without the old macro definitions can define the macro", " *      __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES to 0 before this file is", " *      included.", " */", "", "", "/*", " *  Before including this file, #define DEBUG_ASSERT_COMPONENT_NAME_STRING to", " *  a C-string containing the name of your client. This string will be passed to", " *  the DEBUG_ASSERT_MESSAGE macro for inclusion in any assertion messages.", " *", " *  If you do not define DEBUG_ASSERT_COMPONENT_NAME_STRING, the default", " *  DEBUG_ASSERT_COMPONENT_NAME_STRING value, an empty string, will be used by", " *  the assertion macros.", " */", "#ifndef DEBUG_ASSERT_COMPONENT_NAME_STRING", '    #define DEBUG_ASSERT_COMPONENT_NAME_STRING ""', "#endif", "", "", "/*", " *  To activate the additional assertion code and messages for non-production builds,", " *  #define DEBUG_ASSERT_PRODUCTION_CODE to zero before including this file.", " *", " *  If you do not define DEBUG_ASSERT_PRODUCTION_CODE, the default value 1 will be used", " *  (production code = no assertion code and no messages).", " */", "#ifndef DEBUG_ASSERT_PRODUCTION_CODE", "   #define DEBUG_ASSERT_PRODUCTION_CODE !DEBUG", "#endif", "", "", "/*", " *  DEBUG_ASSERT_MESSAGE(component, assertion, label, error, file, line, errorCode)", " *", " *  Summary:", " *    All assertion messages are routed through this macro. If you wish to use your", " *    own routine to display assertion messages, you can override DEBUG_ASSERT_MESSAGE", " *    by #defining DEBUG_ASSERT_MESSAGE before including this file.", " *", " *  Parameters:", " *", " *    componentNameString:", " *      A pointer to a string constant containing the name of the", " *      component this code is part of. This must be a string constant", " *      (and not a string variable or NULL) because the preprocessor", " *      concatenates it with other string constants.", " *", " *    assertionString:", " *      A pointer to a string constant containing the assertion.", " *      This must be a string constant (and not a string variable or", " *      NULL) because the Preprocessor concatenates it with other", " *      string constants.", " *    ", " *    exceptionLabelString:", " *      A pointer to a string containing the exceptionLabel, or NULL.", " *    ", " *    errorString:", " *      A pointer to the error string, or NULL. DEBUG_ASSERT_MESSAGE macros", " *      must not attempt to concatenate this string with constant", " *      character strings.", " *    ", " *    fileName:", " *      A pointer to the fileName or pathname (generated by the", " *      preprocessor __FILE__ identifier), or NULL.", " *    ", " *    lineNumber:", " *      The line number in the file (generated by the preprocessor", " *      __LINE__ identifier), or 0 (zero).", " *    ", " *    errorCode:", " *      A value associated with the assertion, or 0.", " *", " *  Here is an example of a DEBUG_ASSERT_MESSAGE macro and a routine which displays", " *  assertion messsages:", " *", ' *      #define DEBUG_ASSERT_COMPONENT_NAME_STRING "MyCoolProgram"', " *", " *      #define DEBUG_ASSERT_MESSAGE(componentNameString, assertionString,                           \\", " *                                   exceptionLabelString, errorString, fileName, lineNumber, errorCode) \\", " *              MyProgramDebugAssert(componentNameString, assertionString,                           \\", " *                                   exceptionLabelString, errorString, fileName, lineNumber, errorCode)", " *", " *      static void", " *      MyProgramDebugAssert(const char *componentNameString, const char *assertionString, ", " *                           const char *exceptionLabelString, const char *errorString, ", " *                           const char *fileName, long lineNumber, int errorCode)", " *      {", " *          if ( (assertionString != NULL) && (*assertionString != '\\0') )", ' *              fprintf(stderr, "Assertion failed: %s: %s\\n", componentNameString, assertionString);', " *          else", ' *              fprintf(stderr, "Check failed: %s:\\n", componentNameString);', " *          if ( exceptionLabelString != NULL )", ' *              fprintf(stderr, "    %s\\n", exceptionLabelString);', " *          if ( errorString != NULL )", ' *              fprintf(stderr, "    %s\\n", errorString);', " *          if ( fileName != NULL )", ' *              fprintf(stderr, "    file: %s\\n", fileName);', " *          if ( lineNumber != 0 )", ' *              fprintf(stderr, "    line: %ld\\n", lineNumber);', " *          if ( errorCode != 0 )", ' *              fprintf(stderr, "    error: %d\\n", errorCode);', " *      }", " *", " *  If you do not define DEBUG_ASSERT_MESSAGE, a simple printf to stderr will be used.", " */", "#ifndef DEBUG_ASSERT_MESSAGE", "   #ifdef KERNEL", "      #include <libkern/libkern.h>", "      #define DEBUG_ASSERT_MESSAGE(name, assertion, label, message, file, line, value) \\", '                                  printf( "AssertMacros: %s, %s file: %s, line: %d\\n", assertion, (message!=0) ? message : "", file, line);', "   #else", "      #include <stdio.h>", "      #define DEBUG_ASSERT_MESSAGE(name, assertion, label, message, file, line, value) \\", '                                  fprintf(stderr, "AssertMacros: %s, %s file: %s, line: %d\\n", assertion, (message!=0) ? message : "", file, line);', "   #endif", "#endif", "", "", "", "", "", "/*", " *  __Debug_String(message)", " *", " *  Summary:", " *    Production builds: does nothing and produces no code.", " *", " *    Non-production builds: call DEBUG_ASSERT_MESSAGE.", " *", " *  Parameters:", " *", " *    message:", " *      The C string to display.", " *", " */", "#ifndef __Debug_String", "\t#if DEBUG_ASSERT_PRODUCTION_CODE", "\t   #define __Debug_String(message)", "\t#else", "\t   #define __Debug_String(message)                                             \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  DEBUG_ASSERT_MESSAGE(                                               \\", "\t\t\t\t  DEBUG_ASSERT_COMPONENT_NAME_STRING,                             \\", '\t\t\t\t  "",                                                             \\', "\t\t\t\t  0,                                                              \\", "\t\t\t\t  message,                                                        \\", "\t\t\t\t  __FILE__,                                                       \\", "\t\t\t\t  __LINE__,                                                       \\", "\t\t\t\t  0);                                                             \\", "\t\t  } while ( 0 )", "\t#endif", "#endif", "", "/*", " *  __Check(assertion)", " *", " *  Summary:", " *    Production builds: does nothing and produces no code.", " *", " *    Non-production builds: if the assertion expression evaluates to false,", " *    call DEBUG_ASSERT_MESSAGE.", " *", " *  Parameters:", " *", " *    assertion:", " *      The assertion expression.", " */", "#ifndef __Check", "\t#if DEBUG_ASSERT_PRODUCTION_CODE", "\t   #define __Check(assertion)", "\t#else", "\t   #define __Check(assertion)                                                 \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  if ( __builtin_expect(!(assertion), 0) )                            \\", "\t\t\t  {                                                                   \\", "\t\t\t\t  DEBUG_ASSERT_MESSAGE(                                           \\", "\t\t\t\t\t  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \\", "\t\t\t\t\t  #assertion, 0, 0, __FILE__, __LINE__, 0 );                  \\", "\t\t\t  }                                                                   \\", "\t\t  } while ( 0 )", "\t#endif", "#endif", "", "#ifndef __nCheck", "\t#define __nCheck(assertion)  __Check(!(assertion))", "#endif", "", "/*", " *  __Check_String(assertion, message)", " *", " *  Summary:", " *    Production builds: does nothing and produces no code.", " *", " *    Non-production builds: if the assertion expression evaluates to false,", " *    call DEBUG_ASSERT_MESSAGE.", " *", " *  Parameters:", " *", " *    assertion:", " *      The assertion expression.", " *", " *    message:", " *      The C string to display.", " */", "#ifndef __Check_String", "\t#if DEBUG_ASSERT_PRODUCTION_CODE", "\t   #define __Check_String(assertion, message)", "\t#else", "\t   #define __Check_String(assertion, message)                                 \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  if ( __builtin_expect(!(assertion), 0) )                            \\", "\t\t\t  {                                                                   \\", "\t\t\t\t  DEBUG_ASSERT_MESSAGE(                                           \\", "\t\t\t\t\t  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \\", "\t\t\t\t\t  #assertion, 0, message, __FILE__, __LINE__, 0 );            \\", "\t\t\t  }                                                                   \\", "\t\t  } while ( 0 )", "\t#endif", "#endif", "", "#ifndef __nCheck_String", "\t#define __nCheck_String(assertion, message)  __Check_String(!(assertion), message)", "#endif", "", "/*", " *  __Check_noErr(errorCode)", " *", " *  Summary:", " *    Production builds: does nothing and produces no code.", " *", " *    Non-production builds: if the errorCode expression does not equal 0 (noErr),", " *    call DEBUG_ASSERT_MESSAGE.", " *", " *  Parameters:", " *", " *    errorCode:", " *      The errorCode expression to compare with 0.", " */", "#ifndef __Check_noErr", "\t#if DEBUG_ASSERT_PRODUCTION_CODE", "\t   #define __Check_noErr(errorCode)", "\t#else", "\t   #define __Check_noErr(errorCode)                                           \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  long evalOnceErrorCode = (errorCode);                               \\", "\t\t\t  if ( __builtin_expect(0 != evalOnceErrorCode, 0) )                  \\", "\t\t\t  {                                                                   \\", "\t\t\t\t  DEBUG_ASSERT_MESSAGE(                                           \\", "\t\t\t\t\t  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \\", '\t\t\t\t\t  #errorCode " == 0 ", 0, 0, __FILE__, __LINE__, evalOnceErrorCode ); \\', "\t\t\t  }                                                                   \\", "\t\t  } while ( 0 )", "\t#endif", "#endif", "", "/*", " *  __Check_noErr_String(errorCode, message)", " *", " *  Summary:", " *    Production builds: check_noerr_string() does nothing and produces", " *    no code.", " *", " *    Non-production builds: if the errorCode expression does not equal 0 (noErr),", " *    call DEBUG_ASSERT_MESSAGE.", " *", " *  Parameters:", " *", " *    errorCode:", " *      The errorCode expression to compare to 0.", " *", " *    message:", " *      The C string to display.", " */", "#ifndef __Check_noErr_String", "\t#if DEBUG_ASSERT_PRODUCTION_CODE", "\t   #define __Check_noErr_String(errorCode, message)", "\t#else", "\t   #define __Check_noErr_String(errorCode, message)                           \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  long evalOnceErrorCode = (errorCode);                               \\", "\t\t\t  if ( __builtin_expect(0 != evalOnceErrorCode, 0) )                  \\", "\t\t\t  {                                                                   \\", "\t\t\t\t  DEBUG_ASSERT_MESSAGE(                                           \\", "\t\t\t\t\t  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \\", '\t\t\t\t\t  #errorCode " == 0 ", 0, message, __FILE__, __LINE__, evalOnceErrorCode ); \\', "\t\t\t  }                                                                   \\", "\t\t  } while ( 0 )", "\t#endif", "#endif", "", "/*", " *  __Verify(assertion)", " *", " *  Summary:", " *    Production builds: evaluate the assertion expression, but ignore", " *    the result.", " *", " *    Non-production builds: if the assertion expression evaluates to false,", " *    call DEBUG_ASSERT_MESSAGE.", " *", " *  Parameters:", " *", " *    assertion:", " *      The assertion expression.", " */", "#ifndef __Verify", "\t#if DEBUG_ASSERT_PRODUCTION_CODE", "\t   #define __Verify(assertion)                                                \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  if ( !(assertion) )                                                 \\", "\t\t\t  {                                                                   \\", "\t\t\t  }                                                                   \\", "\t\t  } while ( 0 )", "\t#else", "\t   #define __Verify(assertion)                                                \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  if ( __builtin_expect(!(assertion), 0) )                            \\", "\t\t\t  {                                                                   \\", "\t\t\t\t  DEBUG_ASSERT_MESSAGE(                                           \\", "\t\t\t\t\t  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \\", "\t\t\t\t\t  #assertion, 0, 0, __FILE__, __LINE__, 0 );                  \\", "\t\t\t  }                                                                   \\", "\t\t  } while ( 0 )", "\t#endif", "#endif", "", "#ifndef __nVerify", "\t#define __nVerify(assertion)\t__Verify(!(assertion))", "#endif", "", "/*", " *  __Verify_String(assertion, message)", " *", " *  Summary:", " *    Production builds: evaluate the assertion expression, but ignore", " *    the result.", " *", " *    Non-production builds: if the assertion expression evaluates to false,", " *    call DEBUG_ASSERT_MESSAGE.", " *", " *  Parameters:", " *", " *    assertion:", " *      The assertion expression.", " *", " *    message:", " *      The C string to display.", " */", "#ifndef __Verify_String", "\t#if DEBUG_ASSERT_PRODUCTION_CODE", "\t   #define __Verify_String(assertion, message)                                \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  if ( !(assertion) )                                                 \\", "\t\t\t  {                                                                   \\", "\t\t\t  }                                                                   \\", "\t\t  } while ( 0 )", "\t#else", "\t   #define __Verify_String(assertion, message)                                \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  if ( __builtin_expect(!(assertion), 0) )                            \\", "\t\t\t  {                                                                   \\", "\t\t\t\t  DEBUG_ASSERT_MESSAGE(                                           \\", "\t\t\t\t\t  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \\", "\t\t\t\t\t  #assertion, 0, message, __FILE__, __LINE__, 0 );            \\", "\t\t\t  }                                                                   \\", "\t\t  } while ( 0 )", "\t#endif", "#endif", "", "#ifndef __nVerify_String", "\t#define __nVerify_String(assertion, message)  __Verify_String(!(assertion), message)", "#endif", "", "/*", " *  __Verify_noErr(errorCode)", " *", " *  Summary:", " *    Production builds: evaluate the errorCode expression, but ignore", " *    the result.", " *", " *    Non-production builds: if the errorCode expression does not equal 0 (noErr),", " *    call DEBUG_ASSERT_MESSAGE.", " *", " *  Parameters:", " *", " *    errorCode:", " *      The expression to compare to 0.", " */", "#ifndef __Verify_noErr", "\t#if DEBUG_ASSERT_PRODUCTION_CODE", "\t   #define __Verify_noErr(errorCode)                                          \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  if ( 0 != (errorCode) )                                             \\", "\t\t\t  {                                                                   \\", "\t\t\t  }                                                                   \\", "\t\t  } while ( 0 )", "\t#else", "\t   #define __Verify_noErr(errorCode)                                          \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  long evalOnceErrorCode = (errorCode);                               \\", "\t\t\t  if ( __builtin_expect(0 != evalOnceErrorCode, 0) )                  \\", "\t\t\t  {                                                                   \\", "\t\t\t\t  DEBUG_ASSERT_MESSAGE(                                           \\", "\t\t\t\t\t  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \\", '\t\t\t\t\t  #errorCode " == 0 ", 0, 0, __FILE__, __LINE__, evalOnceErrorCode ); \\', "\t\t\t  }                                                                   \\", "\t\t  } while ( 0 )", "\t#endif", "#endif", "", "/*", " *  __Verify_noErr_String(errorCode, message)", " *", " *  Summary:", " *    Production builds: evaluate the errorCode expression, but ignore", " *    the result.", " *", " *    Non-production builds: if the errorCode expression does not equal 0 (noErr),", " *    call DEBUG_ASSERT_MESSAGE.", " *", " *  Parameters:", " *", " *    errorCode:", " *      The expression to compare to 0.", " *", " *    message:", " *      The C string to display.", " */", "#ifndef __Verify_noErr_String", "\t#if DEBUG_ASSERT_PRODUCTION_CODE", "\t   #define __Verify_noErr_String(errorCode, message)                          \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  if ( 0 != (errorCode) )                                             \\", "\t\t\t  {                                                                   \\", "\t\t\t  }                                                                   \\", "\t\t  } while ( 0 )", "\t#else", "\t   #define __Verify_noErr_String(errorCode, message)                          \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  long evalOnceErrorCode = (errorCode);                               \\", "\t\t\t  if ( __builtin_expect(0 != evalOnceErrorCode, 0) )                  \\", "\t\t\t  {                                                                   \\", "\t\t\t\t  DEBUG_ASSERT_MESSAGE(                                           \\", "\t\t\t\t\t  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \\", '\t\t\t\t\t  #errorCode " == 0 ", 0, message, __FILE__, __LINE__, evalOnceErrorCode ); \\', "\t\t\t  }                                                                   \\", "\t\t  } while ( 0 )", "\t#endif", "#endif", "", "/*", " *  __Verify_noErr_Action(errorCode, action)", " *", " *  Summary:", " *    Production builds: if the errorCode expression does not equal 0 (noErr),", " *    execute the action statement or compound statement (block).", " *", " *    Non-production builds: if the errorCode expression does not equal 0 (noErr),", " *    call DEBUG_ASSERT_MESSAGE and then execute the action statement or compound", " *    statement (block).", " *", " *  Parameters:", " *", " *    errorCode:", " *      The expression to compare to 0.", " *", " *    action:", " *      The statement or compound statement (block).", " */", "#ifndef __Verify_noErr_Action", "\t#if DEBUG_ASSERT_PRODUCTION_CODE", "\t   #define __Verify_noErr_Action(errorCode, action)                          \\", "\t\t  if ( 0 != (errorCode) ) {                                              \\", "\t\t\t  action;                                                            \\", "\t\t  }                                                                      \\", "\t\t  else do {} while (0)", "\t#else", "\t   #define __Verify_noErr_Action(errorCode, action)                          \\", "               do {                                                                   \\", "\t\t  long evalOnceErrorCode = (errorCode);                                  \\", "\t\t  if ( __builtin_expect(0 != evalOnceErrorCode, 0) ) {                   \\", "\t\t\t  DEBUG_ASSERT_MESSAGE(                                              \\", "\t\t\t\t  DEBUG_ASSERT_COMPONENT_NAME_STRING,                            \\", '\t\t\t\t  #errorCode " == 0 ", 0, 0, __FILE__, __LINE__, 0 );            \\', "\t\t\t  action;                                                            \\", "\t\t  }                                                                      \\", "\t       } while (0)", "\t#endif", "#endif", "", "/*", " *  __Verify_Action(assertion, action)", " *", " *  Summary:", " *    Production builds: if the assertion expression evaluates to false,", " *    then execute the action statement or compound statement (block).", " *", " *    Non-production builds: if the assertion expression evaluates to false,", " *    call DEBUG_ASSERT_MESSAGE and then execute the action statement or compound", " *    statement (block).", " *", " *  Parameters:", " *", " *    assertion:", " *      The assertion expression.", " *", " *    action:", " *      The statement or compound statement (block).", " */", "#ifndef __Verify_Action", "\t#if DEBUG_ASSERT_PRODUCTION_CODE", "\t   #define __Verify_Action(assertion, action)                                \\", "\t\t  if ( __builtin_expect(!(assertion), 0) ) {                             \\", "\t\t\taction;                                                              \\", "\t\t  }                                                                      \\", "\t\t  else do {} while (0)", "\t#else", "\t   #define __Verify_Action(assertion, action)                                \\", "\t\t  if ( __builtin_expect(!(assertion), 0) ) {                             \\", "\t\t\t  DEBUG_ASSERT_MESSAGE(                                              \\", "\t\t\t\t\t  DEBUG_ASSERT_COMPONENT_NAME_STRING,                        \\", "\t\t\t\t\t  #assertion, 0, 0, __FILE__, __LINE__, 0 );                 \\", "\t\t\t  action;                                                            \\", "\t\t  }                                                                      \\", "\t\t  else do {} while (0)", "\t#endif", "#endif", "", "/*", " *  __Require(assertion, exceptionLabel)", " *", " *  Summary:", " *    Production builds: if the assertion expression evaluates to false,", " *    goto exceptionLabel.", " *", " *    Non-production builds: if the assertion expression evaluates to false,", " *    call DEBUG_ASSERT_MESSAGE and then goto exceptionLabel.", " *", " *  Parameters:", " *", " *    assertion:", " *      The assertion expression.", " *", " *    exceptionLabel:", " *      The label.", " */", "#ifndef __Require", "\t#if DEBUG_ASSERT_PRODUCTION_CODE", "\t   #define __Require(assertion, exceptionLabel)                               \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  if ( __builtin_expect(!(assertion), 0) )                            \\", "\t\t\t  {                                                                   \\", "\t\t\t\t  goto exceptionLabel;                                            \\", "\t\t\t  }                                                                   \\", "\t\t  } while ( 0 )", "\t#else", "\t   #define __Require(assertion, exceptionLabel)                               \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  if ( __builtin_expect(!(assertion), 0) ) {                          \\", "\t\t\t\t  DEBUG_ASSERT_MESSAGE(                                           \\", "\t\t\t\t\t  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \\", "\t\t\t\t\t  #assertion, #exceptionLabel, 0, __FILE__, __LINE__,  0);    \\", "\t\t\t\t  goto exceptionLabel;                                            \\", "\t\t\t  }                                                                   \\", "\t\t  } while ( 0 )", "\t#endif", "#endif", "", "#ifndef __nRequire", "\t#define __nRequire(assertion, exceptionLabel)  __Require(!(assertion), exceptionLabel)", "#endif", "", "/*", " *  __Require_Action(assertion, exceptionLabel, action)", " *", " *  Summary:", " *    Production builds: if the assertion expression evaluates to false,", " *    execute the action statement or compound statement (block) and then", " *    goto exceptionLabel.", " *", " *    Non-production builds: if the assertion expression evaluates to false,", " *    call DEBUG_ASSERT_MESSAGE, execute the action statement or compound", " *    statement (block), and then goto exceptionLabel.", " *", " *  Parameters:", " *", " *    assertion:", " *      The assertion expression.", " *", " *    exceptionLabel:", " *      The label.", " *", " *    action:", " *      The statement or compound statement (block).", " */", "#ifndef __Require_Action", "\t#if DEBUG_ASSERT_PRODUCTION_CODE", "\t   #define __Require_Action(assertion, exceptionLabel, action)                \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  if ( __builtin_expect(!(assertion), 0) )                            \\", "\t\t\t  {                                                                   \\", "\t\t\t\t  {                                                               \\", "\t\t\t\t\t  action;                                                     \\", "\t\t\t\t  }                                                               \\", "\t\t\t\t  goto exceptionLabel;                                            \\", "\t\t\t  }                                                                   \\", "\t\t  } while ( 0 )", "\t#else", "\t   #define __Require_Action(assertion, exceptionLabel, action)                \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  if ( __builtin_expect(!(assertion), 0) )                            \\", "\t\t\t  {                                                                   \\", "\t\t\t\t  DEBUG_ASSERT_MESSAGE(                                           \\", "\t\t\t\t\t  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \\", "\t\t\t\t\t  #assertion, #exceptionLabel, 0,   __FILE__, __LINE__, 0);   \\", "\t\t\t\t  {                                                               \\", "\t\t\t\t\t  action;                                                     \\", "\t\t\t\t  }                                                               \\", "\t\t\t\t  goto exceptionLabel;                                            \\", "\t\t\t  }                                                                   \\", "\t\t  } while ( 0 )", "\t#endif", "#endif", "", "#ifndef __nRequire_Action", "\t#define __nRequire_Action(assertion, exceptionLabel, action)                  \\", "\t__Require_Action(!(assertion), exceptionLabel, action)", "#endif", "", "/*", " *  __Require_Quiet(assertion, exceptionLabel)", " *", " *  Summary:", " *    If the assertion expression evaluates to false, goto exceptionLabel.", " *", " *  Parameters:", " *", " *    assertion:", " *      The assertion expression.", " *", " *    exceptionLabel:", " *      The label.", " */", "#ifndef __Require_Quiet", "\t#define __Require_Quiet(assertion, exceptionLabel)                            \\", "\t  do                                                                          \\", "\t  {                                                                           \\", "\t\t  if ( __builtin_expect(!(assertion), 0) )                                \\", "\t\t  {                                                                       \\", "\t\t\t  goto exceptionLabel;                                                \\", "\t\t  }                                                                       \\", "\t  } while ( 0 )", "#endif", "", "#ifndef __nRequire_Quiet", "\t#define __nRequire_Quiet(assertion, exceptionLabel)  __Require_Quiet(!(assertion), exceptionLabel)", "#endif", "", "/*", " *  __Require_Action_Quiet(assertion, exceptionLabel, action)", " *", " *  Summary:", " *    If the assertion expression evaluates to false, execute the action", " *    statement or compound statement (block), and goto exceptionLabel.", " *", " *  Parameters:", " *", " *    assertion:", " *      The assertion expression.", " *", " *    exceptionLabel:", " *      The label.", " *", " *    action:", " *      The statement or compound statement (block).", " */", "#ifndef __Require_Action_Quiet", "\t#define __Require_Action_Quiet(assertion, exceptionLabel, action)             \\", "\t  do                                                                          \\", "\t  {                                                                           \\", "\t\t  if ( __builtin_expect(!(assertion), 0) )                                \\", "\t\t  {                                                                       \\", "\t\t\t  {                                                                   \\", "\t\t\t\t  action;                                                         \\", "\t\t\t  }                                                                   \\", "\t\t\t  goto exceptionLabel;                                                \\", "\t\t  }                                                                       \\", "\t  } while ( 0 )", "#endif", "", "#ifndef __nRequire_Action_Quiet", "\t#define __nRequire_Action_Quiet(assertion, exceptionLabel, action)              \\", "\t\t__Require_Action_Quiet(!(assertion), exceptionLabel, action)", "#endif", "", "/*", " *  __Require_String(assertion, exceptionLabel, message)", " *", " *  Summary:", " *    Production builds: if the assertion expression evaluates to false,", " *    goto exceptionLabel.", " *", " *    Non-production builds: if the assertion expression evaluates to false,", " *    call DEBUG_ASSERT_MESSAGE, and then goto exceptionLabel.", " *", " *  Parameters:", " *", " *    assertion:", " *      The assertion expression.", " *", " *    exceptionLabel:", " *      The label.", " *", " *    message:", " *      The C string to display.", " */", "#ifndef __Require_String", "\t#if DEBUG_ASSERT_PRODUCTION_CODE", "\t   #define __Require_String(assertion, exceptionLabel, message)               \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  if ( __builtin_expect(!(assertion), 0) )                            \\", "\t\t\t  {                                                                   \\", "\t\t\t\t  goto exceptionLabel;                                            \\", "\t\t\t  }                                                                   \\", "\t\t  } while ( 0 )", "\t#else", "\t   #define __Require_String(assertion, exceptionLabel, message)               \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  if ( __builtin_expect(!(assertion), 0) )                            \\", "\t\t\t  {                                                                   \\", "\t\t\t\t  DEBUG_ASSERT_MESSAGE(                                           \\", "\t\t\t\t\t  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \\", "\t\t\t\t\t  #assertion, #exceptionLabel,  message,  __FILE__, __LINE__, 0); \\", "\t\t\t\t  goto exceptionLabel;                                            \\", "\t\t\t  }                                                                   \\", "\t\t  } while ( 0 )", "\t#endif", "#endif", "", "#ifndef __nRequire_String", "\t#define __nRequire_String(assertion, exceptionLabel, string)                  \\", "\t\t__Require_String(!(assertion), exceptionLabel, string)", "#endif", "", "/*", " *  __Require_Action_String(assertion, exceptionLabel, action, message)", " *", " *  Summary:", " *    Production builds: if the assertion expression evaluates to false,", " *    execute the action statement or compound statement (block), and then", " *    goto exceptionLabel.", " *", " *    Non-production builds: if the assertion expression evaluates to false,", " *    call DEBUG_ASSERT_MESSAGE, execute the action statement or compound", " *    statement (block), and then goto exceptionLabel.", " *", " *  Parameters:", " *", " *    assertion:", " *      The assertion expression.", " *", " *    exceptionLabel:", " *      The label.", " *", " *    action:", " *      The statement or compound statement (block).", " *", " *    message:", " *      The C string to display.", " */", "#ifndef __Require_Action_String", "\t#if DEBUG_ASSERT_PRODUCTION_CODE", "\t   #define __Require_Action_String(assertion, exceptionLabel, action, message)  \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  if ( __builtin_expect(!(assertion), 0) )                            \\", "\t\t\t  {                                                                   \\", "\t\t\t\t  {                                                               \\", "\t\t\t\t\t  action;                                                     \\", "\t\t\t\t  }                                                               \\", "\t\t\t\t  goto exceptionLabel;                                            \\", "\t\t\t  }                                                                   \\", "\t\t  } while ( 0 )", "\t#else", "\t   #define __Require_Action_String(assertion, exceptionLabel, action, message)  \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  if ( __builtin_expect(!(assertion), 0) )                            \\", "\t\t\t  {                                                                   \\", "\t\t\t\t  DEBUG_ASSERT_MESSAGE(                                           \\", "\t\t\t\t\t  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \\", "\t\t\t\t\t  #assertion, #exceptionLabel,  message,  __FILE__,  __LINE__, 0); \\", "\t\t\t\t  {                                                               \\", "\t\t\t\t\t  action;                                                     \\", "\t\t\t\t  }                                                               \\", "\t\t\t\t  goto exceptionLabel;                                            \\", "\t\t\t  }                                                                   \\", "\t\t  } while ( 0 )", "\t#endif", "#endif", "", "#ifndef __nRequire_Action_String", "\t#define __nRequire_Action_String(assertion, exceptionLabel, action, message)    \\", "\t\t__Require_Action_String(!(assertion), exceptionLabel, action, message)", "#endif", "", "/*", " *  __Require_noErr(errorCode, exceptionLabel)", " *", " *  Summary:", " *    Production builds: if the errorCode expression does not equal 0 (noErr),", " *    goto exceptionLabel.", " *", " *    Non-production builds: if the errorCode expression does not equal 0 (noErr),", " *    call DEBUG_ASSERT_MESSAGE and then goto exceptionLabel.", " *", " *  Parameters:", " *", " *    errorCode:", " *      The expression to compare to 0.", " *", " *    exceptionLabel:", " *      The label.", " */", "#ifndef __Require_noErr", "\t#if DEBUG_ASSERT_PRODUCTION_CODE", "\t   #define __Require_noErr(errorCode, exceptionLabel)                         \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  if ( __builtin_expect(0 != (errorCode), 0) )                        \\", "\t\t\t  {                                                                   \\", "\t\t\t\t  goto exceptionLabel;                                            \\", "\t\t\t  }                                                                   \\", "\t\t  } while ( 0 )", "\t#else", "\t   #define __Require_noErr(errorCode, exceptionLabel)                         \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  long evalOnceErrorCode = (errorCode);                               \\", "\t\t\t  if ( __builtin_expect(0 != evalOnceErrorCode, 0) )                  \\", "\t\t\t  {                                                                   \\", "\t\t\t\t  DEBUG_ASSERT_MESSAGE(                                           \\", "\t\t\t\t\t  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \\", '\t\t\t\t\t  #errorCode " == 0 ",  #exceptionLabel,  0,  __FILE__, __LINE__, evalOnceErrorCode); \\', "\t\t\t\t  goto exceptionLabel;                                            \\", "\t\t\t  }                                                                   \\", "\t\t  } while ( 0 )", "\t#endif", "#endif", "", "/*", " *  __Require_noErr_Action(errorCode, exceptionLabel, action)", " *", " *  Summary:", " *    Production builds: if the errorCode expression does not equal 0 (noErr),", " *    execute the action statement or compound statement (block) and", " *    goto exceptionLabel.", " *", " *    Non-production builds: if the errorCode expression does not equal 0 (noErr),", " *    call DEBUG_ASSERT_MESSAGE, execute the action statement or", " *    compound statement (block), and then goto exceptionLabel.", " *", " *  Parameters:", " *", " *    errorCode:", " *      The expression to compare to 0.", " *", " *    exceptionLabel:", " *      The label.", " *", " *    action:", " *      The statement or compound statement (block).", " */", "#ifndef __Require_noErr_Action", "\t#if DEBUG_ASSERT_PRODUCTION_CODE", "\t   #define __Require_noErr_Action(errorCode, exceptionLabel, action)          \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  if ( __builtin_expect(0 != (errorCode), 0) )                        \\", "\t\t\t  {                                                                   \\", "\t\t\t\t  {                                                               \\", "\t\t\t\t\t  action;                                                     \\", "\t\t\t\t  }                                                               \\", "\t\t\t\t  goto exceptionLabel;                                            \\", "\t\t\t  }                                                                   \\", "\t\t  } while ( 0 )", "\t#else", "\t   #define __Require_noErr_Action(errorCode, exceptionLabel, action)          \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  long evalOnceErrorCode = (errorCode);                               \\", "\t\t\t  if ( __builtin_expect(0 != evalOnceErrorCode, 0) )                  \\", "\t\t\t  {                                                                   \\", "\t\t\t\t  DEBUG_ASSERT_MESSAGE(                                           \\", "\t\t\t\t\t  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \\", '\t\t\t\t\t  #errorCode " == 0 ", #exceptionLabel,  0,  __FILE__, __LINE__,  evalOnceErrorCode); \\', "\t\t\t\t  {                                                               \\", "\t\t\t\t\t  action;                                                     \\", "\t\t\t\t  }                                                               \\", "\t\t\t\t  goto exceptionLabel;                                            \\", "\t\t\t  }                                                                   \\", "\t\t  } while ( 0 )", "\t#endif", "#endif", "", "/*", " *  __Require_noErr_Quiet(errorCode, exceptionLabel)", " *", " *  Summary:", " *    If the errorCode expression does not equal 0 (noErr),", " *    goto exceptionLabel.", " *", " *  Parameters:", " *", " *    errorCode:", " *      The expression to compare to 0.", " *", " *    exceptionLabel:", " *      The label.", " */", "#ifndef __Require_noErr_Quiet", "\t#define __Require_noErr_Quiet(errorCode, exceptionLabel)                      \\", "\t  do                                                                          \\", "\t  {                                                                           \\", "\t\t  if ( __builtin_expect(0 != (errorCode), 0) )                            \\", "\t\t  {                                                                       \\", "\t\t\t  goto exceptionLabel;                                                \\", "\t\t  }                                                                       \\", "\t  } while ( 0 )", "#endif", "", "/*", " *  __Require_noErr_Action_Quiet(errorCode, exceptionLabel, action)", " *", " *  Summary:", " *    If the errorCode expression does not equal 0 (noErr),", " *    execute the action statement or compound statement (block) and", " *    goto exceptionLabel.", " *", " *  Parameters:", " *", " *    errorCode:", " *      The expression to compare to 0.", " *", " *    exceptionLabel:", " *      The label.", " *", " *    action:", " *      The statement or compound statement (block).", " */", "#ifndef __Require_noErr_Action_Quiet", "\t#define __Require_noErr_Action_Quiet(errorCode, exceptionLabel, action)       \\", "\t  do                                                                          \\", "\t  {                                                                           \\", "\t\t  if ( __builtin_expect(0 != (errorCode), 0) )                            \\", "\t\t  {                                                                       \\", "\t\t\t  {                                                                   \\", "\t\t\t\t  action;                                                         \\", "\t\t\t  }                                                                   \\", "\t\t\t  goto exceptionLabel;                                                \\", "\t\t  }                                                                       \\", "\t  } while ( 0 )", "#endif", "", "/*", " *  __Require_noErr_String(errorCode, exceptionLabel, message)", " *", " *  Summary:", " *    Production builds: if the errorCode expression does not equal 0 (noErr),", " *    goto exceptionLabel.", " *", " *    Non-production builds: if the errorCode expression does not equal 0 (noErr),", " *    call DEBUG_ASSERT_MESSAGE, and then goto exceptionLabel.", " *", " *  Parameters:", " *", " *    errorCode:", " *      The expression to compare to 0.", " *", " *    exceptionLabel:", " *      The label.", " *", " *    message:", " *      The C string to display.", " */", "#ifndef __Require_noErr_String", "\t#if DEBUG_ASSERT_PRODUCTION_CODE", "\t   #define __Require_noErr_String(errorCode, exceptionLabel, message)         \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  if ( __builtin_expect(0 != (errorCode), 0) )                        \\", "\t\t\t  {                                                                   \\", "\t\t\t\t  goto exceptionLabel;                                            \\", "\t\t\t  }                                                                   \\", "\t\t  } while ( 0 )", "\t#else", "\t   #define __Require_noErr_String(errorCode, exceptionLabel, message)         \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  long evalOnceErrorCode = (errorCode);                               \\", "\t\t\t  if ( __builtin_expect(0 != evalOnceErrorCode, 0) )                  \\", "\t\t\t  {                                                                   \\", "\t\t\t\t  DEBUG_ASSERT_MESSAGE(                                           \\", "\t\t\t\t\t  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \\", '\t\t\t\t\t  #errorCode " == 0 ",  #exceptionLabel, message, __FILE__,  __LINE__,  evalOnceErrorCode); \\', "\t\t\t\t  goto exceptionLabel;                                            \\", "\t\t\t  }                                                                   \\", "\t\t  } while ( 0 )", "\t#endif", "#endif", "", "/*", " *  __Require_noErr_Action_String(errorCode, exceptionLabel, action, message)", " *", " *  Summary:", " *    Production builds: if the errorCode expression does not equal 0 (noErr),", " *    execute the action statement or compound statement (block) and", " *    goto exceptionLabel.", " *", " *    Non-production builds: if the errorCode expression does not equal 0 (noErr),", " *    call DEBUG_ASSERT_MESSAGE, execute the action statement or compound", " *    statement (block), and then goto exceptionLabel.", " *", " *  Parameters:", " *", " *    errorCode:", " *      The expression to compare to 0.", " *", " *    exceptionLabel:", " *      The label.", " *", " *    action:", " *      The statement or compound statement (block).", " *", " *    message:", " *      The C string to display.", " */", "#ifndef __Require_noErr_Action_String", "\t#if DEBUG_ASSERT_PRODUCTION_CODE", "\t   #define __Require_noErr_Action_String(errorCode, exceptionLabel, action, message) \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  if ( __builtin_expect(0 != (errorCode), 0) )                        \\", "\t\t\t  {                                                                   \\", "\t\t\t\t  {                                                               \\", "\t\t\t\t\t  action;                                                     \\", "\t\t\t\t  }                                                               \\", "\t\t\t\t  goto exceptionLabel;                                            \\", "\t\t\t  }                                                                   \\", "\t\t  } while ( 0 )", "\t#else", "\t   #define __Require_noErr_Action_String(errorCode, exceptionLabel, action, message) \\", "\t\t  do                                                                      \\", "\t\t  {                                                                       \\", "\t\t\t  long evalOnceErrorCode = (errorCode);                               \\", "\t\t\t  if ( __builtin_expect(0 != evalOnceErrorCode, 0) )                  \\", "\t\t\t  {                                                                   \\", "\t\t\t\t  DEBUG_ASSERT_MESSAGE(                                           \\", "\t\t\t\t\t  DEBUG_ASSERT_COMPONENT_NAME_STRING,                         \\", '\t\t\t\t\t  #errorCode " == 0 ", #exceptionLabel, message, __FILE__, __LINE__, evalOnceErrorCode); \\', "\t\t\t\t  {                                                               \\", "\t\t\t\t\t  action;                                                     \\", "\t\t\t\t  }                                                               \\", "\t\t\t\t  goto exceptionLabel;                                            \\", "\t\t\t  }                                                                   \\", "\t\t  } while ( 0 )", "\t#endif", "#endif", "", "/*", " *  __Check_Compile_Time(expr)", " *", " *  Summary:", " *    any build: if the expression is not true, generated a compile time error.", " *", " *  Parameters:", " *", " *    expr:", " *      The compile time expression that should evaluate to non-zero.", " *", " *  Discussion:", " *     This declares an array with a size that is determined by a compile-time expression.", " *     If false, it declares a negatively sized array, which generates a compile-time error.", " *", " * Examples:", " *     __Check_Compile_Time( sizeof( int ) == 4 );", " *     __Check_Compile_Time( offsetof( MyStruct, myField ) == 4 );", " *     __Check_Compile_Time( ( kMyBufferSize % 512 ) == 0 );", " *", " *  Note: This only works with compile-time expressions.", " *  Note: This only works in places where extern declarations are allowed (e.g. global scope).", " */", "#ifndef __Check_Compile_Time", "    #ifdef __GNUC__ ", "        #define __Check_Compile_Time( expr )    \\", "            extern int compile_time_assert_failed[ ( expr ) ? 1 : -1 ] __attribute__( ( unused ) )", "    #else", "        #define __Check_Compile_Time( expr )    \\", "            extern int compile_time_assert_failed[ ( expr ) ? 1 : -1 ]", "    #endif", "#endif", "", "/*", " *\tFor time immemorial, Mac OS X has defined version of most of these macros without the __ prefix, which", " *\tcould collide with similarly named functions or macros in user code, including new functionality in", " *\tBoost and the C++ standard library.", " *", " *\tA future release of Mac OS X will no longer do this, and will require that clients move to the", " *  new macros as defined above.  However, in the interim both the new and old macros will work, unless", " *  clients define a macro __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES before this file is included", " *  in their compilations.  Clients who do not want the older macros defined can accomplish this by adding", " *    #define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0", " *  at the top of their sources, or my adding -D__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES=0 to the", " *  gcc compilation options.", " *", " *  To aid users of these macros in converting their sources, the following tops script will convert usages", " *  of the old macros into the new equivalents.  To do so, in Terminal go into the directory containing the", " *  sources to be converted and run this command.", " *", "    find . -name '*.[c|cc|cp|cpp|m|mm|h]' -print0 |  xargs -0 tops -verbose \\", '      replace "check(<b args>)" with "__Check(<args>)" \\', '      replace "check_noerr(<b args>)" with "__Check_noErr(<args>)" \\', '      replace "check_noerr_string(<b args>)" with "__Check_noErr_String(<args>)" \\', '      replace "check_string(<b args>)" with "__Check_String(<args>)" \\', '      replace "require(<b args>)" with "__Require(<args>)" \\', '      replace "require_action(<b args>)" with "__Require_Action(<args>)" \\', '      replace "require_action_string(<b args>)" with "__Require_Action_String(<args>)" \\', '      replace "require_noerr(<b args>)" with "__Require_noErr(<args>)" \\', '      replace "require_noerr_action(<b args>)" with "__Require_noErr_Action(<args>)" \\', '      replace "require_noerr_action_string(<b args>)" with "__Require_noErr_Action_String(<args>)" \\', '      replace "require_noerr_string(<b args>)" with "__Require_noErr_String(<args>)" \\', '      replace "require_string(<b args>)" with "__Require_String(<args>)" \\', '      replace "verify(<b args>)" with "__Verify(<args>)" \\', '      replace "verify_action(<b args>)" with "__Verify_Action(<args>)" \\', '      replace "verify_noerr(<b args>)" with "__Verify_noErr(<args>)" \\', '      replace "verify_noerr_action(<b args>)" with "__Verify_noErr_Action(<args>)" \\', '      replace "verify_noerr_string(<b args>)" with "__Verify_noErr_String(<args>)" \\', '      replace "verify_string(<b args>)" with "__Verify_String(<args>)" \\', '      replace "ncheck(<b args>)" with "__nCheck(<args>)" \\', '      replace "ncheck_string(<b args>)" with "__nCheck_String(<args>)" \\', '      replace "nrequire(<b args>)" with "__nRequire(<args>)" \\', '      replace "nrequire_action(<b args>)" with "__nRequire_Action(<args>)" \\', '      replace "nrequire_action_quiet(<b args>)" with "__nRequire_Action_Quiet(<args>)" \\', '      replace "nrequire_action_string(<b args>)" with "__nRequire_Action_String(<args>)" \\', '      replace "nrequire_quiet(<b args>)" with "__nRequire_Quiet(<args>)" \\', '      replace "nrequire_string(<b args>)" with "__nRequire_String(<args>)" \\', '      replace "nverify(<b args>)" with "__nVerify(<args>)" \\', '      replace "nverify_string(<b args>)" with "__nVerify_String(<args>)" \\', '      replace "require_action_quiet(<b args>)" with "__Require_Action_Quiet(<args>)" \\', '      replace "require_noerr_action_quiet(<b args>)" with "__Require_noErr_Action_Quiet(<args>)" \\', '      replace "require_noerr_quiet(<b args>)" with "__Require_noErr_Quiet(<args>)" \\', '      replace "require_quiet(<b args>)" with "__Require_Quiet(<args>)" \\', '      replace "check_compile_time(<b args>)" with "__Check_Compile_Time(<args>)" \\', '      replace "debug_string(<b args>)" with "__Debug_String(<args>)"', " *", " */", "", "#ifndef __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES", "\t/* If we haven't set this yet, it defaults to on.  In the next release, this will default to off. */", "\t#define\t__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES\t1", "#endif", "", "#if\t__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES", "", "\t#ifndef check", "\t#define check(assertion)  __Check(assertion)", "\t#endif", "", "\t#ifndef check_noerr", "\t#define check_noerr(errorCode)  __Check_noErr(errorCode)", "\t#endif", "", "\t#ifndef check_noerr_string", "\t\t#define check_noerr_string(errorCode, message)  __Check_noErr_String(errorCode, message)", "\t#endif", "", "\t#ifndef check_string", "\t\t#define check_string(assertion, message)  __Check_String(assertion, message)", "\t#endif", "", "\t#ifndef require", "\t\t#define require(assertion, exceptionLabel)  __Require(assertion, exceptionLabel)", "\t#endif", "", "\t#ifndef require_action", "\t\t#define require_action(assertion, exceptionLabel, action)  __Require_Action(assertion, exceptionLabel, action)", "\t#endif", "", "\t#ifndef require_action_string", "\t\t#define require_action_string(assertion, exceptionLabel, action, message)  __Require_Action_String(assertion, exceptionLabel, action, message)", "\t#endif", "", "\t#ifndef require_noerr", "\t\t#define require_noerr(errorCode, exceptionLabel)  __Require_noErr(errorCode, exceptionLabel)", "\t#endif", "", "\t#ifndef require_noerr_action", "\t\t#define require_noerr_action(errorCode, exceptionLabel, action)  __Require_noErr_Action(errorCode, exceptionLabel, action)", "\t#endif", "", "\t#ifndef require_noerr_action_string", "\t\t#define require_noerr_action_string(errorCode, exceptionLabel, action, message)  __Require_noErr_Action_String(errorCode, exceptionLabel, action, message)", "\t#endif", "", "\t#ifndef require_noerr_string", "\t\t#define require_noerr_string(errorCode, exceptionLabel, message)  __Require_noErr_String(errorCode, exceptionLabel, message)", "\t#endif", "", "\t#ifndef require_string", "\t\t#define require_string(assertion, exceptionLabel, message)  __Require_String(assertion, exceptionLabel, message)", "\t#endif", "", "\t#ifndef verify", "\t\t#define verify(assertion) __Verify(assertion)", "\t#endif", "", "\t#ifndef verify_action", "\t\t#define verify_action(assertion, action)  __Verify_Action(assertion, action)", "\t#endif", "", "\t#ifndef verify_noerr", "\t\t#define verify_noerr(errorCode)  __Verify_noErr(errorCode)", "\t#endif", "", "\t#ifndef verify_noerr_action", "\t\t#define verify_noerr_action(errorCode, action)  __Verify_noErr_Action(errorCode, action)", "\t#endif", "", "\t#ifndef verify_noerr_string", "\t\t#define verify_noerr_string(errorCode, message)  __Verify_noErr_String(errorCode, message)", "\t#endif", "", "\t#ifndef verify_string", "\t\t#define verify_string(assertion, message)  __Verify_String(assertion, message)", "\t#endif", "", "\t#ifndef ncheck", "\t\t#define ncheck(assertion)  __nCheck(assertion)", "\t#endif", "", "\t#ifndef ncheck_string", "\t\t#define ncheck_string(assertion, message)  __nCheck_String(assertion, message)", "\t#endif", "", "\t#ifndef nrequire", "\t\t#define nrequire(assertion, exceptionLabel)  __nRequire(assertion, exceptionLabel)", "\t#endif", "", "\t#ifndef nrequire_action", "\t\t#define nrequire_action(assertion, exceptionLabel, action)  __nRequire_Action(assertion, exceptionLabel, action)", "\t#endif", "", "\t#ifndef nrequire_action_quiet", "\t\t#define nrequire_action_quiet(assertion, exceptionLabel, action)  __nRequire_Action_Quiet(assertion, exceptionLabel, action)", "\t#endif", "", "\t#ifndef nrequire_action_string", "\t\t#define nrequire_action_string(assertion, exceptionLabel, action, message)  __nRequire_Action_String(assertion, exceptionLabel, action, message)", "\t#endif", "", "\t#ifndef nrequire_quiet", "\t\t#define nrequire_quiet(assertion, exceptionLabel)  __nRequire_Quiet(assertion, exceptionLabel)", "\t#endif", "", "\t#ifndef nrequire_string", "\t\t#define nrequire_string(assertion, exceptionLabel, string)  __nRequire_String(assertion, exceptionLabel, string)", "\t#endif", "", "\t#ifndef nverify", "\t\t#define nverify(assertion)  __nVerify(assertion)", "\t#endif", "", "\t#ifndef nverify_string", "\t\t#define nverify_string(assertion, message)  __nVerify_String(assertion, message)", "\t#endif", "", "\t#ifndef require_action_quiet", "\t\t#define require_action_quiet(assertion, exceptionLabel, action)  __Require_Action_Quiet(assertion, exceptionLabel, action)", "\t#endif", "", "\t#ifndef require_noerr_action_quiet", "\t\t#define require_noerr_action_quiet(errorCode, exceptionLabel, action)  __Require_noErr_Action_Quiet(errorCode, exceptionLabel, action)", "\t#endif", "", "\t#ifndef require_noerr_quiet", "\t\t#define require_noerr_quiet(errorCode, exceptionLabel)  __Require_noErr_Quiet(errorCode, exceptionLabel)", "\t#endif", "", "\t#ifndef require_quiet", "\t\t#define require_quiet(assertion, exceptionLabel)  __Require_Quiet(assertion, exceptionLabel)", "\t#endif", "", "\t#ifndef check_compile_time", "\t\t#define check_compile_time( expr )  __Check_Compile_Time( expr )", "\t#endif", "", "\t#ifndef debug_string", "\t\t#define debug_string(message)  __Debug_String(message)", "\t#endif", "\t", "#endif\t/* ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES */", "", "", "#endif /* __ASSERTMACROS__ */" },
    ["Availability.h"] = { "/*", " * Copyright (c) 2007-2011 by Apple Inc.. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", " ", "#ifndef __AVAILABILITY__", "#define __AVAILABILITY__", " /*     ", "    These macros are for use in OS header files. They enable function prototypes", "    and Objective-C methods to be tagged with the OS version in which they", "    were first available; and, if applicable, the OS version in which they ", "    became deprecated.  ", "     ", "    The desktop Mac OS X and iOS each have different version numbers.", "    The __OSX_AVAILABLE_STARTING() macro allows you to specify both the desktop", "    and iOS version numbers.  For instance:", "        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_2_0)", "    means the function/method was first available on Mac OS X 10.2 on the desktop", "    and first available in iOS 2.0 on the iPhone.", "    ", "    If a function is available on one platform, but not the other a _NA (not", "    applicable) parameter is used.  For instance:", "            __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA)", "    means that the function/method was first available on Mac OS X 10.3, and it", "    currently not implemented on the iPhone.", "", "    At some point, a function/method may be deprecated.  That means Apple", "    recommends applications stop using the function, either because there is a ", "    better replacement or the functionality is being phased out.  Deprecated", "    functions/methods can be tagged with a __OSX_AVAILABLE_BUT_DEPRECATED()", "    macro which specifies the OS version where the function became available", "    as well as the OS version in which it became deprecated.  For instance:", "        __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0,__MAC_10_5,__IPHONE_NA,__IPHONE_NA)", "    means that the function/method was introduced in Mac OS X 10.0, then", "    became deprecated beginning in Mac OS X 10.5.  On iOS the function ", "    has never been available.  ", "    ", "    For these macros to function properly, a program must specify the OS version range ", "    it is targeting.  The min OS version is specified as an option to the compiler:", "    -mmacosx-version-min=10.x when building for Mac OS X, and -miphoneos-version-min=y.z", "    when building for the iPhone.  The upper bound for the OS version is rarely needed,", "    but it can be set on the command line via: -D__MAC_OS_X_VERSION_MAX_ALLOWED=10x0 for", "    Mac OS X and __IPHONE_OS_VERSION_MAX_ALLOWED = y0z00 for iOS.  ", "    ", "    Examples:", "", "        A function available in Mac OS X 10.5 and later, but not on the phone:", "        ", "            extern void mymacfunc() __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);", "", "", "        An Objective-C method in Mac OS X 10.5 and later, but not on the phone:", "        ", "            @interface MyClass : NSObject", "            -(void) mymacmethod __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);", "            @end", "", "        ", "        An enum available on the phone, but not available on Mac OS X:", "        ", "            #if __IPHONE_OS_VERSION_MIN_REQUIRED", "                enum { myEnum = 1 };", "            #endif", "           Note: this works when targeting the Mac OS X platform because ", "           __IPHONE_OS_VERSION_MIN_REQUIRED is undefined which evaluates to zero. ", "        ", "", "        An enum with values added in different iPhoneOS versions:", "\t\t", "\t\t\tenum {", "\t\t\t    myX  = 1,\t// Usable on iPhoneOS 2.1 and later", "\t\t\t    myY  = 2,\t// Usable on iPhoneOS 3.0 and later", "\t\t\t    myZ  = 3,\t// Usable on iPhoneOS 3.0 and later", "\t\t\t\t...", "\t\t      Note: you do not want to use #if with enumeration values", "\t\t\t  when a client needs to see all values at compile time", "\t\t\t  and use runtime logic to only use the viable values.", "\t\t\t  ", "", "    It is also possible to use the *_VERSION_MIN_REQUIRED in source code to make one", "    source base that can be compiled to target a range of OS versions.  It is best", "    to not use the _MAC_* and __IPHONE_* macros for comparisons, but rather their values.", "    That is because you might get compiled on an old OS that does not define a later", "    OS version macro, and in the C preprocessor undefined values evaluate to zero", "    in expresssions, which could cause the #if expression to evaluate in an unexpected", "    way.", "    ", "        #ifdef __MAC_OS_X_VERSION_MIN_REQUIRED", "            // code only compiled when targeting Mac OS X and not iPhone", "            // note use of 1050 instead of __MAC_10_5", "            #if __MAC_OS_X_VERSION_MIN_REQUIRED < 1050", "                // code in here might run on pre-Leopard OS", "            #else", "                // code here can assume Leopard or later", "            #endif", "        #endif", "", "", "*/", "", "#define __MAC_10_0            1000", "#define __MAC_10_1            1010", "#define __MAC_10_2            1020", "#define __MAC_10_3            1030", "#define __MAC_10_4            1040", "#define __MAC_10_5            1050", "#define __MAC_10_6            1060", "#define __MAC_10_7            1070", "#define __MAC_10_8            1080", "#define __MAC_10_9            1090", "/* __MAC_NA is not defined to a value but is uses as a token by macros to indicate that the API is unavailable */", "", "#define __IPHONE_2_0         20000", "#define __IPHONE_2_1         20100", "#define __IPHONE_2_2         20200", "#define __IPHONE_3_0         30000", "#define __IPHONE_3_1         30100", "#define __IPHONE_3_2         30200", "#define __IPHONE_4_0         40000", "#define __IPHONE_4_1         40100", "#define __IPHONE_4_2         40200", "#define __IPHONE_4_3         40300", "#define __IPHONE_5_0         50000", "#define __IPHONE_5_1         50100", "#define __IPHONE_6_0         60000", "#define __IPHONE_6_1         60100", "#define __IPHONE_7_0         70000", "/* __IPHONE_NA is not defined to a value but is uses as a token by macros to indicate that the API is unavailable */", "", "#include <AvailabilityInternal.h>", "", "", "#ifdef __IPHONE_OS_VERSION_MIN_REQUIRED", "    #define __OSX_AVAILABLE_STARTING(_osx, _ios) __AVAILABILITY_INTERNAL##_ios", "    #define __OSX_AVAILABLE_BUT_DEPRECATED(_osxIntro, _osxDep, _iosIntro, _iosDep) \\", "                                                    __AVAILABILITY_INTERNAL##_iosIntro##_DEP##_iosDep", "    #define __OSX_AVAILABLE_BUT_DEPRECATED_MSG(_osxIntro, _osxDep, _iosIntro, _iosDep, _msg) \\", "                                                    __AVAILABILITY_INTERNAL##_iosIntro##_DEP##_iosDep##_MSG(_msg)", "", "#elif defined(__MAC_OS_X_VERSION_MIN_REQUIRED)", "    #define __OSX_AVAILABLE_STARTING(_osx, _ios) __AVAILABILITY_INTERNAL##_osx", "    #define __OSX_AVAILABLE_BUT_DEPRECATED(_osxIntro, _osxDep, _iosIntro, _iosDep) \\", "                                                    __AVAILABILITY_INTERNAL##_osxIntro##_DEP##_osxDep", "    #define __OSX_AVAILABLE_BUT_DEPRECATED_MSG(_osxIntro, _osxDep, _iosIntro, _iosDep, _msg) \\", "                                                    __AVAILABILITY_INTERNAL##_osxIntro##_DEP##_osxDep##_MSG(_msg)", "", "#else", "    #define __OSX_AVAILABLE_STARTING(_osx, _ios)", "    #define __OSX_AVAILABLE_BUT_DEPRECATED(_osxIntro, _osxDep, _iosIntro, _iosDep)", "    #define __OSX_AVAILABLE_BUT_DEPRECATED_MSG(_osxIntro, _osxDep, _iosIntro, _iosDep, _msg)", "#endif", "", "", "#endif /* __AVAILABILITY__ */" },
    ["AvailabilityInternal.h"] = { "/*", " * Copyright (c) 2007-2012 by Apple Inc.. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "", "/*", "    File:       AvailabilityInternal.h", " ", "    Contains:   implementation details of __OSX_AVAILABLE_* macros from <Availability.h>", "", "*/", "#ifndef __AVAILABILITY_INTERNAL__", "#define __AVAILABILITY_INTERNAL__", "", "", "", "#ifndef __IPHONE_OS_VERSION_MIN_REQUIRED", "    #ifdef __ENVIRONMENT_IPHONE_OS_VERSION_MIN_REQUIRED__", "        /* compiler sets __ENVIRONMENT_IPHONE_OS_VERSION_MIN_REQUIRED__ when -miphoneos-version-min is used */", "        #define __IPHONE_OS_VERSION_MIN_REQUIRED __ENVIRONMENT_IPHONE_OS_VERSION_MIN_REQUIRED__", "    #endif", "#endif", "", "#define __AVAILABILITY_INTERNAL_DEPRECATED            __attribute__((deprecated))", "#ifdef __has_feature", "    #if __has_feature(attribute_deprecated_with_message)", "        #define __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)  __attribute__((deprecated(_msg)))", "    #else", "        #define __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)  __attribute__((deprecated))", "    #endif", "#elif defined(__GNUC__) && ((__GNUC__ >= 5) || ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)))", "    #define __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)  __attribute__((deprecated(_msg)))", "#else", "    #define __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)  __attribute__((deprecated))", "#endif", "#define __AVAILABILITY_INTERNAL_UNAVAILABLE           __attribute__((unavailable))", "#define __AVAILABILITY_INTERNAL_WEAK_IMPORT           __attribute__((weak_import))", "#define __AVAILABILITY_INTERNAL_REGULAR            ", "", "#ifdef __IPHONE_OS_VERSION_MIN_REQUIRED", "    /* make sure a default max version is set */", "    #ifndef __IPHONE_OS_VERSION_MAX_ALLOWED", "        #define __IPHONE_OS_VERSION_MAX_ALLOWED     __IPHONE_7_0", "    #endif", "    /* make sure a valid min is set */", "    #if __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_0", "        #undef __IPHONE_OS_VERSION_MIN_REQUIRED", "        #define __IPHONE_OS_VERSION_MIN_REQUIRED    __IPHONE_2_0 ", "    #endif", "", "    #if defined(__has_attribute) && defined(__has_feature)", "        #if __has_attribute(availability)", "            /* use better attributes if possible */", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0                    __attribute__((availability(ios,introduced=2.0)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_2_0    __attribute__((availability(ios,introduced=2.0,deprecated=2.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_2_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=2.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_2_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=2.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_2_1    __attribute__((availability(ios,introduced=2.0,deprecated=2.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_2_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=2.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_2_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=2.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_2_2    __attribute__((availability(ios,introduced=2.0,deprecated=2.2)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_2_2_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=2.2,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_2_2_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=2.2)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_0    __attribute__((availability(ios,introduced=2.0,deprecated=3.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=3.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=3.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_1    __attribute__((availability(ios,introduced=2.0,deprecated=3.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=3.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=3.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_2    __attribute__((availability(ios,introduced=2.0,deprecated=3.2)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_2_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=3.2,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_2_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=3.2)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_0    __attribute__((availability(ios,introduced=2.0,deprecated=4.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=4.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=4.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_1    __attribute__((availability(ios,introduced=2.0,deprecated=4.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=4.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=4.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_2    __attribute__((availability(ios,introduced=2.0,deprecated=4.2)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_2_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=4.2,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_2_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=4.2)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_3    __attribute__((availability(ios,introduced=2.0,deprecated=4.3)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_3_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=4.3,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_3_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=4.3)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_0    __attribute__((availability(ios,introduced=2.0,deprecated=5.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=5.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=5.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1    __attribute__((availability(ios,introduced=2.0,deprecated=5.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=5.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=5.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0    __attribute__((availability(ios,introduced=2.0,deprecated=6.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=6.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=6.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1    __attribute__((availability(ios,introduced=2.0,deprecated=6.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=6.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=6.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0    __attribute__((availability(ios,introduced=2.0,deprecated=7.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=7.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=7.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_NA               __attribute__((availability(ios,introduced=2.0)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_NA_MSG(_msg)     __attribute__((availability(ios,introduced=2.0)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1                    __attribute__((availability(ios,introduced=2.1)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_2_1    __attribute__((availability(ios,introduced=2.1,deprecated=2.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_2_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.1,deprecated=2.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_2_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.1,deprecated=2.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_2_2    __attribute__((availability(ios,introduced=2.1,deprecated=2.2)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_2_2_MSG(_msg)    __attribute__((availability(ios,introduced=2.1,deprecated=2.2,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_2_2_MSG(_msg)    __attribute__((availability(ios,introduced=2.1,deprecated=2.2)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_0    __attribute__((availability(ios,introduced=2.1,deprecated=3.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.1,deprecated=3.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.1,deprecated=3.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_1    __attribute__((availability(ios,introduced=2.1,deprecated=3.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.1,deprecated=3.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.1,deprecated=3.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_2    __attribute__((availability(ios,introduced=2.1,deprecated=3.2)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_2_MSG(_msg)    __attribute__((availability(ios,introduced=2.1,deprecated=3.2,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_2_MSG(_msg)    __attribute__((availability(ios,introduced=2.1,deprecated=3.2)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_0    __attribute__((availability(ios,introduced=2.1,deprecated=4.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.1,deprecated=4.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.1,deprecated=4.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_1    __attribute__((availability(ios,introduced=2.1,deprecated=4.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.1,deprecated=4.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.1,deprecated=4.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_2    __attribute__((availability(ios,introduced=2.1,deprecated=4.2)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_2_MSG(_msg)    __attribute__((availability(ios,introduced=2.1,deprecated=4.2,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_2_MSG(_msg)    __attribute__((availability(ios,introduced=2.1,deprecated=4.2)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_3    __attribute__((availability(ios,introduced=2.1,deprecated=4.3)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_3_MSG(_msg)    __attribute__((availability(ios,introduced=2.1,deprecated=4.3,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_3_MSG(_msg)    __attribute__((availability(ios,introduced=2.1,deprecated=4.3)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_0    __attribute__((availability(ios,introduced=2.1,deprecated=5.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.1,deprecated=5.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.1,deprecated=5.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_1    __attribute__((availability(ios,introduced=2.1,deprecated=5.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.1,deprecated=5.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.1,deprecated=5.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0    __attribute__((availability(ios,introduced=2.1,deprecated=6.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.1,deprecated=6.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.1,deprecated=6.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1    __attribute__((availability(ios,introduced=2.1,deprecated=6.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.1,deprecated=6.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.1,deprecated=6.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0    __attribute__((availability(ios,introduced=2.1,deprecated=7.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.1,deprecated=7.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.1,deprecated=7.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_NA               __attribute__((availability(ios,introduced=2.1)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_NA_MSG(_msg)     __attribute__((availability(ios,introduced=2.1)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2                    __attribute__((availability(ios,introduced=2.2)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_2_2    __attribute__((availability(ios,introduced=2.2,deprecated=2.2)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_2_2_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=2.2,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_2_2_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=2.2)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_0    __attribute__((availability(ios,introduced=2.2,deprecated=3.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=3.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=3.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_1    __attribute__((availability(ios,introduced=2.2,deprecated=3.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=3.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=3.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_2    __attribute__((availability(ios,introduced=2.2,deprecated=3.2)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_2_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=3.2,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_2_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=3.2)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_0    __attribute__((availability(ios,introduced=2.2,deprecated=4.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=4.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=4.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_1    __attribute__((availability(ios,introduced=2.2,deprecated=4.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=4.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=4.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_2    __attribute__((availability(ios,introduced=2.2,deprecated=4.2)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_2_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=4.2,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_2_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=4.2)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_3    __attribute__((availability(ios,introduced=2.2,deprecated=4.3)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_3_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=4.3,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_3_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=4.3)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_0    __attribute__((availability(ios,introduced=2.2,deprecated=5.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=5.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=5.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1    __attribute__((availability(ios,introduced=2.2,deprecated=5.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=5.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=5.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0    __attribute__((availability(ios,introduced=2.2,deprecated=6.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=6.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=6.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1    __attribute__((availability(ios,introduced=2.2,deprecated=6.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=6.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=6.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0    __attribute__((availability(ios,introduced=2.2,deprecated=7.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=7.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=7.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_NA               __attribute__((availability(ios,introduced=2.2)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_NA_MSG(_msg)     __attribute__((availability(ios,introduced=2.2)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0                    __attribute__((availability(ios,introduced=3.0)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_0    __attribute__((availability(ios,introduced=3.0,deprecated=3.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.0,deprecated=3.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.0,deprecated=3.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_1    __attribute__((availability(ios,introduced=3.0,deprecated=3.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_1_MSG(_msg)    __attribute__((availability(ios,introduced=3.0,deprecated=3.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_1_MSG(_msg)    __attribute__((availability(ios,introduced=3.0,deprecated=3.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_2    __attribute__((availability(ios,introduced=3.0,deprecated=3.2)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_2_MSG(_msg)    __attribute__((availability(ios,introduced=3.0,deprecated=3.2,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_2_MSG(_msg)    __attribute__((availability(ios,introduced=3.0,deprecated=3.2)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_0    __attribute__((availability(ios,introduced=3.0,deprecated=4.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.0,deprecated=4.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.0,deprecated=4.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_1    __attribute__((availability(ios,introduced=3.0,deprecated=4.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_1_MSG(_msg)    __attribute__((availability(ios,introduced=3.0,deprecated=4.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_1_MSG(_msg)    __attribute__((availability(ios,introduced=3.0,deprecated=4.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_2    __attribute__((availability(ios,introduced=3.0,deprecated=4.2)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_2_MSG(_msg)    __attribute__((availability(ios,introduced=3.0,deprecated=4.2,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_2_MSG(_msg)    __attribute__((availability(ios,introduced=3.0,deprecated=4.2)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_3    __attribute__((availability(ios,introduced=3.0,deprecated=4.3)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_3_MSG(_msg)    __attribute__((availability(ios,introduced=3.0,deprecated=4.3,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_3_MSG(_msg)    __attribute__((availability(ios,introduced=3.0,deprecated=4.3)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_0    __attribute__((availability(ios,introduced=3.0,deprecated=5.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.0,deprecated=5.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.0,deprecated=5.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_1    __attribute__((availability(ios,introduced=3.0,deprecated=5.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=3.0,deprecated=5.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=3.0,deprecated=5.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0    __attribute__((availability(ios,introduced=3.0,deprecated=6.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.0,deprecated=6.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.0,deprecated=6.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1    __attribute__((availability(ios,introduced=3.0,deprecated=6.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=3.0,deprecated=6.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=3.0,deprecated=6.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0    __attribute__((availability(ios,introduced=3.0,deprecated=7.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.0,deprecated=7.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.0,deprecated=7.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_NA               __attribute__((availability(ios,introduced=3.0)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_NA_MSG(_msg)     __attribute__((availability(ios,introduced=3.0)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1                    __attribute__((availability(ios,introduced=3.1)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_1    __attribute__((availability(ios,introduced=3.1,deprecated=3.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_1_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=3.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_1_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=3.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_2    __attribute__((availability(ios,introduced=3.1,deprecated=3.2)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_2_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=3.2,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_2_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=3.2)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_0    __attribute__((availability(ios,introduced=3.1,deprecated=4.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=4.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=4.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_1    __attribute__((availability(ios,introduced=3.1,deprecated=4.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_1_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=4.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_1_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=4.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_2    __attribute__((availability(ios,introduced=3.1,deprecated=4.2)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_2_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=4.2,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_2_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=4.2)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_3    __attribute__((availability(ios,introduced=3.1,deprecated=4.3)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_3_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=4.3,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_3_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=4.3)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_0    __attribute__((availability(ios,introduced=3.1,deprecated=5.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=5.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=5.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1    __attribute__((availability(ios,introduced=3.1,deprecated=5.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=5.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=5.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0    __attribute__((availability(ios,introduced=3.1,deprecated=6.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=6.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=6.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1    __attribute__((availability(ios,introduced=3.1,deprecated=6.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=6.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=6.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0    __attribute__((availability(ios,introduced=3.1,deprecated=7.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=7.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=7.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_NA               __attribute__((availability(ios,introduced=3.1)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_NA_MSG(_msg)     __attribute__((availability(ios,introduced=3.1)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2                    __attribute__((availability(ios,introduced=3.2)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_3_2    __attribute__((availability(ios,introduced=3.2,deprecated=3.2)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_3_2_MSG(_msg)    __attribute__((availability(ios,introduced=3.2,deprecated=3.2,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_3_2_MSG(_msg)    __attribute__((availability(ios,introduced=3.2,deprecated=3.2)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_0    __attribute__((availability(ios,introduced=3.2,deprecated=4.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.2,deprecated=4.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.2,deprecated=4.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_1    __attribute__((availability(ios,introduced=3.2,deprecated=4.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_1_MSG(_msg)    __attribute__((availability(ios,introduced=3.2,deprecated=4.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_1_MSG(_msg)    __attribute__((availability(ios,introduced=3.2,deprecated=4.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_2    __attribute__((availability(ios,introduced=3.2,deprecated=4.2)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_2_MSG(_msg)    __attribute__((availability(ios,introduced=3.2,deprecated=4.2,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_2_MSG(_msg)    __attribute__((availability(ios,introduced=3.2,deprecated=4.2)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_3    __attribute__((availability(ios,introduced=3.2,deprecated=4.3)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_3_MSG(_msg)    __attribute__((availability(ios,introduced=3.2,deprecated=4.3,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_3_MSG(_msg)    __attribute__((availability(ios,introduced=3.2,deprecated=4.3)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_0    __attribute__((availability(ios,introduced=3.2,deprecated=5.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.2,deprecated=5.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.2,deprecated=5.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_1    __attribute__((availability(ios,introduced=3.2,deprecated=5.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=3.2,deprecated=5.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=3.2,deprecated=5.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0    __attribute__((availability(ios,introduced=3.2,deprecated=6.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.2,deprecated=6.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.2,deprecated=6.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1    __attribute__((availability(ios,introduced=3.2,deprecated=6.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=3.2,deprecated=6.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=3.2,deprecated=6.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0    __attribute__((availability(ios,introduced=3.2,deprecated=7.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.2,deprecated=7.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.2,deprecated=7.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_NA               __attribute__((availability(ios,introduced=3.2)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_NA_MSG(_msg)     __attribute__((availability(ios,introduced=3.2)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0                    __attribute__((availability(ios,introduced=4.0)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_0    __attribute__((availability(ios,introduced=4.0,deprecated=4.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.0,deprecated=4.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.0,deprecated=4.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_1    __attribute__((availability(ios,introduced=4.0,deprecated=4.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_1_MSG(_msg)    __attribute__((availability(ios,introduced=4.0,deprecated=4.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_1_MSG(_msg)    __attribute__((availability(ios,introduced=4.0,deprecated=4.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_2    __attribute__((availability(ios,introduced=4.0,deprecated=4.2)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_2_MSG(_msg)    __attribute__((availability(ios,introduced=4.0,deprecated=4.2,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_2_MSG(_msg)    __attribute__((availability(ios,introduced=4.0,deprecated=4.2)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_3    __attribute__((availability(ios,introduced=4.0,deprecated=4.3)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_3_MSG(_msg)    __attribute__((availability(ios,introduced=4.0,deprecated=4.3,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_3_MSG(_msg)    __attribute__((availability(ios,introduced=4.0,deprecated=4.3)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_0    __attribute__((availability(ios,introduced=4.0,deprecated=5.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.0,deprecated=5.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.0,deprecated=5.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1    __attribute__((availability(ios,introduced=4.0,deprecated=5.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=4.0,deprecated=5.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=4.0,deprecated=5.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0    __attribute__((availability(ios,introduced=4.0,deprecated=6.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.0,deprecated=6.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.0,deprecated=6.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1    __attribute__((availability(ios,introduced=4.0,deprecated=6.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=4.0,deprecated=6.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=4.0,deprecated=6.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0    __attribute__((availability(ios,introduced=4.0,deprecated=7.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.0,deprecated=7.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.0,deprecated=7.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_NA               __attribute__((availability(ios,introduced=4.0)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_NA_MSG(_msg)     __attribute__((availability(ios,introduced=4.0)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1                    __attribute__((availability(ios,introduced=4.1)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_1    __attribute__((availability(ios,introduced=4.1,deprecated=4.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_1_MSG(_msg)    __attribute__((availability(ios,introduced=4.1,deprecated=4.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_1_MSG(_msg)    __attribute__((availability(ios,introduced=4.1,deprecated=4.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_2    __attribute__((availability(ios,introduced=4.1,deprecated=4.2)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_2_MSG(_msg)    __attribute__((availability(ios,introduced=4.1,deprecated=4.2,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_2_MSG(_msg)    __attribute__((availability(ios,introduced=4.1,deprecated=4.2)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_3    __attribute__((availability(ios,introduced=4.1,deprecated=4.3)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_3_MSG(_msg)    __attribute__((availability(ios,introduced=4.1,deprecated=4.3,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_3_MSG(_msg)    __attribute__((availability(ios,introduced=4.1,deprecated=4.3)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_0    __attribute__((availability(ios,introduced=4.1,deprecated=5.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.1,deprecated=5.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.1,deprecated=5.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_1    __attribute__((availability(ios,introduced=4.1,deprecated=5.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=4.1,deprecated=5.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=4.1,deprecated=5.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0    __attribute__((availability(ios,introduced=4.1,deprecated=6.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.1,deprecated=6.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.1,deprecated=6.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1    __attribute__((availability(ios,introduced=4.1,deprecated=6.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=4.1,deprecated=6.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=4.1,deprecated=6.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0    __attribute__((availability(ios,introduced=4.1,deprecated=7.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.1,deprecated=7.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.1,deprecated=7.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_NA               __attribute__((availability(ios,introduced=4.1)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_NA_MSG(_msg)     __attribute__((availability(ios,introduced=4.1)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2                    __attribute__((availability(ios,introduced=4.2)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_2    __attribute__((availability(ios,introduced=4.2,deprecated=4.2)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_2_MSG(_msg)    __attribute__((availability(ios,introduced=4.2,deprecated=4.2,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_2_MSG(_msg)    __attribute__((availability(ios,introduced=4.2,deprecated=4.2)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_3    __attribute__((availability(ios,introduced=4.2,deprecated=4.3)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_3_MSG(_msg)    __attribute__((availability(ios,introduced=4.2,deprecated=4.3,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_3_MSG(_msg)    __attribute__((availability(ios,introduced=4.2,deprecated=4.3)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_0    __attribute__((availability(ios,introduced=4.2,deprecated=5.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.2,deprecated=5.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.2,deprecated=5.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1    __attribute__((availability(ios,introduced=4.2,deprecated=5.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=4.2,deprecated=5.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=4.2,deprecated=5.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0    __attribute__((availability(ios,introduced=4.2,deprecated=6.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.2,deprecated=6.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.2,deprecated=6.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1    __attribute__((availability(ios,introduced=4.2,deprecated=6.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=4.2,deprecated=6.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=4.2,deprecated=6.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0    __attribute__((availability(ios,introduced=4.2,deprecated=7.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.2,deprecated=7.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.2,deprecated=7.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_NA               __attribute__((availability(ios,introduced=4.2)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_NA_MSG(_msg)     __attribute__((availability(ios,introduced=4.2)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3                    __attribute__((availability(ios,introduced=4.3)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_4_3    __attribute__((availability(ios,introduced=4.3,deprecated=4.3)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_4_3_MSG(_msg)    __attribute__((availability(ios,introduced=4.3,deprecated=4.3,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_4_3_MSG(_msg)    __attribute__((availability(ios,introduced=4.3,deprecated=4.3)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_0    __attribute__((availability(ios,introduced=4.3,deprecated=5.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.3,deprecated=5.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.3,deprecated=5.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_1    __attribute__((availability(ios,introduced=4.3,deprecated=5.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=4.3,deprecated=5.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=4.3,deprecated=5.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0    __attribute__((availability(ios,introduced=4.3,deprecated=6.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.3,deprecated=6.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.3,deprecated=6.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1    __attribute__((availability(ios,introduced=4.3,deprecated=6.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=4.3,deprecated=6.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=4.3,deprecated=6.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0    __attribute__((availability(ios,introduced=4.3,deprecated=7.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.3,deprecated=7.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.3,deprecated=7.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_NA               __attribute__((availability(ios,introduced=4.3)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_NA_MSG(_msg)     __attribute__((availability(ios,introduced=4.3)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0                    __attribute__((availability(ios,introduced=5.0)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_0    __attribute__((availability(ios,introduced=5.0,deprecated=5.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_0_MSG(_msg)    __attribute__((availability(ios,introduced=5.0,deprecated=5.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_0_MSG(_msg)    __attribute__((availability(ios,introduced=5.0,deprecated=5.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1    __attribute__((availability(ios,introduced=5.0,deprecated=5.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=5.0,deprecated=5.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=5.0,deprecated=5.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0    __attribute__((availability(ios,introduced=5.0,deprecated=6.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=5.0,deprecated=6.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=5.0,deprecated=6.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1    __attribute__((availability(ios,introduced=5.0,deprecated=6.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=5.0,deprecated=6.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=5.0,deprecated=6.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0    __attribute__((availability(ios,introduced=5.0,deprecated=7.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=5.0,deprecated=7.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=5.0,deprecated=7.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_NA               __attribute__((availability(ios,introduced=5.0)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_NA_MSG(_msg)     __attribute__((availability(ios,introduced=5.0)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1                    __attribute__((availability(ios,introduced=5.1)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_5_1    __attribute__((availability(ios,introduced=5.1,deprecated=5.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=5.1,deprecated=5.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=5.1,deprecated=5.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0    __attribute__((availability(ios,introduced=5.1,deprecated=6.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=5.1,deprecated=6.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=5.1,deprecated=6.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1    __attribute__((availability(ios,introduced=5.1,deprecated=6.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=5.1,deprecated=6.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=5.1,deprecated=6.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0    __attribute__((availability(ios,introduced=5.1,deprecated=7.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=5.1,deprecated=7.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=5.1,deprecated=7.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_NA               __attribute__((availability(ios,introduced=5.1)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_NA_MSG(_msg)     __attribute__((availability(ios,introduced=5.1)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0                    __attribute__((availability(ios,introduced=6.0)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0    __attribute__((availability(ios,introduced=6.0,deprecated=6.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=6.0,deprecated=6.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=6.0,deprecated=6.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1    __attribute__((availability(ios,introduced=6.0,deprecated=6.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=6.0,deprecated=6.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=6.0,deprecated=6.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0    __attribute__((availability(ios,introduced=6.0,deprecated=7.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=6.0,deprecated=7.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=6.0,deprecated=7.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_NA               __attribute__((availability(ios,introduced=6.0)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_NA_MSG(_msg)     __attribute__((availability(ios,introduced=6.0)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1                    __attribute__((availability(ios,introduced=6.1)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1    __attribute__((availability(ios,introduced=6.1,deprecated=6.1)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=6.1,deprecated=6.1,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=6.1,deprecated=6.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0    __attribute__((availability(ios,introduced=6.1,deprecated=7.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=6.1,deprecated=7.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=6.1,deprecated=7.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_NA               __attribute__((availability(ios,introduced=6.1)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_NA_MSG(_msg)     __attribute__((availability(ios,introduced=6.1)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0                    __attribute__((availability(ios,introduced=7.0)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0    __attribute__((availability(ios,introduced=7.0,deprecated=7.0)))", "            #if __has_feature(attribute_availability_with_message)", "                    #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=7.0,deprecated=7.0,message=_msg)))", "            #else", "                    #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=7.0,deprecated=7.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_NA               __attribute__((availability(ios,introduced=7.0)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_NA_MSG(_msg)     __attribute__((availability(ios,introduced=7.0)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_NA                               __attribute__((availability(ios,unavailable)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_NA_DEP__IPHONE_NA                __attribute__((availability(ios,unavailable)))", "            #define __AVAILABILITY_INTERNAL__IPHONE_NA_DEP__IPHONE_NA_MSG(_msg)      __attribute__((availability(ios,unavailable)))", "        #endif", "    #endif", "", "    #ifndef __AVAILABILITY_INTERNAL__IPHONE_2_0", "        /* set up old style internal macros (up to 2.0) */", "        #if __IPHONE_OS_VERSION_MAX_ALLOWED < __IPHONE_2_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0                      __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0                      __AVAILABILITY_INTERNAL_WEAK_IMPORT", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0                      __AVAILABILITY_INTERNAL_REGULAR", "        #endif", "        #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_NA           __AVAILABILITY_INTERNAL__IPHONE_2_0", "        #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_NA_MSG(_msg) __AVAILABILITY_INTERNAL__IPHONE_2_0", "        #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_2_0              __AVAILABILITY_INTERNAL_DEPRECATED", "        #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_2_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "        /* set up old style internal macros (up to 2.1) */", "        #if __IPHONE_OS_VERSION_MAX_ALLOWED < __IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1                      __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1                      __AVAILABILITY_INTERNAL_WEAK_IMPORT", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1                      __AVAILABILITY_INTERNAL_REGULAR", "        #endif", "        #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_NA           __AVAILABILITY_INTERNAL__IPHONE_2_1", "        #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_NA_MSG(_msg) __AVAILABILITY_INTERNAL__IPHONE_2_1", "        #if __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_2_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_2_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_2_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_2_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_2_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_2_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_2_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_2_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "        #endif", "        /* set up old style internal macros (up to 2.2) */", "        #if __IPHONE_OS_VERSION_MAX_ALLOWED < __IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2                      __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2                      __AVAILABILITY_INTERNAL_WEAK_IMPORT", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2                      __AVAILABILITY_INTERNAL_REGULAR", "        #endif", "        #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_NA           __AVAILABILITY_INTERNAL__IPHONE_2_2", "        #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_NA_MSG(_msg) __AVAILABILITY_INTERNAL__IPHONE_2_2", "        #if __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_2_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_2_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_2_2              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_2_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_2_2              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_2_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_2_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_2_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_2_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_2_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_2_2              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_2_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_2_2              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_2_2_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_2_2              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_2_2_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_2_2              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_2_2_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "        #endif", "        /* set up old style internal macros (up to 3.0) */", "        #if __IPHONE_OS_VERSION_MAX_ALLOWED < __IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0                      __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0                      __AVAILABILITY_INTERNAL_WEAK_IMPORT", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0                      __AVAILABILITY_INTERNAL_REGULAR", "        #endif", "        #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_NA           __AVAILABILITY_INTERNAL__IPHONE_3_0", "        #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_NA_MSG(_msg) __AVAILABILITY_INTERNAL__IPHONE_3_0", "        #if __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "        #endif", "        /* set up old style internal macros (up to 3.1) */", "        #if __IPHONE_OS_VERSION_MAX_ALLOWED < __IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1                      __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1                      __AVAILABILITY_INTERNAL_WEAK_IMPORT", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1                      __AVAILABILITY_INTERNAL_REGULAR", "        #endif", "        #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_NA           __AVAILABILITY_INTERNAL__IPHONE_3_1", "        #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_NA_MSG(_msg) __AVAILABILITY_INTERNAL__IPHONE_3_1", "        #if __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_1              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_1              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_1              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "        #endif", "        /* set up old style internal macros (up to 3.2) */", "        #if __IPHONE_OS_VERSION_MAX_ALLOWED < __IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2                      __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2                      __AVAILABILITY_INTERNAL_WEAK_IMPORT", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2                      __AVAILABILITY_INTERNAL_REGULAR", "        #endif", "        #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_NA           __AVAILABILITY_INTERNAL__IPHONE_3_2", "        #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_NA_MSG(_msg) __AVAILABILITY_INTERNAL__IPHONE_3_2", "        #if __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_3_2              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_3_2_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "        #endif", "        /* set up old style internal macros (up to 4.0) */", "        #if __IPHONE_OS_VERSION_MAX_ALLOWED < __IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0                      __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0                      __AVAILABILITY_INTERNAL_WEAK_IMPORT", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0                      __AVAILABILITY_INTERNAL_REGULAR", "        #endif", "        #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_NA           __AVAILABILITY_INTERNAL__IPHONE_4_0", "        #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_NA_MSG(_msg) __AVAILABILITY_INTERNAL__IPHONE_4_0", "        #if __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "        #endif", "        /* set up old style internal macros (up to 4.1) */", "        #if __IPHONE_OS_VERSION_MAX_ALLOWED < __IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1                      __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1                      __AVAILABILITY_INTERNAL_WEAK_IMPORT", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1                      __AVAILABILITY_INTERNAL_REGULAR", "        #endif", "        #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_NA           __AVAILABILITY_INTERNAL__IPHONE_4_1", "        #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_NA_MSG(_msg) __AVAILABILITY_INTERNAL__IPHONE_4_1", "        #if __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "        #endif", "        /* set up old style internal macros (up to 4.2) */", "        #if __IPHONE_OS_VERSION_MAX_ALLOWED < __IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2                      __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2                      __AVAILABILITY_INTERNAL_WEAK_IMPORT", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2                      __AVAILABILITY_INTERNAL_REGULAR", "        #endif", "        #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_NA           __AVAILABILITY_INTERNAL__IPHONE_4_2", "        #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_NA_MSG(_msg) __AVAILABILITY_INTERNAL__IPHONE_4_2", "        #if __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_2", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_2              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_2_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "        #endif", "        /* set up old style internal macros (up to 4.3) */", "        #if __IPHONE_OS_VERSION_MAX_ALLOWED < __IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3                      __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3                      __AVAILABILITY_INTERNAL_WEAK_IMPORT", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3                      __AVAILABILITY_INTERNAL_REGULAR", "        #endif", "        #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_NA           __AVAILABILITY_INTERNAL__IPHONE_4_3", "        #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_NA_MSG(_msg) __AVAILABILITY_INTERNAL__IPHONE_4_3", "        #if __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_2", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_3", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_4_3              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_4_3_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "        #endif", "        /* set up old style internal macros (up to 5.0) */", "        #if __IPHONE_OS_VERSION_MAX_ALLOWED < __IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0                      __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0                      __AVAILABILITY_INTERNAL_WEAK_IMPORT", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0                      __AVAILABILITY_INTERNAL_REGULAR", "        #endif", "        #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_NA           __AVAILABILITY_INTERNAL__IPHONE_5_0", "        #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_NA_MSG(_msg) __AVAILABILITY_INTERNAL__IPHONE_5_0", "        #if __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_2", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_3", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL__IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_5_0", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "        #endif", "        /* set up old style internal macros (up to 5.1) */", "        #if __IPHONE_OS_VERSION_MAX_ALLOWED < __IPHONE_5_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1                      __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_5_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1                      __AVAILABILITY_INTERNAL_WEAK_IMPORT", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1                      __AVAILABILITY_INTERNAL_REGULAR", "        #endif", "        #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_NA           __AVAILABILITY_INTERNAL__IPHONE_5_1", "        #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_NA_MSG(_msg) __AVAILABILITY_INTERNAL__IPHONE_5_1", "        #if __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_2", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_3", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_5_0", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_5_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL__IPHONE_5_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_5_1", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_5_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_5_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "        #endif", "        /* set up old style internal macros (up to 6.0) */", "        #if __IPHONE_OS_VERSION_MAX_ALLOWED < __IPHONE_6_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0                      __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_6_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0                      __AVAILABILITY_INTERNAL_WEAK_IMPORT", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0                      __AVAILABILITY_INTERNAL_REGULAR", "        #endif", "        #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_NA           __AVAILABILITY_INTERNAL__IPHONE_6_0", "        #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_NA_MSG(_msg) __AVAILABILITY_INTERNAL__IPHONE_6_0", "        #if __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_2", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_3", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_5_0", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_5_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_5_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_5_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_5_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_5_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_6_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL__IPHONE_6_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_6_0", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "        #endif", "        /* set up old style internal macros (up to 6.1) */", "        #if __IPHONE_OS_VERSION_MAX_ALLOWED < __IPHONE_6_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1                      __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_6_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1                      __AVAILABILITY_INTERNAL_WEAK_IMPORT", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1                      __AVAILABILITY_INTERNAL_REGULAR", "        #endif", "        #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_NA           __AVAILABILITY_INTERNAL__IPHONE_6_1", "        #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_NA_MSG(_msg) __AVAILABILITY_INTERNAL__IPHONE_6_1", "        #if __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_2", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_3", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_5_0", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_5_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_5_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_5_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_5_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_5_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_5_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_5_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_6_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_6_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_6_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_6_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_6_0", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_6_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL__IPHONE_6_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_6_1", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_6_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "        #endif", "        /* set up old style internal macros (up to 7.0) */", "        #if __IPHONE_OS_VERSION_MAX_ALLOWED < __IPHONE_7_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0                      __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_7_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0                      __AVAILABILITY_INTERNAL_WEAK_IMPORT", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0                      __AVAILABILITY_INTERNAL_REGULAR", "        #endif", "        #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_NA           __AVAILABILITY_INTERNAL__IPHONE_7_0", "        #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_NA_MSG(_msg) __AVAILABILITY_INTERNAL__IPHONE_7_0", "        #if __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_2_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_2_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_2_2", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_0", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_3_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_3_2", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_0", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_2", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_2", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_4_3", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_4_3", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_5_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_5_0", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_5_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_5_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_5_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_5_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_5_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_5_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_5_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_5_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_5_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_6_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_6_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_6_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_6_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_6_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_6_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_6_0", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_6_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_6_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_6_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_6_1", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_6_1", "        #elif __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_7_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_REGULAR", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL__IPHONE_7_0", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL__IPHONE_7_0", "        #else", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "        #endif", "        /* set up internal macros (n/a) */", "        #define __AVAILABILITY_INTERNAL__IPHONE_NA                               __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #define __AVAILABILITY_INTERNAL__IPHONE_NA_DEP__IPHONE_NA                __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #define __AVAILABILITY_INTERNAL__IPHONE_NA_DEP__IPHONE_NA_MSG(_msg)      __AVAILABILITY_INTERNAL_UNAVAILABLE", "    #endif", "", "#elif defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__)", "    /* compiler for Mac OS X sets __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ */", "    #define __MAC_OS_X_VERSION_MIN_REQUIRED __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__", "    /* make sure a default max version is set */", "    #ifndef __MAC_OS_X_VERSION_MAX_ALLOWED", "        #define __MAC_OS_X_VERSION_MAX_ALLOWED __MAC_10_9", "    #endif", "", "    #if defined(__has_attribute) && defined(__has_feature)", "        #if __has_attribute(availability)", "            /* use better attributes if possible */", "            #define __AVAILABILITY_INTERNAL__MAC_10_0                  __attribute__((availability(macosx,introduced=10.0)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_0    __attribute__((availability(macosx,introduced=10.0,deprecated=10.0)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_0_MSG(_msg)    __attribute__((availability(macosx,introduced=10.0,deprecated=10.0,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_0_MSG(_msg)    __attribute__((availability(macosx,introduced=10.0,deprecated=10.0)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_1    __attribute__((availability(macosx,introduced=10.0,deprecated=10.1)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_1_MSG(_msg)    __attribute__((availability(macosx,introduced=10.0,deprecated=10.1,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_1_MSG(_msg)    __attribute__((availability(macosx,introduced=10.0,deprecated=10.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_2    __attribute__((availability(macosx,introduced=10.0,deprecated=10.2)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_2_MSG(_msg)    __attribute__((availability(macosx,introduced=10.0,deprecated=10.2,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_2_MSG(_msg)    __attribute__((availability(macosx,introduced=10.0,deprecated=10.2)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_3    __attribute__((availability(macosx,introduced=10.0,deprecated=10.3)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_3_MSG(_msg)    __attribute__((availability(macosx,introduced=10.0,deprecated=10.3,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_3_MSG(_msg)    __attribute__((availability(macosx,introduced=10.0,deprecated=10.3)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_4    __attribute__((availability(macosx,introduced=10.0,deprecated=10.4)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_4_MSG(_msg)    __attribute__((availability(macosx,introduced=10.0,deprecated=10.4,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_4_MSG(_msg)    __attribute__((availability(macosx,introduced=10.0,deprecated=10.4)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_5    __attribute__((availability(macosx,introduced=10.0,deprecated=10.5)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_5_MSG(_msg)    __attribute__((availability(macosx,introduced=10.0,deprecated=10.5,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_5_MSG(_msg)    __attribute__((availability(macosx,introduced=10.0,deprecated=10.5)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_6    __attribute__((availability(macosx,introduced=10.0,deprecated=10.6)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_6_MSG(_msg)    __attribute__((availability(macosx,introduced=10.0,deprecated=10.6,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_6_MSG(_msg)    __attribute__((availability(macosx,introduced=10.0,deprecated=10.6)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_7    __attribute__((availability(macosx,introduced=10.0,deprecated=10.7)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_7_MSG(_msg)    __attribute__((availability(macosx,introduced=10.0,deprecated=10.7,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_7_MSG(_msg)    __attribute__((availability(macosx,introduced=10.0,deprecated=10.7)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_8    __attribute__((availability(macosx,introduced=10.0,deprecated=10.8)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_8_MSG(_msg)    __attribute__((availability(macosx,introduced=10.0,deprecated=10.8,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_8_MSG(_msg)    __attribute__((availability(macosx,introduced=10.0,deprecated=10.8)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_9    __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_9_MSG(_msg)    __attribute__((availability(macosx,introduced=10.0,deprecated=10.9,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_9_MSG(_msg)    __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_NA_MSG(_msg)      __attribute__((availability(macosx,introduced=10.0)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_NA                __attribute__((availability(macosx,introduced=10.0)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_1                  __attribute__((availability(macosx,introduced=10.1)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_1    __attribute__((availability(macosx,introduced=10.1,deprecated=10.1)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_1_MSG(_msg)    __attribute__((availability(macosx,introduced=10.1,deprecated=10.1,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_1_MSG(_msg)    __attribute__((availability(macosx,introduced=10.1,deprecated=10.1)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_2    __attribute__((availability(macosx,introduced=10.1,deprecated=10.2)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_2_MSG(_msg)    __attribute__((availability(macosx,introduced=10.1,deprecated=10.2,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_2_MSG(_msg)    __attribute__((availability(macosx,introduced=10.1,deprecated=10.2)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_3    __attribute__((availability(macosx,introduced=10.1,deprecated=10.3)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_3_MSG(_msg)    __attribute__((availability(macosx,introduced=10.1,deprecated=10.3,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_3_MSG(_msg)    __attribute__((availability(macosx,introduced=10.1,deprecated=10.3)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_4    __attribute__((availability(macosx,introduced=10.1,deprecated=10.4)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_4_MSG(_msg)    __attribute__((availability(macosx,introduced=10.1,deprecated=10.4,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_4_MSG(_msg)    __attribute__((availability(macosx,introduced=10.1,deprecated=10.4)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_5    __attribute__((availability(macosx,introduced=10.1,deprecated=10.5)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_5_MSG(_msg)    __attribute__((availability(macosx,introduced=10.1,deprecated=10.5,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_5_MSG(_msg)    __attribute__((availability(macosx,introduced=10.1,deprecated=10.5)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_6    __attribute__((availability(macosx,introduced=10.1,deprecated=10.6)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_6_MSG(_msg)    __attribute__((availability(macosx,introduced=10.1,deprecated=10.6,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_6_MSG(_msg)    __attribute__((availability(macosx,introduced=10.1,deprecated=10.6)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_7    __attribute__((availability(macosx,introduced=10.1,deprecated=10.7)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_7_MSG(_msg)    __attribute__((availability(macosx,introduced=10.1,deprecated=10.7,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_7_MSG(_msg)    __attribute__((availability(macosx,introduced=10.1,deprecated=10.7)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_8    __attribute__((availability(macosx,introduced=10.1,deprecated=10.8)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_8_MSG(_msg)    __attribute__((availability(macosx,introduced=10.1,deprecated=10.8,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_8_MSG(_msg)    __attribute__((availability(macosx,introduced=10.1,deprecated=10.8)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_9    __attribute__((availability(macosx,introduced=10.1,deprecated=10.9)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_9_MSG(_msg)    __attribute__((availability(macosx,introduced=10.1,deprecated=10.9,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_9_MSG(_msg)    __attribute__((availability(macosx,introduced=10.1,deprecated=10.9)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_NA_MSG(_msg)      __attribute__((availability(macosx,introduced=10.1)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_NA                __attribute__((availability(macosx,introduced=10.1)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_2                  __attribute__((availability(macosx,introduced=10.2)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_2    __attribute__((availability(macosx,introduced=10.2,deprecated=10.2)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_2_MSG(_msg)    __attribute__((availability(macosx,introduced=10.2,deprecated=10.2,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_2_MSG(_msg)    __attribute__((availability(macosx,introduced=10.2,deprecated=10.2)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_3    __attribute__((availability(macosx,introduced=10.2,deprecated=10.3)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_3_MSG(_msg)    __attribute__((availability(macosx,introduced=10.2,deprecated=10.3,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_3_MSG(_msg)    __attribute__((availability(macosx,introduced=10.2,deprecated=10.3)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_4    __attribute__((availability(macosx,introduced=10.2,deprecated=10.4)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_4_MSG(_msg)    __attribute__((availability(macosx,introduced=10.2,deprecated=10.4,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_4_MSG(_msg)    __attribute__((availability(macosx,introduced=10.2,deprecated=10.4)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_5    __attribute__((availability(macosx,introduced=10.2,deprecated=10.5)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_5_MSG(_msg)    __attribute__((availability(macosx,introduced=10.2,deprecated=10.5,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_5_MSG(_msg)    __attribute__((availability(macosx,introduced=10.2,deprecated=10.5)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_6    __attribute__((availability(macosx,introduced=10.2,deprecated=10.6)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_6_MSG(_msg)    __attribute__((availability(macosx,introduced=10.2,deprecated=10.6,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_6_MSG(_msg)    __attribute__((availability(macosx,introduced=10.2,deprecated=10.6)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_7    __attribute__((availability(macosx,introduced=10.2,deprecated=10.7)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_7_MSG(_msg)    __attribute__((availability(macosx,introduced=10.2,deprecated=10.7,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_7_MSG(_msg)    __attribute__((availability(macosx,introduced=10.2,deprecated=10.7)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_8    __attribute__((availability(macosx,introduced=10.2,deprecated=10.8)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_8_MSG(_msg)    __attribute__((availability(macosx,introduced=10.2,deprecated=10.8,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_8_MSG(_msg)    __attribute__((availability(macosx,introduced=10.2,deprecated=10.8)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_9    __attribute__((availability(macosx,introduced=10.2,deprecated=10.9)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_9_MSG(_msg)    __attribute__((availability(macosx,introduced=10.2,deprecated=10.9,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_9_MSG(_msg)    __attribute__((availability(macosx,introduced=10.2,deprecated=10.9)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_NA_MSG(_msg)      __attribute__((availability(macosx,introduced=10.2)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_NA                __attribute__((availability(macosx,introduced=10.2)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_3                  __attribute__((availability(macosx,introduced=10.3)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_3    __attribute__((availability(macosx,introduced=10.3,deprecated=10.3)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_3_MSG(_msg)    __attribute__((availability(macosx,introduced=10.3,deprecated=10.3,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_3_MSG(_msg)    __attribute__((availability(macosx,introduced=10.3,deprecated=10.3)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_4    __attribute__((availability(macosx,introduced=10.3,deprecated=10.4)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_4_MSG(_msg)    __attribute__((availability(macosx,introduced=10.3,deprecated=10.4,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_4_MSG(_msg)    __attribute__((availability(macosx,introduced=10.3,deprecated=10.4)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_5    __attribute__((availability(macosx,introduced=10.3,deprecated=10.5)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_5_MSG(_msg)    __attribute__((availability(macosx,introduced=10.3,deprecated=10.5,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_5_MSG(_msg)    __attribute__((availability(macosx,introduced=10.3,deprecated=10.5)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_6    __attribute__((availability(macosx,introduced=10.3,deprecated=10.6)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_6_MSG(_msg)    __attribute__((availability(macosx,introduced=10.3,deprecated=10.6,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_6_MSG(_msg)    __attribute__((availability(macosx,introduced=10.3,deprecated=10.6)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_7    __attribute__((availability(macosx,introduced=10.3,deprecated=10.7)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_7_MSG(_msg)    __attribute__((availability(macosx,introduced=10.3,deprecated=10.7,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_7_MSG(_msg)    __attribute__((availability(macosx,introduced=10.3,deprecated=10.7)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_8    __attribute__((availability(macosx,introduced=10.3,deprecated=10.8)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_8_MSG(_msg)    __attribute__((availability(macosx,introduced=10.3,deprecated=10.8,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_8_MSG(_msg)    __attribute__((availability(macosx,introduced=10.3,deprecated=10.8)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_9    __attribute__((availability(macosx,introduced=10.3,deprecated=10.9)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_9_MSG(_msg)    __attribute__((availability(macosx,introduced=10.3,deprecated=10.9,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_9_MSG(_msg)    __attribute__((availability(macosx,introduced=10.3,deprecated=10.9)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_NA_MSG(_msg)      __attribute__((availability(macosx,introduced=10.3)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_NA                __attribute__((availability(macosx,introduced=10.3)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_4                  __attribute__((availability(macosx,introduced=10.4)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_4    __attribute__((availability(macosx,introduced=10.4,deprecated=10.4)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_4_MSG(_msg)    __attribute__((availability(macosx,introduced=10.4,deprecated=10.4,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_4_MSG(_msg)    __attribute__((availability(macosx,introduced=10.4,deprecated=10.4)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_5    __attribute__((availability(macosx,introduced=10.4,deprecated=10.5)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_5_MSG(_msg)    __attribute__((availability(macosx,introduced=10.4,deprecated=10.5,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_5_MSG(_msg)    __attribute__((availability(macosx,introduced=10.4,deprecated=10.5)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_6    __attribute__((availability(macosx,introduced=10.4,deprecated=10.6)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_6_MSG(_msg)    __attribute__((availability(macosx,introduced=10.4,deprecated=10.6,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_6_MSG(_msg)    __attribute__((availability(macosx,introduced=10.4,deprecated=10.6)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_7    __attribute__((availability(macosx,introduced=10.4,deprecated=10.7)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_7_MSG(_msg)    __attribute__((availability(macosx,introduced=10.4,deprecated=10.7,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_7_MSG(_msg)    __attribute__((availability(macosx,introduced=10.4,deprecated=10.7)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_8    __attribute__((availability(macosx,introduced=10.4,deprecated=10.8)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_8_MSG(_msg)    __attribute__((availability(macosx,introduced=10.4,deprecated=10.8,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_8_MSG(_msg)    __attribute__((availability(macosx,introduced=10.4,deprecated=10.8)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_9    __attribute__((availability(macosx,introduced=10.4,deprecated=10.9)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_9_MSG(_msg)    __attribute__((availability(macosx,introduced=10.4,deprecated=10.9,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_9_MSG(_msg)    __attribute__((availability(macosx,introduced=10.4,deprecated=10.9)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_NA_MSG(_msg)      __attribute__((availability(macosx,introduced=10.4)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_NA                __attribute__((availability(macosx,introduced=10.4)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_5                  __attribute__((availability(macosx,introduced=10.5)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_5    __attribute__((availability(macosx,introduced=10.5,deprecated=10.5)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_5_MSG(_msg)    __attribute__((availability(macosx,introduced=10.5,deprecated=10.5,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_5_MSG(_msg)    __attribute__((availability(macosx,introduced=10.5,deprecated=10.5)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_6    __attribute__((availability(macosx,introduced=10.5,deprecated=10.6)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_6_MSG(_msg)    __attribute__((availability(macosx,introduced=10.5,deprecated=10.6,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_6_MSG(_msg)    __attribute__((availability(macosx,introduced=10.5,deprecated=10.6)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_7    __attribute__((availability(macosx,introduced=10.5,deprecated=10.7)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_7_MSG(_msg)    __attribute__((availability(macosx,introduced=10.5,deprecated=10.7,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_7_MSG(_msg)    __attribute__((availability(macosx,introduced=10.5,deprecated=10.7)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_8    __attribute__((availability(macosx,introduced=10.5,deprecated=10.8)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_8_MSG(_msg)    __attribute__((availability(macosx,introduced=10.5,deprecated=10.8,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_8_MSG(_msg)    __attribute__((availability(macosx,introduced=10.5,deprecated=10.8)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_9    __attribute__((availability(macosx,introduced=10.5,deprecated=10.9)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_9_MSG(_msg)    __attribute__((availability(macosx,introduced=10.5,deprecated=10.9,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_9_MSG(_msg)    __attribute__((availability(macosx,introduced=10.5,deprecated=10.9)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_NA_MSG(_msg)      __attribute__((availability(macosx,introduced=10.5)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_NA                __attribute__((availability(macosx,introduced=10.5)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_6                  __attribute__((availability(macosx,introduced=10.6)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_6    __attribute__((availability(macosx,introduced=10.6,deprecated=10.6)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_6_MSG(_msg)    __attribute__((availability(macosx,introduced=10.6,deprecated=10.6,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_6_MSG(_msg)    __attribute__((availability(macosx,introduced=10.6,deprecated=10.6)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_7    __attribute__((availability(macosx,introduced=10.6,deprecated=10.7)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_7_MSG(_msg)    __attribute__((availability(macosx,introduced=10.6,deprecated=10.7,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_7_MSG(_msg)    __attribute__((availability(macosx,introduced=10.6,deprecated=10.7)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_8    __attribute__((availability(macosx,introduced=10.6,deprecated=10.8)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_8_MSG(_msg)    __attribute__((availability(macosx,introduced=10.6,deprecated=10.8,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_8_MSG(_msg)    __attribute__((availability(macosx,introduced=10.6,deprecated=10.8)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_9    __attribute__((availability(macosx,introduced=10.6,deprecated=10.9)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_9_MSG(_msg)    __attribute__((availability(macosx,introduced=10.6,deprecated=10.9,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_9_MSG(_msg)    __attribute__((availability(macosx,introduced=10.6,deprecated=10.9)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_NA_MSG(_msg)      __attribute__((availability(macosx,introduced=10.6)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_NA                __attribute__((availability(macosx,introduced=10.6)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_7                  __attribute__((availability(macosx,introduced=10.7)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_7    __attribute__((availability(macosx,introduced=10.7,deprecated=10.7)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_7_MSG(_msg)    __attribute__((availability(macosx,introduced=10.7,deprecated=10.7,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_7_MSG(_msg)    __attribute__((availability(macosx,introduced=10.7,deprecated=10.7)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_8    __attribute__((availability(macosx,introduced=10.7,deprecated=10.8)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_8_MSG(_msg)    __attribute__((availability(macosx,introduced=10.7,deprecated=10.8,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_8_MSG(_msg)    __attribute__((availability(macosx,introduced=10.7,deprecated=10.8)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_9    __attribute__((availability(macosx,introduced=10.7,deprecated=10.9)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_9_MSG(_msg)    __attribute__((availability(macosx,introduced=10.7,deprecated=10.9,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_9_MSG(_msg)    __attribute__((availability(macosx,introduced=10.7,deprecated=10.9)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_NA_MSG(_msg)      __attribute__((availability(macosx,introduced=10.7)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_NA                __attribute__((availability(macosx,introduced=10.7)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_8                  __attribute__((availability(macosx,introduced=10.8)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_8    __attribute__((availability(macosx,introduced=10.8,deprecated=10.8)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_8_MSG(_msg)    __attribute__((availability(macosx,introduced=10.8,deprecated=10.8,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_8_MSG(_msg)    __attribute__((availability(macosx,introduced=10.8,deprecated=10.8)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_9    __attribute__((availability(macosx,introduced=10.8,deprecated=10.9)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_9_MSG(_msg)    __attribute__((availability(macosx,introduced=10.8,deprecated=10.9,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_9_MSG(_msg)    __attribute__((availability(macosx,introduced=10.8,deprecated=10.9)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_NA_MSG(_msg)      __attribute__((availability(macosx,introduced=10.8)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_NA                __attribute__((availability(macosx,introduced=10.8)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_9                  __attribute__((availability(macosx,introduced=10.9)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_9    __attribute__((availability(macosx,introduced=10.9,deprecated=10.9)))", "            #if __has_feature(attribute_availability_with_message)", "                #define __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_9_MSG(_msg)    __attribute__((availability(macosx,introduced=10.9,deprecated=10.9,message=_msg)))", "            #else", "                #define __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_9_MSG(_msg)    __attribute__((availability(macosx,introduced=10.9,deprecated=10.9)))", "            #endif", "            #define __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_NA_MSG(_msg)      __attribute__((availability(macosx,introduced=10.9)))", "            #define __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_NA                __attribute__((availability(macosx,introduced=10.9)))", "            #define __AVAILABILITY_INTERNAL__MAC_NA                        __attribute__((availability(macosx,unavailable)))", "            #define __AVAILABILITY_INTERNAL__MAC_NA_DEP__MAC_NA            __attribute__((availability(macosx,unavailable)))", "            #define __AVAILABILITY_INTERNAL__MAC_NA_DEP__MAC_NA_MSG(_msg)  __attribute__((availability(macosx,unavailable)))", "        #endif", "    #endif", "", "    #ifndef __AVAILABILITY_INTERNAL__MAC_10_0", "        /* use old style attributes */", "        #if __MAC_OS_X_VERSION_MAX_ALLOWED < __MAC_10_9", "            #define __AVAILABILITY_INTERNAL__MAC_10_9        __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #elif __MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_9", "            #define __AVAILABILITY_INTERNAL__MAC_10_9        __AVAILABILITY_INTERNAL_WEAK_IMPORT", "        #else", "            #define __AVAILABILITY_INTERNAL__MAC_10_9        __AVAILABILITY_INTERNAL_REGULAR", "        #endif", "        #if __MAC_OS_X_VERSION_MAX_ALLOWED < __MAC_10_8", "            #define __AVAILABILITY_INTERNAL__MAC_10_8        __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #elif __MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_8", "            #define __AVAILABILITY_INTERNAL__MAC_10_8        __AVAILABILITY_INTERNAL_WEAK_IMPORT", "        #else", "            #define __AVAILABILITY_INTERNAL__MAC_10_8        __AVAILABILITY_INTERNAL_REGULAR", "        #endif", "        #if __MAC_OS_X_VERSION_MAX_ALLOWED < __MAC_10_7", "            #define __AVAILABILITY_INTERNAL__MAC_10_7        __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #elif __MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_7", "            #define __AVAILABILITY_INTERNAL__MAC_10_7        __AVAILABILITY_INTERNAL_WEAK_IMPORT", "        #else", "            #define __AVAILABILITY_INTERNAL__MAC_10_7        __AVAILABILITY_INTERNAL_REGULAR", "        #endif", "        #if __MAC_OS_X_VERSION_MAX_ALLOWED < __MAC_10_6", "            #define __AVAILABILITY_INTERNAL__MAC_10_6        __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #elif __MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_6", "            #define __AVAILABILITY_INTERNAL__MAC_10_6        __AVAILABILITY_INTERNAL_WEAK_IMPORT", "        #else", "            #define __AVAILABILITY_INTERNAL__MAC_10_6        __AVAILABILITY_INTERNAL_REGULAR", "        #endif", "        #if __MAC_OS_X_VERSION_MAX_ALLOWED < __MAC_10_5", "            #define __AVAILABILITY_INTERNAL__MAC_10_5        __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #elif __MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_5", "            #define __AVAILABILITY_INTERNAL__MAC_10_5        __AVAILABILITY_INTERNAL_WEAK_IMPORT", "        #else", "            #define __AVAILABILITY_INTERNAL__MAC_10_5        __AVAILABILITY_INTERNAL_REGULAR", "        #endif", "        #if __MAC_OS_X_VERSION_MAX_ALLOWED < __MAC_10_4", "            #define __AVAILABILITY_INTERNAL__MAC_10_4        __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #elif __MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_4", "            #define __AVAILABILITY_INTERNAL__MAC_10_4        __AVAILABILITY_INTERNAL_WEAK_IMPORT", "        #else", "            #define __AVAILABILITY_INTERNAL__MAC_10_4        __AVAILABILITY_INTERNAL_REGULAR", "        #endif", "        #if __MAC_OS_X_VERSION_MAX_ALLOWED < __MAC_10_3", "            #define __AVAILABILITY_INTERNAL__MAC_10_3        __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #elif __MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_3", "            #define __AVAILABILITY_INTERNAL__MAC_10_3        __AVAILABILITY_INTERNAL_WEAK_IMPORT", "        #else", "            #define __AVAILABILITY_INTERNAL__MAC_10_3        __AVAILABILITY_INTERNAL_REGULAR", "        #endif", "        #if __MAC_OS_X_VERSION_MAX_ALLOWED < __MAC_10_2", "            #define __AVAILABILITY_INTERNAL__MAC_10_2        __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #elif __MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_2", "            #define __AVAILABILITY_INTERNAL__MAC_10_2        __AVAILABILITY_INTERNAL_WEAK_IMPORT", "        #else", "            #define __AVAILABILITY_INTERNAL__MAC_10_2        __AVAILABILITY_INTERNAL_REGULAR", "        #endif", "        #if __MAC_OS_X_VERSION_MAX_ALLOWED < __MAC_10_1", "            #define __AVAILABILITY_INTERNAL__MAC_10_1        __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #elif __MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_1", "            #define __AVAILABILITY_INTERNAL__MAC_10_1        __AVAILABILITY_INTERNAL_WEAK_IMPORT", "        #else", "            #define __AVAILABILITY_INTERNAL__MAC_10_1        __AVAILABILITY_INTERNAL_REGULAR", "        #endif", "        #if __MAC_OS_X_VERSION_MAX_ALLOWED < __MAC_10_0", "            #define __AVAILABILITY_INTERNAL__MAC_10_0        __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #elif __MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_0", "            #define __AVAILABILITY_INTERNAL__MAC_10_0        __AVAILABILITY_INTERNAL_WEAK_IMPORT", "        #else", "            #define __AVAILABILITY_INTERNAL__MAC_10_0        __AVAILABILITY_INTERNAL_REGULAR", "        #endif", "        #define __AVAILABILITY_INTERNAL__MAC_NA             __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #if __MAC_OS_X_VERSION_MIN_REQUIRED >= __MAC_10_1", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_1              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_1_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "        #else", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_1              __AVAILABILITY_INTERNAL__MAC_10_0", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_1_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_0", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_1              __AVAILABILITY_INTERNAL__MAC_10_1", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_1_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_1", "        #endif", "        #if __MAC_OS_X_VERSION_MIN_REQUIRED >= __MAC_10_2", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_2              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_2_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_2              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_2_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_2              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_2_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "        #else", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_2              __AVAILABILITY_INTERNAL__MAC_10_0", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_2_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_0", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_2              __AVAILABILITY_INTERNAL__MAC_10_1", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_2_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_1", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_2              __AVAILABILITY_INTERNAL__MAC_10_2", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_2_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_2", "        #endif", "        #if __MAC_OS_X_VERSION_MIN_REQUIRED >= __MAC_10_3", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_3              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_3_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_3              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_3_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_3              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_3_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_3              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_3_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "        #else", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_3              __AVAILABILITY_INTERNAL__MAC_10_0", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_3_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_0", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_3              __AVAILABILITY_INTERNAL__MAC_10_1", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_3_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_1", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_3              __AVAILABILITY_INTERNAL__MAC_10_2", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_3_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_2", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_3              __AVAILABILITY_INTERNAL__MAC_10_3", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_3_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_3", "        #endif", "        #if __MAC_OS_X_VERSION_MIN_REQUIRED >= __MAC_10_4", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_4              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_4_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_4              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_4_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_4              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_4_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_4              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_4_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_4              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_4_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "        #else", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_4              __AVAILABILITY_INTERNAL__MAC_10_0", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_4_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_0", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_4              __AVAILABILITY_INTERNAL__MAC_10_1", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_4_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_1", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_4              __AVAILABILITY_INTERNAL__MAC_10_2", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_4_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_2", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_4              __AVAILABILITY_INTERNAL__MAC_10_3", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_4_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_3", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_4              __AVAILABILITY_INTERNAL__MAC_10_4", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_4_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_4", "        #endif", "        #if __MAC_OS_X_VERSION_MIN_REQUIRED >= __MAC_10_5", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_5              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_5_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_5              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_5_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_5              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_5_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_5              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_5_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_5              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_5_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_5              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_5_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "        #else", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_5              __AVAILABILITY_INTERNAL__MAC_10_0", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_5_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_0", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_5              __AVAILABILITY_INTERNAL__MAC_10_1", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_5_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_1", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_5              __AVAILABILITY_INTERNAL__MAC_10_2", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_5_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_2", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_5              __AVAILABILITY_INTERNAL__MAC_10_3", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_5_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_3", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_5              __AVAILABILITY_INTERNAL__MAC_10_4", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_5_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_4", "            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_5              __AVAILABILITY_INTERNAL__MAC_10_5", "            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_5_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_5", "        #endif", "        #if __MAC_OS_X_VERSION_MIN_REQUIRED >= __MAC_10_6", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_6              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_6_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_6              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_6_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_6              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_6_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_6              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_6_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_6              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_6_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_6              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_6_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_6              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_6_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "        #else", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_6              __AVAILABILITY_INTERNAL__MAC_10_0", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_6_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_0", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_6              __AVAILABILITY_INTERNAL__MAC_10_1", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_6_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_1", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_6              __AVAILABILITY_INTERNAL__MAC_10_2", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_6_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_2", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_6              __AVAILABILITY_INTERNAL__MAC_10_3", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_6_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_3", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_6              __AVAILABILITY_INTERNAL__MAC_10_4", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_6_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_4", "            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_6              __AVAILABILITY_INTERNAL__MAC_10_5", "            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_6_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_5", "            #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_6              __AVAILABILITY_INTERNAL__MAC_10_6", "            #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_6_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_6", "        #endif", "        #if __MAC_OS_X_VERSION_MIN_REQUIRED >= __MAC_10_7", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_7              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_7_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_7              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_7_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_7              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_7_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_7              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_7_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_7              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_7_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_7              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_7_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_7              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_7_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_7              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_7_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "        #else", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_7              __AVAILABILITY_INTERNAL__MAC_10_0", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_7_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_0", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_7              __AVAILABILITY_INTERNAL__MAC_10_1", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_7_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_1", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_7              __AVAILABILITY_INTERNAL__MAC_10_2", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_7_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_2", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_7              __AVAILABILITY_INTERNAL__MAC_10_3", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_7_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_3", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_7              __AVAILABILITY_INTERNAL__MAC_10_4", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_7_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_4", "            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_7              __AVAILABILITY_INTERNAL__MAC_10_5", "            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_7_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_5", "            #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_7              __AVAILABILITY_INTERNAL__MAC_10_6", "            #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_7_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_6", "            #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_7              __AVAILABILITY_INTERNAL__MAC_10_7", "            #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_7_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_7", "        #endif", "        #if __MAC_OS_X_VERSION_MIN_REQUIRED >= __MAC_10_8", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_8              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_8_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_8              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_8_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_8              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_8_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_8              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_8_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_8              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_8_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_8              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_8_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_8              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_8_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_8              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_8_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_8              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_8_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "        #else", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_8              __AVAILABILITY_INTERNAL__MAC_10_0", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_8_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_0", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_8              __AVAILABILITY_INTERNAL__MAC_10_1", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_8_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_1", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_8              __AVAILABILITY_INTERNAL__MAC_10_2", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_8_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_2", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_8              __AVAILABILITY_INTERNAL__MAC_10_3", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_8_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_3", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_8              __AVAILABILITY_INTERNAL__MAC_10_4", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_8_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_4", "            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_8              __AVAILABILITY_INTERNAL__MAC_10_5", "            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_8_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_5", "            #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_8              __AVAILABILITY_INTERNAL__MAC_10_6", "            #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_8_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_6", "            #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_8              __AVAILABILITY_INTERNAL__MAC_10_7", "            #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_8_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_7", "            #define __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_8              __AVAILABILITY_INTERNAL__MAC_10_8", "            #define __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_8_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_8", "        #endif", "        #if __MAC_OS_X_VERSION_MIN_REQUIRED >= __MAC_10_9", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_9              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_9_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_9              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_9_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_9              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_9_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_9              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_9_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_9              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_9_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_9              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_9_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_9              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_9_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_9              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_9_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_9              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_9_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "            #define __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_9              __AVAILABILITY_INTERNAL_DEPRECATED", "            #define __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_9_MSG(_msg)    __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg)", "        #else", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_9              __AVAILABILITY_INTERNAL__MAC_10_0", "            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_9_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_0", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_9              __AVAILABILITY_INTERNAL__MAC_10_1", "            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_9_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_1", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_9              __AVAILABILITY_INTERNAL__MAC_10_2", "            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_9_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_2", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_9              __AVAILABILITY_INTERNAL__MAC_10_3", "            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_9_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_3", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_9              __AVAILABILITY_INTERNAL__MAC_10_4", "            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_9_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_4", "            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_9              __AVAILABILITY_INTERNAL__MAC_10_5", "            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_9_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_5", "            #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_9              __AVAILABILITY_INTERNAL__MAC_10_6", "            #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_9_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_6", "            #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_9              __AVAILABILITY_INTERNAL__MAC_10_7", "            #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_9_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_7", "            #define __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_9              __AVAILABILITY_INTERNAL__MAC_10_8", "            #define __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_9_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_8", "            #define __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_9              __AVAILABILITY_INTERNAL__MAC_10_9", "            #define __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_9_MSG(_msg)    __AVAILABILITY_INTERNAL__MAC_10_9", "        #endif", "        #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_NA             __AVAILABILITY_INTERNAL__MAC_10_0", "        #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_NA_MSG(_msg)   __AVAILABILITY_INTERNAL__MAC_10_0", "        #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_NA             __AVAILABILITY_INTERNAL__MAC_10_1", "        #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_NA_MSG(_msg)   __AVAILABILITY_INTERNAL__MAC_10_1", "        #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_NA             __AVAILABILITY_INTERNAL__MAC_10_2", "        #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_NA_MSG(_msg)   __AVAILABILITY_INTERNAL__MAC_10_2", "        #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_NA             __AVAILABILITY_INTERNAL__MAC_10_3", "        #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_NA_MSG(_msg)   __AVAILABILITY_INTERNAL__MAC_10_3", "        #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_NA             __AVAILABILITY_INTERNAL__MAC_10_4", "        #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_NA_MSG(_msg)   __AVAILABILITY_INTERNAL__MAC_10_4", "        #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_NA             __AVAILABILITY_INTERNAL__MAC_10_5", "        #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_NA_MSG(_msg)   __AVAILABILITY_INTERNAL__MAC_10_5", "        #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_NA             __AVAILABILITY_INTERNAL__MAC_10_6", "        #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_NA_MSG(_msg)   __AVAILABILITY_INTERNAL__MAC_10_6", "        #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_NA             __AVAILABILITY_INTERNAL__MAC_10_7", "        #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_NA_MSG(_msg)   __AVAILABILITY_INTERNAL__MAC_10_7", "        #define __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_NA             __AVAILABILITY_INTERNAL__MAC_10_8", "        #define __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_NA_MSG(_msg)   __AVAILABILITY_INTERNAL__MAC_10_8", "        #define __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_NA             __AVAILABILITY_INTERNAL__MAC_10_9", "        #define __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_NA_MSG(_msg)   __AVAILABILITY_INTERNAL__MAC_10_9", "        #define __AVAILABILITY_INTERNAL__MAC_NA_DEP__MAC_NA               __AVAILABILITY_INTERNAL_UNAVAILABLE", "        #define __AVAILABILITY_INTERNAL__MAC_NA_DEP__MAC_NA_MSG(_msg)     __AVAILABILITY_INTERNAL_UNAVAILABLE", "    #endif", "#endif", "", "#endif /* __AVAILABILITY_INTERNAL__ */" },
    ["AvailabilityMacros.h"] = { "/*", " * Copyright (c) 2001-2010 by Apple Inc.. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "", "/*", "     File:       AvailabilityMacros.h", " ", "     More Info:  See TechNote 2064", "", "     Contains:   Autoconfiguration of AVAILABLE_ macros for Mac OS X", "", "                 This header enables a developer to specify build time", "                 constraints on what Mac OS X versions the resulting", "                 application will be run.  There are two bounds a developer", "                 can specify:", "                 ", "                      MAC_OS_X_VERSION_MIN_REQUIRED", "                      MAC_OS_X_VERSION_MAX_ALLOWED", "                      ", "                The lower bound controls which calls to OS functions will ", "                be weak-importing (allowed to be unresolved at launch time).", "                The upper bound controls which OS functionality, if used,", "                will result in a compiler error because that functionality is", "                not available on on any OS is the specifed range.", "                ", "                For example, suppose an application is compiled with:", "                ", "                      MAC_OS_X_VERSION_MIN_REQUIRED = MAC_OS_X_VERSION_10_2", "                      MAC_OS_X_VERSION_MAX_ALLOWED  = MAC_OS_X_VERSION_10_3", "                     ", "                and an OS header contains:", "                ", "                     extern void funcA(void) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;", "                     extern void funcB(void) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_2;", "                     extern void funcC(void) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;", "                     extern void funcD(void) AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER;", "                     extern void funcE(void) AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;", "                     extern void funcF(void) AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;", "                     extern void funcG(void) AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;", "                     ", "                     typedef long TypeA DEPRECATED_IN_MAC_OS_X_VERSION_10_0_AND_LATER;", "                     typedef long TypeB DEPRECATED_IN_MAC_OS_X_VERSION_10_1_AND_LATER;", "                     typedef long TypeC DEPRECATED_IN_MAC_OS_X_VERSION_10_2_AND_LATER;", "                     typedef long TypeD DEPRECATED_IN_MAC_OS_X_VERSION_10_3_AND_LATER;", "                     typedef long TypeE DEPRECATED_IN_MAC_OS_X_VERSION_10_4_AND_LATER;", "", "                Any application code which uses these declarations will get the following:", "                ", "                                compile         link          run ", "                                -------         ------        -------", "                     funcA:     normal          normal        normal", "                     funcB:     warning         normal        normal", "                     funcC:     normal          normal        normal", "                     funcD:     normal          normal        normal", "                     funcE:     normal          normal        normal", "                     funcF:     normal          weak          on 10.3 normal, on 10.2 (&funcF == NULL)", "                     funcG:     error           error         n/a", "                     typeA:     warning", "                     typeB:     warning", "                     typeC:     warning", "                     typeD:     normal", "                     typeE:     normal", "                  ", "  ", "*/", "#ifndef __AVAILABILITYMACROS__", "#define __AVAILABILITYMACROS__", "", "", "/*", " * Set up standard Mac OS X versions", " */", "#define MAC_OS_X_VERSION_10_0         1000", "#define MAC_OS_X_VERSION_10_1         1010", "#define MAC_OS_X_VERSION_10_2         1020", "#define MAC_OS_X_VERSION_10_3         1030", "#define MAC_OS_X_VERSION_10_4         1040", "#define MAC_OS_X_VERSION_10_5         1050", "#define MAC_OS_X_VERSION_10_6         1060", "#define MAC_OS_X_VERSION_10_7         1070", "#define MAC_OS_X_VERSION_10_8         1080", "#define MAC_OS_X_VERSION_10_9         1090", "", "/* ", " * If min OS not specified, assume 10.1 for ppc and 10.4 for all others", " * Note: gcc driver may set _ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED_ based on MACOSX_DEPLOYMENT_TARGET environment variable", " */", "#ifndef MAC_OS_X_VERSION_MIN_REQUIRED", "    #ifdef __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__", "        #if (__i386__ || __x86_64__) && (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ < MAC_OS_X_VERSION_10_4)", "            #warning Building for Intel with Mac OS X Deployment Target < 10.4 is invalid.", "        #elif __ppc64__ && (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ < MAC_OS_X_VERSION_10_4)", "            #warning Building for ppc64 with Mac OS X Deployment Target < 10.4 is invalid.", "        #endif", "        #define MAC_OS_X_VERSION_MIN_REQUIRED __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__", "    #else", "        #if __ppc64__ || __i386__ || __x86_64__", "            #define MAC_OS_X_VERSION_MIN_REQUIRED MAC_OS_X_VERSION_10_4", "        #elif __arm__", "            #define MAC_OS_X_VERSION_MIN_REQUIRED MAC_OS_X_VERSION_10_5", "        #else", "            #define MAC_OS_X_VERSION_MIN_REQUIRED MAC_OS_X_VERSION_10_1", "        #endif", "    #endif", "#endif", "", "/*", " * if max OS not specified, assume larger of (10.9, min)", " */", "#ifndef MAC_OS_X_VERSION_MAX_ALLOWED", "    #if MAC_OS_X_VERSION_MIN_REQUIRED > MAC_OS_X_VERSION_10_9", "        #define MAC_OS_X_VERSION_MAX_ALLOWED MAC_OS_X_VERSION_MIN_REQUIRED", "    #else", "        #define MAC_OS_X_VERSION_MAX_ALLOWED MAC_OS_X_VERSION_10_9", "    #endif", "#endif", "", "/*", " * Error on bad values", " */", "#if MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_MIN_REQUIRED", "    #error MAC_OS_X_VERSION_MAX_ALLOWED must be >= MAC_OS_X_VERSION_MIN_REQUIRED", "#endif", "#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_0", "    #error MAC_OS_X_VERSION_MIN_REQUIRED must be >= MAC_OS_X_VERSION_10_0", "#endif", "", "/*", " * only certain compilers support __attribute__((weak_import))", " */", "#if defined(__GNUC__) && ((__GNUC__ >= 4) || ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 1))) && (MAC_OS_X_VERSION_MIN_REQUIRED >= 1020)", "    #define WEAK_IMPORT_ATTRIBUTE __attribute__((weak_import))", "#elif defined(__MWERKS__) && (__MWERKS__ >= 0x3205) && (MAC_OS_X_VERSION_MIN_REQUIRED >= 1020) && !defined(__INTEL__)", "    #define WEAK_IMPORT_ATTRIBUTE __attribute__((weak_import))", "#else", "    #define WEAK_IMPORT_ATTRIBUTE", "#endif", "", "/*", " * only certain compilers support __attribute__((deprecated))", " */", "#if defined(__has_feature) && defined(__has_attribute)", "    #if __has_attribute(deprecated)", "        #define DEPRECATED_ATTRIBUTE        __attribute__((deprecated))", "        #if __has_feature(attribute_deprecated_with_message)", "            #define DEPRECATED_MSG_ATTRIBUTE(s) __attribute__((deprecated(s)))", "        #else", "            #define DEPRECATED_MSG_ATTRIBUTE(s) __attribute__((deprecated))", "        #endif", "    #else", "        #define DEPRECATED_ATTRIBUTE", "        #define DEPRECATED_MSG_ATTRIBUTE(s)", "    #endif", "#elif defined(__GNUC__) && ((__GNUC__ >= 4) || ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 1)))", "    #define DEPRECATED_ATTRIBUTE        __attribute__((deprecated))", "    #if (__GNUC__ >= 5) || ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5))", "        #define DEPRECATED_MSG_ATTRIBUTE(s) __attribute__((deprecated(s)))", "    #else", "        #define DEPRECATED_MSG_ATTRIBUTE(s) __attribute__((deprecated))", "    #endif", "#else", "    #define DEPRECATED_ATTRIBUTE", "    #define DEPRECATED_MSG_ATTRIBUTE(s)", "#endif", "", "/*", " * only certain compilers support __attribute__((unavailable))", " */", "#if defined(__GNUC__) && ((__GNUC__ >= 4) || ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 1)))", "    #define UNAVAILABLE_ATTRIBUTE __attribute__((unavailable))", "#else", "    #define UNAVAILABLE_ATTRIBUTE", "#endif", "", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER", " * ", " * Used on functions introduced in Mac OS X 10.0 ", " */", "#define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED", " * ", " * Used on functions introduced in Mac OS X 10.0, ", " * and deprecated in Mac OS X 10.0", " */", "#define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED    DEPRECATED_ATTRIBUTE", "", "/*", " * DEPRECATED_IN_MAC_OS_X_VERSION_10_0_AND_LATER", " * ", " * Used on types deprecated in Mac OS X 10.0 ", " */", "#define DEPRECATED_IN_MAC_OS_X_VERSION_10_0_AND_LATER     DEPRECATED_ATTRIBUTE", "", "#ifndef __AVAILABILITY_MACROS_USES_AVAILABILITY", "\t#ifdef __has_attribute", "\t\t#if __has_attribute(availability)", "\t\t\t#include <Availability.h>", "\t\t\t#define __AVAILABILITY_MACROS_USES_AVAILABILITY 1", "\t\t#endif", "\t#endif", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER", " * ", " * Used on declarations introduced in Mac OS X 10.1 ", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER     __OSX_AVAILABLE_STARTING(__MAC_10_1, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_1", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER     UNAVAILABLE_ATTRIBUTE", "#elif MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_1", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER     WEAK_IMPORT_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED", " *", " * Used on declarations introduced in Mac OS X 10.1,", " * and deprecated in Mac OS X 10.1", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED     __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1, __MAC_10_1, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_1", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED    AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_1", " *", " * Used on declarations introduced in Mac OS X 10.0,", " * but later deprecated in Mac OS X 10.1", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_1    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_1, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_1", "    #define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_1    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_1    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER", "#endif", "", "/*", " * DEPRECATED_IN_MAC_OS_X_VERSION_10_1_AND_LATER", " *", " * Used on types deprecated in Mac OS X 10.1", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define DEPRECATED_IN_MAC_OS_X_VERSION_10_1_AND_LATER    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_1, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_1", "    #define DEPRECATED_IN_MAC_OS_X_VERSION_10_1_AND_LATER    DEPRECATED_ATTRIBUTE", "#else", "    #define DEPRECATED_IN_MAC_OS_X_VERSION_10_1_AND_LATER", "#endif", "", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER", " * ", " * Used on declarations introduced in Mac OS X 10.2 ", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER     __OSX_AVAILABLE_STARTING(__MAC_10_2, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_2", "    #define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER     UNAVAILABLE_ATTRIBUTE", "#elif MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_2", "    #define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER     WEAK_IMPORT_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED", " *", " * Used on declarations introduced in Mac OS X 10.2,", " * and deprecated in Mac OS X 10.2", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED     __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_2, __MAC_10_2, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_2", "    #define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED    AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_2", " *", " * Used on declarations introduced in Mac OS X 10.0,", " * but later deprecated in Mac OS X 10.2", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_2    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_2, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_2", "    #define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_2    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_2    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_2", " *", " * Used on declarations introduced in Mac OS X 10.1,", " * but later deprecated in Mac OS X 10.2", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_2    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1, __MAC_10_2, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_2", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_2    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_2    AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER", "#endif", "", "/*", " * DEPRECATED_IN_MAC_OS_X_VERSION_10_2_AND_LATER", " *", " * Used on types deprecated in Mac OS X 10.2", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define DEPRECATED_IN_MAC_OS_X_VERSION_10_2_AND_LATER    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_2, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_2", "    #define DEPRECATED_IN_MAC_OS_X_VERSION_10_2_AND_LATER    DEPRECATED_ATTRIBUTE", "#else", "    #define DEPRECATED_IN_MAC_OS_X_VERSION_10_2_AND_LATER", "#endif", "", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER", " * ", " * Used on declarations introduced in Mac OS X 10.3 ", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER     __OSX_AVAILABLE_STARTING(__MAC_10_3, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_3", "    #define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER     UNAVAILABLE_ATTRIBUTE", "#elif MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_3", "    #define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER     WEAK_IMPORT_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED", " *", " * Used on declarations introduced in Mac OS X 10.3,", " * and deprecated in Mac OS X 10.3", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED     __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_3, __MAC_10_3, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_3", "    #define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED    AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3", " *", " * Used on declarations introduced in Mac OS X 10.0,", " * but later deprecated in Mac OS X 10.3", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_3, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_3", "    #define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3", " *", " * Used on declarations introduced in Mac OS X 10.1,", " * but later deprecated in Mac OS X 10.3", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1, __MAC_10_3, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_3", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3    AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3", " *", " * Used on declarations introduced in Mac OS X 10.2,", " * but later deprecated in Mac OS X 10.3", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_2, __MAC_10_3, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_3", "    #define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3    AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER", "#endif", "", "/*", " * DEPRECATED_IN_MAC_OS_X_VERSION_10_3_AND_LATER", " *", " * Used on types deprecated in Mac OS X 10.3", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define DEPRECATED_IN_MAC_OS_X_VERSION_10_3_AND_LATER    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_3, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_3", "    #define DEPRECATED_IN_MAC_OS_X_VERSION_10_3_AND_LATER    DEPRECATED_ATTRIBUTE", "#else", "    #define DEPRECATED_IN_MAC_OS_X_VERSION_10_3_AND_LATER", "#endif", "", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER", " * ", " * Used on declarations introduced in Mac OS X 10.4 ", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER     __OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_4", "    #define AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER     UNAVAILABLE_ATTRIBUTE", "#elif MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_4", "    #define AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER     WEAK_IMPORT_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED", " *", " * Used on declarations introduced in Mac OS X 10.4,", " * and deprecated in Mac OS X 10.4", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED     __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_4, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_4", "    #define AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED    AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4", " *", " * Used on declarations introduced in Mac OS X 10.0,", " * but later deprecated in Mac OS X 10.4", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_4, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_4", "    #define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4", " *", " * Used on declarations introduced in Mac OS X 10.1,", " * but later deprecated in Mac OS X 10.4", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1, __MAC_10_4, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_4", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4    AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4", " *", " * Used on declarations introduced in Mac OS X 10.2,", " * but later deprecated in Mac OS X 10.4", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_2, __MAC_10_4, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_4", "    #define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4    AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4", " *", " * Used on declarations introduced in Mac OS X 10.3,", " * but later deprecated in Mac OS X 10.4", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_3, __MAC_10_4, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_4", "    #define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4    AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER", "#endif", "", "/*", " * DEPRECATED_IN_MAC_OS_X_VERSION_10_4_AND_LATER", " *", " * Used on types deprecated in Mac OS X 10.4", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define DEPRECATED_IN_MAC_OS_X_VERSION_10_4_AND_LATER    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_4, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_4", "    #define DEPRECATED_IN_MAC_OS_X_VERSION_10_4_AND_LATER    DEPRECATED_ATTRIBUTE", "#else", "    #define DEPRECATED_IN_MAC_OS_X_VERSION_10_4_AND_LATER", "#endif", "", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER", " * ", " * Used on declarations introduced in Mac OS X 10.5 ", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER     __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_5", "    #define AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER     UNAVAILABLE_ATTRIBUTE", "#elif MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_5", "    #define AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER     WEAK_IMPORT_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED", " *", " * Used on declarations introduced in Mac OS X 10.5,", " * and deprecated in Mac OS X 10.5", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED     __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5, __MAC_10_5, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_5", "    #define AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED    AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5", " *", " * Used on declarations introduced in Mac OS X 10.0,", " * but later deprecated in Mac OS X 10.5", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_5, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_5", "    #define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5", " *", " * Used on declarations introduced in Mac OS X 10.1,", " * but later deprecated in Mac OS X 10.5", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1, __MAC_10_5, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_5", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5    AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5", " *", " * Used on declarations introduced in Mac OS X 10.2,", " * but later deprecated in Mac OS X 10.5", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_2, __MAC_10_5, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_5", "    #define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5    AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5", " *", " * Used on declarations introduced in Mac OS X 10.3,", " * but later deprecated in Mac OS X 10.5", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_3, __MAC_10_5, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_5", "    #define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5    AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5", " *", " * Used on declarations introduced in Mac OS X 10.4,", " * but later deprecated in Mac OS X 10.5", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_5, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_5", "    #define AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5    AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER", "#endif", "", "/*", " * DEPRECATED_IN_MAC_OS_X_VERSION_10_5_AND_LATER", " *", " * Used on types deprecated in Mac OS X 10.5", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define DEPRECATED_IN_MAC_OS_X_VERSION_10_5_AND_LATER    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_5, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_5", "    #define DEPRECATED_IN_MAC_OS_X_VERSION_10_5_AND_LATER    DEPRECATED_ATTRIBUTE", "#else", "    #define DEPRECATED_IN_MAC_OS_X_VERSION_10_5_AND_LATER", "#endif", "", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER", " * ", " * Used on declarations introduced in Mac OS X 10.6 ", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER     __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_6", "    #define AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER     UNAVAILABLE_ATTRIBUTE", "#elif MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_6", "    #define AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER     WEAK_IMPORT_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED", " *", " * Used on declarations introduced in Mac OS X 10.6,", " * and deprecated in Mac OS X 10.6", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED     __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_6, __MAC_10_6, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_6", "    #define AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED    AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6", " *", " * Used on declarations introduced in Mac OS X 10.0,", " * but later deprecated in Mac OS X 10.6", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_6, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_6", "    #define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6", " *", " * Used on declarations introduced in Mac OS X 10.1,", " * but later deprecated in Mac OS X 10.6", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1, __MAC_10_6, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_6", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6    AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6", " *", " * Used on declarations introduced in Mac OS X 10.2,", " * but later deprecated in Mac OS X 10.6", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_2, __MAC_10_6, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_6", "    #define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6    AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6", " *", " * Used on declarations introduced in Mac OS X 10.3,", " * but later deprecated in Mac OS X 10.6", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_3, __MAC_10_6, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_6", "    #define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6    AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6", " *", " * Used on declarations introduced in Mac OS X 10.4,", " * but later deprecated in Mac OS X 10.6", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_6, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_6", "    #define AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6    AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6", " *", " * Used on declarations introduced in Mac OS X 10.5,", " * but later deprecated in Mac OS X 10.6", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5, __MAC_10_6, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_6", "    #define AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6    AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER", "#endif", "", "/*", " * DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER", " *", " * Used on types deprecated in Mac OS X 10.6", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_6, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_6", "    #define DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER    DEPRECATED_ATTRIBUTE", "#else", "    #define DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER", "#endif", "", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER", " * ", " * Used on declarations introduced in Mac OS X 10.7 ", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER     __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_7", "    #define AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER     UNAVAILABLE_ATTRIBUTE", "#elif MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_7", "    #define AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER     WEAK_IMPORT_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED", " *", " * Used on declarations introduced in Mac OS X 10.7,", " * and deprecated in Mac OS X 10.7", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED     __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_7, __MAC_10_7, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_7", "    #define AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED    AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7", " *", " * Used on declarations introduced in Mac OS X 10.0,", " * but later deprecated in Mac OS X 10.7", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_7, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_7", "    #define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7", " *", " * Used on declarations introduced in Mac OS X 10.1,", " * but later deprecated in Mac OS X 10.7", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1, __MAC_10_7, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_7", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7    AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7", " *", " * Used on declarations introduced in Mac OS X 10.2,", " * but later deprecated in Mac OS X 10.7", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_2, __MAC_10_7, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_7", "    #define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7    AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7", " *", " * Used on declarations introduced in Mac OS X 10.3,", " * but later deprecated in Mac OS X 10.7", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_3, __MAC_10_7, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_7", "    #define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7    AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7", " *", " * Used on declarations introduced in Mac OS X 10.4,", " * but later deprecated in Mac OS X 10.7", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_7, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_7", "    #define AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7    AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7", " *", " * Used on declarations introduced in Mac OS X 10.5,", " * but later deprecated in Mac OS X 10.7", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5, __MAC_10_7, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_7", "    #define AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7    AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7", " *", " * Used on declarations introduced in Mac OS X 10.6,", " * but later deprecated in Mac OS X 10.7", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_6, __MAC_10_7, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_7", "    #define AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7    AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER", "#endif", "", "/*", " * DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER", " *", " * Used on types deprecated in Mac OS X 10.7", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_7, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_7", "    #define DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER    DEPRECATED_ATTRIBUTE", "#else", "    #define DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER", "#endif", "", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER", " * ", " * Used on declarations introduced in Mac OS X 10.8 ", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER     __OSX_AVAILABLE_STARTING(__MAC_10_8, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_8", "    #define AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER     UNAVAILABLE_ATTRIBUTE", "#elif MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_8", "    #define AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER     WEAK_IMPORT_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED", " *", " * Used on declarations introduced in Mac OS X 10.8,", " * and deprecated in Mac OS X 10.8", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED     __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_8, __MAC_10_8, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_8", "    #define AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED    AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8", " *", " * Used on declarations introduced in Mac OS X 10.0,", " * but later deprecated in Mac OS X 10.8", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_8, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_8", "    #define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8", " *", " * Used on declarations introduced in Mac OS X 10.1,", " * but later deprecated in Mac OS X 10.8", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1, __MAC_10_8, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_8", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8    AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8", " *", " * Used on declarations introduced in Mac OS X 10.2,", " * but later deprecated in Mac OS X 10.8", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_2, __MAC_10_8, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_8", "    #define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8    AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8", " *", " * Used on declarations introduced in Mac OS X 10.3,", " * but later deprecated in Mac OS X 10.8", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_3, __MAC_10_8, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_8", "    #define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8    AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8", " *", " * Used on declarations introduced in Mac OS X 10.4,", " * but later deprecated in Mac OS X 10.8", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_8, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_8", "    #define AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8    AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8", " *", " * Used on declarations introduced in Mac OS X 10.5,", " * but later deprecated in Mac OS X 10.8", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5, __MAC_10_8, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_8", "    #define AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8    AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8", " *", " * Used on declarations introduced in Mac OS X 10.6,", " * but later deprecated in Mac OS X 10.8", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_6, __MAC_10_8, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_8", "    #define AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8    AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8", " *", " * Used on declarations introduced in Mac OS X 10.7,", " * but later deprecated in Mac OS X 10.8", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_7, __MAC_10_8, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_8", "    #define AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8    AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER", "#endif", "", "/*", " * DEPRECATED_IN_MAC_OS_X_VERSION_10_8_AND_LATER", " *", " * Used on types deprecated in Mac OS X 10.8", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define DEPRECATED_IN_MAC_OS_X_VERSION_10_8_AND_LATER    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_8, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_8", "    #define DEPRECATED_IN_MAC_OS_X_VERSION_10_8_AND_LATER    DEPRECATED_ATTRIBUTE", "#else", "    #define DEPRECATED_IN_MAC_OS_X_VERSION_10_8_AND_LATER", "#endif", "", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER", " * ", " * Used on declarations introduced in Mac OS X 10.9 ", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER     __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_9", "    #define AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER     UNAVAILABLE_ATTRIBUTE", "#elif MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_9", "    #define AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER     WEAK_IMPORT_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER_BUT_DEPRECATED", " *", " * Used on declarations introduced in Mac OS X 10.9,", " * and deprecated in Mac OS X 10.9", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER_BUT_DEPRECATED     __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_9, __MAC_10_9, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_9", "    #define AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER_BUT_DEPRECATED    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER_BUT_DEPRECATED    AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9", " *", " * Used on declarations introduced in Mac OS X 10.0,", " * but later deprecated in Mac OS X 10.9", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_9, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_9", "    #define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9", " *", " * Used on declarations introduced in Mac OS X 10.1,", " * but later deprecated in Mac OS X 10.9", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1, __MAC_10_9, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_9", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9    AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9", " *", " * Used on declarations introduced in Mac OS X 10.2,", " * but later deprecated in Mac OS X 10.9", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_2, __MAC_10_9, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_9", "    #define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9    AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9", " *", " * Used on declarations introduced in Mac OS X 10.3,", " * but later deprecated in Mac OS X 10.9", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_3, __MAC_10_9, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_9", "    #define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9    AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9", " *", " * Used on declarations introduced in Mac OS X 10.4,", " * but later deprecated in Mac OS X 10.9", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_9, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_9", "    #define AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9    AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9", " *", " * Used on declarations introduced in Mac OS X 10.5,", " * but later deprecated in Mac OS X 10.9", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5, __MAC_10_9, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_9", "    #define AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9    AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9", " *", " * Used on declarations introduced in Mac OS X 10.6,", " * but later deprecated in Mac OS X 10.9", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_6, __MAC_10_9, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_9", "    #define AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9    AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9", " *", " * Used on declarations introduced in Mac OS X 10.7,", " * but later deprecated in Mac OS X 10.9", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_7, __MAC_10_9, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_9", "    #define AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9    AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER", "#endif", "", "/*", " * AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9", " *", " * Used on declarations introduced in Mac OS X 10.8,", " * but later deprecated in Mac OS X 10.9", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_8, __MAC_10_9, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_9", "    #define AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9    DEPRECATED_ATTRIBUTE", "#else", "    #define AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9    AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER", "#endif", "", "/*", " * DEPRECATED_IN_MAC_OS_X_VERSION_10_9_AND_LATER", " *", " * Used on types deprecated in Mac OS X 10.9", " */", "#if __AVAILABILITY_MACROS_USES_AVAILABILITY", "    #define DEPRECATED_IN_MAC_OS_X_VERSION_10_9_AND_LATER    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_9, __IPHONE_NA, __IPHONE_NA)", "#elif MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_9", "    #define DEPRECATED_IN_MAC_OS_X_VERSION_10_9_AND_LATER    DEPRECATED_ATTRIBUTE", "#else", "    #define DEPRECATED_IN_MAC_OS_X_VERSION_10_9_AND_LATER", "#endif", "", "", "", "", "#endif  /* __AVAILABILITYMACROS__ */", "", "" },
    ["Block.h"] = { "/*", " *  Block.h", " *", " * Copyright (c) 2008-2010 Apple Inc. All rights reserved.", " *", " * @APPLE_LLVM_LICENSE_HEADER@", " *", " */", "", "#ifndef _Block_H_", "#define _Block_H_", "", "#if !defined(BLOCK_EXPORT)", "#   if defined(__cplusplus)", '#       define BLOCK_EXPORT extern "C" ', "#   else", "#       define BLOCK_EXPORT extern", "#   endif", "#endif", "", "#include <Availability.h>", "#include <TargetConditionals.h>", "", "#if __cplusplus", 'extern "C" {', "#endif", "", "// Create a heap based copy of a Block or simply add a reference to an existing one.", "// This must be paired with Block_release to recover memory, even when running", "// under Objective-C Garbage Collection.", "BLOCK_EXPORT void *_Block_copy(const void *aBlock)", "    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);", "", "// Lose the reference, and if heap based and last reference, recover the memory", "BLOCK_EXPORT void _Block_release(const void *aBlock)", "    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);", "", "", "// Used by the compiler. Do not call this function yourself.", "BLOCK_EXPORT void _Block_object_assign(void *, const void *, const int)", "    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);", "", "// Used by the compiler. Do not call this function yourself.", "BLOCK_EXPORT void _Block_object_dispose(const void *, const int)", "    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);", "", "// Used by the compiler. Do not use these variables yourself.", "BLOCK_EXPORT void * _NSConcreteGlobalBlock[32]", "    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);", "BLOCK_EXPORT void * _NSConcreteStackBlock[32]", "    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);", "", "", "#if __cplusplus", "}", "#endif", "", "// Type correct macros", "", "#define Block_copy(...) ((__typeof(__VA_ARGS__))_Block_copy((const void *)(__VA_ARGS__)))", "#define Block_release(...) _Block_release((const void *)(__VA_ARGS__))", "", "", "#endif" },
    ["ConditionalMacros.h"] = { "/*", " * Copyright (c) 1993-2011 by Apple Inc.. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "", "/*", "     File:       ConditionalMacros.h", " ", "     Contains:   Set up for compiler independent conditionals", " ", "     Version:    CarbonCore-769~1", "  ", "     Bugs?:      For bug reports, consult the following page on", "                 the World Wide Web:", " ", "                     http://developer.apple.com/bugreporter/", " ", "*/", "#ifndef __CONDITIONALMACROS__", "#define __CONDITIONALMACROS__", "", "#include <Availability.h>", "/****************************************************************************************************", "    UNIVERSAL_INTERFACES_VERSION", "    ", "        0x0400 --> version 4.0 (Mac OS X only)", "        0x0335 --> version 3.4 ", "        0x0331 --> version 3.3.1", "        0x0330 --> version 3.3", "        0x0320 --> version 3.2", "        0x0310 --> version 3.1", "        0x0301 --> version 3.0.1", "        0x0300 --> version 3.0", "        0x0210 --> version 2.1", "        This conditional did not exist prior to version 2.1", "****************************************************************************************************/", "#define UNIVERSAL_INTERFACES_VERSION 0x0400", "/****************************************************************************************************", "", "    All TARGET_* condtionals are set up by TargetConditionals.h", "", "****************************************************************************************************/", "#include <TargetConditionals.h>", "", "", "", "", "/****************************************************************************************************", "", "    PRAGMA_*", "    These conditionals specify whether the compiler supports particular #pragma's", "    ", "        PRAGMA_IMPORT           - Compiler supports: #pragma import on/off/reset", "        PRAGMA_ONCE             - Compiler supports: #pragma once", "        PRAGMA_STRUCT_ALIGN     - Compiler supports: #pragma options align=mac68k/power/reset", "        PRAGMA_STRUCT_PACK      - Compiler supports: #pragma pack(n)", "        PRAGMA_STRUCT_PACKPUSH  - Compiler supports: #pragma pack(push, n)/pack(pop)", "        PRAGMA_ENUM_PACK        - Compiler supports: #pragma options(!pack_enums)", "        PRAGMA_ENUM_ALWAYSINT   - Compiler supports: #pragma enumsalwaysint on/off/reset", "        PRAGMA_ENUM_OPTIONS     - Compiler supports: #pragma options enum=int/small/reset", "", "", "    FOUR_CHAR_CODE", "    This conditional is deprecated.  It was used to work around a bug in one obscure compiler that did not pack multiple characters in single quotes rationally.", "    It was never intended for endian swapping.", "", "        FOUR_CHAR_CODE('abcd')  - Convert a four-char-code to the correct 32-bit value", "", "", "    TYPE_*", "    These conditionals specify whether the compiler supports particular types.", "", '        TYPE_LONGLONG               - Compiler supports "long long" 64-bit integers', '        TYPE_BOOL                   - Compiler supports "bool"', '        TYPE_EXTENDED               - Compiler supports "extended" 80/96 bit floating point', '        TYPE_LONGDOUBLE_IS_DOUBLE   - Compiler implements "long double" same as "double"', "", "", "    FUNCTION_*", "    These conditionals specify whether the compiler supports particular language extensions", "    to function prototypes and definitions.", "", '        FUNCTION_PASCAL         - Compiler supports "pascal void Foo()"', '        FUNCTION_DECLSPEC       - Compiler supports "__declspec(xxx) void Foo()"', '        FUNCTION_WIN32CC        - Compiler supports "void __cdecl Foo()" and "void __stdcall Foo()"', "", "****************************************************************************************************/", "", "#if defined(__GNUC__) && (defined(__APPLE_CPP__) || defined(__APPLE_CC__) || defined(__NEXT_CPP__) || defined(__MACOS_CLASSIC__))", "   /*", "     gcc based compilers used on Mac OS X", "   */", "  #define PRAGMA_IMPORT               0", "  #define PRAGMA_ONCE                 0", "", "  #if __GNUC__ >= 4", "    #define PRAGMA_STRUCT_PACK          1", "    #define PRAGMA_STRUCT_PACKPUSH      1", "  #else", "    #define PRAGMA_STRUCT_PACK          0", "    #define PRAGMA_STRUCT_PACKPUSH      0", "  #endif", "", "  #if __LP64__", "    #define PRAGMA_STRUCT_ALIGN         0", "  #else", "    #define PRAGMA_STRUCT_ALIGN         1", "  #endif", "", "  #define PRAGMA_ENUM_PACK            0", "  #define PRAGMA_ENUM_ALWAYSINT       0", "  #define PRAGMA_ENUM_OPTIONS         0", "  #define FOUR_CHAR_CODE(x)           (x)", "", "  #define TYPE_EXTENDED               0", "", "  #ifdef __ppc__", "  #ifdef __LONG_DOUBLE_128__", "     #define TYPE_LONGDOUBLE_IS_DOUBLE 0", "    #else", "      #define TYPE_LONGDOUBLE_IS_DOUBLE 1", "    #endif", "  #else", "    #define TYPE_LONGDOUBLE_IS_DOUBLE 0", "  #endif", "", "  #define TYPE_LONGLONG               1", "  #ifdef __cplusplus", "     #define TYPE_BOOL                1", "  #else", "     #define TYPE_BOOL                0", "  #endif", " ", "  #define FUNCTION_PASCAL             0", "  #define FUNCTION_DECLSPEC           0", "  #define FUNCTION_WIN32CC            0 ", "  ", "  #ifdef __MACOS_CLASSIC__", "    #ifndef TARGET_API_MAC_CARBON            /* gcc cfm cross compiler assumes you're building Carbon code */", "       #define TARGET_API_MAC_CARBON 1", "    #endif", "  #endif", "  ", "", "", "#elif defined(__MWERKS__)", "   /*", "       CodeWarrior compiler from Metrowerks/Motorola", "   */", "   #define PRAGMA_ONCE                 1", "   #define PRAGMA_IMPORT               0", "   #define PRAGMA_STRUCT_ALIGN         1", "   #define PRAGMA_STRUCT_PACK          1", "   #define PRAGMA_STRUCT_PACKPUSH      0", "   #define PRAGMA_ENUM_PACK            0", "   #define PRAGMA_ENUM_ALWAYSINT       1", "   #define PRAGMA_ENUM_OPTIONS         0", "   #if __option(enumsalwaysint) && __option(ANSI_strict)", "     #define FOUR_CHAR_CODE(x)       ((long)(x)) /* otherwise compiler will complain about values with high bit set */", "   #else", "     #define FOUR_CHAR_CODE(x)       (x)", "   #endif", "   #define FUNCTION_PASCAL             1", "   #define FUNCTION_DECLSPEC           1", "   #define FUNCTION_WIN32CC            0           ", "      ", "   #if __option(longlong)", "      #define TYPE_LONGLONG            1", "   #else", "     #define TYPE_LONGLONG             0", "   #endif", "   #if __option(bool)", "     #define TYPE_BOOL                 1", "   #else", "      #define TYPE_BOOL                0", "   #endif", "   #define TYPE_EXTENDED               0", "   #define TYPE_LONGDOUBLE_IS_DOUBLE   1", "", "", "", "#else", "    /*", "     Unknown compiler, perhaps set up from the command line", "    */", "   #error unknown compiler", "    #ifndef PRAGMA_IMPORT", "  #define PRAGMA_IMPORT               0", "  #endif", " #ifndef PRAGMA_STRUCT_ALIGN", "    #define PRAGMA_STRUCT_ALIGN         0", "  #endif", " #ifndef PRAGMA_ONCE", "    #define PRAGMA_ONCE                 0", "  #endif", " #ifndef PRAGMA_STRUCT_PACK", " #define PRAGMA_STRUCT_PACK          0", "  #endif", " #ifndef PRAGMA_STRUCT_PACKPUSH", " #define PRAGMA_STRUCT_PACKPUSH      0", "  #endif", " #ifndef PRAGMA_ENUM_PACK", "   #define PRAGMA_ENUM_PACK            0", "  #endif", " #ifndef PRAGMA_ENUM_ALWAYSINT", "  #define PRAGMA_ENUM_ALWAYSINT       0", "  #endif", " #ifndef PRAGMA_ENUM_OPTIONS", "    #define PRAGMA_ENUM_OPTIONS         0", "  #endif", " #ifndef FOUR_CHAR_CODE", " #define FOUR_CHAR_CODE(x)           (x)", "    #endif", "", "    #ifndef TYPE_LONGDOUBLE_IS_DOUBLE", "  #define TYPE_LONGDOUBLE_IS_DOUBLE   1", "  #endif", " #ifndef TYPE_EXTENDED", "  #define TYPE_EXTENDED               0", "  #endif", " #ifndef TYPE_LONGLONG", "  #define TYPE_LONGLONG               0", "  #endif", " #ifndef TYPE_BOOL", "  #define TYPE_BOOL                   0", "  #endif", " #ifndef FUNCTION_PASCAL", "    #define FUNCTION_PASCAL             0", "  #endif", " #ifndef FUNCTION_DECLSPEC", "  #define FUNCTION_DECLSPEC           0", "  #endif", " #ifndef FUNCTION_WIN32CC", "   #define FUNCTION_WIN32CC            0", "  #endif", "#endif", "", "", "", "", "/****************************************************************************************************", "", "    Under MacOS, the classic 68k runtime has two calling conventions: pascal or C", "    Under Win32, there are two calling conventions: __cdecl or __stdcall", "    Headers and implementation files can use the following macros to make their", "    source more portable by hiding the calling convention details:", "", "    EXTERN_API*", "    These macros are used to specify the calling convention on a function prototype.", "", "        EXTERN_API              - Classic 68k: pascal, Win32: __cdecl", "        EXTERN_API_C            - Classic 68k: C,      Win32: __cdecl", "        EXTERN_API_STDCALL      - Classic 68k: pascal, Win32: __stdcall", "        EXTERN_API_C_STDCALL    - Classic 68k: C,      Win32: __stdcall", "", "", "    DEFINE_API*", "    These macros are used to specify the calling convention on a function definition.", "", "        DEFINE_API              - Classic 68k: pascal, Win32: __cdecl", "        DEFINE_API_C            - Classic 68k: C,      Win32: __cdecl", "        DEFINE_API_STDCALL      - Classic 68k: pascal, Win32: __stdcall", "        DEFINE_API_C_STDCALL    - Classic 68k: C,      Win32: __stdcall", "", "", "    CALLBACK_API*", "    These macros are used to specify the calling convention of a function pointer.", "", "        CALLBACK_API            - Classic 68k: pascal, Win32: __stdcall", "        CALLBACK_API_C          - Classic 68k: C,      Win32: __stdcall", "        CALLBACK_API_STDCALL    - Classic 68k: pascal, Win32: __cdecl", "        CALLBACK_API_C_STDCALL  - Classic 68k: C,      Win32: __cdecl", "", "****************************************************************************************************/", "", "#if FUNCTION_PASCAL && !FUNCTION_DECLSPEC && !FUNCTION_WIN32CC", "    /* compiler supports pascal keyword only  */", "    #define EXTERN_API(_type)                       extern pascal _type", "    #define EXTERN_API_C(_type)                     extern        _type", "    #define EXTERN_API_STDCALL(_type)               extern pascal _type", "    #define EXTERN_API_C_STDCALL(_type)             extern        _type", "    ", "    #define DEFINE_API(_type)                       pascal _type", "    #define DEFINE_API_C(_type)                            _type", "    #define DEFINE_API_STDCALL(_type)               pascal _type", "    #define DEFINE_API_C_STDCALL(_type)                    _type", "    ", "    #define CALLBACK_API(_type, _name)              pascal _type (*_name)", "    #define CALLBACK_API_C(_type, _name)                   _type (*_name)", "    #define CALLBACK_API_STDCALL(_type, _name)      pascal _type (*_name)", "    #define CALLBACK_API_C_STDCALL(_type, _name)           _type (*_name)", "", "#elif FUNCTION_PASCAL && FUNCTION_DECLSPEC && !FUNCTION_WIN32CC", "    /* compiler supports pascal and __declspec() */", "    #define EXTERN_API(_type)                       extern pascal __declspec(dllimport) _type", "    #define EXTERN_API_C(_type)                     extern        __declspec(dllimport) _type", "    #define EXTERN_API_STDCALL(_type)               extern pascal __declspec(dllimport) _type", "    #define EXTERN_API_C_STDCALL(_type)             extern        __declspec(dllimport) _type", "    ", "    #define DEFINE_API(_type)                       pascal __declspec(dllexport) _type", "    #define DEFINE_API_C(_type)                            __declspec(dllexport) _type", "    #define DEFINE_API_STDCALL(_type)               pascal __declspec(dllexport) _type", "    #define DEFINE_API_C_STDCALL(_type)                    __declspec(dllexport) _type", "", "    #define CALLBACK_API(_type, _name)              pascal _type (*_name)", "    #define CALLBACK_API_C(_type, _name)                   _type (*_name)", "    #define CALLBACK_API_STDCALL(_type, _name)      pascal _type (*_name)", "    #define CALLBACK_API_C_STDCALL(_type, _name)           _type (*_name)", "", "#elif !FUNCTION_PASCAL && FUNCTION_DECLSPEC && !FUNCTION_WIN32CC", "    /* compiler supports __declspec() */", "    #define EXTERN_API(_type)                       extern __declspec(dllimport) _type", "    #define EXTERN_API_C(_type)                     extern __declspec(dllimport) _type", "    #define EXTERN_API_STDCALL(_type)               extern __declspec(dllimport) _type", "    #define EXTERN_API_C_STDCALL(_type)             extern __declspec(dllimport) _type", "    ", "    #define DEFINE_API(_type)                       __declspec(dllexport) _type ", "    #define DEFINE_API_C(_type)                     __declspec(dllexport) _type", "    #define DEFINE_API_STDCALL(_type)               __declspec(dllexport) _type", "    #define DEFINE_API_C_STDCALL(_type)             __declspec(dllexport) _type", "", "    #define CALLBACK_API(_type, _name)              _type ( * _name)", "    #define CALLBACK_API_C(_type, _name)            _type ( * _name)", "    #define CALLBACK_API_STDCALL(_type, _name)      _type ( * _name)", "    #define CALLBACK_API_C_STDCALL(_type, _name)    _type ( * _name)", "", "#elif !FUNCTION_PASCAL && FUNCTION_DECLSPEC && FUNCTION_WIN32CC", "    /* compiler supports __declspec() and __cdecl */", "    #define EXTERN_API(_type)                       __declspec(dllimport) _type __cdecl", "    #define EXTERN_API_C(_type)                     __declspec(dllimport) _type __cdecl", "    #define EXTERN_API_STDCALL(_type)               __declspec(dllimport) _type __stdcall", "    #define EXTERN_API_C_STDCALL(_type)             __declspec(dllimport) _type __stdcall", "    ", "    #define DEFINE_API(_type)                       __declspec(dllexport) _type __cdecl", "    #define DEFINE_API_C(_type)                     __declspec(dllexport) _type __cdecl", "    #define DEFINE_API_STDCALL(_type)               __declspec(dllexport) _type __stdcall", "    #define DEFINE_API_C_STDCALL(_type)             __declspec(dllexport) _type __stdcall", "    ", "    #define CALLBACK_API(_type, _name)              _type (__cdecl * _name)", "    #define CALLBACK_API_C(_type, _name)            _type (__cdecl * _name)", "    #define CALLBACK_API_STDCALL(_type, _name)      _type (__stdcall * _name)", "    #define CALLBACK_API_C_STDCALL(_type, _name)    _type (__stdcall * _name)", "", "#elif !FUNCTION_PASCAL && !FUNCTION_DECLSPEC && FUNCTION_WIN32CC", "    /* compiler supports __cdecl */", "    #define EXTERN_API(_type)                       _type __cdecl", "    #define EXTERN_API_C(_type)                     _type __cdecl", "    #define EXTERN_API_STDCALL(_type)               _type __stdcall", "    #define EXTERN_API_C_STDCALL(_type)             _type __stdcall", "    ", "    #define DEFINE_API(_type)                       _type __cdecl", "    #define DEFINE_API_C(_type)                     _type __cdecl", "    #define DEFINE_API_STDCALL(_type)               _type __stdcall", "    #define DEFINE_API_C_STDCALL(_type)             _type __stdcall", "    ", "    #define CALLBACK_API(_type, _name)              _type (__cdecl * _name)", "    #define CALLBACK_API_C(_type, _name)            _type (__cdecl * _name)", "    #define CALLBACK_API_STDCALL(_type, _name)      _type (__stdcall * _name)", "    #define CALLBACK_API_C_STDCALL(_type, _name)    _type (__stdcall * _name)", "", "#else ", "    /* compiler supports no extensions */", "    #define EXTERN_API(_type)                       extern _type", "    #define EXTERN_API_C(_type)                     extern _type", "    #define EXTERN_API_STDCALL(_type)               extern _type", "    #define EXTERN_API_C_STDCALL(_type)             extern _type", "    ", "    #define DEFINE_API(_type)                       _type", "    #define DEFINE_API_C(_type)                     _type", "    #define DEFINE_API_STDCALL(_type)               _type", "    #define DEFINE_API_C_STDCALL(_type)             _type", "", "    #define CALLBACK_API(_type, _name)              _type ( * _name)", "    #define CALLBACK_API_C(_type, _name)            _type ( * _name)", "    #define CALLBACK_API_STDCALL(_type, _name)      _type ( * _name)", "    #define CALLBACK_API_C_STDCALL(_type, _name)    _type ( * _name)", "    #undef pascal", "    #define pascal", "#endif", "", "/****************************************************************************************************", "    ", "    Set up TARGET_API_*_* values", "", "****************************************************************************************************/", "#if !defined(TARGET_API_MAC_OS8) && !defined(TARGET_API_MAC_OSX) && !defined(TARGET_API_MAC_CARBON)", "/* No TARGET_API_MAC_* predefined on command line */", "#if TARGET_RT_MAC_MACHO", "/* Looks like MachO style compiler */", "#define TARGET_API_MAC_OS8 0", "#define TARGET_API_MAC_CARBON 1", "#define TARGET_API_MAC_OSX 1", "#elif defined(TARGET_CARBON) && TARGET_CARBON", "/* grandfather in use of TARGET_CARBON */", "#define TARGET_API_MAC_OS8 0", "#define TARGET_API_MAC_CARBON 1", "#define TARGET_API_MAC_OSX 0", "#elif TARGET_CPU_PPC && TARGET_RT_MAC_CFM", "/* Looks like CFM style PPC compiler */", "#define TARGET_API_MAC_OS8 1", "#define TARGET_API_MAC_CARBON 0", "#define TARGET_API_MAC_OSX 0", "#else", "/* 68k or some other compiler */", "#define TARGET_API_MAC_OS8 1", "#define TARGET_API_MAC_CARBON 0", "#define TARGET_API_MAC_OSX 0", "#endif  /*  */", "", "#else", "#ifndef TARGET_API_MAC_OS8", "#define TARGET_API_MAC_OS8 0", "#endif  /* !defined(TARGET_API_MAC_OS8) */", "", "#ifndef TARGET_API_MAC_OSX", "#define TARGET_API_MAC_OSX TARGET_RT_MAC_MACHO", "#endif  /* !defined(TARGET_API_MAC_OSX) */", "", "#ifndef TARGET_API_MAC_CARBON", "#define TARGET_API_MAC_CARBON TARGET_API_MAC_OSX", "#endif  /* !defined(TARGET_API_MAC_CARBON) */", "", "#endif  /* !defined(TARGET_API_MAC_OS8) && !defined(TARGET_API_MAC_OSX) && !defined(TARGET_API_MAC_CARBON) */", "", "#if TARGET_API_MAC_OS8 && TARGET_API_MAC_OSX", "#error TARGET_API_MAC_OS8 and TARGET_API_MAC_OSX are mutually exclusive", "#endif  /* TARGET_API_MAC_OS8 && TARGET_API_MAC_OSX */", "", "#if !TARGET_API_MAC_OS8 && !TARGET_API_MAC_CARBON && !TARGET_API_MAC_OSX", "#error At least one of TARGET_API_MAC_* must be true", "#endif  /* !TARGET_API_MAC_OS8 && !TARGET_API_MAC_CARBON && !TARGET_API_MAC_OSX */", "", "/* Support source code still using TARGET_CARBON */", "#ifndef TARGET_CARBON", "#if TARGET_API_MAC_CARBON && !TARGET_API_MAC_OS8", "#define TARGET_CARBON 1", "#else", "#define TARGET_CARBON 0", "#endif  /* TARGET_API_MAC_CARBON && !TARGET_API_MAC_OS8 */", "", "#endif  /* !defined(TARGET_CARBON) */", "", "/****************************************************************************************************", "    Backward compatibility for clients expecting 2.x version on ConditionalMacros.h", "", "    GENERATINGPOWERPC       - Compiler is generating PowerPC instructions", "    GENERATING68K           - Compiler is generating 68k family instructions", "    GENERATING68881         - Compiler is generating mc68881 floating point instructions", "    GENERATINGCFM           - Code being generated assumes CFM calling conventions", "    CFMSYSTEMCALLS          - No A-traps.  Systems calls are made using CFM and UPP's", "    PRAGMA_ALIGN_SUPPORTED  - Compiler supports: #pragma options align=mac68k/power/reset", "    PRAGMA_IMPORT_SUPPORTED - Compiler supports: #pragma import on/off/reset", "    CGLUESUPPORTED          - Clients can use all lowercase toolbox functions that take C strings instead of pascal strings", "", "****************************************************************************************************/", "#if !TARGET_API_MAC_CARBON", "#define GENERATINGPOWERPC TARGET_CPU_PPC", "#define GENERATING68K 0", "#define GENERATING68881 TARGET_RT_MAC_68881", "#define GENERATINGCFM TARGET_RT_MAC_CFM", "#define CFMSYSTEMCALLS TARGET_RT_MAC_CFM", "#ifndef CGLUESUPPORTED", "#define CGLUESUPPORTED 0", "#endif  /* !defined(CGLUESUPPORTED) */", "", "#ifndef OLDROUTINELOCATIONS", "#define OLDROUTINELOCATIONS 0", "#endif  /* !defined(OLDROUTINELOCATIONS) */", "", "#define PRAGMA_ALIGN_SUPPORTED  PRAGMA_STRUCT_ALIGN", "#define PRAGMA_IMPORT_SUPPORTED PRAGMA_IMPORT", "#else", "/* Carbon code should not use old conditionals */", "#define PRAGMA_ALIGN_SUPPORTED  ..PRAGMA_ALIGN_SUPPORTED_is_obsolete..", "#define GENERATINGPOWERPC       ..GENERATINGPOWERPC_is_obsolete..", "#define GENERATING68K           ..GENERATING68K_is_obsolete..", "#define GENERATING68881         ..GENERATING68881_is_obsolete..", "#define GENERATINGCFM           ..GENERATINGCFM_is_obsolete..", "#define CFMSYSTEMCALLS          ..CFMSYSTEMCALLS_is_obsolete..", "#endif  /* !TARGET_API_MAC_CARBON */", "", "", "", "/****************************************************************************************************", "", '    OLDROUTINENAMES         - "Old" names for Macintosh system calls are allowed in source code.', "                              (e.g. DisposPtr instead of DisposePtr). The names of system routine", "                              are now more sensitive to change because CFM binds by name.  In the ", "                              past, system routine names were compiled out to just an A-Trap.  ", "                              Macros have been added that each map an old name to its new name.  ", "                              This allows old routine names to be used in existing source files,", "                              but the macros only work if OLDROUTINENAMES is true.  This support", "                              will be removed in the near future.  Thus, all source code should ", "                              be changed to use the new names! You can set OLDROUTINENAMES to false", "                              to see if your code has any old names left in it.", "    ", "****************************************************************************************************/", "#ifndef OLDROUTINENAMES", "#define OLDROUTINENAMES 0", "#endif  /* !defined(OLDROUTINENAMES) */", "", "", "", "/****************************************************************************************************", " The following macros isolate the use of 68K inlines in function prototypes.", "    On the Mac OS under the Classic 68K runtime, function prototypes were followed", " by a list of 68K opcodes which the compiler inserted in the generated code instead", " of a JSR.  Under Classic 68K on the Mac OS, this macro will put the opcodes", "    in the right syntax.  For all other OS's and runtimes the macro suppress the opcodes.", "  Example:", "   ", "       EXTERN_P void DrawPicture(PicHandle myPicture, const Rect *dstRect)", "            ONEWORDINLINE(0xA8F6);", " ", "****************************************************************************************************/", "", "#if TARGET_OS_MAC && TARGET_CPU_68K && !TARGET_RT_MAC_CFM", " #define ONEWORDINLINE(w1) = w1", " #define TWOWORDINLINE(w1,w2) = {w1,w2}", " #define THREEWORDINLINE(w1,w2,w3) = {w1,w2,w3}", " #define FOURWORDINLINE(w1,w2,w3,w4)  = {w1,w2,w3,w4}", "   #define FIVEWORDINLINE(w1,w2,w3,w4,w5) = {w1,w2,w3,w4,w5}", "  #define SIXWORDINLINE(w1,w2,w3,w4,w5,w6)     = {w1,w2,w3,w4,w5,w6}", " #define SEVENWORDINLINE(w1,w2,w3,w4,w5,w6,w7)    = {w1,w2,w3,w4,w5,w6,w7}", "  #define EIGHTWORDINLINE(w1,w2,w3,w4,w5,w6,w7,w8)     = {w1,w2,w3,w4,w5,w6,w7,w8}", "   #define NINEWORDINLINE(w1,w2,w3,w4,w5,w6,w7,w8,w9)   = {w1,w2,w3,w4,w5,w6,w7,w8,w9}", "    #define TENWORDINLINE(w1,w2,w3,w4,w5,w6,w7,w8,w9,w10)  = {w1,w2,w3,w4,w5,w6,w7,w8,w9,w10}", "  #define ELEVENWORDINLINE(w1,w2,w3,w4,w5,w6,w7,w8,w9,w10,w11)     = {w1,w2,w3,w4,w5,w6,w7,w8,w9,w10,w11}", "    #define TWELVEWORDINLINE(w1,w2,w3,w4,w5,w6,w7,w8,w9,w10,w11,w12)     = {w1,w2,w3,w4,w5,w6,w7,w8,w9,w10,w11,w12}", "#else", "  #define ONEWORDINLINE(w1)", "  #define TWOWORDINLINE(w1,w2)", "   #define THREEWORDINLINE(w1,w2,w3)", "  #define FOURWORDINLINE(w1,w2,w3,w4)", "    #define FIVEWORDINLINE(w1,w2,w3,w4,w5)", " #define SIXWORDINLINE(w1,w2,w3,w4,w5,w6)", "   #define SEVENWORDINLINE(w1,w2,w3,w4,w5,w6,w7)", "  #define EIGHTWORDINLINE(w1,w2,w3,w4,w5,w6,w7,w8)", "   #define NINEWORDINLINE(w1,w2,w3,w4,w5,w6,w7,w8,w9)", " #define TENWORDINLINE(w1,w2,w3,w4,w5,w6,w7,w8,w9,w10)", "  #define ELEVENWORDINLINE(w1,w2,w3,w4,w5,w6,w7,w8,w9,w10,w11)", "   #define TWELVEWORDINLINE(w1,w2,w3,w4,w5,w6,w7,w8,w9,w10,w11,w12)", "#endif", "", "", "/****************************************************************************************************", "", "    TARGET_CARBON                   - default: false. Switches all of the above as described.  Overrides all others", "                                    - NOTE: If you set TARGET_CARBON to 1, then the other switches will be setup by", "                                            ConditionalMacros, and should not be set manually.", "", "    If you wish to do development for pre-Carbon Systems, you can set the following:", "", "    OPAQUE_TOOLBOX_STRUCTS          - default: false. True for Carbon builds, hides struct fields.", "    OPAQUE_UPP_TYPES                - default: false. True for Carbon builds, UPP types are unique and opaque.", "    ACCESSOR_CALLS_ARE_FUNCTIONS    - default: false. True for Carbon builds, enables accessor functions.", "    CALL_NOT_IN_CARBON              - default: true.  False for Carbon builds, hides calls not supported in Carbon.", "    ", "    Specifically, if you are building a non-Carbon application (one that links against InterfaceLib)", "    but you wish to use some of the accessor functions, you can set ACCESSOR_CALLS_ARE_FUNCTIONS to 1", "    and link with CarbonAccessors.o, which implements just the accessor functions. This will help you", "    preserve source compatibility between your Carbon and non-Carbon application targets.", "    ", "    MIXEDMODE_CALLS_ARE_FUNCTIONS   - deprecated.", "", "****************************************************************************************************/", "#if TARGET_API_MAC_CARBON && !TARGET_API_MAC_OS8", "#ifndef OPAQUE_TOOLBOX_STRUCTS", "#define OPAQUE_TOOLBOX_STRUCTS 1", "#endif  /* !defined(OPAQUE_TOOLBOX_STRUCTS) */", "", "#ifndef OPAQUE_UPP_TYPES", "#define OPAQUE_UPP_TYPES 1", "#endif  /* !defined(OPAQUE_UPP_TYPES) */", "", "#ifndef ACCESSOR_CALLS_ARE_FUNCTIONS", "#define ACCESSOR_CALLS_ARE_FUNCTIONS 1", "#endif  /* !defined(ACCESSOR_CALLS_ARE_FUNCTIONS) */", "", "#ifndef CALL_NOT_IN_CARBON", "#define CALL_NOT_IN_CARBON 0", "#endif  /* !defined(CALL_NOT_IN_CARBON) */", "", "#ifndef MIXEDMODE_CALLS_ARE_FUNCTIONS", "#define MIXEDMODE_CALLS_ARE_FUNCTIONS 1", "#endif  /* !defined(MIXEDMODE_CALLS_ARE_FUNCTIONS) */", "", "#else", "#ifndef OPAQUE_TOOLBOX_STRUCTS", "#define OPAQUE_TOOLBOX_STRUCTS 0", "#endif  /* !defined(OPAQUE_TOOLBOX_STRUCTS) */", "", "#ifndef ACCESSOR_CALLS_ARE_FUNCTIONS", "#define ACCESSOR_CALLS_ARE_FUNCTIONS 0", "#endif  /* !defined(ACCESSOR_CALLS_ARE_FUNCTIONS) */", "", "/*", "     * It's possible to have ACCESSOR_CALLS_ARE_FUNCTIONS set to true and OPAQUE_TOOLBOX_STRUCTS", "     * set to false, but not the other way around, so make sure the defines are not set this way.", "     */", "#ifndef CALL_NOT_IN_CARBON", "#define CALL_NOT_IN_CARBON 1", "#endif  /* !defined(CALL_NOT_IN_CARBON) */", "", "#ifndef MIXEDMODE_CALLS_ARE_FUNCTIONS", "#define MIXEDMODE_CALLS_ARE_FUNCTIONS 0", "#endif  /* !defined(MIXEDMODE_CALLS_ARE_FUNCTIONS) */", "", "#endif  /* TARGET_API_MAC_CARBON && !TARGET_API_MAC_OS8 */", "", "", "", "", "#endif /* __CONDITIONALMACROS__ */", "" },
    ["MacTypes.h"] = { "/*", " * Copyright (c) 1985-2011 by Apple Inc.. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", " ", "/*", "     File:       MacTypes.h", " ", "     Contains:   Basic Macintosh data types.", " ", "     Version:    CarbonCore-769~1", "  ", "     Bugs?:      For bug reports, consult the following page on", "                 the World Wide Web:", " ", "                     http://developer.apple.com/bugreporter/", " ", "*/", "#ifndef __MACTYPES__", "#define __MACTYPES__", "", "#ifndef __CONDITIONALMACROS__", "#include <ConditionalMacros.h>", "#endif", "", "#include <stdbool.h>", "", "#include <sys/types.h>", "", "#include <Availability.h>", "", "#if PRAGMA_ONCE", "#pragma once", "#endif", "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "", "#pragma pack(push, 2)", "", "", "/*", "        CarbonCore Deprecation flags.", "", "     Certain Carbon API functions are deprecated in 10.3 and later", "      systems.  These will produce a warning when compiling on 10.3.", "", "        Other functions and constants do not produce meaningful", "        results when building Carbon for Mac OS X.  For these", "      functions, no-op macros are provided, but only when the", "        ALLOW_OBSOLETE_CARBON flag is defined to be 0: eg", "      -DALLOW_OBSOLETE_CARBON=0.", "*/", "", "#if  ! defined(ALLOW_OBSOLETE_CARBON) || ! ALLOW_OBSOLETE_CARBON", "", "#define ALLOW_OBSOLETE_CARBON_MACMEMORY        0", "#define ALLOW_OBSOLETE_CARBON_OSUTILS     0", "", "#else", "", "#define ALLOW_OBSOLETE_CARBON_MACMEMORY       1       /* Removes obsolete constants; turns HLock/HUnlock into no-op macros */", "#define ALLOW_OBSOLETE_CARBON_OSUTILS       1       /* Removes obsolete structures */", "", "#endif", "", "#ifndef NULL", "#define NULL    __DARWIN_NULL", "#endif /* ! NULL */", "#ifndef nil", "    #define nil NULL", "#endif /* ! nil */", "/********************************************************************************", "", "    Base integer types for all target OS's and CPU's", "    ", "        UInt8            8-bit unsigned integer ", "        SInt8            8-bit signed integer", "        UInt16          16-bit unsigned integer ", "        SInt16          16-bit signed integer           ", "        UInt32          32-bit unsigned integer ", "        SInt32          32-bit signed integer   ", "        UInt64          64-bit unsigned integer ", "        SInt64          64-bit signed integer   ", "", "*********************************************************************************/", "typedef unsigned char                   UInt8;", "typedef signed char                     SInt8;", "typedef unsigned short                  UInt16;", "typedef signed short                    SInt16;", "", "#if __LP64__", "typedef unsigned int                    UInt32;", "typedef signed int                      SInt32;", "#else", "typedef unsigned long                   UInt32;", "typedef signed long                     SInt32;", "#endif", "", "/* avoid redeclaration if libkern/OSTypes.h */", "#ifndef _OS_OSTYPES_H", "#if TARGET_RT_BIG_ENDIAN", "struct wide {", "  SInt32              hi;", "  UInt32              lo;", "};", "typedef struct wide                     wide;", "struct UnsignedWide {", "  UInt32              hi;", "  UInt32              lo;", "};", "typedef struct UnsignedWide             UnsignedWide;", "#else", "struct wide {", "  UInt32              lo;", "  SInt32              hi;", "};", "typedef struct wide                     wide;", "struct UnsignedWide {", "  UInt32              lo;", "  UInt32              hi;", "};", "typedef struct UnsignedWide             UnsignedWide;", "#endif  /* TARGET_RT_BIG_ENDIAN */", "", "#endif", "", "#if TYPE_LONGLONG", "/*", "  Note:   wide and UnsignedWide must always be structs for source code", "           compatibility. On the other hand UInt64 and SInt64 can be", "          either a struct or a long long, depending on the compiler.", "         ", "           If you use UInt64 and SInt64 you should do all operations on ", "          those data types through the functions/macros in Math64.h.  ", "           This will assure that your code compiles with compilers that", "           support long long and those that don't.", "            ", "           The MS Visual C/C++ compiler uses __int64 instead of long long. ", "*/", "    #if defined(_MSC_VER) && !defined(__MWERKS__) && defined(_M_IX86)", "      typedef   signed __int64                SInt64;", "        typedef unsigned __int64                UInt64;", "    #else", "      typedef   signed long long              SInt64;", "        typedef unsigned long long              UInt64;", "    #endif", "#else", "", "", "typedef wide                            SInt64;", "typedef UnsignedWide                    UInt64;", "#endif  /* TYPE_LONGLONG */", "", "/********************************************************************************", "", "    Base fixed point types ", "    ", "        Fixed           16-bit signed integer plus 16-bit fraction", "        UnsignedFixed   16-bit unsigned integer plus 16-bit fraction", "        Fract           2-bit signed integer plus 30-bit fraction", "        ShortFixed      8-bit signed integer plus 8-bit fraction", "        ", "*********************************************************************************/", "typedef SInt32                          Fixed;", "typedef Fixed *                         FixedPtr;", "typedef SInt32                          Fract;", "typedef Fract *                         FractPtr;", "typedef UInt32                          UnsignedFixed;", "typedef UnsignedFixed *                 UnsignedFixedPtr;", "typedef short                           ShortFixed;", "typedef ShortFixed *                    ShortFixedPtr;", "", "", "/********************************************************************************", "", "    Base floating point types ", "    ", "        Float32         32 bit IEEE float:  1 sign bit, 8 exponent bits, 23 fraction bits", "        Float64         64 bit IEEE float:  1 sign bit, 11 exponent bits, 52 fraction bits  ", "        Float80         80 bit MacOS float: 1 sign bit, 15 exponent bits, 1 integer bit, 63 fraction bits", "        Float96         96 bit 68881 float: 1 sign bit, 15 exponent bits, 16 pad bits, 1 integer bit, 63 fraction bits", "        ", "    Note: These are fixed size floating point types, useful when writing a floating", "          point value to disk.  If your compiler does not support a particular size ", "          float, a struct is used instead.", "          Use of of the NCEG types (e.g. double_t) or an ANSI C type (e.g. double) if", "          you want a floating point representation that is natural for any given", "          compiler, but might be a different size on different compilers.", "", "*********************************************************************************/", "typedef float               Float32;", "typedef double              Float64;", "struct Float80 {", "    SInt16  exp;", "    UInt16  man[4];", "};", "typedef struct Float80 Float80;", "", "struct Float96 {", "    SInt16  exp[2];     /* the second 16-bits are undefined */", "    UInt16  man[4];", "};", "typedef struct Float96 Float96;", "struct Float32Point {", "    Float32             x;", "    Float32             y;", "};", "typedef struct Float32Point Float32Point;", "", "/********************************************************************************", "", "    MacOS Memory Manager types", "    ", "        Ptr             Pointer to a non-relocatable block", "        Handle          Pointer to a master pointer to a relocatable block", "        Size            The number of bytes in a block (signed for historical reasons)", "        ", "*********************************************************************************/", "typedef char *                          Ptr;", "typedef Ptr *                           Handle;", "typedef long                            Size;", "", "/********************************************************************************", "", "    Higher level basic types", "    ", "        OSErr                   16-bit result error code", "        OSStatus                32-bit result error code", "        LogicalAddress          Address in the clients virtual address space", "        ConstLogicalAddress     Address in the clients virtual address space that will only be read", "        PhysicalAddress         Real address as used on the hardware bus", "        BytePtr                 Pointer to an array of bytes", "        ByteCount               The size of an array of bytes", "        ByteOffset              An offset into an array of bytes", "        ItemCount               32-bit iteration count", "        OptionBits              Standard 32-bit set of bit flags", "        PBVersion               ?", "        Duration                32-bit millisecond timer for drivers", "        AbsoluteTime            64-bit clock", "        ScriptCode              A particular set of written characters (e.g. Roman vs Cyrillic) and their encoding", "        LangCode                A particular language (e.g. English), as represented using a particular ScriptCode", "        RegionCode              Designates a language as used in a particular region (e.g. British vs American", "                                English) together with other region-dependent characteristics (e.g. date format)", "        FourCharCode            A 32-bit value made by packing four 1 byte characters together", "        OSType                  A FourCharCode used in the OS and file system (e.g. creator)", "        ResType                 A FourCharCode used to tag resources (e.g. 'DLOG')", "        ", "*********************************************************************************/", "typedef SInt16                          OSErr;", "typedef SInt32                          OSStatus;", "typedef void *                          LogicalAddress;", "typedef const void *                    ConstLogicalAddress;", "typedef void *                          PhysicalAddress;", "typedef UInt8 *                         BytePtr;", "typedef unsigned long                   ByteCount;", "typedef unsigned long                   ByteOffset;", "typedef SInt32                          Duration;", "typedef UnsignedWide                    AbsoluteTime;", "typedef UInt32                          OptionBits;", "typedef unsigned long                   ItemCount;", "typedef UInt32                          PBVersion;", "typedef SInt16                          ScriptCode;", "typedef SInt16                          LangCode;", "typedef SInt16                          RegionCode;", "typedef UInt32                          FourCharCode;", "typedef FourCharCode                    OSType;", "typedef FourCharCode                    ResType;", "typedef OSType *                        OSTypePtr;", "typedef ResType *                       ResTypePtr;", "/********************************************************************************", "", "    Boolean types and values", "    ", "        Boolean         Mac OS historic type, sizeof(Boolean)==1", "        bool            Defined in stdbool.h, ISO C/C++ standard type", "        false           Now defined in stdbool.h", "        true            Now defined in stdbool.h", "        ", "*********************************************************************************/", "typedef unsigned char                   Boolean;", "/********************************************************************************", "", "    Function Pointer Types", "    ", "        ProcPtr                 Generic pointer to a function", "        Register68kProcPtr      Pointer to a 68K function that expects parameters in registers", "        UniversalProcPtr        Pointer to classic 68K code or a RoutineDescriptor", "        ", "        ProcHandle              Pointer to a ProcPtr", "        UniversalProcHandle     Pointer to a UniversalProcPtr", "        ", "*********************************************************************************/", "typedef CALLBACK_API_C( long , ProcPtr )();", "typedef CALLBACK_API( void , Register68kProcPtr )();", "#if TARGET_RT_MAC_CFM", "/*  The RoutineDescriptor structure is defined in MixedMode.h */", "typedef struct RoutineDescriptor *UniversalProcPtr;", "#else", "typedef ProcPtr                         UniversalProcPtr;", "#endif  /* TARGET_RT_MAC_CFM */", "", "typedef ProcPtr *                       ProcHandle;", "typedef UniversalProcPtr *              UniversalProcHandle;", "/********************************************************************************", "", "    RefCon Types", "    ", "        For access to private data in callbacks, etc.; refcons are generally", "        used as a pointer to something, but in the 32-bit world refcons in", "        different APIs have had various types: pointer, unsigned scalar, and", "        signed scalar. The RefCon types defined here support the current 32-bit", "        usage but provide normalization to pointer types for 64-bit.", "        ", "        PRefCon is preferred for new APIs; URefCon and SRefCon are primarily", "        for compatibility with existing APIs.", "        ", "*********************************************************************************/", "typedef void *                          PRefCon;", "#if __LP64__", "typedef void *                          URefCon;", "typedef void *                          SRefCon;", "#else", "typedef UInt32                          URefCon;", "typedef SInt32                          SRefCon;", "#endif  /* __LP64__ */", "", "/********************************************************************************", "", "    Common Constants", "    ", "        noErr                   OSErr: function performed properly - no error", "        kNilOptions             OptionBits: all flags false", "        kInvalidID              KernelID: NULL is for pointers as kInvalidID is for ID's", "        kVariableLengthArray    array bounds: variable length array", "", "    Note: kVariableLengthArray was used in array bounds to specify a variable length array,", "          usually the last field in a struct.  Now that the C language supports ", "\t\t  the concept of flexible array members, you can instead use: ", "\t\t", "\t\tstruct BarList", "\t\t{", "\t\t\tshort\tlistLength;", "\t\t\tBar\t\telements[];", "\t\t};", "", "\t\tHowever, this changes the semantics somewhat, as sizeof( BarList ) contains", "\t\tno space for any of the elements, so to allocate a list with space for", "\t\tthe count elements", "", "\t\tstruct BarList* l = (struct BarList*) malloc( sizeof(BarList) + count * sizeof(Bar) );", "        ", "*********************************************************************************/", "enum {", "  noErr                         = 0", "};", "", "enum {", "  kNilOptions                   = 0", "};", "", "#define kInvalidID   0", "enum {", "  kVariableLengthArray  ", "#ifdef __has_extension", "   #if __has_extension(enumerator_attributes)", "\t\t__attribute__((deprecated))  ", "\t#endif", "#endif", "  = 1", "};", "", "enum {", '  kUnknownType                  = 0x3F3F3F3F /* "????" QuickTime 3.0: default unknown ResType or OSType */', "};", "", "", "", "/********************************************************************************", "", "    String Types and Unicode Types", "    ", "        UnicodeScalarValue,     A complete Unicode character in UTF-32 format, with", "        UTF32Char               values from 0 through 0x10FFFF (excluding the surrogate", "                                range 0xD800-0xDFFF and certain disallowed values).", "", "        UniChar,                A 16-bit Unicode code value in the default UTF-16 format.", "        UTF16Char               UnicodeScalarValues 0-0xFFFF are expressed in UTF-16", "                                format using a single UTF16Char with the same value.", "                                UnicodeScalarValues 0x10000-0x10FFFF are expressed in", "                                UTF-16 format using a pair of UTF16Chars - one in the", "                                high surrogate range (0xD800-0xDBFF) followed by one in", "                                the low surrogate range (0xDC00-0xDFFF). All of the", "                                characters defined in Unicode versions through 3.0 are", "                                in the range 0-0xFFFF and can be expressed using a single", '                                UTF16Char, thus the term "Unicode character" generally', "                                refers to a UniChar = UTF16Char.", "", "        UTF8Char                An 8-bit code value in UTF-8 format. UnicodeScalarValues", "                                0-0x7F are expressed in UTF-8 format using one UTF8Char", "                                with the same value. UnicodeScalarValues above 0x7F are", "                                expressed in UTF-8 format using 2-4 UTF8Chars, all with", "                                values in the range 0x80-0xF4 (UnicodeScalarValues", "                                0x100-0xFFFF use two or three UTF8Chars,", "                                UnicodeScalarValues 0x10000-0x10FFFF use four UTF8Chars).", "", "        UniCharCount            A count of UTF-16 code values in an array or buffer.", "", "        StrNNN                  Pascal string holding up to NNN bytes", "        StringPtr               Pointer to a pascal string", "        StringHandle            Pointer to a StringPtr", "        ConstStringPtr          Pointer to a read-only pascal string", "        ConstStrNNNParam        For function parameters only - means string is const", "        ", "        CStringPtr              Pointer to a C string           (in C:  char*)", "        ConstCStringPtr         Pointer to a read-only C string (in C:  const char*)", "        ", "    Note: The length of a pascal string is stored as the first byte.", "          A pascal string does not have a termination byte.", "          A pascal string can hold at most 255 bytes of data.", "          The first character in a pascal string is offset one byte from the start of the string. ", "          ", "          A C string is terminated with a byte of value zero.  ", "          A C string has no length limitation.", "          The first character in a C string is the zeroth byte of the string. ", "          ", "        ", "*********************************************************************************/", "typedef UInt32                          UnicodeScalarValue;", "typedef UInt32                          UTF32Char;", "typedef UInt16                          UniChar;", "typedef UInt16                          UTF16Char;", "typedef UInt8                           UTF8Char;", "typedef UniChar *                       UniCharPtr;", "typedef unsigned long                   UniCharCount;", "typedef UniCharCount *                  UniCharCountPtr;", "typedef unsigned char                   Str255[256];", "typedef unsigned char                   Str63[64];", "typedef unsigned char                   Str32[33];", "typedef unsigned char                   Str31[32];", "typedef unsigned char                   Str27[28];", "typedef unsigned char                   Str15[16];", "/*", "    The type Str32 is used in many AppleTalk based data structures.", "    It holds up to 32 one byte chars.  The problem is that with the", "    length byte it is 33 bytes long.  This can cause weird alignment", '    problems in structures.  To fix this the type "Str32Field" has', "    been created.  It should only be used to hold 32 chars, but", "    it is 34 bytes long so that there are no alignment problems.", "*/", "typedef unsigned char                   Str32Field[34];", "/*", "    QuickTime 3.0:", "    The type StrFileName is used to make MacOS structs work ", "    cross-platform.  For example FSSpec or SFReply previously", "    contained a Str63 field.  They now contain a StrFileName", "    field which is the same when targeting the MacOS but is", "    a 256 char buffer for Win32 and unix, allowing them to", "    contain long file names.", "*/", "typedef Str63                           StrFileName;", "typedef unsigned char *                 StringPtr;", "typedef StringPtr *                     StringHandle;", "typedef const unsigned char *           ConstStringPtr;", "typedef const unsigned char *           ConstStr255Param;", "typedef const unsigned char *           ConstStr63Param;", "typedef const unsigned char *           ConstStr32Param;", "typedef const unsigned char *           ConstStr31Param;", "typedef const unsigned char *           ConstStr27Param;", "typedef const unsigned char *           ConstStr15Param;", "typedef ConstStr63Param                 ConstStrFileNameParam;", "#ifdef __cplusplus", "inline unsigned char StrLength(ConstStr255Param string) { return (*string); }", "#else", "#define StrLength(string) (*(unsigned char *)(string))", "#endif  /* defined(__cplusplus) */", "", "#if OLDROUTINENAMES", "#define Length(string) StrLength(string)", "#endif  /* OLDROUTINENAMES */", "", "/********************************************************************************", "", "    Process Manager type ProcessSerialNumber (previously in Processes.h)", "", "*********************************************************************************/", "/* type for unique process identifier */", "struct ProcessSerialNumber {", "  UInt32              highLongOfPSN;", "  UInt32              lowLongOfPSN;", "};", "typedef struct ProcessSerialNumber      ProcessSerialNumber;", "typedef ProcessSerialNumber *           ProcessSerialNumberPtr;", "/********************************************************************************", "", "    Quickdraw Types", "    ", "        Point               2D Quickdraw coordinate, range: -32K to +32K", "        Rect                Rectangular Quickdraw area", "        Style               Quickdraw font rendering styles", "        StyleParameter      Style when used as a parameter (historical 68K convention)", "        StyleField          Style when used as a field (historical 68K convention)", "        CharParameter       Char when used as a parameter (historical 68K convention)", "        ", "    Note:   The original Macintosh toolbox in 68K Pascal defined Style as a SET.  ", "            Both Style and CHAR occupy 8-bits in packed records or 16-bits when ", "            used as fields in non-packed records or as parameters. ", "        ", "*********************************************************************************/", "struct Point {", "  short               v;", "  short               h;", "};", "typedef struct Point                    Point;", "typedef Point *                         PointPtr;", "struct Rect {", "  short               top;", "  short               left;", "  short               bottom;", "  short               right;", "};", "typedef struct Rect                     Rect;", "typedef Rect *                          RectPtr;", "struct FixedPoint {", "  Fixed               x;", "  Fixed               y;", "};", "typedef struct FixedPoint               FixedPoint;", "struct FixedRect {", "  Fixed               left;", "  Fixed               top;", "  Fixed               right;", "  Fixed               bottom;", "};", "typedef struct FixedRect                FixedRect;", "", "typedef short                           CharParameter;", "enum {", "  normal                        = 0,", "  bold                          = 1,", "  italic                        = 2,", "  underline                     = 4,", "  outline                       = 8,", "  shadow                        = 0x10,", "  condense                      = 0x20,", "  extend                        = 0x40", "};", "", "typedef unsigned char                   Style;", "typedef short                           StyleParameter;", "typedef Style                           StyleField;", "", "", "/********************************************************************************", "", "    QuickTime TimeBase types (previously in Movies.h)", "    ", "        TimeValue           Count of units", "        TimeScale           Units per second", "        CompTimeValue       64-bit count of units (always a struct) ", "        TimeValue64         64-bit count of units (long long or struct) ", "        TimeBase            An opaque reference to a time base", "        TimeRecord          Package of TimeBase, duration, and scale", "        ", "*********************************************************************************/", "typedef SInt32                          TimeValue;", "typedef SInt32                          TimeScale;", "typedef wide                            CompTimeValue;", "typedef SInt64                          TimeValue64;", "typedef struct TimeBaseRecord*          TimeBase;", "struct TimeRecord {", "  CompTimeValue       value;                  /* units (duration or absolute) */", "  TimeScale           scale;                  /* units per second */", "  TimeBase            base;                   /* refernce to the time base */", "};", "typedef struct TimeRecord               TimeRecord;", "", "/********************************************************************************", "", "    THINK C base objects", "", "        HandleObject        Root class for handle based THINK C++ objects", "        PascalObject        Root class for pascal style objects in THINK C++ ", "", "*********************************************************************************/", "#if defined(__SC__) && !defined(__STDC__) && defined(__cplusplus)", "        class __machdl HandleObject {};", "        #if TARGET_CPU_68K", "            class __pasobj PascalObject {};", "        #endif", "#endif", "", "", "/********************************************************************************", "", "    MacOS versioning structures", "    ", "        VersRec                 Contents of a 'vers' resource", "        VersRecPtr              Pointer to a VersRecPtr", "        VersRecHndl             Resource Handle containing a VersRec", '        NumVersion              Packed BCD version representation (e.g. "4.2.1a3" is 0x04214003)', "        UniversalProcPtr        Pointer to classic 68K code or a RoutineDescriptor", "        ", "        ProcHandle              Pointer to a ProcPtr", "        UniversalProcHandle     Pointer to a UniversalProcPtr", "        ", "*********************************************************************************/", "#if TARGET_RT_BIG_ENDIAN", "struct NumVersion {", "                                              /* Numeric version part of 'vers' resource */", "  UInt8               majorRev;               /*1st part of version number in BCD*/", "  UInt8               minorAndBugRev;         /*2nd & 3rd part of version number share a byte*/", "  UInt8               stage;                  /*stage code: dev, alpha, beta, final*/", "  UInt8               nonRelRev;              /*revision level of non-released version*/", "};", "typedef struct NumVersion               NumVersion;", "#else", "struct NumVersion {", "                                              /* Numeric version part of 'vers' resource accessable in little endian format */", "  UInt8               nonRelRev;              /*revision level of non-released version*/", "  UInt8               stage;                  /*stage code: dev, alpha, beta, final*/", "  UInt8               minorAndBugRev;         /*2nd & 3rd part of version number share a byte*/", "  UInt8               majorRev;               /*1st part of version number in BCD*/", "};", "typedef struct NumVersion               NumVersion;", "#endif  /* TARGET_RT_BIG_ENDIAN */", "", "enum {", "                                        /* Version Release Stage Codes */", "  developStage                  = 0x20,", "  alphaStage                    = 0x40,", "  betaStage                     = 0x60,", "  finalStage                    = 0x80", "};", "", "union NumVersionVariant {", "                                              /* NumVersionVariant is a wrapper so NumVersion can be accessed as a 32-bit value */", "  NumVersion          parts;", "  UInt32              whole;", "};", "typedef union NumVersionVariant         NumVersionVariant;", "typedef NumVersionVariant *             NumVersionVariantPtr;", "typedef NumVersionVariantPtr *          NumVersionVariantHandle;", "struct VersRec {", "                                              /* 'vers' resource format */", "  NumVersion          numericVersion;         /*encoded version number*/", "  short               countryCode;            /*country code from intl utilities*/", "  Str255              shortVersion;           /*version number string - worst case*/", "  Str255              reserved;               /*longMessage string packed after shortVersion*/", "};", "typedef struct VersRec                  VersRec;", "typedef VersRec *                       VersRecPtr;", "typedef VersRecPtr *                    VersRecHndl;", "/*********************************************************************************", "", "    Old names for types", "        ", "*********************************************************************************/", "typedef UInt8                           Byte;", "typedef SInt8                           SignedByte;", "typedef wide *                          WidePtr;", "typedef UnsignedWide *                  UnsignedWidePtr;", "typedef Float80                         extended80;", "typedef Float96                         extended96;", "typedef SInt8                           VHSelect;", "/*********************************************************************************", "", "    Debugger functions", "    ", "*********************************************************************************/", "/*", " *  Debugger()", " *  ", " *  Availability:", " *    Mac OS X:         in version 10.0 and later in CoreServices.framework", " *    CarbonLib:        in CarbonLib 1.0 and later", " *    Non-Carbon CFM:   in InterfaceLib 7.1 and later", " */", "extern void ", "Debugger(void)                                                __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_8, __IPHONE_NA, __IPHONE_NA);", "", "", "/*", " *  DebugStr()", " *  ", " *  Availability:", " *    Mac OS X:         in version 10.0 and later in CoreServices.framework", " *    CarbonLib:        in CarbonLib 1.0 and later", " *    Non-Carbon CFM:   in InterfaceLib 7.1 and later", " */", "extern void ", "DebugStr(ConstStr255Param debuggerMsg)                        __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_8, __IPHONE_NA, __IPHONE_NA);", "", "", "/*", " *  debugstr()", " *  ", " *  Availability:", " *    Mac OS X:         not available", " *    CarbonLib:        not available", " *    Non-Carbon CFM:   in InterfaceLib 7.1 and later", " */", "", "", "#if TARGET_CPU_PPC", "/* Only for Mac OS native drivers */", "/*", " *  SysDebug()", " *  ", " *  Availability:", " *    Mac OS X:         not available", " *    CarbonLib:        not available", " *    Non-Carbon CFM:   in DriverServicesLib 1.0 and later", " */", "", "", "/*", " *  SysDebugStr()", " *  ", " *  Availability:", " *    Mac OS X:         not available", " *    CarbonLib:        not available", " *    Non-Carbon CFM:   in DriverServicesLib 1.0 and later", " */", "", "", "#endif  /* TARGET_CPU_PPC */", "", "/* SADE break points */", "/*", " *  SysBreak()", " *  ", " *  Availability:", " *    Mac OS X:         in version 10.0 and later in CoreServices.framework", " *    CarbonLib:        in CarbonLib 1.0 and later", " *    Non-Carbon CFM:   in InterfaceLib 7.1 and later", " */", "extern void ", "SysBreak(void)                                                __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_8, __IPHONE_NA, __IPHONE_NA);", "", "", "/*", " *  SysBreakStr()", " *  ", " *  Availability:", " *    Mac OS X:         in version 10.0 and later in CoreServices.framework", " *    CarbonLib:        in CarbonLib 1.0 and later", " *    Non-Carbon CFM:   in InterfaceLib 7.1 and later", " */", "extern void ", "SysBreakStr(ConstStr255Param debuggerMsg)                     __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_8, __IPHONE_NA, __IPHONE_NA);", "", "", "/*", " *  SysBreakFunc()", " *  ", " *  Availability:", " *    Mac OS X:         in version 10.0 and later in CoreServices.framework", " *    CarbonLib:        in CarbonLib 1.0 and later", " *    Non-Carbon CFM:   in InterfaceLib 7.1 and later", " */", "extern void ", "SysBreakFunc(ConstStr255Param debuggerMsg)                    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_8, __IPHONE_NA, __IPHONE_NA);", "", "", "/* old names for Debugger and DebugStr */", "#if OLDROUTINENAMES && TARGET_CPU_68K", "    #define Debugger68k()   Debugger()", "    #define DebugStr68k(s)  DebugStr(s)", "#endif", "", "", "#pragma pack(pop)", "", "#ifdef __cplusplus", "}", "#endif", "", "#endif /* __MACTYPES__ */", "" },
    ["NSSystemDirectories.h"] = { "/*", " * Copyright (c) 1999-2000, 2009 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "", "/*", " This API returns the various standard system directories where apps, resources, etc get installed.", " Because queries can return multiple directories, the API is in the form of an enumeration.", " The directories are returned in search path order; that is, the first place to look is returned first.", " This API may return directories that do not exist yet.", " If NSUserDomain is included in a query, then the results will contain \"~\" to refer to the user's directory.", " NEXT_ROOT is prepended as necessary to the returned values.", " Some calls might return no directories!", " The buffer that is passed in will be filled with a null-terminated string, possibly containing as many as PATH_MAX-1 characters.", "", " Typical usage:", " ", "    #include <limits.h>", "    #include <NSSystemDirectories.h>", "", "    char path[PATH_MAX];", "    NSSearchPathEnumerationState state = NSStartSearchPathEnumeration(dir, domainMask);", "    while (state = NSGetNextSearchPathEnumeration(state, path)) {", "        // Handle path", "    }", "", "", "*/", "", "#ifndef __NS_SYSTEM_DIRECTORIES_H__", "#define __NS_SYSTEM_DIRECTORIES_H__", "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "", "// Directories", "", "typedef enum {", "    NSApplicationDirectory = 1,             // supported applications (Applications)", "    NSDemoApplicationDirectory = 2,         // unsupported applications, demonstration versions (Applications/GrabBag)", "    NSDeveloperApplicationDirectory = 3,    // developer applications (Developer/Applications)", "    NSAdminApplicationDirectory = 4,        // system and network administration applications (Applications/Utilities)", "    NSLibraryDirectory = 5,                 // various user-visible documentation, support, and configuration files, resources (Library)", "    NSDeveloperDirectory = 6,               // developer resources (Developer)", "    NSUserDirectory = 7,                    // user home directories (Users)", "    NSDocumentationDirectory = 8,           // documentation (Library/Documentation)", "    NSDocumentDirectory = 9,                // documents (Documents)", "    NSCoreServiceDirectory = 10,            // location of core services (System/Library/CoreServices)", "    NSAutosavedInformationDirectory = 11,   // location of user's directory for use with autosaving (Library/Autosave Information)", "    NSDesktopDirectory = 12,                // location of user's Desktop (Desktop)", "    NSCachesDirectory = 13,                 // location of discardable cache files (Library/Caches)", "    NSApplicationSupportDirectory = 14,     // location of application support files (plug-ins, etc) (Library/Application Support)", "    NSDownloadsDirectory = 15,              // location of user's Downloads directory (Downloads)", "    NSInputMethodsDirectory = 16,           // input methods (Library/Input Methods)", "    NSMoviesDirectory = 17,                 // location of user's Movies directory (~/Movies)", "    NSMusicDirectory = 18,                  // location of user's Music directory (~/Music)", "    NSPicturesDirectory = 19,               // location of user's Pictures directory (~/Pictures)", "    NSPrinterDescriptionDirectory = 20,     // location of system's PPDs directory (Library/Printers/PPDs)", "    NSSharedPublicDirectory = 21,           // location of user's Public sharing directory (~/Public)", "    NSPreferencePanesDirectory = 22,        // location of the PreferencePanes directory for use with System Preferences (Library/PreferencePanes)", "    NSAllApplicationsDirectory = 100,       // all directories where applications can occur (Applications, Applications/Utilities, Developer/Applications, ...)", "    NSAllLibrariesDirectory = 101           // all directories where resources can occur (Library, Developer)", "} NSSearchPathDirectory;", "", "// Domains", "", "typedef enum {", "   NSUserDomainMask = 1,\t// user's home directory --- place to install user's personal items (~)", "   NSLocalDomainMask = 2,\t// local to the current machine --- place to install items available to everyone on this machine", "   NSNetworkDomainMask = 4, \t// publically available location in the local area network --- place to install items available on the network (/Network)", "   NSSystemDomainMask = 8,\t// provided by Apple", "   NSAllDomainsMask = 0x0ffff\t// all domains: all of the above and more, future items", "} NSSearchPathDomainMask;", "", "typedef unsigned int NSSearchPathEnumerationState;", "", "/* Enumeration", " Call NSStartSearchPathEnumeration() once, then call NSGetNextSearchPathEnumeration() one or more times with the returned state.", " The return value of NSGetNextSearchPathEnumeration() should be used as the state next time around.", " When NSGetNextSearchPathEnumeration() returns 0, you're done.", "*/", "", "extern NSSearchPathEnumerationState NSStartSearchPathEnumeration(NSSearchPathDirectory dir, NSSearchPathDomainMask domainMask);", "", "extern NSSearchPathEnumerationState NSGetNextSearchPathEnumeration(NSSearchPathEnumerationState state, char *path);", "", "#ifdef __cplusplus", "}", "#endif", "", "#endif /* __NS_SYSTEM_DIRECTORIES_H__ */" },
    ["TargetConditionals.h"] = { "/*", " * Copyright (c) 2000-2008 by Apple Inc.. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", " ", "/*", "     File:       TargetConditionals.h", " ", "     Contains:   Autoconfiguration of TARGET_ conditionals for Mac OS X and iPhone", "     ", "                 Note:  TargetConditionals.h in 3.4 Universal Interfaces works", "                        with all compilers.  This header only recognizes compilers", "                        known to run on Mac OS X.", "  ", "*/", "", "#ifndef __TARGETCONDITIONALS__", "#define __TARGETCONDITIONALS__", "/****************************************************************************************************", "", "    TARGET_CPU_*    ", "    These conditionals specify which microprocessor instruction set is being", "    generated.  At most one of these is true, the rest are false.", "", "        TARGET_CPU_PPC          - Compiler is generating PowerPC instructions for 32-bit mode", "        TARGET_CPU_PPC64        - Compiler is generating PowerPC instructions for 64-bit mode", "        TARGET_CPU_68K          - Compiler is generating 680x0 instructions", "        TARGET_CPU_X86          - Compiler is generating x86 instructions", "        TARGET_CPU_ARM          - Compiler is generating ARM instructions", "        TARGET_CPU_MIPS         - Compiler is generating MIPS instructions", "        TARGET_CPU_SPARC        - Compiler is generating Sparc instructions", "        TARGET_CPU_ALPHA        - Compiler is generating Dec Alpha instructions", "", "", "    TARGET_OS_* ", "    These conditionals specify in which Operating System the generated code will", "    run. The MAC/WIN32/UNIX conditionals are mutually exclusive.  The EMBEDDED/IPHONE ", "\tconditionals are variants of TARGET_OS_MAC. ", "", "        TARGET_OS_MAC           - Generate code will run under Mac OS", "        TARGET_OS_WIN32         - Generate code will run under 32-bit Windows", "        TARGET_OS_UNIX          - Generate code will run under some non Mac OS X unix ", "        TARGET_OS_EMBEDDED      - Generate code will run under an embedded OS variant", "                                  of TARGET_OS_MAC", "        TARGET_OS_IPHONE        - Generate code will run under iPhone OS which ", "                                  is a variant of TARGET_OS_MAC.", "", "    TARGET_RT_* ", "    These conditionals specify in which runtime the generated code will", "    run. This is needed when the OS and CPU support more than one runtime", "    (e.g. Mac OS X supports CFM and mach-o).", "", "        TARGET_RT_LITTLE_ENDIAN - Generated code uses little endian format for integers", "        TARGET_RT_BIG_ENDIAN    - Generated code uses big endian format for integers    ", "        TARGET_RT_64_BIT        - Generated code uses 64-bit pointers    ", "        TARGET_RT_MAC_CFM       - TARGET_OS_MAC is true and CFM68K or PowerPC CFM (TVectors) are used", "        TARGET_RT_MAC_MACHO     - TARGET_OS_MAC is true and Mach-O/dlyd runtime is used", "", "", "    TARGET_IPHONE_SIMULATOR     - Generate code for running under iPhone Simulator", "        ", "", "****************************************************************************************************/", "", "", "/*", " *    gcc based compiler used on Mac OS X", " */", "#if defined(__GNUC__) && ( defined(__APPLE_CPP__) || defined(__APPLE_CC__) || defined(__MACOS_CLASSIC__) )", "    #define TARGET_OS_MAC               1", "    #define TARGET_OS_WIN32             0", "    #define TARGET_OS_UNIX              0", "    #define TARGET_OS_EMBEDDED          0 ", "    #define TARGET_OS_IPHONE            0 ", "    #define TARGET_IPHONE_SIMULATOR     0 ", "    #if defined(__ppc__) ", "        #define TARGET_CPU_PPC          1", "        #define TARGET_CPU_PPC64        0", "        #define TARGET_CPU_68K          0", "        #define TARGET_CPU_X86          0", "        #define TARGET_CPU_X86_64       0", "        #define TARGET_CPU_ARM          0", "        #define TARGET_CPU_MIPS         0", "        #define TARGET_CPU_SPARC        0   ", "        #define TARGET_CPU_ALPHA        0", "        #define TARGET_RT_LITTLE_ENDIAN 0", "        #define TARGET_RT_BIG_ENDIAN    1", "        #define TARGET_RT_64_BIT        0", "        #ifdef __MACOS_CLASSIC__", "           #define TARGET_RT_MAC_CFM    1", "           #define TARGET_RT_MAC_MACHO  0", "        #else", "           #define TARGET_RT_MAC_CFM    0", "           #define TARGET_RT_MAC_MACHO  1", "       #endif", "    #elif defined(__ppc64__) ", "        #define TARGET_CPU_PPC          0", "        #define TARGET_CPU_PPC64        1", "        #define TARGET_CPU_68K          0", "        #define TARGET_CPU_X86          0", "        #define TARGET_CPU_X86_64       0", "        #define TARGET_CPU_ARM          0", "        #define TARGET_CPU_MIPS         0", "        #define TARGET_CPU_SPARC        0   ", "        #define TARGET_CPU_ALPHA        0", "        #define TARGET_RT_LITTLE_ENDIAN 0", "        #define TARGET_RT_BIG_ENDIAN    1", "        #define TARGET_RT_64_BIT        1", "        #define TARGET_RT_MAC_CFM       0", "        #define TARGET_RT_MAC_MACHO     1", "     #elif defined(__i386__) ", "        #define TARGET_CPU_PPC          0", "        #define TARGET_CPU_PPC64        0", "        #define TARGET_CPU_68K          0", "        #define TARGET_CPU_X86          1", "        #define TARGET_CPU_X86_64       0", "        #define TARGET_CPU_ARM          0", "        #define TARGET_CPU_MIPS         0", "        #define TARGET_CPU_SPARC        0", "        #define TARGET_CPU_ALPHA        0", "        #define TARGET_RT_MAC_CFM       0", "        #define TARGET_RT_MAC_MACHO     1", "        #define TARGET_RT_LITTLE_ENDIAN 1", "        #define TARGET_RT_BIG_ENDIAN    0", "        #define TARGET_RT_64_BIT        0", "     #elif defined(__x86_64__) ", "        #define TARGET_CPU_PPC          0", "        #define TARGET_CPU_PPC64        0", "        #define TARGET_CPU_68K          0", "        #define TARGET_CPU_X86          0", "        #define TARGET_CPU_X86_64       1", "        #define TARGET_CPU_ARM          0", "        #define TARGET_CPU_MIPS         0", "        #define TARGET_CPU_SPARC        0", "        #define TARGET_CPU_ALPHA        0", "        #define TARGET_RT_MAC_CFM       0", "        #define TARGET_RT_MAC_MACHO     1", "        #define TARGET_RT_LITTLE_ENDIAN 1", "        #define TARGET_RT_BIG_ENDIAN    0", "        #define TARGET_RT_64_BIT        1", "     #elif defined(__arm__) ", "        #define TARGET_CPU_PPC          0", "        #define TARGET_CPU_PPC64        0", "        #define TARGET_CPU_68K          0", "        #define TARGET_CPU_X86          0", "        #define TARGET_CPU_X86_64       0", "        #define TARGET_CPU_ARM          1", "        #define TARGET_CPU_MIPS         0", "        #define TARGET_CPU_SPARC        0", "        #define TARGET_CPU_ALPHA        0", "        #define TARGET_RT_MAC_CFM       0", "        #define TARGET_RT_MAC_MACHO     1", "        #define TARGET_RT_LITTLE_ENDIAN 1", "        #define TARGET_RT_BIG_ENDIAN    0", "        #define TARGET_RT_64_BIT        0", "    #else", "        #error unrecognized GNU C compiler", "    #endif", "", "", "/*", " *   CodeWarrior compiler from Metrowerks/Motorola", " */", "#elif defined(__MWERKS__)", "    #define TARGET_OS_MAC               1", "    #define TARGET_OS_WIN32             0", "    #define TARGET_OS_UNIX              0", "    #define TARGET_OS_EMBEDDED          0", "    #if defined(__POWERPC__)", "        #define TARGET_CPU_PPC          1", "        #define TARGET_CPU_PPC64        0", "        #define TARGET_CPU_68K          0", "        #define TARGET_CPU_X86          0", "        #define TARGET_CPU_MIPS         0", "        #define TARGET_CPU_SPARC        0", "        #define TARGET_CPU_ALPHA        0", "        #define TARGET_RT_LITTLE_ENDIAN 0", "        #define TARGET_RT_BIG_ENDIAN    1", "    #elif defined(__INTEL__)", "        #define TARGET_CPU_PPC          0", "        #define TARGET_CPU_PPC64        0", "        #define TARGET_CPU_68K          0", "        #define TARGET_CPU_X86          1", "        #define TARGET_CPU_MIPS         0", "        #define TARGET_CPU_SPARC        0", "        #define TARGET_CPU_ALPHA        0", "        #define TARGET_RT_LITTLE_ENDIAN 1", "        #define TARGET_RT_BIG_ENDIAN    0", "    #else", "        #error unknown Metrowerks CPU type", "    #endif", "    #define TARGET_RT_64_BIT            0", "    #ifdef __MACH__", "        #define TARGET_RT_MAC_CFM       0", "        #define TARGET_RT_MAC_MACHO     1", "    #else", "        #define TARGET_RT_MAC_CFM       1", "        #define TARGET_RT_MAC_MACHO     0", "    #endif", "", "/*", " *   unknown compiler", " */", "#else", "    #if defined(TARGET_CPU_PPC) && TARGET_CPU_PPC", "        #define TARGET_CPU_PPC64    0", "        #define TARGET_CPU_68K      0", "        #define TARGET_CPU_X86      0", "        #define TARGET_CPU_X86_64   0", "        #define TARGET_CPU_ARM      0", "        #define TARGET_CPU_MIPS     0", "        #define TARGET_CPU_SPARC    0", "        #define TARGET_CPU_ALPHA    0", "    #elif defined(TARGET_CPU_PPC64) && TARGET_CPU_PPC64", "        #define TARGET_CPU_PPC      0", "        #define TARGET_CPU_68K      0", "        #define TARGET_CPU_X86      0", "        #define TARGET_CPU_X86_64   0", "        #define TARGET_CPU_ARM      0", "        #define TARGET_CPU_MIPS     0", "        #define TARGET_CPU_SPARC    0", "        #define TARGET_CPU_ALPHA    0", "    #elif defined(TARGET_CPU_X86) && TARGET_CPU_X86", "        #define TARGET_CPU_PPC      0", "        #define TARGET_CPU_PPC64    0", "        #define TARGET_CPU_X86_64   0", "        #define TARGET_CPU_68K      0", "        #define TARGET_CPU_ARM      0", "        #define TARGET_CPU_MIPS     0", "        #define TARGET_CPU_SPARC    0", "        #define TARGET_CPU_ALPHA    0", "    #elif defined(TARGET_CPU_X86_64) && TARGET_CPU_X86_64", "        #define TARGET_CPU_PPC      0", "        #define TARGET_CPU_PPC64    0", "        #define TARGET_CPU_X86      0", "        #define TARGET_CPU_68K      0", "        #define TARGET_CPU_ARM      0", "        #define TARGET_CPU_MIPS     0", "        #define TARGET_CPU_SPARC    0", "        #define TARGET_CPU_ALPHA    0", "    #elif defined(TARGET_CPU_ARM) && TARGET_CPU_ARM", "        #define TARGET_CPU_PPC      0", "        #define TARGET_CPU_PPC64    0", "        #define TARGET_CPU_X86      0", "        #define TARGET_CPU_X86_64   0", "        #define TARGET_CPU_68K      0", "        #define TARGET_CPU_MIPS     0", "        #define TARGET_CPU_SPARC    0", "        #define TARGET_CPU_ALPHA    0", "    #else", "        /*", "            NOTE:   If your compiler errors out here then support for your compiler ", "            has not yet been added to TargetConditionals.h.  ", "            ", "            TargetConditionals.h is designed to be plug-and-play.  It auto detects", "            which compiler is being run and configures the TARGET_ conditionals", "            appropriately.  ", "            ", "            The short term work around is to set the TARGET_CPU_ and TARGET_OS_", "            on the command line to the compiler (e.g. -DTARGET_CPU_MIPS=1 -DTARGET_OS_UNIX=1)", "            ", "            The long term solution is to add a new case to this file which", "            auto detects your compiler and sets up the TARGET_ conditionals.", "            Then submit the changes to Apple Computer.", "        */", "        #error TargetConditionals.h: unknown compiler (see comment above)", "        #define TARGET_CPU_PPC    0", "        #define TARGET_CPU_68K    0", "        #define TARGET_CPU_X86    0", "        #define TARGET_CPU_ARM    0", "        #define TARGET_CPU_MIPS   0", "        #define TARGET_CPU_SPARC  0", "        #define TARGET_CPU_ALPHA  0", "    #endif", "    #define TARGET_OS_MAC                1", "    #define TARGET_OS_WIN32              0", "    #define TARGET_OS_UNIX               0", "    #define TARGET_OS_EMBEDDED           0", "    #if TARGET_CPU_PPC || TARGET_CPU_PPC64", "        #define TARGET_RT_BIG_ENDIAN     1", "        #define TARGET_RT_LITTLE_ENDIAN  0", "    #else", "        #define TARGET_RT_BIG_ENDIAN     0", "        #define TARGET_RT_LITTLE_ENDIAN  1", "    #endif", "    #if TARGET_CPU_PPC64 || TARGET_CPU_X86_64", "        #define TARGET_RT_64_BIT         1", "    #else", "        #define TARGET_RT_64_BIT         0", "    #endif", "    #ifdef __MACH__", "        #define TARGET_RT_MAC_MACHO      1", "        #define TARGET_RT_MAC_CFM        0", "    #else", "        #define TARGET_RT_MAC_MACHO      0", "        #define TARGET_RT_MAC_CFM        1", "    #endif", "    ", "#endif", "", "#endif  /* __TARGETCONDITIONALS__ */" },
    ["Xplugin.h"] = { "/* Xplugin.h -- windowing API for rootless X11 server", "   $Id: Xplugin.h,v 1.4 2003-03-03 23:30:53 jharper Exp $", "", "   Copyright (c) 2002 Apple Computer, Inc. All rights reserved.", "", "   Permission is hereby granted, free of charge, to any person", "   obtaining a copy of this software and associated documentation files", '   (the "Software"), to deal in the Software without restriction,', "   including without limitation the rights to use, copy, modify, merge,", "   publish, distribute, sublicense, and/or sell copies of the Software,", "   and to permit persons to whom the Software is furnished to do so,", "   subject to the following conditions:", "", "   The above copyright notice and this permission notice shall be", "   included in all copies or substantial portions of the Software.", "", '   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,', "   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF", "   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND", "   NONINFRINGEMENT.  IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT", "   HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,", "   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER", "   DEALINGS IN THE SOFTWARE.", "", "   Except as contained in this notice, the name(s) of the above", "   copyright holders shall not be used in advertising or otherwise to", "   promote the sale, use or other dealings in this Software without", "   prior written authorization.", "", "   Note that these interfaces are provided solely for the use of the", "   X11 server. Any other uses are unsupported and strongly discouraged. */", "", "#ifndef XPLUGIN_H", "#define XPLUGIN_H 1", "", "#define XPLUGIN_VERSION 6", "", "#include <Availability.h>", "#if defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && !defined(XPLUGIN_VERSION_MIN_REQUIRED)", "#if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1082", "#define XPLUGIN_VERSION_MIN_REQUIRED 6", "#elif __MAC_OS_X_VERSION_MIN_REQUIRED >= 1080", "#define XPLUGIN_VERSION_MIN_REQUIRED 5", "#elif __MAC_OS_X_VERSION_MIN_REQUIRED >= 1070", "#define XPLUGIN_VERSION_MIN_REQUIRED 4", "#elif __MAC_OS_X_VERSION_MIN_REQUIRED >= 1060", "#define XPLUGIN_VERSION_MIN_REQUIRED 3", "#elif __MAC_OS_X_VERSION_MIN_REQUIRED >= 1050", "#define XPLUGIN_VERSION_MIN_REQUIRED 1", "#else", "#define XPLUGIN_VERSION_MIN_REQUIRED 0", "#endif", "#endif /* __MAC_OS_X_VERSION_MIN_REQUIRED && !XPLUGIN_VERSION_MIN_REQUIRED */", "", "#if XPLUGIN_VERSION_MIN_REQUIRED >= 6 || !defined(XPLUGIN_VERSION_MIN_REQUIRED)", "#define XPLUGIN_VERSION_6", "#else", "#define XPLUGIN_VERSION_6 __attribute__((weak_import))", "#endif", "", "#if XPLUGIN_VERSION_MIN_REQUIRED >= 5 || !defined(XPLUGIN_VERSION_MIN_REQUIRED)", "#define XPLUGIN_VERSION_5", "#else", "#define XPLUGIN_VERSION_5 __attribute__((weak_import))", "#endif", "", "#if XPLUGIN_VERSION_MIN_REQUIRED >= 4 || !defined(XPLUGIN_VERSION_MIN_REQUIRED)", "#define XPLUGIN_VERSION_4", "#else", "#define XPLUGIN_VERSION_4 __attribute__((weak_import))", "#endif", "", "#if XPLUGIN_VERSION_MIN_REQUIRED >= 3 || !defined(XPLUGIN_VERSION_MIN_REQUIRED)", "#define XPLUGIN_VERSION_3", "#else", "#define XPLUGIN_VERSION_3 __attribute__((weak_import))", "#endif", "", "#if XPLUGIN_VERSION_MIN_REQUIRED >= 2 || !defined(XPLUGIN_VERSION_MIN_REQUIRED)", "#define XPLUGIN_VERSION_2", "#else", "#define XPLUGIN_VERSION_2 __attribute__((weak_import))", "#endif", "", "#if XPLUGIN_VERSION_MIN_REQUIRED >= 1 || !defined(XPLUGIN_VERSION_MIN_REQUIRED)", "#define XPLUGIN_VERSION_1", "#else", "#define XPLUGIN_VERSION_1 __attribute__((weak_import))", "#endif", "", "#include <stdint.h>", "", "/* By default we use the X server definition of BoxRec to define xp_box,", "   so that the compiler can silently convert between the two. But if", "   XP_NO_X_HEADERS is defined, we'll define it ourselves. */", "", "#ifndef XP_NO_X_HEADERS", '# include "miscstruct.h"', "  typedef BoxRec xp_box;", "#else", "  struct xp_box_struct {", "      short x1, y1, x2, y2;", "  };", "  typedef struct xp_box_struct xp_box;", "#endif", "", "typedef unsigned int xp_resource_id;", "typedef xp_resource_id xp_window_id;", "typedef xp_resource_id xp_surface_id;", "typedef unsigned int xp_native_window_id; /* XPLUGIN_VERSION_5 */", "typedef unsigned int xp_client_id;", "typedef unsigned int xp_request_type;", "typedef int xp_error;", "typedef int xp_bool;", "", "/* Error codes that the functions declared here may return. They all", "   numerically match their X equivalents, i.e. the XP_ can be dropped", "   if <X11/X.h> has been included. */", "", "enum xp_error_enum {", "    XP_Success\t\t\t= 0,", "    XP_BadRequest\t\t= 1,", "    XP_BadValue\t\t\t= 2,", "    XP_BadWindow\t\t= 3,", "    XP_BadMatch\t\t\t= 8,", "    XP_BadAccess\t\t= 10,", "    XP_BadImplementation\t= 17,", "};    ", "", "", "/* Event types generated by the plugin. */", "", "enum xp_event_type_enum {", "    /* The global display configuration changed somehow. */", "    XP_EVENT_DISPLAY_CHANGED\t= 1 << 0,", "", "    /* A window changed state. Argument is xp_window_state_event */", "    XP_EVENT_WINDOW_STATE_CHANGED = 1 << 1,", "", "    /* An async request encountered an error. Argument is of type", "       xp_async_error_event */", "    XP_EVENT_ASYNC_ERROR\t= 1 << 2,", "", "    /* Sent when a surface is destroyed as a side effect of destroying", "       a window. Arg is of type xp_surface_id. */", "    XP_EVENT_SURFACE_DESTROYED\t= 1 << 3,", "", "    /* Sent when any GL contexts pointing at the given surface need to", "       call xp_update_gl_context () to refresh their state (because the", "       window moved or was resized. Arg is of type xp_surface_id. */", "    XP_EVENT_SURFACE_CHANGED\t= 1 << 4,", "", "    /* Sent when a window has been moved. Arg is of type xp_window_id. */", "    XP_EVENT_WINDOW_MOVED\t= 1 << 5,", "    ", "    /* Spaces.app caused us to change spaces Arg is of type uint32_t. */", "    XP_EVENT_SPACE_CHANGED  = 1 << 6,", "};", "", "/* Function type used to receive events. */", "", "typedef void (xp_event_fun) (unsigned int type, const void *arg,", "\t\t\t     unsigned int arg_size, void *user_data);", "", "", "/* Operation types. Used when reporting errors asynchronously. */", "", "enum xp_request_type_enum {", "    XP_REQUEST_NIL = 0,", "    XP_REQUEST_DESTROY_WINDOW = 1,", "    XP_REQUEST_CONFIGURE_WINDOW = 2,", "    XP_REQUEST_FLUSH_WINDOW = 3,", "    XP_REQUEST_COPY_WINDOW = 4,", "    XP_REQUEST_UNLOCK_WINDOW = 5,", "    XP_REQUEST_DISABLE_UPDATE = 6,", "    XP_REQUEST_REENABLE_UPDATE = 7,", "    XP_REQUEST_HIDE_CURSOR = 8,", "    XP_REQUEST_SHOW_CURSOR = 9,", "    XP_REQUEST_FRAME_DRAW = 10,", "};", "", '/* Structure used to report an error asynchronously. Passed as the "arg"', "   of an XP_EVENT_ASYNC_ERROR event. */", "", "struct xp_async_error_event_struct {", "    xp_request_type request_type;", "    xp_resource_id id;", "    xp_error error;", "};", "", "typedef struct xp_async_error_event_struct xp_async_error_event;", "", "", "/* Possible window states. */", "", "enum xp_window_state_enum {", "    /* The window is not in the global list of possibly-visible windows. */", "    XP_WINDOW_STATE_OFFSCREEN\t= 1 << 0,", "", "    /* Parts of the window may be obscured by other windows. */", "    XP_WINDOW_STATE_OBSCURED\t= 1 << 1,", "};", "", "/* Structure passed as argument of an XP_EVENT_WINDOW_STATE_CHANGED event. */", "", "struct xp_window_state_event_struct {", "    xp_window_id id;", "    unsigned int state;", "};", "", "typedef struct xp_window_state_event_struct xp_window_state_event;", "", "", "/* Function type used to supply a colormap for indexed drawables. */", "", "typedef xp_error (xp_colormap_fun) (void *data, int first_color,", "\t\t\t\t    int n_colors, uint32_t *colors);", "", "", "/* Window attributes structure. Used when creating and configuring windows.", "   Also used when configuring surfaces attached to windows. Functions that", "   take one of these structures also take a bit mask defining which", "   fields are set to meaningful values. */", "", "enum xp_window_changes_enum {", "    XP_ORIGIN\t\t\t= 1 << 0,", "    XP_SIZE\t\t\t= 1 << 1,", "    XP_BOUNDS\t\t\t= XP_ORIGIN | XP_SIZE,", "    XP_SHAPE\t\t\t= 1 << 2,", "    XP_STACKING\t\t\t= 1 << 3,", "    XP_DEPTH\t\t\t= 1 << 4,", "    XP_COLORMAP\t\t\t= 1 << 5,", "    XP_WINDOW_LEVEL\t\t= 1 << 6,", "    XP_ATTACH_TRANSIENT\t\t= 1 << 7, /* XPLUGIN_VERSION_3 */", "};", "", "/* This stucture may grow with API changes, so don't rely on it remaining", " * a fixed size.", " */", "struct xp_window_changes_struct {", "    /* XP_ORIGIN */", "    int x, y;", "", "    /* XP_SIZE */", "    unsigned int width, height;", "    int bit_gravity;\t\t\t/* how to resize the backing store */", "", "    /* XP_SHAPE */", "    int shape_nrects;\t\t\t/* -1 = remove shape */", "    xp_box *shape_rects;", "    int shape_tx, shape_ty;\t\t/* translation for shape */", "", "    /* XP_STACKING */", "    int stack_mode;", "    xp_window_id sibling;\t\t/* may be zero; in ABOVE/BELOW modes", "\t\t\t\t\t   it may specify a relative window */", "    /* XP_DEPTH, window-only */", "    unsigned int depth;", "", "    /* XP_COLORMAP, window-only */", "    xp_colormap_fun *colormap;", "    void *colormap_data;", "", "    /* XP_WINDOW_LEVEL, window-only */", "    int window_level;", "", "    /* XP_ATTACH_TRANSIENT, window-only, XPLUGIN_VERSION_3 */", "    xp_window_id transient_for;", "};", "", "typedef struct xp_window_changes_struct xp_window_changes;", "", "/* Values for bit_gravity field */", "", "enum xp_bit_gravity_enum {", "    XP_GRAVITY_NONE\t\t= 0,\t/* no gravity, fill everything */", "    XP_GRAVITY_NORTH_WEST\t= 1,\t/* anchor to top-left corner */", "    XP_GRAVITY_NORTH_EAST\t= 2,\t/* anchor to top-right corner */", "    XP_GRAVITY_SOUTH_EAST\t= 3,\t/* anchor to bottom-right corner */", "    XP_GRAVITY_SOUTH_WEST\t= 4,\t/* anchor to bottom-left corner */", "};", "", "/* Values for stack_mode field */", "", "enum xp_window_stack_mode_enum {", "    XP_UNMAPPED\t\t\t= 0,\t/* remove the window */", "    XP_MAPPED_ABOVE\t\t= 1,\t/* display the window on top */", "    XP_MAPPED_BELOW\t\t= 2,\t/* display the window at bottom */", "};", "", "/* Data formats for depth field and composite functions */", "", "enum xp_depth_enum {", "    XP_DEPTH_NIL = 0,\t\t\t/* null source when compositing */", "    XP_DEPTH_ARGB8888,", "    XP_DEPTH_RGB555,", "    XP_DEPTH_A8,\t\t\t/* for masks when compositing */", "    XP_DEPTH_INDEX8,", "};", "", "/* Options that may be passed to the xp_init () function. */", "", "enum xp_init_options_enum {", "    /* Don't mark that this process can be in the foreground. ", "     * libGL *MUST* set this, xorg-server *MUST NOT* set this.", "     */", "    XP_IN_BACKGROUND\t\t= 1 << 0,", "", "    /* Deliver background pointer events to this process. */", "    XP_BACKGROUND_EVENTS\t= 1 << 1,", "", "    /* Enable support for the xp_dock_ APIs */", "    XP_DOCK_SUPPORT\t\t= 1 << 2,", "};", "", "", "\f", "/* Miscellaneous functions */", "", "/* Initialize the plugin library. Only the copy/fill/composite functions", "   may be called without having previously called xp_init () */", "", "extern xp_error xp_init (unsigned int options);", "", "/* Sets the current set of requested notifications to MASK. When any of", "   these arrive, CALLBACK will be invoked with CALLBACK-DATA. Note that", "   calling this function cancels any previously requested notifications", "   that aren't set in MASK. */", "", "extern xp_error xp_select_events (unsigned int mask,", "\t\t\t\t  xp_event_fun *callback,", "\t\t\t\t  void *callback_data);", "", "/* Waits for all initiated operations to complete. */", "", "extern xp_error xp_synchronize (void);", "", "/* Causes any display update initiated through the plugin libary to be", "   queued until update is reenabled. Note that calls to these functions", "   nest. */", "  ", "extern xp_error xp_disable_update (void);", "extern xp_error xp_reenable_update (void);", "", "", "\f", "/* Cursor functions. */", "", "/* Installs the specified cursor. ARGB-DATA should point to 32-bit", "   premultiplied big-endian ARGB data. The HOT-X,HOT-Y parameters", "   specify the offset to the cursor's hot spot from its top-left", "   corner. */", "", "extern xp_error xp_set_cursor (unsigned int width, unsigned int height,", "\t\t\t       unsigned int hot_x, unsigned int hot_y,", "\t\t\t       const uint32_t *argb_data,", "\t\t\t       unsigned int rowbytes);", "", "/* Hide and show the cursor if it's owned by the current process. Calls", "   to these functions nest. */", "", "extern xp_error xp_hide_cursor (void);", "extern xp_error xp_show_cursor (void);", "", "", "\f", "/* Window functions. */", "", "/* Create a new window as defined by MASK and VALUES. MASK must contain", "   XP_BOUNDS or an error is raised. The id of the newly created window", "   is stored in *RET-ID if this function returns XP_Success. */", "", "extern xp_error xp_create_window (unsigned int mask,", "\t\t\t\t  const xp_window_changes *values,", "\t\t\t\t  xp_window_id *ret_id);", "", "/* Destroys the window identified by ID. */", "", "extern xp_error xp_destroy_window (xp_window_id id);", "", "/* Reconfigures the given window according to MASK and VALUES. */", "", "extern xp_error xp_configure_window (xp_window_id id, unsigned int mask,", "\t\t\t\t     const xp_window_changes *values);", "", "", "/* Returns true if NATIVE-ID is a window created by the plugin library.", "   If so and RET-ID is non-null, stores the id of the window in *RET-ID. */", "", "extern xp_bool xp_lookup_native_window (xp_native_window_id native_id,", "\t\t\t\t\txp_window_id *ret_id);", "", "/* If ID names a window created by the plugin library, stores it's native", "   window id in *RET-NATIVE-ID. */", "", "extern xp_error xp_get_native_window (xp_window_id id,", "\t\t\t\t      xp_native_window_id *ret_native_id);", "", "", "/* Locks the rectangle IN-RECT (or, if null, the entire window) of the", "   given window's backing store. Any other non-null parameters are filled", "   in as follows:", "", "   DEPTH = format of returned data. Currently either XP_DEPTH_ARGB8888", "   or XP_DEPTH_RGB565 (possibly with 8 bit planar alpha). Data is", "   always stored in native byte order.", "", "   BITS[0] = pointer to top-left pixel of locked color data", "   BITS[1] = pointer to top-left of locked alpha data, or null if window", "   has no alpha. If the alpha data is meshed, then BITS[1] = BITS[0].", "", "   ROWBYTES[0,1] = size in bytes of each row of color,alpha data", "", "   OUT-RECT = rectangle specifying the current position and size of the", "   locked region relative to the window origin.", "", "   Note that an error is raised when trying to lock an already locked", "   window. While the window is locked, the only operations that may", "   be performed on it are to modify, access or flush its marked region. */", "", "extern xp_error xp_lock_window (xp_window_id id,", "\t\t\t\tconst xp_box *in_rect,", "\t\t\t\tunsigned int *depth,", "\t\t\t\tvoid *bits[2],", "\t\t\t\tunsigned int rowbytes[2],", "\t\t\t\txp_box *out_rect);", "", "/* Mark that the region specified by SHAPE-NRECTS, SHAPE-RECTS,", "   SHAPE-TX, and SHAPE-TY in the specified window has been updated, and", "   will need to subsequently be redisplayed. */", "", "extern xp_error xp_mark_window (xp_window_id id, int shape_nrects,", "\t\t\t\tconst xp_box *shape_rects,", "\t\t\t\tint shape_tx, int shape_ty);", "", "/* Unlocks the specified window. If FLUSH is true, then any marked", "   regions are immediately redisplayed. Note that it's an error to", "   unlock an already unlocked window. */", "", "extern xp_error xp_unlock_window (xp_window_id id, xp_bool flush);", "", "/* If anything is marked in the given window for redisplay, do it now. */", "", "extern xp_error xp_flush_window (xp_window_id id);", "", "/* Moves the contents of the region DX,DY pixels away from that specified", "   by DST_RECTS and DST_NRECTS in the window with SRC-ID to the", "   destination region in the window DST-ID. Note that currently source", "   and destination windows must be the same. */", "", "extern xp_error xp_copy_window (xp_window_id src_id, xp_window_id dst_id,", "\t\t\t\tint dst_nrects, const xp_box *dst_rects,", "\t\t\t\tint dx, int dy);", "", "/* Returns true if the given window has any regions marked for", "   redisplay. */", "", "extern xp_bool xp_is_window_marked (xp_window_id id);", "", "/* If successful returns a superset of the region marked for update in", "   the given window. Use xp_free_region () to release the returned data. */", "", "extern xp_error xp_get_marked_shape (xp_window_id id,", "\t\t\t\t     int *ret_nrects, xp_box **ret_rects);", "", "extern void xp_free_shape (int nrects, xp_box *rects);", "", "/* Searches for the first window below ABOVE-ID containing the point X,Y,", "   and returns it's window id in *RET-ID. If no window is found, *RET-ID", "   is set to zero. If ABOVE-ID is zero, finds the topmost window", "   containing the given point. */", "", "extern xp_error xp_find_window (int x, int y, xp_window_id above_id,", "\t\t\t\txp_window_id *ret_id);", "", "/* Returns the current origin and size of the window ID in *BOUNDS-RET if", "   successful. */", "extern xp_error xp_get_window_bounds (xp_window_id id, xp_box *bounds_ret);", "", "", "\f", "/* Window surface functions. */", "", "/* Create a new VRAM surface on the specified window. If successful,", "   returns the identifier of the new surface in *RET-SID. */", "", "extern xp_error xp_create_surface (xp_window_id id, xp_surface_id *ret_sid);", "", "/* Destroys the specified surface. */", "", "extern xp_error xp_destroy_surface (xp_surface_id sid);", "", "/* Reconfigures the specified surface as defined by MASK and VALUES.", "   Note that specifying XP_DEPTH is an error. */", "", "extern xp_error xp_configure_surface (xp_surface_id sid, unsigned int mask,", "\t\t\t\t      const xp_window_changes *values);", "", "/* If successful, places the client identifier of the current process", "   in *RET-CLIENT. */", "", "extern xp_error xp_get_client_id (xp_client_id *ret_client);", "", "/* Given a valid window,surface combination created by the current", "   process, attempts to allow the specified external client access", "   to that surface. If successful, returns two integers in RET-KEY", "   which the client can use to import the surface into their process. */", "", "extern xp_error xp_export_surface (xp_window_id wid, xp_surface_id sid,", "\t\t\t\t   xp_client_id client,", "\t\t\t\t   unsigned int ret_key[2]);", "", "/* Given a two integer key returned from xp_export_surface (), tries", "   to import the surface into the current process. If successful the", "   local surface identifier is stored in *SID-RET. */", "", "extern xp_error xp_import_surface (const unsigned int key[2],", "\t\t\t\t   xp_surface_id *sid_ret);", "", "/* If successful, stores the number of surfaces attached to the", "   specified window in *RET. */", "", "extern xp_error xp_get_window_surface_count (xp_window_id id,", "\t\t\t\t\t     unsigned int *ret);", "", "/* Attaches the CGLContextObj CGL-CTX to the specified surface. */", "", "extern xp_error xp_attach_gl_context (void *cgl_ctx, xp_surface_id sid);", "", "/* Updates the CGLContextObj CGL-CTX to reflect any recent changes to", "   the surface it's attached to. */", "", "extern xp_error xp_update_gl_context (void *cgl_ctx);", "", "", "\f", "/* Window frame functions. */", "", "/* Possible arguments to xp_frame_get_rect (). */", "", "enum xp_frame_rect_enum {", "    XP_FRAME_RECT_TITLEBAR\t\t= 1,", "    XP_FRAME_RECT_TRACKING\t\t= 2,", "    XP_FRAME_RECT_GROWBOX\t\t= 3,", "};", "typedef enum xp_frame_rect_enum xp_frame_rect;", "", "/* Classes of window frame.", " * All classes *MUST* have one of the DECOR bits set.  BEHAVIOR bits are", " * optional.  If no BEHAVIOR bit is set, default values are used based on ", " * DECOR (MANAGED for LARGE/SMALL, TRANSIENT for NONE).", " *", " * RESERVED bits are currently used for binary compatability with older", " * quartz-wm versions, but they may be allocated to other purposes in the", " * future.", " */", "", "enum xp_frame_class_enum {", "    XP_FRAME_CLASS_DECOR_LARGE\t\t= 1 << 0,", "    XP_FRAME_CLASS_RESERVED1\t\t= 1 << 1,", "    XP_FRAME_CLASS_RESERVED2\t\t= 1 << 2,", "    XP_FRAME_CLASS_RESERVED3\t\t= 1 << 3,", "    XP_FRAME_CLASS_DECOR_SMALL\t\t= 1 << 4,", "    XP_FRAME_CLASS_RESERVED5\t\t= 1 << 5,", "    XP_FRAME_CLASS_RESERVED6\t\t= 1 << 6,", "    XP_FRAME_CLASS_DECOR_NONE\t\t= 1 << 7,", "    XP_FRAME_CLASS_RESERVED8\t\t= 1 << 8,", "    XP_FRAME_CLASS_BEHAVIOR_MANAGED\t= 1 << 15,", "    XP_FRAME_CLASS_BEHAVIOR_TRANSIENT\t= 1 << 16,", "    XP_FRAME_CLASS_BEHAVIOR_STATIONARY\t= 1 << 17,", "};", "typedef enum xp_frame_class_enum xp_frame_class;", "", "/* Attributes of window frames. */", "", "enum xp_frame_attr_enum {", "    XP_FRAME_ATTR_ACTIVE\t\t= 0x0001,", "    XP_FRAME_ATTR_URGENT\t\t= 0x0002,", "    XP_FRAME_ATTR_TITLE\t\t\t= 0x0004,", "    XP_FRAME_ATTR_PRELIGHT\t\t= 0x0008,", "    XP_FRAME_ATTR_SHADED\t\t= 0x0010,", "    XP_FRAME_ATTR_CLOSE_BOX\t\t= 0x0100,", "    XP_FRAME_ATTR_COLLAPSE\t\t= 0x0200,", "    XP_FRAME_ATTR_ZOOM\t\t\t= 0x0400,", "    XP_FRAME_ATTR_CLOSE_BOX_CLICKED\t= 0x0800,", "    XP_FRAME_ATTR_COLLAPSE_BOX_CLICKED\t= 0x1000,", "    XP_FRAME_ATTR_ZOOM_BOX_CLICKED\t= 0x2000,", "    XP_FRAME_ATTR_GROW_BOX\t\t= 0x4000,", "};", "typedef enum xp_frame_attr_enum xp_frame_attr;", "", "#define XP_FRAME_ATTR_IS_SET(a,b)\t(((a) & (b)) == (b))", "#define XP_FRAME_ATTR_IS_CLICKED(a,m)\t((a) & ((m) << 3))", "#define XP_FRAME_ATTR_SET_CLICKED(a,m)\t((a) |= ((m) << 3))", "#define XP_FRAME_ATTR_UNSET_CLICKED(a,m) ((a) &= ~((m) << 3))", "", "#define XP_FRAME_ATTRS_ANY_BUTTON       (XP_FRAME_ATTR_CLOSE_BOX | \\", "                                         XP_FRAME_ATTR_COLLAPSE | \\", "                                         XP_FRAME_ATTR_ZOOM)", "", "#define XP_FRAME_ATTRS_ANY_CLICKED      (XP_FRAME_ATTR_CLOSE_BOX_CLICKED | \\", "                                         XP_FRAME_ATTR_COLLAPSE_BOX_CLICKED | \\", "                                         XP_FRAME_ATTR_ZOOM_BOX_CLICKED)", "", "#define XP_FRAME_ATTRS_POINTER\t\t(XP_FRAME_ATTR_PRELIGHT | \\", "\t\t\t\t\t XP_FRAME_ATTRS_ANY_BUTTON | \\", "\t\t\t\t\t XP_FRAME_ATTRS_ANY_CLICKED)", "", "extern xp_error xp_frame_get_rect (xp_frame_rect type, xp_frame_class class, const xp_box *outer,", "\t\t\t\t   const xp_box *inner, xp_box *ret);", "extern xp_error xp_frame_hit_test (xp_frame_class class, int x, int y,", "\t\t\t\t   const xp_box *outer,", "\t\t\t\t   const xp_box *inner, int *ret);", "extern xp_error xp_frame_draw (xp_window_id wid, xp_frame_class class, xp_frame_attr attr,", "\t\t\t       const xp_box *outer, const xp_box *inner,", "\t\t\t       unsigned int title_len,", "\t\t\t       const unsigned char *title_bytes);", "", "\f", "/* Memory manipulation functions. */", "", "enum xp_composite_op_enum {", "    XP_COMPOSITE_SRC = 0,", "    XP_COMPOSITE_OVER,", "};", "", "#define XP_COMPOSITE_FUNCTION(op, src_depth, mask_depth, dest_depth) \\", "    (((op) << 24) | ((src_depth) << 16) \\", "     | ((mask_depth) << 8) | ((dest_depth) << 0))", "", "#define XP_COMPOSITE_FUNCTION_OP(f)         (((f) >> 24) & 255)", "#define XP_COMPOSITE_FUNCTION_SRC_DEPTH(f)  (((f) >> 16) & 255)", "#define XP_COMPOSITE_FUNCTION_MASK_DEPTH(f) (((f) >>  8) & 255)", "#define XP_COMPOSITE_FUNCTION_DEST_DEPTH(f) (((f) >>  0) & 255)", "", "/* Composite WIDTH by HEIGHT pixels from source and mask to destination", "   using a specified function (if source and destination overlap,", "   undefined behavior results).", "", "   For SRC and DEST, the first element of the array is the color data. If", "   the second element is non-null it implies that there is alpha data", "   (which may be meshed or planar). Data without alpha is assumed to be", "   opaque.", "", "   Passing a null SRC-ROWBYTES pointer implies that the data SRC points", "   to is a single element.", "", "   Operations that are not supported will return XP_BadImplementation. */", "", "extern xp_error xp_composite_pixels (unsigned int width, unsigned int height,", "\t\t\t\t     unsigned int function,", "\t\t\t\t     void *src[2], unsigned int src_rowbytes[2],", "\t\t\t\t     void *mask, unsigned int mask_rowbytes,", "\t\t\t\t     void *dest[2], unsigned int dest_rowbytes[2]);", "", "/* Fill HEIGHT rows of data starting at DST. Each row will have WIDTH", "   bytes filled with the 32-bit pattern VALUE. Each row is DST-ROWBYTES", "   wide in total. */", "", "extern void xp_fill_bytes (unsigned int width,", "\t\t\t   unsigned int height, uint32_t value,", "\t\t\t   void *dst, unsigned int dst_rowbytes);", "", "/* Copy HEIGHT rows of bytes from SRC to DST. Each row will have WIDTH", "   bytes copied. SRC and DST may overlap, and the right thing will happen. */", "", "extern void xp_copy_bytes (unsigned int width, unsigned int height,", "\t\t\t   const void *src, unsigned int src_rowbytes,", "\t\t\t   void *dst, unsigned int dst_rowbytes);", "", "/* Suggestions for the minimum number of bytes or pixels for which it", "   makes sense to use some of the xp_ functions */", "", "extern unsigned int xp_fill_bytes_threshold, xp_copy_bytes_threshold,", "    xp_composite_area_threshold, xp_scroll_area_threshold;", "", "/* e is an EventRef.  This returns true if the passed event corresponds to a", " * hotkey that the user has enabled.", " */", "XPLUGIN_VERSION_1", "extern xp_bool xp_is_symbolic_hotkey_event(const void *e);", "", "/* Set the state for disabled hotkeys */", "XPLUGIN_VERSION_1", "extern xp_error xp_disable_hot_keys(xp_bool state);", "", "/* Set the ProcessSerialNumber for the application that is going to be our dock", " * proxy.  This is probably quartz-wm.", " * ", " * The hi/lo values passed are the corresponding hi and low bits of", " * the ProcessSerialNumber, but we pass it as hi/lo values to avoid", " * namespace polution in the server.", " *", " */", "XPLUGIN_VERSION_2", "extern xp_error xp_set_dock_proxy(uint32_t hi, uint32_t lo);", "", "\f", "/* Support for dock integration, primarily used by quartz-wm */", "", "#define XP_NULL_NATIVE_WINDOW_ID ((xp_native_window_id)0)", "", "/* Dock location */", "enum xp_dock_orientation_enum {", "    XP_DOCK_ORIENTATION_BOTTOM = 2,", "    XP_DOCK_ORIENTATION_LEFT   = 3,", "    XP_DOCK_ORIENTATION_RIGHT  = 4,", "};", "typedef enum xp_dock_orientation_enum xp_dock_orientation;", "", "XPLUGIN_VERSION_5", "extern xp_dock_orientation xp_dock_get_orientation(void);", "", "XPLUGIN_VERSION_5", "extern xp_box xp_dock_get_rect(void);", "", "/* Window Visibility / Activation */", "XPLUGIN_VERSION_5", "extern xp_error xp_dock_is_window_visible(xp_native_window_id osxwindow_id, xp_bool *is_visible);", "", "XPLUGIN_VERSION_5", "extern xp_error xp_dock_activate_window(xp_native_window_id osxwindow_id);", "", "/* Minimize / Restore */", "XPLUGIN_VERSION_5", "extern xp_error xp_dock_minimize_item_with_title_async(xp_native_window_id osxwindow_id, const char *title);", "", "XPLUGIN_VERSION_5", "extern xp_error xp_dock_restore_item_async(xp_native_window_id osxwindow_id);", "", "XPLUGIN_VERSION_5", "extern xp_error xp_dock_remove_item(xp_native_window_id osxwindow_id);", "", "/* Window dragging */", "XPLUGIN_VERSION_5", "extern xp_error xp_dock_drag_begin(xp_native_window_id osxwindow_id);", "", "XPLUGIN_VERSION_5", "extern xp_error xp_dock_drag_end(xp_native_window_id osxwindow_id);", "", "/* Event handling */", "typedef enum {", "    XP_DOCK_EVENT_RESTORE_ALL_WINDOWS = 1,", "    XP_DOCK_EVENT_RESTORE_WINDOWS     = 2,", "    XP_DOCK_EVENT_SELECT_WINDOWS      = 3,", "    XP_DOCK_EVENT_RESTORE_DONE        = 4,", "    XP_DOCK_EVENT_MINIMIZE_DONE       = 5,", "} xp_dock_event_type;", "", "typedef struct {", "    xp_dock_event_type type;", "", "    /* XP_NULL_NATIVE_WINDOW_ID terminated list of windows affected by this event */", "    xp_native_window_id *windows;", "", "    /* YES if the event was successful (for XP_DOCK_EVENT_RESTORE_DONE and XP_DOCK_EVENT_MINIMIZE_DONE) */", "    xp_bool success;", "} xp_dock_event;", "", "typedef void (*xp_dock_event_handler)(xp_dock_event *event);", "", "XPLUGIN_VERSION_5", "extern void xp_dock_event_set_handler(xp_dock_event_handler new_handler);", "", "/* Cause all X11 windows to be ordered above other application windows", " * Useful for responding to Dock/cmd-tab", " */", "XPLUGIN_VERSION_6", "extern xp_error xp_window_bring_all_to_front(void);", "", "/* Return XPLUGIN_VERSION for runtime checks of Xplugin's version", " * Better late than never...", " */", "XPLUGIN_VERSION_6", "extern uint32_t xp_api_version(void);", "", "#endif /* XPLUGIN_H */" },
    ["_locale.h"] = { "/*", " * Copyright (c) 1991, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)locale.h\t8.1 (Berkeley) 6/2/93", " * $FreeBSD: /repoman/r/ncvs/src/include/locale.h,v 1.7 2002/10/09 09:19:27 tjr Exp $", " */", "", "#ifndef __LOCALE_H_", "#define __LOCALE_H_", "", "#include <sys/cdefs.h>", "#include <_types.h>", "", "struct lconv {", "\tchar\t*decimal_point;", "\tchar\t*thousands_sep;", "\tchar\t*grouping;", "\tchar\t*int_curr_symbol;", "\tchar\t*currency_symbol;", "\tchar\t*mon_decimal_point;", "\tchar\t*mon_thousands_sep;", "\tchar\t*mon_grouping;", "\tchar\t*positive_sign;", "\tchar\t*negative_sign;", "\tchar\tint_frac_digits;", "\tchar\tfrac_digits;", "\tchar\tp_cs_precedes;", "\tchar\tp_sep_by_space;", "\tchar\tn_cs_precedes;", "\tchar\tn_sep_by_space;", "\tchar\tp_sign_posn;", "\tchar\tn_sign_posn;", "\tchar\tint_p_cs_precedes;", "\tchar\tint_n_cs_precedes;", "\tchar\tint_p_sep_by_space;", "\tchar\tint_n_sep_by_space;", "\tchar\tint_p_sign_posn;", "\tchar\tint_n_sign_posn;", "};", "", "#include <sys/_types/_null.h>", "", "__BEGIN_DECLS", "struct lconv\t*localeconv(void);", "__END_DECLS", "", "#endif /* __LOCALE_H_ */" },
    ["_structs.h"] = { "/*", " * Copyright (c) 2004 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "", "#include <sys/_structs.h>", "" },
    ["_types.h"] = { "/*", " * Copyright (c) 2004, 2008, 2009 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "", "#ifndef __TYPES_H_", "#define __TYPES_H_", "", "#include <sys/_types.h>", "", "#if __GNUC__ > 2 || __GNUC__ == 2 && __GNUC_MINOR__ >= 7", "#define __strfmonlike(fmtarg, firstvararg) \\", "\t\t__attribute__((__format__ (__strfmon__, fmtarg, firstvararg)))", "#define __strftimelike(fmtarg) \\", "\t\t__attribute__((__format__ (__strftime__, fmtarg, 0)))", "#else", "#define __strfmonlike(fmtarg, firstvararg)", "#define __strftimelike(fmtarg)", "#endif", "", "typedef\tint\t\t__darwin_nl_item;", "typedef\tint\t\t__darwin_wctrans_t;", "#ifdef __LP64__", "typedef\t__uint32_t\t__darwin_wctype_t;", "#else /* !__LP64__ */", "typedef\tunsigned long\t__darwin_wctype_t;", "#endif /* __LP64__ */", "", "#ifdef __WCHAR_MAX__", "#define __DARWIN_WCHAR_MAX\t__WCHAR_MAX__", "#else /* ! __WCHAR_MAX__ */", "#define __DARWIN_WCHAR_MAX\t0x7fffffff", "#endif /* __WCHAR_MAX__ */", "", "#if __DARWIN_WCHAR_MAX > 0xffffU", "#define __DARWIN_WCHAR_MIN\t(-0x7fffffff - 1)", "#else", "#define __DARWIN_WCHAR_MIN\t0", "#endif", "#define\t__DARWIN_WEOF \t((__darwin_wint_t)-1)", "", "#ifndef _FORTIFY_SOURCE", "#  if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && ((__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__-0) < 1050)", "#    define _FORTIFY_SOURCE 0", "#  else", "#    define _FORTIFY_SOURCE 2\t/* on by default */", "#  endif", "#endif", "", "#endif /* __TYPES_H_ */" },
    ["_wctype.h"] = { "/*-", " * Copyright (c)1999 Citrus Project,", " * All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " *", " * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " */", "", "/*", " * Common header for wctype.h and wchar.h", " *", " * Contains everything required by wctype.h except:", " *", " *\t#include <_types/_wctrans_t.h>", " *\tint iswblank(wint_t);", " *\twint_t towctrans(wint_t, wctrans_t);", " *\twctrans_t wctrans(const char *);", " */", "", "#ifndef __WCTYPE_H_", "#define __WCTYPE_H_", "", "#include <sys/cdefs.h>", "#include <_types.h>", "", "#include <sys/_types/_wint_t.h>", "#include <sys/_types/_wint_t.h>", "#include <_types/_wctype_t.h>", "", "#ifndef WEOF", "#define WEOF\t\t\t__DARWIN_WEOF", "#endif", "", "#ifndef __DARWIN_WCTYPE_TOP_inline", "#define __DARWIN_WCTYPE_TOP_inline __header_inline", "#endif", "", "#include <ctype.h>", "", "/*", " * Use inline functions if we are allowed to and the compiler supports them.", " */", "#if !defined(_DONT_USE_CTYPE_INLINE_) && \\", "    (defined(_USE_CTYPE_INLINE_) || defined(__GNUC__) || defined(__cplusplus))", "", "__DARWIN_WCTYPE_TOP_inline int", "iswalnum(wint_t _wc)", "{", "\treturn (__istype(_wc, _CTYPE_A|_CTYPE_D));", "}", "", "__DARWIN_WCTYPE_TOP_inline int", "iswalpha(wint_t _wc)", "{", "\treturn (__istype(_wc, _CTYPE_A));", "}", "", "__DARWIN_WCTYPE_TOP_inline int", "iswcntrl(wint_t _wc)", "{", "\treturn (__istype(_wc, _CTYPE_C));", "}", "", "__DARWIN_WCTYPE_TOP_inline int", "iswctype(wint_t _wc, wctype_t _charclass)", "{", "\treturn (__istype(_wc, _charclass));", "}", "", "__DARWIN_WCTYPE_TOP_inline int", "iswdigit(wint_t _wc)", "{", "\treturn (__isctype(_wc, _CTYPE_D));", "}", "", "__DARWIN_WCTYPE_TOP_inline int", "iswgraph(wint_t _wc)", "{", "\treturn (__istype(_wc, _CTYPE_G));", "}", "", "__DARWIN_WCTYPE_TOP_inline int", "iswlower(wint_t _wc)", "{", "\treturn (__istype(_wc, _CTYPE_L));", "}", "", "__DARWIN_WCTYPE_TOP_inline int", "iswprint(wint_t _wc)", "{", "\treturn (__istype(_wc, _CTYPE_R));", "}", "", "__DARWIN_WCTYPE_TOP_inline int", "iswpunct(wint_t _wc)", "{", "\treturn (__istype(_wc, _CTYPE_P));", "}", "", "__DARWIN_WCTYPE_TOP_inline int", "iswspace(wint_t _wc)", "{", "\treturn (__istype(_wc, _CTYPE_S));", "}", "", "__DARWIN_WCTYPE_TOP_inline int", "iswupper(wint_t _wc)", "{", "\treturn (__istype(_wc, _CTYPE_U));", "}", "", "__DARWIN_WCTYPE_TOP_inline int", "iswxdigit(wint_t _wc)", "{", "\treturn (__isctype(_wc, _CTYPE_X));", "}", "", "__DARWIN_WCTYPE_TOP_inline wint_t", "towlower(wint_t _wc)", "{", "        return (__tolower(_wc));", "}", "", "__DARWIN_WCTYPE_TOP_inline wint_t", "towupper(wint_t _wc)", "{", "        return (__toupper(_wc));", "}", "", "#else /* not using inlines */", "", "__BEGIN_DECLS", "int\tiswalnum(wint_t);", "int\tiswalpha(wint_t);", "int\tiswcntrl(wint_t);", "int\tiswctype(wint_t, wctype_t);", "int\tiswdigit(wint_t);", "int\tiswgraph(wint_t);", "int\tiswlower(wint_t);", "int\tiswprint(wint_t);", "int\tiswpunct(wint_t);", "int\tiswspace(wint_t);", "int\tiswupper(wint_t);", "int\tiswxdigit(wint_t);", "wint_t\ttowlower(wint_t);", "wint_t\ttowupper(wint_t);", "__END_DECLS", "", "#endif /* using inlines */", "", "__BEGIN_DECLS", "wctype_t", "\twctype(const char *);", "__END_DECLS", "", "#ifdef _USE_EXTENDED_LOCALES_", "#include <xlocale/__wctype.h>", "#endif /* _USE_EXTENDED_LOCALES_ */", "", "#endif /* __WCTYPE_H_ */" },
    ["_xlocale.h"] = { "/*", " * Copyright (c) 2005 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "", "#ifndef __XLOCALE_H_", "#define __XLOCALE_H_", "", "#include <sys/cdefs.h>", "", "__BEGIN_DECLS", "int\t\t___mb_cur_max(void);", "int\t\t___mb_cur_max_l(locale_t);", "__END_DECLS", "", "#endif /* __XLOCALE_H_ */" },
    ["aio.h"] = { "/*", " * Copyright (c) 2003 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/* ", " *\tFile:\taio.h", " *\tAuthor:\tUmesh Vaishampayan [umeshv@apple.com]", " *\t\t\t05-Feb-2003\tumeshv\tCreated.", " *", " *\tHeader file for POSIX Asynchronous IO APIs", " *", " */ ", "", "#ifndef _AIO_H_", "#define\t_AIO_H_", "", "#include <sys/aio.h>", "", "#endif /* _AIO_H_ */" },
    ["aliasdb.h"] = { "/*", " * Copyright (c) 1999-2009 Apple Inc.  All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/*", " * Mail alias lookup routines", " * Copyright (c) 1989 by NeXT, Inc.", " */", "", "#ifndef _ALIAS_H_", "#define _ALIAS_H_", "", "struct aliasent {", "\tchar\t\t*alias_name;", "\tunsigned\talias_members_len;", "\tchar\t\t**alias_members;", "\tint\t\t\talias_local;", "};", "", "#include <sys/cdefs.h>", "", "__BEGIN_DECLS", "void alias_setent __P((void));", "struct aliasent *alias_getent __P((void));", "void alias_endent __P((void));", "struct aliasent *alias_getbyname __P((const char *));", "__END_DECLS", "", "#endif /* !_ALIAS_H_ */" },
    ["alloca.h"] = { "/*", " * Copyright (c) 2003 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "", "#ifndef _ALLOCA_H_", "#define _ALLOCA_H_", "", "#include <sys/cdefs.h>", "#include <_types.h>", "#include <sys/_types/_size_t.h>", "", "__BEGIN_DECLS", "void\t*alloca(size_t);\t\t/* built-in for gcc */", "__END_DECLS", "", "#if defined(__GNUC__) && __GNUC__ >= 3", "/* built-in for gcc 3 */", "#undef\talloca", "#undef\t__alloca", "#define\talloca(size)\t__alloca(size)", "#define\t__alloca(size)\t__builtin_alloca(size)", "#endif", "", "#endif /* _ALLOCA_H_ */" },
    ["ar.h"] = { "/*-", " * Copyright (c) 1991, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " * (c) UNIX System Laboratories, Inc.", " * All or some portions of this file are derived from material licensed", " * to the University of California by American Telephone and Telegraph", " * Co. or Unix System Laboratories, Inc. and are reproduced herein with", " * the permission of UNIX System Laboratories, Inc.", " *", " * This code is derived from software contributed to Berkeley by", " * Hugh Smith at The University of Guelph.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)ar.h\t8.2 (Berkeley) 1/21/94", " */", "", "#ifndef _AR_H_", "#define\t_AR_H_", "", "/* Pre-4BSD archives had these magic numbers in them. */", "#define\tOARMAG1\t0177555", "#define\tOARMAG2\t0177545", "", '#define\tARMAG\t\t"!<arch>\\n"\t/* ar "magic number" */', "#define\tSARMAG\t\t8\t\t/* strlen(ARMAG); */", "", '#define\tAR_EFMT1\t"#1/"\t\t/* extended format #1 */', "", "struct ar_hdr {", "\tchar ar_name[16];\t\t/* name */", "\tchar ar_date[12];\t\t/* modification time */", "\tchar ar_uid[6];\t\t\t/* user id */", "\tchar ar_gid[6];\t\t\t/* group id */", "\tchar ar_mode[8];\t\t/* octal file permissions */", "\tchar ar_size[10];\t\t/* size in bytes */", '#define\tARFMAG\t"`\\n"', "\tchar ar_fmag[2];\t\t/* consistency check */", "};", "", "#endif /* !_AR_H_ */" },
    ["asl.h"] = { "/*", " * Copyright (c) 2004-2012 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " *", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "", "#ifndef __ASL_H__", "#define __ASL_H__", "", "#include <stdint.h>", "#include <stdarg.h>", "#include <sys/cdefs.h>", "#include <Availability.h>", "", "typedef struct __aslclient *aslclient;", "typedef struct __aslmsg *aslmsg;", "typedef struct __aslresponse *aslresponse;", "", "/*! @header", " * These routines provide an interface to the Apple System Log facility.", " * The API allows client applications to create flexible, structured messages", " * and send them to the syslogd server.  Messages received by the server are", " * saved in a data store, subject to input filtering constraints.", " * This API also permits clients to create queries and search the message", " * data store for matching messages.", " */", "", "/*", " * NOTE FOR HeaderDoc", " *", " * These are added to allow headerdoc2html to process ", " * the prototypes of asl_log and asl_vlog correctly.", ' * The "-p" option to headerdoc2html is required.', " */", "#ifndef __printflike", "/*! @parseOnly */", "#define __printflike(a,b)", "#endif", "", "/*! @defineblock Log Message Priority Levels", " * Log levels of the message.", " */", "#define ASL_LEVEL_EMERG   0", "#define ASL_LEVEL_ALERT   1", "#define ASL_LEVEL_CRIT    2", "#define ASL_LEVEL_ERR     3", "#define ASL_LEVEL_WARNING 4", "#define ASL_LEVEL_NOTICE  5", "#define ASL_LEVEL_INFO    6", "#define ASL_LEVEL_DEBUG   7", "/*! @/defineblock */", "", "/*! @defineblock Log Message Priority Level Strings", " * Strings corresponding to log levels.", " */", '#define ASL_STRING_EMERG\t"Emergency"', '#define ASL_STRING_ALERT\t"Alert"', '#define ASL_STRING_CRIT\t\t"Critical"', '#define ASL_STRING_ERR\t\t"Error"', '#define ASL_STRING_WARNING  "Warning"', '#define ASL_STRING_NOTICE   "Notice"', '#define ASL_STRING_INFO\t\t"Info"', '#define ASL_STRING_DEBUG\t"Debug"', "/*! @/defineblock */", "", "/*! @defineblock Attribute Matching", " * Attribute value comparison operations.", " */", "#define ASL_QUERY_OP_CASEFOLD      0x0010", "#define ASL_QUERY_OP_PREFIX\t\t   0x0020", "#define ASL_QUERY_OP_SUFFIX\t\t   0x0040", "#define ASL_QUERY_OP_SUBSTRING     0x0060", "#define ASL_QUERY_OP_NUMERIC       0x0080", "#define ASL_QUERY_OP_REGEX         0x0100", "", "#define ASL_QUERY_OP_EQUAL         0x0001", "#define ASL_QUERY_OP_GREATER       0x0002", "#define ASL_QUERY_OP_GREATER_EQUAL 0x0003", "#define ASL_QUERY_OP_LESS          0x0004", "#define ASL_QUERY_OP_LESS_EQUAL    0x0005", "#define ASL_QUERY_OP_NOT_EQUAL     0x0006", "#define ASL_QUERY_OP_TRUE          0x0007", "/*! @/defineblock */", "", "/*! @defineblock Message Attributes", " *", " * These attributes are known by ASL, and are generally", " * associated with all log messages.", " * Additional attributes may be added as desired.", " */", '#define ASL_KEY_TIME        "Time"          /* Timestamp.  Set automatically */', '#define ASL_KEY_TIME_NSEC   "TimeNanoSec"   /* Nanosecond time. */', "#define ASL_KEY_HOST        \"Host\"          /* Sender's address (set by the server). */", "#define ASL_KEY_SENDER      \"Sender\"        /* Sender's identification string.  Default is process name. */", "#define ASL_KEY_FACILITY    \"Facility\"      /* Sender's facility.  Default is \"user\". */", '#define ASL_KEY_PID         "PID"           /* Sending process ID encoded as a string.  Set automatically. */', '#define ASL_KEY_UID         "UID"           /* UID that sent the log message (set by the server). */', '#define ASL_KEY_GID         "GID"           /* GID that sent the log message (set by the server). */', '#define ASL_KEY_LEVEL       "Level"         /* Log level number encoded as a string.  See levels above. */', '#define ASL_KEY_MSG         "Message"       /* Message text. */', '#define ASL_KEY_READ_UID    "ReadUID"       /* User read access (-1 is any user). */', '#define ASL_KEY_READ_GID    "ReadGID"       /* Group read access (-1 is any group). */', '#define ASL_KEY_EXPIRE_TIME "ASLExpireTime" /* Expiration time for messages with long TTL. */', '#define ASL_KEY_MSG_ID      "ASLMessageID"  /* 64-bit message ID number (set by the server). */', '#define ASL_KEY_SESSION     "Session"       /* Session (set by the launchd). */', '#define ASL_KEY_REF_PID     "RefPID"        /* Reference PID for messages proxied by launchd */', '#define ASL_KEY_REF_PROC    "RefProc"       /* Reference process for messages proxied by launchd */', '#define ASL_KEY_AUX_TITLE   "ASLAuxTitle"   /* Auxiliary title string */', '#define ASL_KEY_AUX_UTI     "ASLAuxUTI"     /* Auxiliary Uniform Type ID */', '#define ASL_KEY_AUX_URL     "ASLAuxURL"     /* Auxiliary Uniform Resource Locator */', '#define ASL_KEY_AUX_DATA    "ASLAuxData"    /* Auxiliary in-line data */', '#define ASL_KEY_OPTION      "ASLOption"     /* Internal */', '#define ASL_KEY_SENDER_INSTANCE\t"SenderInstance"\t/* Sender instance UUID. */', "/*! @/defineblock */", "", "/*! @defineblock aslmsg Types", " * Message type argument passed to asl_new().", " */", "#define ASL_TYPE_MSG    0", "#define ASL_TYPE_QUERY  1", "/*! @/defineblock */", "", "/*! @defineblock Filter Masks", " * Used in client-side filtering, which determines which", " * messages are sent by the client to the syslogd server.", " */", "#define ASL_FILTER_MASK_EMERG   0x01", "#define ASL_FILTER_MASK_ALERT   0x02", "#define ASL_FILTER_MASK_CRIT    0x04", "#define ASL_FILTER_MASK_ERR     0x08", "#define ASL_FILTER_MASK_WARNING 0x10", "#define ASL_FILTER_MASK_NOTICE  0x20", "#define ASL_FILTER_MASK_INFO    0x40", "#define ASL_FILTER_MASK_DEBUG   0x80", "/*! @/defineblock */", "", "/*! @defineblock Filter Mask Macros", " * Macros to create bitmasks for filter settings - see asl_set_filter().", " */", "#define\tASL_FILTER_MASK(level) (1 << (level))", "#define\tASL_FILTER_MASK_UPTO(level) ((1 << ((level) + 1)) - 1)", "/*! @/defineblock */", "", "/*! @defineblock Client Creation Options", " * Options for asl_open().", " */", "#define ASL_OPT_STDERR\t\t0x00000001", "#define ASL_OPT_NO_DELAY    0x00000002", "#define ASL_OPT_NO_REMOTE   0x00000004", "/*! @/defineblock */", "", "/*! @defineblock File Descriptor Types", " * Instructions on how to treat the file descriptor in asl_log_descriptor().", " */", "#define ASL_LOG_DESCRIPTOR_READ  1", "#define ASL_LOG_DESCRIPTOR_WRITE 2", "", "/*! @defineblock Output file message and time formats.", " * These select internally defined formats for printed log messages for", " * asl_add_output_file().  Custom message and time formats may also be", " * used.  These pre-defined formats and custom formats are described in detail", " * in the syslog(1) manual page.", " */", '#define ASL_MSG_FMT_RAW "raw"', '#define ASL_MSG_FMT_STD "std"', '#define ASL_MSG_FMT_BSD "bsd"', '#define ASL_MSG_FMT_XML "xml"', '#define ASL_MSG_FMT_MSG "msg"', "", '#define ASL_TIME_FMT_SEC "sec"', '#define ASL_TIME_FMT_UTC "utc"', '#define ASL_TIME_FMT_LCL "lcl"', "", "/*! @defineblock Text Encoding Types", " * These are used by the library when formatting messages to be written ", " * to file descriptors associated with an ASL client handle with ", " * asl_add_output_file().  The syslog(1) manual page describes text encoding", ' * in detail.  ASL_ENCODE_ASL corresponds to the "vis" encoding option', " * described in the syslog(1) manual.  ASL_ENCODE_XML should be used in", " * combination with ASL_MSG_FMT_XML to ensure that special XML characters", " * are correctly encoded.", " */", "#define ASL_ENCODE_NONE 0", "#define ASL_ENCODE_SAFE 1", "#define ASL_ENCODE_ASL  2", "#define ASL_ENCODE_XML  3", "", "/*!", " * ASL_PREFILTER_LOG is a macro similar to asl_log(), but it first checks", " * if the message will simply be ignored due to local filter settings.", " * This prevents the variable argument list from being evaluated.", " * Note that the message may still be processed if it will be written", " * to a file or stderr.", " *", " * @param asl", " *    (input) An ASL client handle", " * @param msg", " *    (input) An aslmsg (default attributes will be supplied if msg is NULL)", " * @param level", " *    (input) Log level (ASL_LEVEL_DEBUG to ASL_LEVEL_EMERG)", " * @param format", " *    (input) A printf() - style format string followed by a list of arguments", " */", "#define ASL_PREFILTER_LOG(asl, msg, level, format, ...) \\", "\tdo { \\", "\t\taslclient _asl = (asl); \\", "\t\taslmsg _msg = (msg); \\", "\t\tuint32_t _asl_eval = _asl_evaluate_send(_asl, _msg, (level)); \\", "\t\tif (_asl_eval != 0) _asl_lib_log(_asl, _asl_eval, _msg, (format), ## __VA_ARGS__); \\", "\t} while (0)", "", "__BEGIN_DECLS", "", "/* ASL Library SPI - do not call directly */", "int _asl_lib_log(aslclient asl, uint32_t eval, aslmsg msg, const char *format, ...) __printflike(4, 5);", "", "uint32_t _asl_evaluate_send(aslclient asl, aslmsg msg, int level);", "", "/*!", " * Initialize a connection to the ASL server.", " *", " * This call is optional in most cases.  The library will perform any", " * necessary initializations on the fly.  A call to asl_open() is required", " * if optional settings must be made before messages are sent to the server.", " * These include setting the client filter and managing additional output", " * file descriptors.  Note that the default setting of the client filter is", " * ASL_FILTER_MASK_UPTO(ASL_LEVEL_NOTICE), so ASL_LEVEL_DEBUG and ASL_LEVEL_INFO", " * messages are not sent to the server by default.", " * ", " * Options (defined above) may be set using the opts parameter. They are:", " *", " *   ASL_OPT_STDERR    - adds stderr as an output file descriptor", " *", " *   ASL_OPT_NO_DELAY  - connects to the server immediately", " *", " *   ASL_OPT_NO_REMOTE - disables the remote-control mechanism for adjusting", " *                       filter levers for processes using e.g. syslog -c ...", " *", " * @param ident", " *    (input) Sender name", " * @param facility", " *    (input) Facility name", " * @param opts", " *    (input) Options (see asl_open Options)", " * @result Returns an ASL client handle", " */", "aslclient asl_open(const char *ident, const char *facility, uint32_t opts);", "", "/*!", " * Shuts down a connection to the server.", " *", " * @param asl", " *    (input) An ASL client handle", " */", "void asl_close(aslclient asl);", "", "/*!", " * Write log messages to the given file descriptor.", " *", " * Log messages will be written to this file as well as to the server.", " * This is equivalent to calling:", " * asl_add_output_file(asl, descriptor, ASL_MSG_FMT_STD, ASL_TIME_FMT_LCL, ASL_FILTER_MASK_UPTO(ASL_LEVEL_DEBUG), ASL_ENCODE_SAFE)", " *", " * @param asl", " *    (input) An ASL client handle", " * @param descriptor", " *    (input) A file descriptor", " * @result Returns 0 on success, non-zero on failure", "*/", "int asl_add_log_file(aslclient asl, int descriptor);", "", "/*!", " * Write log messages to the given file descriptor.", " *", " * Log messages will be written to this file as well as to the server.", " * This routine extends the basic interface offered by asl_add_log_file(),", " * allowing control of the format used to write log message written to the file.", " * control of the time zone used when printing time values, and allowing", " * individual filtering control for each log file.", " *", " * @param asl", " *    (input) An ASL client handle", " * @param descriptor", " *    (input) A file descriptor", " * @param mfmt", " *    (input) A character string specifying the message format", " * @param tfmt", " *    (input) A character string specifying the time format", " * @param filter", " *    (input) A filter value", " * @param text_encoding", " *    (input) A text encoding type", " * @result Returns 0 on success, non-zero on failure", " */", "int asl_add_output_file(aslclient asl, int descriptor, const char *mfmt, const char *tfmt, int filter, int text_encoding) __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0);", "", "/*!", " * Write log messages to the given file descriptor.", " *", " * Sets or changes a filter value for filtering messages written to a file associated", " * with an ASL client handle using asl_add_output_file() or asl_add_log_file(). ", " *", " * @param asl", " *    (input) An ASL client handle", " * @param descriptor", " *    (input) A file descriptor", " * @param filter", " *    (input) A filter value", " * @result Returns the previous filter value", " */", "int asl_set_output_file_filter(aslclient ac, int fd, int filter) __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0);", "", "/*!", " * Stop writing log messages to the given file descriptor.", " * The file descripter is not closed by this routine.", " *", " * @param asl", " *    (input) An ASL client handle", " * @param descriptor", " *    (input) A file descriptor", " * @result Returns 0 on success, non-zero on failure", " */", "int asl_remove_log_file(aslclient asl, int descriptor);", "", "/*!", " * Set a filter for messages being sent to the server.", " * The filter is a bitmask representing priorities.  The ASL_FILTER_MASK", " * macro may be used to convert a priority level into a bitmask for that", " * level.  The ASL_FILTER_MASK_UPTO macro creates a bitmask for all", " * priorities up to and including a given priority.", " * Messages with priority levels that do not have a corresponding bit ", " * set in the filter are not sent to the server, although they will be", " * sent to any file descripters added with asl_add_log_file().", " * The default setting is ASL_FILTER_MASK_UPTO(ASL_LEVEL_NOTICE).", " * Returns the previous filter value.", " *", " * @param asl", " *    (input) An ASL client handle", " * @param f", " *    (input) A filter value", " * @result Returns the previous filter value", " */", "int asl_set_filter(aslclient asl, int f);", "", "/*", " * Examine attribute keys.", " *", " * @param msg", " *    (input) An ASL message", " * @param n", " *    (input) An index value", " * @result Returns the key of the nth attribute in a message (beginning at zero),", " * or NULL if n is greater than the largest message index.", " */", "const char *asl_key(aslmsg msg, uint32_t n);", "", "/*!", " * Create a new log message or query message.", " *", " * @param type", " *    (input) Message type (see aslmsg Types)", " * @result Returns a newly allocated asmsg of the specified type", " */", "aslmsg asl_new(uint32_t type);", "", "/*!", " * Set or re-set a message attribute.", " *", " * @param msg", " *    (input) An aslmsg", " * @param key", " *    (input) Attribute key ", " * @param value", " *    (input) Attribute value", " * @result returns 0 for success, non-zero for failure", " */", "int asl_set(aslmsg msg, const char *key, const char *value);", "", "/*!", " * Remove a message attribute.", " *", " * @param msg", " *    (input) An aslmsg", " * @param key", " *    (input) Attribute key ", " * returns 0 for success, non-zero for failure", " */", "int asl_unset(aslmsg msg, const char *key);", "", "/*!", " * Get the value of a message attribute.", " *", " * @param msg", " *    (input) An aslmsg", " * @param key", " *    (input) Attribute key ", " * @result Returns the attribute value, or NULL if the message does not contain the key", " */", "const char *asl_get(aslmsg msg, const char *key);", "", "/*!", " * Log a message with a particular log level.", " *", " * @param asl", " *    (input) An ASL client handle", " * @param msg", " *    (input) An aslmsg (default attributes will be supplied if msg is NULL)", " * @param level", " *    (input) Log level (ASL_LEVEL_DEBUG to ASL_LEVEL_EMERG)", " * @param format", " *    (input) A printf() - style format string followed by a list of arguments", " * @result Returns 0 for success, non-zero for failure", " */", "int asl_log(aslclient asl, aslmsg msg, int level, const char *format, ...) __printflike(4, 5);", "", "/*!", " * Log a message with a particular log level.", " * Similar to asl_log, but takes a va_list argument.", " *", " * @param asl", " *    (input) An ASL client handle", " * @param msg", " *    (input) An aslmsg (default attributes will be supplied if msg is NULL)", " * @param level", " *    (input) Log level (ASL_LEVEL_DEBUG to ASL_LEVEL_EMERG)", " * @param format", " *    (input) A printf() - style format string followed by a list of arguments", " * @param ap", " *    (input) A va_list containing the values for the format string", " * @result Returns 0 for success, non-zero for failure", " */", "int asl_vlog(aslclient asl, aslmsg msg, int level, const char *format, va_list ap) __printflike(4, 0);", "", "/*!", " * Log a message.", " *", " * This routine may be used instead of asl_log() or asl_vlog() if asl_set() ", " * has been used to set all of a message's attributes.", " *", " * @param asl", " *    (input) An ASL client handle", " * @param msg", " *    (input) An aslmsg", " * @result Returns 0 for success, non-zero for failure", " */", "int asl_send(aslclient asl, aslmsg msg);", "", "/*!", " * Free a message.  Frees all the attribute keys and values.", " *", " * @param msg", " *    (input) An aslmsg to free", " */", "void asl_free(aslmsg msg);", "", "/*!", " * Set arbitrary parameters of a query.", " * This is similar to asl_set, but allows richer query operations.", " * See ASL_QUERY_OP_* above.", " *", " * @param msg", " *    (input) An aslmsg", " * @param key", " *    (input) Attribute key ", " * @param value", " *    (input) Attribute value", " * @param op", " *    (input) An operation (ASL_QUERY_OP_*)", " * @result Returns 0 for success, non-zero for failure", " */", "int asl_set_query(aslmsg msg, const char *key, const char *value, uint32_t op);", "", "/*!", " * Search for messages matching the criteria described by the aslmsg.", " * The caller should set the attributes to match using asl_set_query() or asl_set().", " * The operatoin ASL_QUERY_OP_EQUAL is used for attributes set with asl_set().", " *", " * @param msg", " *    (input) An aslmsg to match", " * @result Returns a set of messages accessable using aslresponse_next(),", " */", "aslresponse asl_search(aslclient asl, aslmsg msg);", "", "/*!", " * Iterate over responses returned from asl_search().", " *", " * @param r", " *    (input) An aslresponse returned by asl_search()", " * @result Returns the next message (an aslmsg) in the response, or NULL when there are no more messages", " */", "aslmsg aslresponse_next(aslresponse r);", "", "/*!", " * Free a response returned from asl_search().", " * @param r", " *    (input) An aslresponse returned by asl_search()", " */", "void aslresponse_free(aslresponse r);", "", "/*!", " * Creates an auxiliary file that may be used to save arbitrary data.  The ASL message msg", " * will be saved at the time that the auxiliary file is closed with asl_close_auxiliary_file().", " * The log entry will include any keys and values found in msg, and it will include the title", " * and Uniform Type Identifier specified.  If NULL is supplied as a value for the uti parameter,", ' * the type "public.data" is used.  Console.app will display a hyperlink to the file.', " * Output parameter out_descriptor will contain a readable and writable file descriptor for the new", " * auxiliary file. ", " *", " * By default, the file will be world-readable.  If the message contains a ReadUID and/or a", " * ReadGID key, then the values for those keys will determine read access to the file.", " *", " * The file will be deleted at the same time that the message expires from the ASL data store.", " * The aslmanager utility manages message expiry.  If msg contains a value for ASLExpireTime,", " * then the message and the file will not be deleted before that time.  The value may be in", ' * seconds after the Epoch, or it may be ctime() format, e.g "Thu Jun 24 18:22:48 2010".', " * ", " * @param msg", " *    (input) An aslmsg", " * @param tite", " *    (input) A title string for the file", " * @param uti", " *    (input) Uniform Type Identifier for the file", " * @param out_descriptor", " *    (output) A writable file descriptor", " * @result Returns 0 for success, non-zero for failure", " */", "int asl_create_auxiliary_file(aslmsg msg, const char *title, const char *uti, int *out_descriptor)", "__OSX_AVAILABLE_STARTING(__MAC_10_7,__IPHONE_5_0);", "", "/*!", " * Close an auxiliary file opened by asl_create_auxiliary_file() when writing is complete.", " * syslogd will log the message provided to asl_create_auxiliary_file() when this routine", " * is called.", " *", " * @param descriptor", " *    (input) The file descriptor", " * @result Returns 0 for success, non-zero for failure", " */", "int asl_close_auxiliary_file(int descriptor)", "__OSX_AVAILABLE_STARTING(__MAC_10_7,__IPHONE_5_0);", "", "/*!", " * Sends an ASL message to syslogd along with a title string, Uniform Resource Locator, ", " * and Uniform Type Identifier specified.  Console.app will hyperlink the title string to", " * the specified URL.  If NULL is supplied as a value for the uti parameter, the default", ' * type "public.data" is used.', " *", " * @param msg", " *    (input) An aslmsg", " * @param title", " *    (input) A title string for the file", " * @param uti", " *    (input) Uniform Type Identifier for the file", " * @param url", " *    (input) Uniform Type Locator", " * @result Returns 0 for success, non-zero for failure", " */", "int asl_log_auxiliary_location(aslmsg msg, const char *title, const char *uti, const char *url)", "__OSX_AVAILABLE_STARTING(__MAC_10_7,__IPHONE_5_0);", "", "/*!", " * Creates an aslclient for logging to a file descriptor.  The file must be opened for read and", " * write access.  This routine may be used in conjunction with asl_create_auxiliary_file() to", " * save ASL format log messages to an auxiliary file.", " *", " * The file will be truncated if it is not empty.  When logging to the auxiliary file is complete,", " * aslclient should be closed using asl_close().  The file should be closed using", " * asl_close_auxiliary_file() if it was returned by asl_create_auxiliary_file(), or close()", " * otherwise.", " *", " * The returned aslclient is thread-safe.", " *", " * Note that per-message read access controls (ReadUID and ReadGID) and message expire", " * times (ASLExpireTime) keys have no effect for messages written to this file.", " *", " * @param descriptor", " *    (input) A file descriptor", " * @param ident", " *    (input) Sender name", " * @param facility", " *    (input) Facility name", " * @result An aslclient", " */", "aslclient asl_open_from_file(int descriptor, const char *ident, const char *facility)", "__OSX_AVAILABLE_STARTING(__MAC_10_7,__IPHONE_5_0);", "", "/*!", " * This API provides functionality to use file descriptors to send logging", " * data to ASL.", " *", " * asl is retained by ASL and must still be closed by the caller by calling", " * asl_close() if the caller loses reference to it.  msg is copied by ASL and", " * similarly must still be freed by the caller by calling asl_free() if the", " * caller loses reference to it.  Any changes made to it after calling", " * asl_log_descriptor() are not applicable to the message used. descriptor", " * is treated differentlty based on the value of fd_type.", " *", " * If fd_type is ASL_LOG_DESCRIPTOR_READ, the descriptor must be open for read", " * access.  ASL uses GCD to read from the descriptor as data becomes available.", " * These data are line buffered and passed to asl_log.  When EOF is read, the", " * descriptor is closed.", " *", " * Example:", " * asl_log_descriptor(c, m, ASL_LEVEL_NOTICE, STDIN_FILENO, ASL_LOG_DESCRIPTOR_READ);", " *", " * If fd_type is ASL_LOG_DESCRIPTOR_WRITE, the descriptor is closed and a new", " * writable descriptor is created with the same fileno.  Any data written to", " * this new descriptor are line buffered and passed to asl_log.  When EOF is", " * sent, no further data are read.  The caller is responsible for closing the", " * new descriptor.  One common use for this API is to redirect writes to stdout", " * or stderr to ASL by passing STDOUT_FILENO or STDERR_FILENO as descriptor.", " *", " * Example:", " * asl_log_descriptor(c, m, ASL_LEVEL_NOTICE, STDOUT_FILENO, ASL_LOG_DESCRIPTOR_WRITE);", " * asl_log_descriptor(c, m, ASL_LEVEL_ERR, STDERR_FILENO, ASL_LOG_DESCRIPTOR_WRITE);", " *", " * @param asl", " *    (input) An ASL client handle", " * @param msg", " *    (input) An aslmsg (default attributes will be supplied if msg is NULL)", " * @param level", " *    (input) Log level (ASL_LEVEL_DEBUG to ASL_LEVEL_EMERG)", " * @param descriptor", " *    (input) An open file descriptor to read from", " * @param fd_type", " *    (input) Either ASL_LOG_DESCRIPTOR_READ or ASL_LOG_DESCRIPTOR_WRITE", " * @result Returns 0 for success, non-zero for failure", " */", "int asl_log_descriptor(aslclient asl, aslmsg msg, int level, int descriptor, uint32_t fd_type)", "__OSX_AVAILABLE_STARTING(__MAC_10_8,__IPHONE_5_1);", "", "__END_DECLS", "", "#endif /* __ASL_H__ */" },
    ["assert.h"] = { "/*-", " * Copyright (c) 1992, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " * (c) UNIX System Laboratories, Inc.", " * All or some portions of this file are derived from material licensed", " * to the University of California by American Telephone and Telegraph", " * Co. or Unix System Laboratories, Inc. and are reproduced herein with", " * the permission of UNIX System Laboratories, Inc.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)assert.h\t8.2 (Berkeley) 1/21/94", " * $FreeBSD: src/include/assert.h,v 1.4 2002/03/23 17:24:53 imp Exp $", " */", "", "#include <sys/cdefs.h>", "#ifdef __cplusplus", "#include <stdlib.h>", "#endif /* __cplusplus */", "", "/*", " * Unlike other ANSI header files, <assert.h> may usefully be included", " * multiple times, with and without NDEBUG defined.", " */", "", "#undef assert", "#undef __assert", "", "#ifdef NDEBUG", "#define\tassert(e)\t((void)0)", "#else", "", "#ifndef __GNUC__", "", "__BEGIN_DECLS", "#ifndef __cplusplus", "void abort(void) __dead2;", "#endif /* !__cplusplus */", "int  printf(const char * __restrict, ...);", "__END_DECLS", "", "#define assert(e)  \\", "    ((void) ((e) ? 0 : __assert (#e, __FILE__, __LINE__)))", "#define __assert(e, file, line) \\", "    ((void)printf (\"%s:%u: failed assertion `%s'\\n\", file, line, e), abort())", "", "#else /* __GNUC__ */", "", "__BEGIN_DECLS", "void __assert_rtn(const char *, const char *, int, const char *) __dead2;", "#if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && ((__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__-0) < 1070)", "void __eprintf(const char *, const char *, unsigned, const char *) __dead2;", "#endif", "__END_DECLS", "", "#if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && ((__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__-0) < 1070)", "#define __assert(e, file, line) \\", "    __eprintf (\"%s:%u: failed assertion `%s'\\n\", file, line, e)", "#else", "/* 8462256: modified __assert_rtn() replaces deprecated __eprintf() */", "#define __assert(e, file, line) \\", "    __assert_rtn ((const char *)-1L, file, line, e)", "#endif", "", "#if __DARWIN_UNIX03", "#define\tassert(e) \\", "    (__builtin_expect(!(e), 0) ? __assert_rtn(__func__, __FILE__, __LINE__, #e) : (void)0)", "#else /* !__DARWIN_UNIX03 */", "#define assert(e)  \\", "    (__builtin_expect(!(e), 0) ? __assert (#e, __FILE__, __LINE__) : (void)0)", "#endif /* __DARWIN_UNIX03 */", "", "#endif /* __GNUC__ */", "#endif /* NDEBUG */" },
    ["bitstring.h"] = { "/*", " * Copyright (c) 1989, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * This code is derived from software contributed to Berkeley by", " * Paul Vixie.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)bitstring.h\t8.1 (Berkeley) 7/19/93", " */", "", "#ifndef _BITSTRING_H_", "#define\t_BITSTRING_H_", "", "typedef\tunsigned char bitstr_t;", "", "/* internal macros */", "\t\t\t\t/* byte of the bitstring bit is in */", "#define\t_bit_byte(bit) \\", "\t((bit) >> 3)", "", "\t\t\t\t/* mask for the bit within its byte */", "#define\t_bit_mask(bit) \\", "\t(1 << ((bit)&0x7))", "", "/* external macros */", "\t\t\t\t/* bytes in a bitstring of nbits bits */", "#define\tbitstr_size(nbits) \\", "\t((((nbits) - 1) >> 3) + 1)", "", "\t\t\t\t/* allocate a bitstring */", "#define\tbit_alloc(nbits) \\", "\t(bitstr_t *)calloc(1, \\", "\t    (unsigned int)bitstr_size(nbits) * sizeof(bitstr_t))", "", "\t\t\t\t/* allocate a bitstring on the stack */", "#define\tbit_decl(name, nbits) \\", "\t(name)[bitstr_size(nbits)]", "", "\t\t\t\t/* is bit N of bitstring name set? */", "#define\tbit_test(name, bit) \\", "\t((name)[_bit_byte(bit)] & _bit_mask(bit))", "", "\t\t\t\t/* set bit N of bitstring name */", "#define\tbit_set(name, bit) \\", "\t(name)[_bit_byte(bit)] |= _bit_mask(bit)", "", "\t\t\t\t/* clear bit N of bitstring name */", "#define\tbit_clear(name, bit) \\", "\t(name)[_bit_byte(bit)] &= ~_bit_mask(bit)", "", "\t\t\t\t/* clear bits start ... stop in bitstring */", "#define\tbit_nclear(name, start, stop) { \\", "\tregister bitstr_t *_name = name; \\", "\tregister int _start = start, _stop = stop; \\", "\tregister int _startbyte = _bit_byte(_start); \\", "\tregister int _stopbyte = _bit_byte(_stop); \\", "\tif (_startbyte == _stopbyte) { \\", "\t\t_name[_startbyte] &= ((0xff >> (8 - (_start&0x7))) | \\", "\t\t\t\t      (0xff << ((_stop&0x7) + 1))); \\", "\t} else { \\", "\t\t_name[_startbyte] &= 0xff >> (8 - (_start&0x7)); \\", "\t\twhile (++_startbyte < _stopbyte) \\", "\t\t\t_name[_startbyte] = 0; \\", "\t\t_name[_stopbyte] &= 0xff << ((_stop&0x7) + 1); \\", "\t} \\", "}", "", "\t\t\t\t/* set bits start ... stop in bitstring */", "#define\tbit_nset(name, start, stop) { \\", "\tregister bitstr_t *_name = name; \\", "\tregister int _start = start, _stop = stop; \\", "\tregister int _startbyte = _bit_byte(_start); \\", "\tregister int _stopbyte = _bit_byte(_stop); \\", "\tif (_startbyte == _stopbyte) { \\", "\t\t_name[_startbyte] |= ((0xff << (_start&0x7)) & \\", "\t\t\t\t    (0xff >> (7 - (_stop&0x7)))); \\", "\t} else { \\", "\t\t_name[_startbyte] |= 0xff << ((_start)&0x7); \\", "\t\twhile (++_startbyte < _stopbyte) \\", "\t    \t\t_name[_startbyte] = 0xff; \\", "\t\t_name[_stopbyte] |= 0xff >> (7 - (_stop&0x7)); \\", "\t} \\", "}", "", "\t\t\t\t/* find first bit clear in name */", "#define\tbit_ffc(name, nbits, value) { \\", "\tregister bitstr_t *_name = name; \\", "\tregister int _byte, _nbits = nbits; \\", "\tregister int _stopbyte = _bit_byte(_nbits), _value = -1; \\", "\tfor (_byte = 0; _byte < _stopbyte; ++_byte) \\", "\t\tif (_name[_byte] != 0xff) { \\", "\t\t\t_value = _byte << 3; \\", "\t\t\tfor (_stopbyte = _name[_byte]; (_stopbyte&0x1); \\", "\t\t\t    ++_value, _stopbyte >>= 1); \\", "\t\t\tbreak; \\", "\t\t} \\", "\t*(value) = _value; \\", "}", "", "\t\t\t\t/* find first bit set in name */", "#define\tbit_ffs(name, nbits, value) { \\", "\tregister bitstr_t *_name = name; \\", "\tregister int _byte, _nbits = nbits; \\", "\tregister int _stopbyte = _bit_byte(_nbits), _value = -1; \\", "\tfor (_byte = 0; _byte < _stopbyte; ++_byte) \\", "\t\tif (_name[_byte]) { \\", "\t\t\t_value = _byte << 3; \\", "\t\t\tfor (_stopbyte = _name[_byte]; !(_stopbyte&0x1); \\", "\t\t\t    ++_value, _stopbyte >>= 1); \\", "\t\t\tbreak; \\", "\t\t} \\", "\t*(value) = _value; \\", "}", "", "#endif /* !_BITSTRING_H_ */" },
    ["bootparams.h"] = { "/*", " * Copyright (c) 1999-2009 Apple Inc.  All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/*", " * Bootparams lookup routines", " *", " * Copyright 1997", " * Apple Computer Inc.", " */", "", "#ifndef _BOOTPARAMS_H_", "#define _BOOTPARAMS_H_", "", "#include <sys/param.h>", "#include <sys/cdefs.h>", "", "/*", " * Structures returned by bootparams calls.", " */", "struct bootparamsent {", "\tchar *bp_name;\t\t\t/* name of host */", "\tchar **bp_bootparams;\t/* bootparams list */", "};", "", "__BEGIN_DECLS", "void bootparams_endent __P((void));", "struct bootparamsent *bootparams_getbyname __P((const char *));", "struct bootparamsent *bootparams_getent __P((void));", "void bootparams_setent __P((void));", "__END_DECLS", "", "#endif /* !_BOOTPARAMS_H_ */" },
    ["bzlib.h"] = { "", "/*-------------------------------------------------------------*/", "/*--- Public header file for the library.                   ---*/", "/*---                                               bzlib.h ---*/", "/*-------------------------------------------------------------*/", "", "/* ------------------------------------------------------------------", "   This file is part of bzip2/libbzip2, a program and library for", "   lossless, block-sorting data compression.", "", "   bzip2/libbzip2 version 1.0.6 of 6 September 2010", "   Copyright (C) 1996-2010 Julian Seward <jseward@bzip.org>", "", "   Please read the WARNING, DISCLAIMER and PATENTS sections in the ", "   README file.", "", "   This program is released under the terms of the license contained", "   in the file LICENSE.", "   ------------------------------------------------------------------ */", "", "", "#ifndef _BZLIB_H", "#define _BZLIB_H", "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "", "#define BZ_RUN               0", "#define BZ_FLUSH             1", "#define BZ_FINISH            2", "", "#define BZ_OK                0", "#define BZ_RUN_OK            1", "#define BZ_FLUSH_OK          2", "#define BZ_FINISH_OK         3", "#define BZ_STREAM_END        4", "#define BZ_SEQUENCE_ERROR    (-1)", "#define BZ_PARAM_ERROR       (-2)", "#define BZ_MEM_ERROR         (-3)", "#define BZ_DATA_ERROR        (-4)", "#define BZ_DATA_ERROR_MAGIC  (-5)", "#define BZ_IO_ERROR          (-6)", "#define BZ_UNEXPECTED_EOF    (-7)", "#define BZ_OUTBUFF_FULL      (-8)", "#define BZ_CONFIG_ERROR      (-9)", "", "typedef ", "   struct {", "      char *next_in;", "      unsigned int avail_in;", "      unsigned int total_in_lo32;", "      unsigned int total_in_hi32;", "", "      char *next_out;", "      unsigned int avail_out;", "      unsigned int total_out_lo32;", "      unsigned int total_out_hi32;", "", "      void *state;", "", "      void *(*bzalloc)(void *,int,int);", "      void (*bzfree)(void *,void *);", "      void *opaque;", "   } ", "   bz_stream;", "", "", "#ifndef BZ_IMPORT", "#define BZ_EXPORT", "#endif", "", "#ifndef BZ_NO_STDIO", "/* Need a definitition for FILE */", "#include <stdio.h>", "#endif", "", "#ifdef _WIN32", "#   include <windows.h>", "#   ifdef small", "      /* windows.h define small to char */", "#      undef small", "#   endif", "#   ifdef BZ_EXPORT", "#   define BZ_API(func) WINAPI func", "#   define BZ_EXTERN extern", "#   else", "   /* import windows dll dynamically */", "#   define BZ_API(func) (WINAPI * func)", "#   define BZ_EXTERN", "#   endif", "#else", "#   define BZ_API(func) func", "#   define BZ_EXTERN extern", "#endif", "", "", "/*-- Core (low-level) library functions --*/", "", "BZ_EXTERN int BZ_API(BZ2_bzCompressInit) ( ", "      bz_stream* strm, ", "      int        blockSize100k, ", "      int        verbosity, ", "      int        workFactor ", "   );", "", "BZ_EXTERN int BZ_API(BZ2_bzCompress) ( ", "      bz_stream* strm, ", "      int action ", "   );", "", "BZ_EXTERN int BZ_API(BZ2_bzCompressEnd) ( ", "      bz_stream* strm ", "   );", "", "BZ_EXTERN int BZ_API(BZ2_bzDecompressInit) ( ", "      bz_stream *strm, ", "      int       verbosity, ", "      int       small", "   );", "", "BZ_EXTERN int BZ_API(BZ2_bzDecompress) ( ", "      bz_stream* strm ", "   );", "", "BZ_EXTERN int BZ_API(BZ2_bzDecompressEnd) ( ", "      bz_stream *strm ", "   );", "", "", "", "/*-- High(er) level library functions --*/", "", "#ifndef BZ_NO_STDIO", "#define BZ_MAX_UNUSED 5000", "", "typedef void BZFILE;", "", "BZ_EXTERN BZFILE* BZ_API(BZ2_bzReadOpen) ( ", "      int*  bzerror,   ", "      FILE* f, ", "      int   verbosity, ", "      int   small,", "      void* unused,    ", "      int   nUnused ", "   );", "", "BZ_EXTERN void BZ_API(BZ2_bzReadClose) ( ", "      int*    bzerror, ", "      BZFILE* b ", "   );", "", "BZ_EXTERN void BZ_API(BZ2_bzReadGetUnused) ( ", "      int*    bzerror, ", "      BZFILE* b, ", "      void**  unused,  ", "      int*    nUnused ", "   );", "", "BZ_EXTERN int BZ_API(BZ2_bzRead) ( ", "      int*    bzerror, ", "      BZFILE* b, ", "      void*   buf, ", "      int     len ", "   );", "", "BZ_EXTERN BZFILE* BZ_API(BZ2_bzWriteOpen) ( ", "      int*  bzerror,      ", "      FILE* f, ", "      int   blockSize100k, ", "      int   verbosity, ", "      int   workFactor ", "   );", "", "BZ_EXTERN void BZ_API(BZ2_bzWrite) ( ", "      int*    bzerror, ", "      BZFILE* b, ", "      void*   buf, ", "      int     len ", "   );", "", "BZ_EXTERN void BZ_API(BZ2_bzWriteClose) ( ", "      int*          bzerror, ", "      BZFILE*       b, ", "      int           abandon, ", "      unsigned int* nbytes_in, ", "      unsigned int* nbytes_out ", "   );", "", "BZ_EXTERN void BZ_API(BZ2_bzWriteClose64) ( ", "      int*          bzerror, ", "      BZFILE*       b, ", "      int           abandon, ", "      unsigned int* nbytes_in_lo32, ", "      unsigned int* nbytes_in_hi32, ", "      unsigned int* nbytes_out_lo32, ", "      unsigned int* nbytes_out_hi32", "   );", "#endif", "", "", "/*-- Utility functions --*/", "", "BZ_EXTERN int BZ_API(BZ2_bzBuffToBuffCompress) ( ", "      char*         dest, ", "      unsigned int* destLen,", "      char*         source, ", "      unsigned int  sourceLen,", "      int           blockSize100k, ", "      int           verbosity, ", "      int           workFactor ", "   );", "", "BZ_EXTERN int BZ_API(BZ2_bzBuffToBuffDecompress) ( ", "      char*         dest, ", "      unsigned int* destLen,", "      char*         source, ", "      unsigned int  sourceLen,", "      int           small, ", "      int           verbosity ", "   );", "", "", "/*--", "   Code contributed by Yoshioka Tsuneo (tsuneo@rr.iij4u.or.jp)", "   to support better zlib compatibility.", "   This code is not _officially_ part of libbzip2 (yet);", "   I haven't tested it, documented it, or considered the", "   threading-safeness of it.", "   If this code breaks, please contact both Yoshioka and me.", "--*/", "", "BZ_EXTERN const char * BZ_API(BZ2_bzlibVersion) (", "      void", "   );", "", "#ifndef BZ_NO_STDIO", "BZ_EXTERN BZFILE * BZ_API(BZ2_bzopen) (", "      const char *path,", "      const char *mode", "   );", "", "BZ_EXTERN BZFILE * BZ_API(BZ2_bzdopen) (", "      int        fd,", "      const char *mode", "   );", "         ", "BZ_EXTERN int BZ_API(BZ2_bzread) (", "      BZFILE* b, ", "      void* buf, ", "      int len ", "   );", "", "BZ_EXTERN int BZ_API(BZ2_bzwrite) (", "      BZFILE* b, ", "      void*   buf, ", "      int     len ", "   );", "", "BZ_EXTERN int BZ_API(BZ2_bzflush) (", "      BZFILE* b", "   );", "", "BZ_EXTERN void BZ_API(BZ2_bzclose) (", "      BZFILE* b", "   );", "", "BZ_EXTERN const char * BZ_API(BZ2_bzerror) (", "      BZFILE *b, ", "      int    *errnum", "   );", "#endif", "", "#ifdef __cplusplus", "}", "#endif", "", "#endif", "", "/*-------------------------------------------------------------*/", "/*--- end                                           bzlib.h ---*/", "/*-------------------------------------------------------------*/" },
    ["cache.h"] = { "/*!", " @header cache.h", " ", " @abstract UNIX-level caching API.  ", " ", " @discussion", " Provides a dictionary associating keys with values.", " The cache determines its size and may remove keys at any time.", " Cache keeps reference counts for cache values and preserves values until", " unreferenced.  Unreferenced values may be removed at any time.", " ", " All API functions return 0 for success, non-zero for failure.  Most", " functions can return EINVAL for malformed arguments and ENOMEM for", " allocation failures.  See function descriptions for other return values.", " ", " Cache functions rely upon a per-cache lock to provide thread safety.  ", " Calling cache functions from cache callbacks should be avoided to ", " prevent deadlock.", " ", " @copyright Copyright (c) 2007-2008 Apple Inc. All rights reserved.", " ", " @updated 03-10-2008 ", " */", "", "#ifndef _CACHE_H_", "#define _CACHE_H_", "", "#include <TargetConditionals.h>", "#include <stddef.h>", "#include <stdint.h>", "#include <stdbool.h>", "", "#if TARGET_OS_WIN32", "", "#ifndef CACHE_PUBLIC_API", "#define CACHE_PUBLIC_API __declspec( dllimport )", "#endif /* CACHE_PUBLIC_API */", "", "#else", "", "#include <sys/cdefs.h> ", "#ifndef CACHE_PUBLIC_API", "#ifdef __GNUC__", "/*! @parseOnly */", '#define CACHE_PUBLIC_API __attribute__((__visibility__("default")))', "#else", "/*! @parseOnly */", "#error __GNUC__ not defined", "#define CACHE_PUBLIC_API", "#endif /* __GNUC__ */", "#endif /* CACHE_PUBLIC_API */", "", "#endif /* ! TARGET_OS_WIN32 */", "", "#ifndef __BEGIN_DECLS", '#define __BEGIN_DECLS extern "C" {', "#endif", "#ifndef __END_DECLS ", "#define __END_DECLS }", "#endif", "", "__BEGIN_DECLS", "", "/*!", " * @typedef cache_t", " *", " * @abstract ", " * Opaque cache object.", " *", " * @discussion", " * Dictionary associating keys with values.", " */", "typedef struct cache_s cache_t;", "", "/*!", " * @typedef cache_attributes_t", " *", " * @abstract ", " * Cache attributes", " *", " * @discussion", " * Collection of callbacks used by cache_create() to customize cache behavior.", " */", "typedef struct cache_attributes_s cache_attributes_t;", "", "/*!", " * @typedef cache_cost_t", " * ", " * @abstract", " * Cost of maintaining a value in the cache.  ", " *", " * @discussion", " * Cache uses cost when deciding", " * which value to evict.  Usually related to a value's memory size in bytes.", " * Zero is a valid cost.", " */", "typedef size_t cache_cost_t;", "", "/*!", " * @function cache_create", " *", " * @abstract ", " * Creates a cache object.", " *", " * @param name ", " * Cache name used for debugging and performance tools.  Name", ' * should be in reverse-DNS form, e.g. "com.mycompany.myproject.mycache" ', " * and must not be NULL.  Name is copied.", " *", " * @param attrs ", " * Cache attributes used to customize cache behavior.  Attributes", " * are defined below and must not be NULL.", " *", " * @param cache_out ", " * Cache object is stored here if cache is successfully ", " * created.  Must not be NULL.", " * ", " *@result Returns 0 for success, non-zero for failure.", " */", "CACHE_PUBLIC_API int cache_create(const char *name, cache_attributes_t *attrs, cache_t **cache_out);", "", "/*!", " * @function cache_set_and_retain", " * ", " * @abstract ", " * Sets value for key.", " *", " * @param cache ", " * Pointer to cache.  Must not be NULL.", " * ", " * @param key ", " * Key to add.  Must not be NULL.", " *", " * @param value ", " * Value to add.  If value is NULL, key is associated with the value NULL.", " * ", " * @param cost ", " * Cost of maintaining value in cache.", " * ", " * @result Returns 0 for success, non-zero for failure.", " * ", " * @discussion", " * Sets value for key.  Value is retained until released using ", " * cache_release_value().  The key retain callback (if provided) is", " * invoked on key.", " * ", " * Replaces previous key and value if present.  Invokes the key release", " * callback immediately for the previous key.  Invokes the value release", " * callback once the previous value's retain count is zero.", " * ", " * Cost indicates the relative cost of maintaining value in the cache ", " * (e.g., size of value in bytes) and may be used by the cache under ", " * memory pressure to select which cache values to evict.  Zero is a ", " * valid cost. ", " */", "CACHE_PUBLIC_API int cache_set_and_retain(cache_t *cache, void *key, void *value, cache_cost_t cost);", "", "/*!", " * @function cache_get_and_retain", " * ", " * @abstract ", " * Fetches value for key.", " *", " * @param cache ", " * Pointer to cache.  Must not be NULL.", " * ", " * @param key ", " * Key used to lookup value.  Must not be NULL.", " *", " * @param value_out ", " * Value is stored here if found.  Must not be NULL.", " *", " * @result Returns 0 for success, ENOENT if not found, other non-zero for failure.", " * ", " * @discussion", " * Fetches value for key, retains value, and stores value in value_out.", " * Caller should release value using cache_release_value(). ", " */", "CACHE_PUBLIC_API int cache_get_and_retain(cache_t *cache, void *key, void **value_out);", "", "/*!", " * @function cache_release_value", " *", " * @abstract ", " * Releases a previously retained cache value.", " *", " * @param cache ", " * Pointer to cache.  Must not be NULL.", " * ", " * @param value ", " * Value to release.  Must not be NULL.", " *", " * @result Returns 0 for success, non-zero for failure.", " * ", " * @discussion ", " * Releases a previously retained cache value. When the reference count ", " * reaches zero the cache may make the value purgeable or destroy it. ", " */", "CACHE_PUBLIC_API int cache_release_value(cache_t *cache, void *value);", "", "/*!", " * @function cache_remove", " *", " * @abstract ", " * Removes a key and its value.", " * ", " * @param cache ", " * Pointer to cache.  Must not be NULL.", " *", " * @param key ", " * Key to remove.  Must not be NULL.", " *", " * @result Returns 0 for success, non-zero for failure.", " * ", " * @discussion", " * Removes a key and its value from the cache such that cache_get_and_retain()", " * will fail.  Invokes the key release callback immediately.  Invokes the ", " * value release callback once value's retain count is zero. ", " */", "CACHE_PUBLIC_API int cache_remove(cache_t *cache, void *key);", "", "/*!", " *@function cache_remove_all", " *", " * @abstract ", " * Invokes cache_remove on all keys. ", " * ", " * @param cache ", " * Pointer to cache.  Must not be NULL.", " *", " * @result Returns 0 for success, non-zero for failure.", " */", "CACHE_PUBLIC_API int cache_remove_all(cache_t *cache);", "", "/*! ", " * @function cache_destroy", " *", " * @abstract ", " * Destroys cache", " *", " * @param cache ", " * Pointer to cache.  Must not be NULL.", " * ", " * @result Returns 0 for success, non-zero for failure.  Returns EAGAIN if ", " * the cache was not destroyed because retained cache values exist.", " *", " * @discussion", " * Invokes cache_remove_all().  If there are no retained cache values then", " * the cache object is freed.  If retained cache values exist then ", " * returns EAGAIN. ", " */", "CACHE_PUBLIC_API int cache_destroy(cache_t *cache);", "", "/*!", " * @group Cache Callbacks", " */", "", "/*!", " * @function cache_key_hash_cb_t", " *", " * @abstract ", " * Calculates a hash value using key.", " * ", " * @param key ", " * Key to user to calculate hash.", " *", " * @param user_data ", " * User-provided value passed during cache creation.", " *", " * @discussion ", " * Calculates and returns a key hash.  If the callback is NULL then a key", " * will be converted from a pointer to an integer to compute the hash code. ", " */", "typedef uintptr_t (*cache_key_hash_cb_t)(void *key, void *user_data);", "", "/*! ", " * @function cache_key_is_equal_cb_t", " *", " * @abstract ", " * Determines if two keys are equal.", " *", " * @param key1 ", " * First key", " *", " * @param key2 ", " * Second key", " * ", " * @param user_data ", " * User-provided value passed during cache creation.", " *", " * @result ", " * Returns true if equal, false if not equal.", " * ", " * @discussion ", " * Determines if two keys are equal.  If the callback is NULL then ", " * the cache uses pointer equality to test equality for keys. ", " */", "typedef bool (*cache_key_is_equal_cb_t)(void *key1, void *key2, void *user_data);", "", "/*! ", " * @function cache_key_retain_cb_t", " *", " * @abstract ", " * Retains a key.", " *", " * @param key_in", " * Key provided in cache_set_and_retain()", " *", " * @param key_out", " * Set key to add here.  If NULL, cache_set_and_retain() will fail.", " *", " * @param user_data ", " * User-provided value passed during cache creation.", " *", " * @discussion ", " * Called when it is added to the cache through", " * cache_set_and_retain.  The cache will add the key stored in key_out", " * and may release it at any time by calling the key release callback.", " * If key_out is NULL then no key will be added.  If callback is NULL then", " * the cache adds key_in. ", " */", "typedef void (*cache_key_retain_cb_t)(void *key_in, void **key_out, void *user_data);", "", "/*! ", " * @function cache_value_retain_cb_t", " *", " * @abstract ", " * Retains a value.", " *", " * @param value_in", " * Value provided in cache_set_and_retain()", " *", " * @param user_data ", " * User-provided value passed during cache creation.", " *", " * @discussion ", " * Called when a unique value is added to the cache through cache_set_and_retain().", " * Allows the client to retain value_in before it is added to the cache.  The cache", " * will call any value_release_cb after removing a cache value.", " */", "typedef void (*cache_value_retain_cb_t)(void *value_in, void *user_data);", "", "/*! ", " * @function cache_release_cb_t", " * ", " * @abstract ", " * Releases or deallocates a cache value.", " *", " * @param key_or_value", " * Key or value to release", " *", " * @param user_data ", " * User-provided value passed during cache creation.", " *", " * @discussion", " * Called when a key or value is removed from the cache, ie. when the", " * cache no longer references it.  In the common case the key or value", " * should be deallocated, or released if reference counted.", " * If the callback is NULL then the cache calls free() on key_or_value. ", " */", "typedef void (*cache_release_cb_t)(void *key_or_value, void *user_data);", "", "/*!", " * @function cache_value_make_nonpurgeable_cb_t", " *", " * @abstract", " * Makes a cache value nonpurgeable and tests to see if value is still valid.", " *", " * @param value", " *", " * @param user_data User-provided value passed during cache creation.", " *", " * @result Should return true if value is valid, or false if it was purged.", " *", " * @discussion", " * Purged cache values will be removed.  If the callback is", " * NULL then the cache does not make value nonpurgeable.  ", " */", "typedef bool (*cache_value_make_nonpurgeable_cb_t)(void *value, void *user_data);", "", "/*! ", " * @function cache_value_make_purgeable_cb_t", " *", " * @abstract", " * Makes a cache value purgeable.  ", " *", " * @param value", " * Cache value to make purgeable.", " *", " * @param user_data ", " * User-provided value passed during cache creation.", " *", " * @discussion", " * Called when the cache determines that no cache clients reference the value.  ", " * If the callback is NULL then the cache does not make value purgeable. ", " */", "typedef void (*cache_value_make_purgeable_cb_t)(void *value, void *user_data);", "", "/*! @group */", "", "/*!", " * @struct cache_attributes_s", " * ", " * @abstract Callbacks passed to cache_create() to customize cache behavior.", " *", " * @field key_hash_cb Key hash callback", " * @field key_is_equal_cb Key is equal callback", " * @field key_retain_cb Key retain callback", " * @field key_release_cb Key release callback", " * @field value_retain_cb Value retain callback", " * @field value_release_cb Value release callback", " * @field value_make_nonpurgeable_cb Value make nonpurgeable callback", " * @field value_make_purgeable_cb Value make purgeable callback", " * @field version Attributes version number used for binary compatibility.", " * @field user_data Passed to all callbacks.  May be NULL.", " */", "struct CACHE_PUBLIC_API cache_attributes_s {", "    uint32_t version;", "    cache_key_hash_cb_t key_hash_cb;                               ", "    cache_key_is_equal_cb_t key_is_equal_cb;                        ", "    ", "    cache_key_retain_cb_t  key_retain_cb;", "    cache_release_cb_t key_release_cb;", "    cache_release_cb_t value_release_cb;                           ", "    ", "    cache_value_make_nonpurgeable_cb_t value_make_nonpurgeable_cb; ", "    cache_value_make_purgeable_cb_t value_make_purgeable_cb;       ", "    ", "    void *user_data;", "", "\t// Added in CACHE_ATTRIBUTES_VERSION_2", "\tcache_value_retain_cb_t value_retain_cb;", "};", "#define CACHE_ATTRIBUTES_VERSION_1 1 ", "#define CACHE_ATTRIBUTES_VERSION_2 2 ", "", "__END_DECLS", "", "#endif /* _CACHE_H_ */", "" },
    ["cache_callbacks.h"] = { "/*", " *  cache_callbacks.h", " *", " *  Copyright 2008 Apple. All rights reserved.", " *", " */", "", "#ifndef _CACHE_CALLBACKS_H_", "#define _CACHE_CALLBACKS_H_", "", "#include <TargetConditionals.h>", '#include "cache.h"', "", "#if TARGET_OS_WIN32", "#ifndef CACHE_PUBLIC_API", "#define CACHE_PUBLIC_API __declspec( dllimport )", "#endif /* CACHE_PUBLIC_API */", "#else", "#include <sys/cdefs.h> ", "#ifndef CACHE_PUBLIC_API", "#ifdef __GNUC__", "/*! @parseOnly */", '#define CACHE_PUBLIC_API     __attribute__((__visibility__("default")))', "#else", "/*! @parseOnly */", "#define CACHE_PUBLIC_API", "#endif /* __GNUC__ */", "#endif /* CACHE_PUBLIC_API */", "#endif /* ! TARGET_OS_WIN32 */", "", "__BEGIN_DECLS", "", "/*", " * Pre-defined callback functions.", " */", "", "CACHE_PUBLIC_API uintptr_t cache_key_hash_cb_cstring(void *key, void *unused);", "CACHE_PUBLIC_API uintptr_t cache_key_hash_cb_integer(void *key, void *unused);", "", "CACHE_PUBLIC_API bool cache_key_is_equal_cb_cstring(void *key1, void *key2, void *unused);", "CACHE_PUBLIC_API bool cache_key_is_equal_cb_integer(void *key1, void *key2, void *unused);", "", "CACHE_PUBLIC_API void cache_release_cb_free(void *key_or_value, void *unused);", "", "CACHE_PUBLIC_API void cache_value_make_purgeable_cb(void *value, void *unused);", "CACHE_PUBLIC_API bool cache_value_make_nonpurgeable_cb(void *value, void *unused);", "", "/* Default hash function for byte strings.  */", "CACHE_PUBLIC_API uintptr_t cache_hash_byte_string(const char *data, size_t bytes);", "", " __END_DECLS", "", "#endif /* _CACHE_CALLBACKS_H_ */" },
    ["checkint.h"] = { "/* ", " * Copyright (c) 2006 Apple Computer, Inc.  All rights reserved.", " */", "", "#ifndef __CHECKINT_H__", "#define __CHECKINT_H__", "", "/* ObjC++ Guard */", "#if defined(__OBJC__) && defined(__cplusplus)", '#error "checkint.h does not support Objective C++"', "#elif defined(__cplusplus)", '#error "checkint.h does not support C++"', "#endif", "", "#include <stdint.h>", "#include <limits.h>", "", "__BEGIN_DECLS", "", "enum {", "\tCHECKINT_NO_ERROR = 0,", "\tCHECKINT_OVERFLOW_ERROR = (1 << 0),", "\tCHECKINT_TYPE_ERROR = (1 << 1)", "};", "", "#define check_int32_add(x, y, err)\t\t__checkint_int32_add(x,y,err)", "#define check_uint32_add(x, y, err)\t\t__checkint_uint32_add(x,y,err)", "#define check_int64_add(x, y, err)\t\t__checkint_int64_add(x,y,err)", "#define check_uint64_add(x, y, err)\t\t__checkint_uint64_add(x,y,err)", "", "#define check_int32_sub(x, y, err)\t\t__checkint_int32_sub(x,y,err)", "#define check_uint32_sub(x, y, err)\t\t__checkint_uint32_sub(x,y,err)", "#define check_int64_sub(x, y, err)\t\t__checkint_int64_sub(x,y,err)", "#define check_uint64_sub(x, y, err)\t\t__checkint_uint64_sub(x,y,err)", "", "#define check_int32_mul(x, y, err)\t\t__checkint_int32_mul(x,y,err)", "#define check_uint32_mul(x, y, err)\t\t__checkint_uint32_mul(x,y,err)", "#define check_int64_mul(x, y, err)\t\t__checkint_int64_mul(x,y,err)", "#define check_uint64_mul(x, y, err)\t\t__checkint_uint64_mul(x,y,err)", "", "#define check_int32_div(x, y, err)\t\t__checkint_int32_div(x,y,err)", "#define check_uint32_div(x, y, err)\t\t__checkint_uint32_div(x,y,err)", "#define check_int64_div(x, y, err)\t\t__checkint_int64_div(x,y,err)", "#define check_uint64_div(x, y, err)\t\t__checkint_uint64_div(x,y,err)", "", "/***", " * Private Interfaces", " *", " * Please do not directly use any interfaces below this point.  They are", " * considered an implementation detail of the above, supported, interfaces", " * and are subject to change at any time without warning.", " ***/", "", "#define __CHECKINT_INLINE static inline __attribute__((always_inline))", "", "__CHECKINT_INLINE int32_t", "__checkint_is_mixed_sign32(int32_t x, int32_t y) {return ((x ^ y) < 0);}", "", "__CHECKINT_INLINE int32_t", "__checkint_is_mixed_sign64(int64_t x, int64_t y) {return ((x ^ y) < 0);}", "", "__CHECKINT_INLINE int32_t", "__checkint_int32_type_error(int32_t* err)  {*err |= CHECKINT_TYPE_ERROR; return -1;}", "", "__CHECKINT_INLINE int32_t", "__checkint_uint32_type_error(int32_t* err) {*err |= CHECKINT_TYPE_ERROR; return -1;}", "", "__CHECKINT_INLINE int32_t", "__checkint_int64_type_error(int32_t* err)  {*err |= CHECKINT_TYPE_ERROR; return -1;}", "", "__CHECKINT_INLINE int32_t", "__checkint_uint64_type_error(int32_t* err) {*err |= CHECKINT_TYPE_ERROR; return -1;}", "", "__CHECKINT_INLINE int32_t", "__checkint_int32_add(int64_t x, int64_t y, int32_t* err) {", "\tint64_t z = x + y;", "\tif (x < INT32_MIN || x > INT32_MAX || y < INT32_MIN || y > INT32_MAX) {", "\t\t*err |= CHECKINT_OVERFLOW_ERROR;", "\t}", "\tif (z > INT32_MAX || z < INT32_MIN) *err |= CHECKINT_OVERFLOW_ERROR;", "\treturn (int32_t)z;", "}", "", "__CHECKINT_INLINE uint32_t", "__checkint_uint32_add(int64_t x, int64_t y, int32_t* err) {", "\tint64_t z = x + y;", "\tif ((x & 0xffffffff00000000ull) || (y & 0xffffffff00000000ull)) *err |= CHECKINT_OVERFLOW_ERROR;", "\tif (z > UINT_MAX || z < 0) *err |= CHECKINT_OVERFLOW_ERROR;", "\treturn (uint32_t)z;", "}", "", "__CHECKINT_INLINE int64_t", "__checkint_int64_add_signed_signed(int64_t x, int64_t y, int32_t* err) {", "\t/* Mixed-sign additions cannot overflow */", "\tif (__checkint_is_mixed_sign64(x,y)) {", "\t/* else, both arguments negative */", "\t} else if (y < 0) {", "\t\tif (x < LLONG_MIN - y) *err |= CHECKINT_OVERFLOW_ERROR;", "\t/* else, both arguments positive */", "\t} else {", "\t\tif (LLONG_MAX - x < y) *err |= CHECKINT_OVERFLOW_ERROR;", "        }", "\treturn x + y;", "}", "", "__CHECKINT_INLINE int64_t", "__checkint_int64_add_signed_unsigned(int64_t x, uint64_t y, int32_t* err) {", "  if(((int64_t)(LLONG_MAX - y)) < x)", "           *err = *err | CHECKINT_OVERFLOW_ERROR;", "  return x + y;", "}", "", "__CHECKINT_INLINE int64_t", "__checkint_int64_add_unsigned_signed(uint64_t x, int64_t y, int32_t* err) {", "   return __checkint_int64_add_signed_unsigned(y, x, err);", "}", "", "__CHECKINT_INLINE int64_t", "__checkint_int64_add_unsigned_unsigned(uint64_t x, uint64_t y, int32_t* err) {", " int64_t diff = LLONG_MAX - y;", "   if(diff < 0 || ((uint64_t) diff) < x)", "        *err = *err | CHECKINT_OVERFLOW_ERROR;", "   return x + y;", "}", "", "__CHECKINT_INLINE uint64_t", "__checkint_uint64_add_unsigned_unsigned(uint64_t x, uint64_t y, int32_t* err) {", "   if((ULLONG_MAX - y) < x)", "        *err = *err | CHECKINT_OVERFLOW_ERROR;", "   return x + y;", "}", "", "__CHECKINT_INLINE uint64_t", "__checkint_uint64_add_signed_signed(int64_t x, int64_t y, int32_t* err) {", "  if(((x < 0 && y >= 0) || (x >= 0 && y < 0)) && (x + y) < 0)", "        *err = *err | CHECKINT_OVERFLOW_ERROR;", "  else if(x < 0 && y < 0)", "        *err = *err | CHECKINT_OVERFLOW_ERROR;", "  return x + y;", "}", "", "__CHECKINT_INLINE uint64_t", "__checkint_uint64_add_signed_unsigned(int64_t x, uint64_t y, int32_t* err) {", "  if(x > 0)", "        return __checkint_uint64_add_unsigned_unsigned(x, y, err);", "  if((y < ((uint64_t)LLONG_MAX + 1)) && (((int64_t) (x + y)) < 0))", "           *err = *err | CHECKINT_OVERFLOW_ERROR;", "  return x + y;", "}", "", "__CHECKINT_INLINE uint64_t", "__checkint_uint64_add_unsigned_signed(uint64_t x, int64_t y, int32_t* err) {", "   return __checkint_uint64_add_signed_unsigned(y, x, err);", "}", "", "__CHECKINT_INLINE int32_t", "__checkint_int32_sub(int64_t x, int64_t y, int32_t* err) {", "\tif (x < INT32_MIN || x > INT32_MAX || y < INT32_MIN || y > INT32_MAX) {", "\t\t*err |= CHECKINT_OVERFLOW_ERROR;", "\t}", "\tint64_t z = x - y;", "\tif (z > INT_MAX || z < INT_MIN) *err |= CHECKINT_OVERFLOW_ERROR;", "\treturn (int32_t)z;", "}", "", "__CHECKINT_INLINE uint32_t", "__checkint_uint32_sub(int64_t x, int64_t y, int32_t* err) {", "\tint64_t z = x - y;", "\tif ((x & 0xffffffff00000000ull) || (y & 0xffffffff00000000ull)) *err |= CHECKINT_OVERFLOW_ERROR;", "\tif (z > UINT_MAX || z < 0) *err |= CHECKINT_OVERFLOW_ERROR;", "\treturn (uint32_t)z;", "}", "", "__CHECKINT_INLINE int64_t", "__checkint_int64_sub_signed_signed(int64_t x, int64_t y, int32_t* err) {", "  if(__checkint_is_mixed_sign64(x, y))", "  {", "     /* Positive x subtract a negative y */", "     if(x >= 0)", "     {", "            if(x > LLONG_MAX + y)", "                *err = *err | CHECKINT_OVERFLOW_ERROR;", "     }", "     /* Negative x subtract a positive y */", "     else", "     {", "            if(x < LLONG_MIN + y)", "                *err = *err | CHECKINT_OVERFLOW_ERROR;", "     }", "  }", "  /* Both negative, or both positive, no possible overflow */", "  return x - y;", "}", "", "__CHECKINT_INLINE int64_t", "__checkint_int64_sub_signed_unsigned(int64_t x, uint64_t y, int32_t* err) {", "  if(x < ((int64_t)(LLONG_MIN + y)))", "        *err = *err | CHECKINT_OVERFLOW_ERROR;", "  return x - y;", "}", "", "__CHECKINT_INLINE int64_t", "__checkint_int64_sub_unsigned_signed(uint64_t x, int64_t y, int32_t* err) {", "  if(x > ((uint64_t)(LLONG_MAX + y)) || y == LLONG_MIN)", "        *err = *err | CHECKINT_OVERFLOW_ERROR;", "  return x - y;", "}", "", "__CHECKINT_INLINE int64_t", "__checkint_int64_sub_unsigned_unsigned(uint64_t x, uint64_t y, int32_t* err) {", "   if(x > y && ((x - y) > LLONG_MAX))", "        *err = *err | CHECKINT_OVERFLOW_ERROR;", "   else if(x < y && ((y - x - 1) > LLONG_MAX))", "        *err = *err | CHECKINT_OVERFLOW_ERROR;", "   return x - y;", "}", "", "__CHECKINT_INLINE uint64_t", "__checkint_uint64_sub_signed_signed(int64_t x, int64_t y, int32_t* err) {", "  if(((x < 0 && y <= 0) || (x >= 0 && y > 0)) && (x - y) < 0)", "        *err = *err | CHECKINT_OVERFLOW_ERROR;", "  else if(x < 0 && y > 0)", "        *err = *err | CHECKINT_OVERFLOW_ERROR;", "  return x - y;", "} ", "", "__CHECKINT_INLINE uint64_t", "__checkint_uint64_sub_signed_unsigned(int64_t x, uint64_t y, int32_t* err) {", "   if(y > ((uint64_t) LLONG_MAX + 1) || ((int64_t) y) > x)", "        *err = *err | CHECKINT_OVERFLOW_ERROR;", "   return x - y;", "}", "", "__CHECKINT_INLINE uint64_t", "__checkint_uint64_sub_unsigned_signed(uint64_t x, int64_t y, int32_t* err) {", "  if(x <= LLONG_MAX)", "        return __checkint_uint64_sub_signed_signed(x, y, err);", "  else if (y == LLONG_MIN || -y > ULLONG_MAX - x)", "        *err = *err | CHECKINT_OVERFLOW_ERROR;", "  return x - y;", "}", "", "__CHECKINT_INLINE uint64_t", "__checkint_uint64_sub_unsigned_unsigned(uint64_t x, uint64_t y, int32_t* err) {", "   if(x < y)", "        *err = *err | CHECKINT_OVERFLOW_ERROR;", "   return x - y;", "}", "", "__CHECKINT_INLINE int32_t", "__checkint_int32_mul(int64_t x, int64_t y, int32_t* err) {", "\tint64_t z = x * y;", "\tif (x < INT32_MIN || x > INT32_MAX || y < INT32_MIN || y > INT32_MAX) {", "\t\t*err |= CHECKINT_OVERFLOW_ERROR;", "\t}", "\tif (z > INT_MAX || z < INT_MIN) *err |= CHECKINT_OVERFLOW_ERROR;", "\treturn (int32_t)z;", "}", "", "__CHECKINT_INLINE uint32_t", "__checkint_uint32_mul(int64_t x, int64_t y, int32_t* err) {", "\tint64_t z = x * y;", "\tif ((x & 0xffffffff00000000ull) || (y & 0xffffffff00000000ull)) *err |= CHECKINT_OVERFLOW_ERROR;", "\tif (z > UINT_MAX || z < 0) *err |= CHECKINT_OVERFLOW_ERROR;", "\treturn (uint32_t)z;", "}", "", "__CHECKINT_INLINE int64_t", "__checkint_int64_mul_signed_signed(int64_t x, int64_t y, int32_t* err) {", "  if(x == 0 || y == 0) return 0;", "", "  if(!__checkint_is_mixed_sign64(x, y))", "  {", "    if(x > 0)", "    {", "       if(LLONG_MAX/x < y)", "            *err = *err | CHECKINT_OVERFLOW_ERROR;", "    }", "    else", "    {", "       if(x == LLONG_MIN || y == LLONG_MIN)", "            *err = *err | CHECKINT_OVERFLOW_ERROR;", "       if(LLONG_MAX/(-x) < (-y))", "            *err = *err | CHECKINT_OVERFLOW_ERROR;", "    }", "  }", "  else", "  {", "    if(x < 0)", "    {", "       if(x < LLONG_MIN/y)", "            *err = *err | CHECKINT_OVERFLOW_ERROR;", "    }", "    else", "       if(y < LLONG_MIN/x)", "            *err = *err | CHECKINT_OVERFLOW_ERROR;", "  }", "  return x * y;", "}", "", "__CHECKINT_INLINE uint64_t", "__checkint_uint64_mul_unsigned_unsigned(uint64_t x, uint64_t y, int32_t* err) {", "  if(x == 0) return 0;", "       ", "  if(ULLONG_MAX/x < y)", "     *err = *err | CHECKINT_OVERFLOW_ERROR;", "  return x * y;", "}", "", "", "__CHECKINT_INLINE int64_t", "__checkint_int64_mul_unsigned_unsigned(uint64_t x, uint64_t y, int32_t* err) {", "  if(x == 0) return 0;", "       ", "  if(LLONG_MAX/x < y)", "     *err = *err | CHECKINT_OVERFLOW_ERROR;", "  return x * y;", "}", "", "__CHECKINT_INLINE int64_t", "__checkint_int64_mul_signed_unsigned(int64_t x, uint64_t y, int32_t* err) {", "  if(y == 0) return 0;", "     ", "  if(x >= 0)", "       return __checkint_int64_mul_unsigned_unsigned(x, y, err);", "  else", "       if(x < LLONG_MIN/y || x > LLONG_MAX/y)", "            *err = *err | CHECKINT_OVERFLOW_ERROR;", "  return x * y;", "}", "", "__CHECKINT_INLINE int64_t", "__checkint_int64_mul_unsigned_signed(uint64_t x, int64_t y, int32_t* err) {", "   return __checkint_int64_mul_signed_unsigned(y, x, err);", "}", "", "__CHECKINT_INLINE uint64_t", "__checkint_uint64_mul_signed_signed(int64_t x, int64_t y, int32_t* err) {", "  if((x < 0 && y > 0) || (x > 0 && y < 0))", "     *err = *err | CHECKINT_OVERFLOW_ERROR;", "  else if(x > 0 && y > 0)", "     return __checkint_uint64_mul_unsigned_unsigned(x, y, err);", "  else", "     return __checkint_uint64_mul_unsigned_unsigned(-x, -y, err);", "  return x * y;", "}", "", "__CHECKINT_INLINE uint64_t", "__checkint_uint64_mul_signed_unsigned(int64_t x, uint64_t y, int32_t* err) {", "  if(x >= 0)", "      return __checkint_uint64_mul_unsigned_unsigned(x, y, err);", "  *err = *err | CHECKINT_OVERFLOW_ERROR;", "  return (uint64_t) (x * y);", "}", "", "__CHECKINT_INLINE uint64_t", "__checkint_uint64_mul_unsigned_signed(uint64_t x, int64_t y, int32_t* err) {", "   return __checkint_uint64_mul_signed_unsigned(y, x, err);", "}", "", "__CHECKINT_INLINE int32_t", "__checkint_int32_div_signed_signed(int32_t x, int32_t y, int32_t* err) {", "   if((x == INT_MIN) && y == -1)", "        *err = *err | CHECKINT_OVERFLOW_ERROR;", "   return x / y;", "}", "", "__CHECKINT_INLINE int32_t", "__checkint_int32_div_signed_unsigned(int32_t x, uint32_t y, int32_t* err) {", "  if(y <= INT_MAX)", "        return x / (int32_t) y;", "  return 0;  ", "}", "", "__CHECKINT_INLINE int32_t", "__checkint_int32_div_unsigned_signed(uint32_t x, int32_t y, int32_t* err) {", "  if(x == ((uint32_t) INT_MAX + 1) && y == -1)", "\treturn INT_MIN;", "  if(x > ((uint32_t) INT_MAX + 1) && y == -1)", "                *err = *err | CHECKINT_OVERFLOW_ERROR;", "  else if(x > INT_MAX && y == 1)", "                *err = *err | CHECKINT_OVERFLOW_ERROR;", "  if(x <= INT_MAX)", "    return ((int32_t) x) / y;", "  if(y > 0)", "    return x / y;", "  return -(x / (uint32_t) -y);", "}", "", "__CHECKINT_INLINE int32_t", "__checkint_int32_div_unsigned_unsigned(uint32_t x, uint32_t y, int32_t* err) {", "   uint32_t result = x / y;", "   if(result > INT_MAX)", "        *err = *err | CHECKINT_OVERFLOW_ERROR;", "   return x / y;", "}", "", "__CHECKINT_INLINE uint32_t", "__checkint_uint32_div_signed_signed(int32_t x, int32_t y, int32_t* err) {", " int32_t result = x / y;", "   if(x == INT_MIN && y == -1)", "\treturn ((uint32_t) -x);", "   if(result < 0)", "        *err = *err | CHECKINT_OVERFLOW_ERROR;", "   if(x >= 0 && y > 0)", "     return x / y;", "   else if(x < 0 && y > 0)", "     return -((uint32_t) -x / y);", "   else if(x > 0 && y < 0)", "     return -(x / (uint32_t) -y);", "   else", "     return ((uint32_t) -x / (uint32_t) -y);", "}", "", "__CHECKINT_INLINE uint32_t", "__checkint_uint32_div_signed_unsigned(int32_t x, uint32_t y, int32_t* err) {", "   if(x < 0 && ((uint32_t) -x) >= y)", "        *err = *err | CHECKINT_OVERFLOW_ERROR;", "   if(x >= 0)", "   \treturn x / y;", "   return -(((uint32_t) -x) / y); ", "}", "", "__CHECKINT_INLINE uint32_t", "__checkint_uint32_div_unsigned_signed(uint32_t x, int32_t y, int32_t* err) {", "   if(y < 0 && ((uint32_t) -y) <= x)", "        *err = *err | CHECKINT_OVERFLOW_ERROR;", "   if(y > 0)", "     return x / y;", "   return -(x / ((uint32_t) -y));", "}", "", "__CHECKINT_INLINE uint32_t", "__checkint_uint32_div_unsigned_unsigned(uint32_t x, uint32_t y, int32_t* err) {", "   return x / y;", "}", "", "__CHECKINT_INLINE int64_t", "__checkint_int64_div_signed_signed(int64_t x, int64_t y, int32_t* err) {", "   if((x == LLONG_MIN) && y == -1)", "        *err = *err | CHECKINT_OVERFLOW_ERROR;", "   return x / y;", "}", "", "__CHECKINT_INLINE int64_t", "__checkint_int64_div_signed_unsigned(int64_t x, uint64_t y, int32_t* err) {", "  if(y <= LLONG_MAX)", "        return x / (int64_t) y;", "  return 0;  ", "}", "", "__CHECKINT_INLINE int64_t", "__checkint_int64_div_unsigned_signed(uint64_t x, int64_t y, int32_t* err) {", "  if(x == ((uint64_t) LLONG_MAX + 1) && y == -1)", "        return LLONG_MIN;", "  if(x > ((uint64_t) LLONG_MAX + 1) && y == -1)", "                *err = *err | CHECKINT_OVERFLOW_ERROR;", "  else if(x > LLONG_MAX && y == 1)", "                *err = *err | CHECKINT_OVERFLOW_ERROR;", "  if(x <= LLONG_MAX)", "    return ((int64_t) x) / y;", "  if(y > 0)", "    return x / y;", "  return -(x / (uint64_t) -y);", "}", "", "__CHECKINT_INLINE int64_t", "__checkint_int64_div_unsigned_unsigned(uint64_t x, uint64_t y, int32_t* err) {", "   uint64_t result = x / y;", "   if(result > LLONG_MAX)", "        *err = *err | CHECKINT_OVERFLOW_ERROR;", "   return x / y;", "}", "", "__CHECKINT_INLINE uint64_t", "__checkint_uint64_div_signed_signed(int64_t x, int64_t y, int32_t* err) {", " int64_t result = x / y;", "   if(x == LLONG_MIN && y == -1)", "\treturn ((uint64_t)LLONG_MAX) + 1;", "   if(result < 0)", "        *err = *err | CHECKINT_OVERFLOW_ERROR;", "   if(x >= 0 && y > 0)", "     return x / y;", "   else if(x < 0 && y > 0)", "     return -((uint64_t) -x / y);", "   else if(x > 0 && y < 0)", "     return -(x / (uint64_t) -y);", "   else", "     return ((uint64_t) -x / (uint64_t) -y);", "}", "", "__CHECKINT_INLINE uint64_t", "__checkint_uint64_div_signed_unsigned(int64_t x, uint64_t y, int32_t* err) {", "   if(x < 0 && ((uint64_t) -x) >= y)", "        *err = *err | CHECKINT_OVERFLOW_ERROR;", "   if(x >= 0)", "        return x / y;", "   return -(((uint64_t) -x) / y);", "}", "", "__CHECKINT_INLINE uint64_t", "__checkint_uint64_div_unsigned_signed(uint64_t x, int64_t y, int32_t* err) {", "   if(y < 0 && ((uint64_t) -y) <= x)", "        *err = *err | CHECKINT_OVERFLOW_ERROR;", "   if(y > 0)", "     return x / y;", "   return -(x / ((uint64_t) -y));", "}", "", "__CHECKINT_INLINE uint64_t", "__checkint_uint64_div_unsigned_unsigned(uint64_t x, uint64_t y, int32_t* err) {", "   return x / y;", "}", "", "#undef __CHECKINT_INLINE", "", "/******/", "", "#ifdef __GNUC__", "#define\t__checkint_same_type(e1, e2)\t__builtin_types_compatible_p(__typeof__(e1), __typeof__(e2))", "#define\t__checkint_cond_expr(c, e1, e2)\t__builtin_choose_expr(c, e1, e2)", "#else", '#error "need compiler support for __checkint_same_type() and __checkint_cond_expr()"', "#endif", "", "/******/", "", "#define __checkint_is_signed(x)\t\t(__checkint_same_type(x, int8_t) || __checkint_same_type(x, int16_t) || __checkint_same_type(x, int32_t) || __checkint_same_type(x, int64_t) || __checkint_same_type(x, signed long))", "#define __checkint_is_unsigned(x)\t(__checkint_same_type(x, uint8_t) || __checkint_same_type(x, uint16_t) || __checkint_same_type(x, uint32_t) || __checkint_same_type(x, uint64_t) || __checkint_same_type(x, uintptr_t) || __checkint_same_type(x, unsigned long))", "", "#define __checkint_is_signed_signed(x, y) (__checkint_is_signed(x) && __checkint_is_signed(y))", "#define __checkint_is_signed_unsigned(x, y) (__checkint_is_signed(x) && __checkint_is_unsigned(y))", "#define __checkint_is_unsigned_signed(x, y) (__checkint_is_unsigned(x) && __checkint_is_signed(y))", "#define __checkint_is_unsigned_unsigned(x, y) (__checkint_is_unsigned(x) && __checkint_is_unsigned(y))", "", "/******/", "", "#define __CHECKINT_SIGN_DEMUX(type,oper,x,y,err) \\", "\t(__checkint_cond_expr(__checkint_is_signed_signed(x, y), __checkint_ ## type ## _ ## oper ## _signed_signed(x, y, err), \\", "\t __checkint_cond_expr(__checkint_is_signed_unsigned(x, y), __checkint_ ## type ## _ ## oper ## _signed_unsigned(x, y, err), \\", "\t __checkint_cond_expr(__checkint_is_unsigned_signed(x, y), __checkint_ ## type ## _ ## oper ## _unsigned_signed(x, y, err), \\", "\t __checkint_cond_expr(__checkint_is_unsigned_unsigned(x, y), __checkint_ ## type ## _ ## oper ## _unsigned_unsigned(x, y, err), \\", "\t\t__checkint_ ## type ## _type_error(err))))))", "", "#define __checkint_int64_add(x,y,err) __CHECKINT_SIGN_DEMUX(int64,add,x,y,err)", "#define __checkint_uint64_add(x,y,err) __CHECKINT_SIGN_DEMUX(uint64,add,x,y,err)", "", "#define __checkint_int64_sub(x,y,err) __CHECKINT_SIGN_DEMUX(int64,sub,x,y,err)", "#define __checkint_uint64_sub(x,y,err) __CHECKINT_SIGN_DEMUX(uint64,sub,x,y,err)", "", "#define __checkint_int64_mul(x,y,err) __CHECKINT_SIGN_DEMUX(int64,mul,x,y,err)", "#define __checkint_uint64_mul(x,y,err) __CHECKINT_SIGN_DEMUX(uint64,mul,x,y,err)", "", "#define __checkint_int32_div(x,y,err) __CHECKINT_SIGN_DEMUX(int32,div,x,y,err)", "#define __checkint_int64_div(x,y,err) __CHECKINT_SIGN_DEMUX(int64,div,x,y,err)", "#define __checkint_uint32_div(x,y,err) __CHECKINT_SIGN_DEMUX(uint32,div,x,y,err)", "#define __checkint_uint64_div(x,y,err) __CHECKINT_SIGN_DEMUX(uint64,div,x,y,err)", "", "__END_DECLS", "", "#endif /* __CHECKINT_H__ */" },
    ["com_err.h"] = { "/* $Copyright:", " *", " * Copyright 1998-2000 by the Massachusetts Institute of Technology.", " * ", " * All rights reserved.", " * ", " * Permission to use, copy, modify, and distribute this software and its", " * documentation for any purpose and without fee is hereby granted,", " * provided that the above copyright notice appear in all copies and that", " * both that copyright notice and this permission notice appear in", " * supporting documentation, and that the name of M.I.T. not be used in", " * advertising or publicity pertaining to distribution of the software", " * without specific, written prior permission.  Furthermore if you modify", " * this software you must label your software as modified software and not", " * distribute it in such a fashion that it might be confused with the", " * original MIT software. M.I.T. makes no representations about the", ' * suitability of this software for any purpose.  It is provided "as is"', " * without express or implied warranty.", " * ", " * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED", " * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF", " * MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.", " * ", " * Individual source code files are copyright MIT, Cygnus Support,", " * OpenVision, Oracle, Sun Soft, FundsXpress, and others.", " * ", " * Project Athena, Athena, Athena MUSE, Discuss, Hesiod, Kerberos, Moira,", " * and Zephyr are trademarks of the Massachusetts Institute of Technology", " * (MIT).  No commercial use of these trademarks may be made without prior", " * written permission of MIT.", " * ", ' * "Commercial use" means use of a name in a product or other for-profit', " * manner.  It does NOT prevent a commercial firm from referring to the MIT", " * trademarks in order to convey information (although in doing so,", " * recognition of their trademark status should be given).", " * $", " */", "", "/* $Header$ */", "", "/* ", " *", " * KerberosComErr.h -- Functions to handle Kerberos errors.", " *", " */", "", "", "#ifndef __KERBEROSCOMERR__", "#define __KERBEROSCOMERR__", "", "#if defined(macintosh) || (defined(__MACH__) && defined(__APPLE__))", "#    include <TargetConditionals.h>", "#    if TARGET_RT_MAC_CFM", '#        error "Use KfM 4.0 SDK headers for CFM compilation."', "#    endif", "#endif", "", "#include <sys/types.h>", "#include <stdarg.h>", "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "", "typedef long errcode_t;", "typedef void (*com_err_handler_t)", "    (const char *whoami, errcode_t code, const char *format, va_list args);", "", "struct error_table {", "    const char * const * const messages;", "    int32_t base;", "    int32_t count;", "};", "", "/* ******************* */", "/* Function prototypes */", "/* ******************* */", "", "void com_err    (const char *progname, errcode_t code, const char *format, ...);", "void com_err_va (const char *progname, errcode_t code, const char *format, va_list args);", "", "const char *error_message (errcode_t code);", "const char *error_manager (errcode_t code);", "", "com_err_handler_t set_com_err_hook(com_err_handler_t handler);", "com_err_handler_t reset_com_err_hook(void);", "", "errcode_t add_error_table    (const struct error_table *et);", "errcode_t remove_error_table (const struct error_table *et);", "", "#ifdef __cplusplus", "}", "#endif", "", "#endif /* __KERBEROSCOMERR__ */" },
    ["complex.h"] = { "/*", " * Copyright (c) 2002 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * The contents of this file constitute Original Code as defined in and", " * are subject to the Apple Public Source License Version 1.1 (the", ' * "License").  You may not use this file except in compliance with the', " * License.  Please obtain a copy of the License at", " * http://www.apple.com/publicsource and read it before using this file.", " * ", " * This Original Code and all software distributed under the License are", ' * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER', " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the", " * License for the specific language governing rights and limitations", " * under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "", "/******************************************************************************", " *                                                                            *", " *     File:  complex.h                                                       *", " *                                                                            *", " *     Contains: prototypes and macros germane to C99 complex math.           *", " *                                                                            *", " ******************************************************************************/", "", "#ifndef __COMPLEX_H__", "#define __COMPLEX_H__", "", "#include <sys/cdefs.h>", "", "#undef complex", "#define complex _Complex", "#undef _Complex_I", "/*  Constant expression of type const float _Complex                          */", "#define _Complex_I (__extension__ 1.0iF)", "#undef I", "#define I _Complex_I", "", "#if (__STDC_VERSION__ > 199901L || __DARWIN_C_LEVEL >= __DARWIN_C_FULL) \\", "    && defined __clang__", "", "/*  Complex initializer macros.  These are a C11 feature, but are also provided", "    as an extension in C99 so long as strict POSIX conformance is not", "    requested.  They are available only when building with the llvm-clang", "    compiler, as there is no way to support them with the gcc-4.2 frontend.", "    These may be used for static initialization of complex values, like so:", " ", "        static const float complex someVariable = CMPLXF(1.0, INFINITY);", " ", "    they may, of course, be used outside of static contexts as well.          */", "", "#define  CMPLX(__real,__imag) \\", '    _Pragma("clang diagnostic push") \\', '    _Pragma("clang diagnostic ignored \\"-Wcomplex-component-init\\"") \\', "    (double _Complex){(__real),(__imag)} \\", '    _Pragma("clang diagnostic pop")', "", "#define CMPLXF(__real,__imag) \\", '    _Pragma("clang diagnostic push") \\', '    _Pragma("clang diagnostic ignored \\"-Wcomplex-component-init\\"") \\', "    (float _Complex){(__real),(__imag)} \\", '    _Pragma("clang diagnostic pop")', "", "#define CMPLXL(__real,__imag) \\", '    _Pragma("clang diagnostic push") \\', '    _Pragma("clang diagnostic ignored \\"-Wcomplex-component-init\\"") \\', "    (long double _Complex){(__real),(__imag)} \\", '    _Pragma("clang diagnostic pop")', "", "#endif /* End C11 features.                                                   */", "", "__BEGIN_DECLS", "extern float complex cacosf(float complex);", "extern double complex cacos(double complex);", "extern long double complex cacosl(long double complex);", "", "extern float complex casinf(float complex);", "extern double complex casin(double complex);", "extern long double complex casinl(long double complex);", "", "extern float complex catanf(float complex);", "extern double complex catan(double complex);", "extern long double complex catanl(long double complex);", "", "extern float complex ccosf(float complex);", "extern double complex ccos(double complex);", "extern long double complex ccosl(long double complex);", "", "extern float complex csinf(float complex);", "extern double complex csin(double complex);", "extern long double complex csinl(long double complex);", "", "extern float complex ctanf(float complex);", "extern double complex ctan(double complex);", "extern long double complex ctanl(long double complex);", "", "extern float complex cacoshf(float complex);", "extern double complex cacosh(double complex);", "extern long double complex cacoshl(long double complex);", "", "extern float complex casinhf(float complex);", "extern double complex casinh(double complex);", "extern long double complex casinhl(long double complex);", "", "extern float complex catanhf(float complex);", "extern double complex catanh(double complex);", "extern long double complex catanhl(long double complex);", "", "extern float complex ccoshf(float complex);", "extern double complex ccosh(double complex);", "extern long double complex ccoshl(long double complex);", "", "extern float complex csinhf(float complex);", "extern double complex csinh(double complex);", "extern long double complex csinhl(long double complex);", "", "extern float complex ctanhf(float complex);", "extern double complex ctanh(double complex);", "extern long double complex ctanhl(long double complex);", "", "extern float complex cexpf(float complex);", "extern double complex cexp(double complex);", "extern long double complex cexpl(long double complex);", "", "extern float complex clogf(float complex);", "extern double complex clog(double complex);", "extern long double complex clogl(long double complex);", "", "extern float cabsf(float complex);", "extern double cabs(double complex);", "extern long double cabsl(long double complex);", "", "extern float complex cpowf(float complex, float complex);", "extern double complex cpow(double complex, double complex);", "extern long double complex cpowl(long double complex, long double complex);", "", "extern float complex csqrtf(float complex);", "extern double complex csqrt(double complex);", "extern long double complex csqrtl(long double complex);", "", "extern float cargf(float complex);", "extern double carg(double complex);", "extern long double cargl(long double complex);", "", "extern float cimagf(float complex);", "extern double cimag(double complex);", "extern long double cimagl(long double complex);", "", "extern float complex conjf(float complex);", "extern double complex conj(double complex);", "extern long double complex conjl(long double complex);", "", "extern float complex cprojf(float complex);", "extern double complex cproj(double complex);", "extern long double complex cprojl(long double complex);", "", "extern float crealf(float complex);", "extern double creal(double complex);", "extern long double creall(long double complex);", "__END_DECLS", "", "#endif /* __COMPLEX_H__ */" },
    ["copyfile.h"] = { "/*", " * Copyright (c) 2004-2010 Apple, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "#ifndef _COPYFILE_H_ /* version 0.1 */", "#define _COPYFILE_H_", "", "/*", " * this is an API to faciliatate copying of files and their", " * associated metadata.  There are several open source projects that", " * need modifications to support preserving extended attributes and", " * acls and this API collapses several hundred lines of modifications", " * into one or two calls.", " *", " * This implementation is incomplete and the interface may change in a ", " * future release.", " */", "", "/* private */", "#include <sys/cdefs.h>", "#include <stdint.h>", "", "__BEGIN_DECLS", "struct _copyfile_state;", "typedef struct _copyfile_state * copyfile_state_t;", "typedef uint32_t copyfile_flags_t;", "", "/* public */", "", "/* receives:", " *   from\tpath to source file system object", " *   to\t\tpath to destination file system object", " *   state\topaque blob for future extensibility", " *\t\tMust be NULL in current implementation", " *   flags\t(described below)", " * returns:", " *   int\tnegative for error", " */", "", "int copyfile(const char *from, const char *to, copyfile_state_t state, copyfile_flags_t flags);", "int fcopyfile(int from_fd, int to_fd, copyfile_state_t, copyfile_flags_t flags);", "", "int copyfile_state_free(copyfile_state_t);", "copyfile_state_t copyfile_state_alloc(void);", "", "", "int copyfile_state_get(copyfile_state_t s, uint32_t flag, void * dst);", "int copyfile_state_set(copyfile_state_t s, uint32_t flag, const void * src);", "", "typedef int (*copyfile_callback_t)(int, int, copyfile_state_t, const char *, const char *, void *);", "", "#define COPYFILE_STATE_SRC_FD\t\t1", "#define COPYFILE_STATE_SRC_FILENAME\t2", "#define COPYFILE_STATE_DST_FD\t\t3", "#define COPYFILE_STATE_DST_FILENAME\t4", "#define COPYFILE_STATE_QUARANTINE\t5", "#define\tCOPYFILE_STATE_STATUS_CB\t6", "#define\tCOPYFILE_STATE_STATUS_CTX\t7", "#define\tCOPYFILE_STATE_COPIED\t\t8", "#define\tCOPYFILE_STATE_XATTRNAME\t9", "", "", '#define\tCOPYFILE_DISABLE_VAR\t"COPYFILE_DISABLE"', "", "/* flags for copyfile */", "", "#define COPYFILE_ACL\t    (1<<0)", "#define COPYFILE_STAT\t    (1<<1)", "#define COPYFILE_XATTR\t    (1<<2)", "#define COPYFILE_DATA\t    (1<<3)", "", "#define COPYFILE_SECURITY   (COPYFILE_STAT | COPYFILE_ACL)", "#define COPYFILE_METADATA   (COPYFILE_SECURITY | COPYFILE_XATTR)", "#define COPYFILE_ALL\t    (COPYFILE_METADATA | COPYFILE_DATA)", "", "#define\tCOPYFILE_RECURSIVE\t(1<<15)\t/* Descend into hierarchies */", "#define COPYFILE_CHECK\t\t(1<<16) /* return flags for xattr or acls if set */", "#define COPYFILE_EXCL\t\t(1<<17) /* fail if destination exists */", "#define COPYFILE_NOFOLLOW_SRC\t(1<<18) /* don't follow if source is a symlink */", "#define COPYFILE_NOFOLLOW_DST\t(1<<19) /* don't follow if dst is a symlink */", "#define COPYFILE_MOVE\t\t(1<<20) /* unlink src after copy */", "#define COPYFILE_UNLINK\t\t(1<<21) /* unlink dst before copy */", "#define COPYFILE_NOFOLLOW\t(COPYFILE_NOFOLLOW_SRC | COPYFILE_NOFOLLOW_DST)", "", "#define COPYFILE_PACK\t\t(1<<22)", "#define COPYFILE_UNPACK\t\t(1<<23)", "", "#define COPYFILE_VERBOSE\t(1<<30)", "", "#define\tCOPYFILE_RECURSE_ERROR\t0", "#define\tCOPYFILE_RECURSE_FILE\t1", "#define\tCOPYFILE_RECURSE_DIR\t2", "#define\tCOPYFILE_RECURSE_DIR_CLEANUP\t3", "#define\tCOPYFILE_COPY_DATA\t4", "#define\tCOPYFILE_COPY_XATTR\t5", "", "#define\tCOPYFILE_START\t\t1", "#define\tCOPYFILE_FINISH\t\t2", "#define\tCOPYFILE_ERR\t\t3", "#define\tCOPYFILE_PROGRESS\t4", "", "#define\tCOPYFILE_CONTINUE\t0", "#define\tCOPYFILE_SKIP\t1", "#define\tCOPYFILE_QUIT\t2", "", "__END_DECLS", "", "#endif /* _COPYFILE_H_ */" },
    ["cpio.h"] = { "/*-", " * Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>", " * All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " *", " * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " * $FreeBSD: src/include/cpio.h,v 1.1 2002/08/01 07:18:38 mike Exp $", " */", "", "#ifndef _CPIO_H_", "#define\t_CPIO_H_", "", "#define\tC_ISSOCK 0140000\t/* Socket. */", "#define\tC_ISLNK\t0120000\t\t/* Symbolic link. */", "#define\tC_ISCTG\t0110000\t\t/* Reserved. */", "#define\tC_ISREG\t0100000\t\t/* Regular file. */", "#define\tC_ISBLK\t0060000\t\t/* Block special. */", "#define\tC_ISDIR\t0040000\t\t/* Directory. */", "#define\tC_ISCHR\t0020000\t\t/* Character special. */", "#define\tC_ISFIFO 0010000\t/* FIFO. */", "#define\tC_ISUID\t0004000\t\t/* Set user ID. */", "#define\tC_ISGID\t0002000\t\t/* Set group ID. */", "#define\tC_ISVTX\t0001000\t\t/* On directories, restricted deletion flag. */", "#define\tC_IRUSR\t0000400\t\t/* Read by owner. */", "#define\tC_IWUSR\t0000200\t\t/* Write by owner. */", "#define\tC_IXUSR\t0000100\t\t/* Execute by owner. */", "#define\tC_IRGRP\t0000040\t\t/* Read by group. */", "#define\tC_IWGRP\t0000020\t\t/* Write by group. */", "#define\tC_IXGRP\t0000010\t\t/* Execute by group. */", "#define\tC_IROTH\t0000004\t\t/* Read by others. */", "#define\tC_IWOTH\t0000002\t\t/* Write by others. */", "#define\tC_IXOTH\t0000001\t\t/* Execute by others. */", "", '#define\tMAGIC\t"070707"', "", "#endif /* _CPIO_H_ */" },
    ["crt_externs.h"] = { "/*", " * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/*", " * Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved", " */", "", "/*", "** Prototypes for the functions to get environment information in", "** the world of dynamic libraries. Lifted from .c file of same name.", "** Fri Jun 23 12:56:47 PDT 1995", "** AOF (afreier@next.com)", "*/", "", "#include <sys/cdefs.h>", "", "__BEGIN_DECLS", "extern char ***_NSGetArgv(void);", "extern int *_NSGetArgc(void);", "extern char ***_NSGetEnviron(void);", "extern char **_NSGetProgname(void);", "#ifdef __LP64__", "extern struct mach_header_64 *", "#else /* !__LP64__ */", "extern struct mach_header *", "#endif /* __LP64__ */", "\t\t\t\t_NSGetMachExecuteHeader(void);", "__END_DECLS" },
    ["ctype.h"] = { "/*", " * Copyright (c) 2000, 2005, 2008 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/*", " * Copyright (c) 1989, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " * (c) UNIX System Laboratories, Inc.", " * All or some portions of this file are derived from material licensed", " * to the University of California by American Telephone and Telegraph", " * Co. or Unix System Laboratories, Inc. and are reproduced herein with", " * the permission of UNIX System Laboratories, Inc.", " *", " * This code is derived from software contributed to Berkeley by", " * Paul Borman at Krystal Technologies.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)ctype.h\t8.4 (Berkeley) 1/21/94", " */", "", "#ifndef\t_CTYPE_H_", "#define _CTYPE_H_", "", "#include <sys/cdefs.h>", "#include <runetype.h>", "", "#define\t_CTYPE_A\t0x00000100L\t\t/* Alpha */", "#define\t_CTYPE_C\t0x00000200L\t\t/* Control */", "#define\t_CTYPE_D\t0x00000400L\t\t/* Digit */", "#define\t_CTYPE_G\t0x00000800L\t\t/* Graph */", "#define\t_CTYPE_L\t0x00001000L\t\t/* Lower */", "#define\t_CTYPE_P\t0x00002000L\t\t/* Punct */", "#define\t_CTYPE_S\t0x00004000L\t\t/* Space */", "#define\t_CTYPE_U\t0x00008000L\t\t/* Upper */", "#define\t_CTYPE_X\t0x00010000L\t\t/* X digit */", "#define\t_CTYPE_B\t0x00020000L\t\t/* Blank */", "#define\t_CTYPE_R\t0x00040000L\t\t/* Print */", "#define\t_CTYPE_I\t0x00080000L\t\t/* Ideogram */", "#define\t_CTYPE_T\t0x00100000L\t\t/* Special */", "#define\t_CTYPE_Q\t0x00200000L\t\t/* Phonogram */", "#define\t_CTYPE_SW0\t0x20000000L\t\t/* 0 width character */", "#define\t_CTYPE_SW1\t0x40000000L\t\t/* 1 width character */", "#define\t_CTYPE_SW2\t0x80000000L\t\t/* 2 width character */", "#define\t_CTYPE_SW3\t0xc0000000L\t\t/* 3 width character */", "#define\t_CTYPE_SWM\t0xe0000000L\t\t/* Mask for screen width data */", "#define\t_CTYPE_SWS\t30\t\t\t/* Bits to shift to get width */", "", "#ifdef _NONSTD_SOURCE", "/*", " * Backward compatibility", " */", "#define\t_A\t\t_CTYPE_A\t\t/* Alpha */", "#define\t_C\t\t_CTYPE_C\t\t/* Control */", "#define\t_D\t\t_CTYPE_D\t\t/* Digit */", "#define\t_G\t\t_CTYPE_G\t\t/* Graph */", "#define\t_L\t\t_CTYPE_L\t\t/* Lower */", "#define\t_P\t\t_CTYPE_P\t\t/* Punct */", "#define\t_S\t\t_CTYPE_S\t\t/* Space */", "#define\t_U\t\t_CTYPE_U\t\t/* Upper */", "#define\t_X\t\t_CTYPE_X\t\t/* X digit */", "#define\t_B\t\t_CTYPE_B\t\t/* Blank */", "#define\t_R\t\t_CTYPE_R\t\t/* Print */", "#define\t_I\t\t_CTYPE_I\t\t/* Ideogram */", "#define\t_T\t\t_CTYPE_T\t\t/* Special */", "#define\t_Q\t\t_CTYPE_Q\t\t/* Phonogram */", "#define\t_SW0\t\t_CTYPE_SW0\t\t/* 0 width character */", "#define\t_SW1\t\t_CTYPE_SW1\t\t/* 1 width character */", "#define\t_SW2\t\t_CTYPE_SW2\t\t/* 2 width character */", "#define\t_SW3\t\t_CTYPE_SW3\t\t/* 3 width character */", "#endif /* _NONSTD_SOURCE */", "", "#define __DARWIN_CTYPE_inline\t\t__header_inline", "", "#define __DARWIN_CTYPE_TOP_inline\t__header_inline", "", "/*", " * Use inline functions if we are allowed to and the compiler supports them.", " */", "#if !defined(_DONT_USE_CTYPE_INLINE_) && \\", "    (defined(_USE_CTYPE_INLINE_) || defined(__GNUC__) || defined(__cplusplus))", "", "/* See comments in <machine/_type.h> about __darwin_ct_rune_t. */", "__BEGIN_DECLS", "unsigned long\t\t___runetype(__darwin_ct_rune_t);", "__darwin_ct_rune_t\t___tolower(__darwin_ct_rune_t);", "__darwin_ct_rune_t\t___toupper(__darwin_ct_rune_t);", "__END_DECLS", "", "__DARWIN_CTYPE_TOP_inline int", "isascii(int _c)", "{", "\treturn ((_c & ~0x7F) == 0);", "}", "", "#ifdef USE_ASCII", "__DARWIN_CTYPE_inline int     ", "__maskrune(__darwin_ct_rune_t _c, unsigned long _f)", "{", "\treturn _DefaultRuneLocale.__runetype[_c & 0xff] & _f;", "}", "#else /* !USE_ASCII */", "__BEGIN_DECLS", "int             \t__maskrune(__darwin_ct_rune_t, unsigned long);   ", "__END_DECLS", "#endif /* USE_ASCII */", "", "__DARWIN_CTYPE_inline int", "__istype(__darwin_ct_rune_t _c, unsigned long _f)", "{", "#ifdef USE_ASCII", "\treturn !!(__maskrune(_c, _f));", "#else /* USE_ASCII */", "\treturn (isascii(_c) ? !!(_DefaultRuneLocale.__runetype[_c] & _f)", "\t\t: !!__maskrune(_c, _f));", "#endif /* USE_ASCII */", "}", "", "__DARWIN_CTYPE_inline __darwin_ct_rune_t", "__isctype(__darwin_ct_rune_t _c, unsigned long _f)", "{", "#ifdef USE_ASCII", "\treturn !!(__maskrune(_c, _f));", "#else /* USE_ASCII */", "\treturn (_c < 0 || _c >= _CACHED_RUNES) ? 0 :", "\t\t!!(_DefaultRuneLocale.__runetype[_c] & _f);", "#endif /* USE_ASCII */", "}", "", "#ifdef USE_ASCII", "__DARWIN_CTYPE_inline __darwin_ct_rune_t", "__toupper(__darwin_ct_rune_t _c)", "{", "\treturn _DefaultRuneLocale.__mapupper[_c & 0xff];", "}", "", "__DARWIN_CTYPE_inline __darwin_ct_rune_t", "__tolower(__darwin_ct_rune_t _c)", "{", "\treturn _DefaultRuneLocale.__maplower[_c & 0xff];", "}", "#else /* !USE_ASCII */", "__BEGIN_DECLS", "__darwin_ct_rune_t\t__toupper(__darwin_ct_rune_t);", "__darwin_ct_rune_t\t__tolower(__darwin_ct_rune_t);", "__END_DECLS", "#endif /* USE_ASCII */", "", "__DARWIN_CTYPE_inline int", "__wcwidth(__darwin_ct_rune_t _c)", "{", "\tunsigned int _x;", "", "\tif (_c == 0)", "\t\treturn (0);", "\t_x = (unsigned int)__maskrune(_c, _CTYPE_SWM|_CTYPE_R);", "\tif ((_x & _CTYPE_SWM) != 0)", "\t\treturn ((_x & _CTYPE_SWM) >> _CTYPE_SWS);", "\treturn ((_x & _CTYPE_R) != 0 ? 1 : -1);", "}", "", "#ifndef _EXTERNALIZE_CTYPE_INLINES_", "", "#define\t_tolower(c)\t__tolower(c)", "#define\t_toupper(c)\t__toupper(c)", "", "__DARWIN_CTYPE_TOP_inline int", "isalnum(int _c)", "{", "\treturn (__istype(_c, _CTYPE_A|_CTYPE_D));", "}", "", "__DARWIN_CTYPE_TOP_inline int", "isalpha(int _c)", "{", "\treturn (__istype(_c, _CTYPE_A));", "}", "", "__DARWIN_CTYPE_TOP_inline int", "isblank(int _c)", "{", "\treturn (__istype(_c, _CTYPE_B));", "}", "", "__DARWIN_CTYPE_TOP_inline int", "iscntrl(int _c)", "{", "\treturn (__istype(_c, _CTYPE_C));", "}", "", "/* ANSI -- locale independent */", "__DARWIN_CTYPE_TOP_inline int", "isdigit(int _c)", "{", "\treturn (__isctype(_c, _CTYPE_D));", "}", "", "__DARWIN_CTYPE_TOP_inline int", "isgraph(int _c)", "{", "\treturn (__istype(_c, _CTYPE_G));", "}", "", "__DARWIN_CTYPE_TOP_inline int", "islower(int _c)", "{", "\treturn (__istype(_c, _CTYPE_L));", "}", "", "__DARWIN_CTYPE_TOP_inline int", "isprint(int _c)", "{", "\treturn (__istype(_c, _CTYPE_R));", "}", "", "__DARWIN_CTYPE_TOP_inline int", "ispunct(int _c)", "{", "\treturn (__istype(_c, _CTYPE_P));", "}", "", "__DARWIN_CTYPE_TOP_inline int", "isspace(int _c)", "{", "\treturn (__istype(_c, _CTYPE_S));", "}", "", "__DARWIN_CTYPE_TOP_inline int", "isupper(int _c)", "{", "\treturn (__istype(_c, _CTYPE_U));", "}", "", "/* ANSI -- locale independent */", "__DARWIN_CTYPE_TOP_inline int", "isxdigit(int _c)", "{", "\treturn (__isctype(_c, _CTYPE_X));", "}", "", "__DARWIN_CTYPE_TOP_inline int", "toascii(int _c)", "{", "\treturn (_c & 0x7F);", "}", "", "__DARWIN_CTYPE_TOP_inline int", "tolower(int _c)", "{", "        return (__tolower(_c));", "}", "", "__DARWIN_CTYPE_TOP_inline int", "toupper(int _c)", "{", "        return (__toupper(_c));", "}", "", "#if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))", "__DARWIN_CTYPE_TOP_inline int", "digittoint(int _c)", "{", "\treturn (__maskrune(_c, 0x0F));", "}", "", "__DARWIN_CTYPE_TOP_inline int", "ishexnumber(int _c)", "{", "\treturn (__istype(_c, _CTYPE_X));", "}", "", "__DARWIN_CTYPE_TOP_inline int", "isideogram(int _c)", "{", "\treturn (__istype(_c, _CTYPE_I));", "}", "", "__DARWIN_CTYPE_TOP_inline int", "isnumber(int _c)", "{", "\treturn (__istype(_c, _CTYPE_D));", "}", "", "__DARWIN_CTYPE_TOP_inline int", "isphonogram(int _c)", "{", "\treturn (__istype(_c, _CTYPE_Q));", "}", "", "__DARWIN_CTYPE_TOP_inline int", "isrune(int _c)", "{", "\treturn (__istype(_c, 0xFFFFFFF0L));", "}", "", "__DARWIN_CTYPE_TOP_inline int", "isspecial(int _c)", "{", "\treturn (__istype(_c, _CTYPE_T));", "}", "#endif /* !_ANSI_SOURCE && (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */", "#endif /* _EXTERNALIZE_CTYPE_INLINES_ */", "", "#else /* not using inlines */", "", "__BEGIN_DECLS", "int     isalnum(int);", "int     isalpha(int);", "int     isblank(int);", "int     iscntrl(int);", "int     isdigit(int);", "int     isgraph(int);", "int     islower(int);", "int     isprint(int);", "int     ispunct(int);", "int     isspace(int);", "int     isupper(int);", "int     isxdigit(int);", "int     tolower(int);", "int     toupper(int);", "int     isascii(int);", "int     toascii(int);", "", "#if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))", "int     _tolower(int);", "int     _toupper(int);", "int     digittoint(int);", "int     ishexnumber(int);", "int     isideogram(int);", "int     isnumber(int);", "int     isphonogram(int);", "int     isrune(int);", "int     isspecial(int);", "#endif", "__END_DECLS", "", "#endif /* using inlines */", "", "#ifdef _USE_EXTENDED_LOCALES_", "#include <xlocale/_ctype.h>", "#endif /* _USE_EXTENDED_LOCALES_ */", "", "#endif /* !_CTYPE_H_ */" },
    ["curses.h"] = { "/****************************************************************************", " * Copyright (c) 1998-2007,2008 Free Software Foundation, Inc.              *", " *                                                                          *", " * Permission is hereby granted, free of charge, to any person obtaining a  *", " * copy of this software and associated documentation files (the            *", ' * "Software"), to deal in the Software without restriction, including      *', " * without limitation the rights to use, copy, modify, merge, publish,      *", " * distribute, distribute with modifications, sublicense, and/or sell       *", " * copies of the Software, and to permit persons to whom the Software is    *", " * furnished to do so, subject to the following conditions:                 *", " *                                                                          *", " * The above copyright notice and this permission notice shall be included  *", " * in all copies or substantial portions of the Software.                   *", " *                                                                          *", ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *', " * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *", " * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *", " * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *", " * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *", " * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *", " * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *", " *                                                                          *", " * Except as contained in this notice, the name(s) of the above copyright   *", " * holders shall not be used in advertising or otherwise to promote the     *", " * sale, use or other dealings in this Software without prior written       *", " * authorization.                                                           *", " ****************************************************************************/", "", "/****************************************************************************", " *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *", " *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *", " *     and: Thomas E. Dickey                        1996-on                 *", " ****************************************************************************/", "", "/* $Id: curses.h.in,v 1.187 2008/08/30 20:11:29 tom Exp $ */", "", "#ifndef __NCURSES_H", "#define __NCURSES_H", "", "#define CURSES 1", "#define CURSES_H 1", "", "/* This should be defined for the enhanced functionality to be visible.", " * However, some of the wide-character (enhanced) functionality is missing.", " * So we do not define it (yet).", "#define _XOPEN_CURSES 1", " */", "", "/* These are defined only in curses.h, and are used for conditional compiles */", "#define NCURSES_VERSION_MAJOR 5", "#define NCURSES_VERSION_MINOR 7", "#define NCURSES_VERSION_PATCH 20081102", "", "/* This is defined in more than one ncurses header, for identification */", "#undef  NCURSES_VERSION", '#define NCURSES_VERSION "5.7"', "", "/*", " * Identify the mouse encoding version.", " */", "#define NCURSES_MOUSE_VERSION 1", "", "/*", " * Definitions to facilitate DLL's.", " */", "#include <ncurses_dll.h>", "", "/*", " * User-definable tweak to disable the include of <stdbool.h>.", " */", "#ifndef NCURSES_ENABLE_STDBOOL_H", "#define NCURSES_ENABLE_STDBOOL_H 1", "#endif", "", "/*", " * NCURSES_ATTR_T is used to quiet compiler warnings when building ncurses", " * configured using --disable-macros.", " */", "#ifdef NCURSES_NOMACROS", "#ifndef NCURSES_ATTR_T", "#define NCURSES_ATTR_T attr_t", "#endif", "#endif /* NCURSES_NOMACROS */", "", "#ifndef NCURSES_ATTR_T", "#define NCURSES_ATTR_T int", "#endif", "", "/*", " * Expands to 'const' if ncurses is configured using --enable-const.  Note that", " * doing so makes it incompatible with other implementations of X/Open Curses.", " */", "#undef  NCURSES_CONST", "#define NCURSES_CONST /*nothing*/", "", "#undef NCURSES_INLINE", "#define NCURSES_INLINE inline", "", "/*", " * The internal type used for color values", " */", "#undef\tNCURSES_COLOR_T", "#define\tNCURSES_COLOR_T short", "", "/*", " * Definition used to make WINDOW and similar structs opaque.", " */", "#ifndef NCURSES_OPAQUE", "#define NCURSES_OPAQUE 1", "#endif", "", "/*", " * The internal type used for window dimensions.", " */", "#undef\tNCURSES_SIZE_T", "#define\tNCURSES_SIZE_T short", "", "/*", " * Control whether tparm() supports varargs or fixed-parameter list.", " */", "#undef NCURSES_TPARM_VARARGS", "#define NCURSES_TPARM_VARARGS 1", "", "/*", " * NCURSES_CH_T is used in building the library, but not used otherwise in", " * this header file, since that would make the normal/wide-character versions", " * of the header incompatible.", " */", "#undef\tNCURSES_CH_T", "#define NCURSES_CH_T cchar_t", "", "#if 0 && defined(_LP64)", "typedef unsigned chtype;", "typedef unsigned mmask_t;", "#else", "typedef unsigned int chtype;", "typedef unsigned long mmask_t;", "#endif", "", "#include <stdio.h>", "#include <unctrl.h>", "#include <stdarg.h>\t/* we need va_list */", "#ifdef _XOPEN_SOURCE_EXTENDED", "#include <stddef.h>\t/* we want wchar_t */", "#endif /* _XOPEN_SOURCE_EXTENDED */", "", "/* X/Open and SVr4 specify that curses implements 'bool'.  However, C++ may also", " * implement it.  If so, we must use the C++ compiler's type to avoid conflict", " * with other interfaces.", " *", " * A further complication is that <stdbool.h> may declare 'bool' to be a", " * different type, such as an enum which is not necessarily compatible with", " * C++.  If we have <stdbool.h>, make 'bool' a macro, so users may #undef it.", " * Otherwise, let it remain a typedef to avoid conflicts with other #define's.", " * In either case, make a typedef for NCURSES_BOOL which can be used if needed", " * from either C or C++.", " */", "", "#undef TRUE", "#define TRUE    1", "", "#undef FALSE", "#define FALSE   0", "", "typedef unsigned char NCURSES_BOOL;", "", "#if defined(__cplusplus)\t/* __cplusplus, etc. */", "", "/* use the C++ compiler's bool type */", "#define NCURSES_BOOL bool", "", "#else\t\t\t/* c89, c99, etc. */", "", "#if NCURSES_ENABLE_STDBOOL_H", "#include <stdbool.h>", "/* use whatever the C compiler decides bool really is */", "#define NCURSES_BOOL bool", "#else", "/* there is no predefined bool - use our own */", "#undef bool", "#define bool NCURSES_BOOL", "#endif", "", "#endif /* !__cplusplus, etc. */", "", "#ifdef __cplusplus", 'extern "C" {', "#define NCURSES_CAST(type,value) static_cast<type>(value)", "#else", "#define NCURSES_CAST(type,value) (type)(value)", "#endif", "", "/*", " * X/Open attributes.  In the ncurses implementation, they are identical to the", " * A_ attributes.", " */", "#define WA_ATTRIBUTES\tA_ATTRIBUTES", "#define WA_NORMAL\tA_NORMAL", "#define WA_STANDOUT\tA_STANDOUT", "#define WA_UNDERLINE\tA_UNDERLINE", "#define WA_REVERSE\tA_REVERSE", "#define WA_BLINK\tA_BLINK", "#define WA_DIM\t\tA_DIM", "#define WA_BOLD\t\tA_BOLD", "#define WA_ALTCHARSET\tA_ALTCHARSET", "#define WA_INVIS\tA_INVIS", "#define WA_PROTECT\tA_PROTECT", "#define WA_HORIZONTAL\tA_HORIZONTAL", "#define WA_LEFT\t\tA_LEFT", "#define WA_LOW\t\tA_LOW", "#define WA_RIGHT\tA_RIGHT", "#define WA_TOP\t\tA_TOP", "#define WA_VERTICAL\tA_VERTICAL", "", "/* colors */", "#define COLOR_BLACK\t0", "#define COLOR_RED\t1", "#define COLOR_GREEN\t2", "#define COLOR_YELLOW\t3", "#define COLOR_BLUE\t4", "#define COLOR_MAGENTA\t5", "#define COLOR_CYAN\t6", "#define COLOR_WHITE\t7", "", "/* line graphics */", "", "#if 0 || 0", "NCURSES_WRAPPED_VAR(chtype*, acs_map);", "#define acs_map (_nc_acs_map())", "#else", "extern NCURSES_EXPORT_VAR(chtype) acs_map[];", "#endif", "", "#define NCURSES_ACS(c)\t(acs_map[NCURSES_CAST(unsigned char,c)])", "", "/* VT100 symbols begin here */", "#define ACS_ULCORNER\tNCURSES_ACS('l') /* upper left corner */", "#define ACS_LLCORNER\tNCURSES_ACS('m') /* lower left corner */", "#define ACS_URCORNER\tNCURSES_ACS('k') /* upper right corner */", "#define ACS_LRCORNER\tNCURSES_ACS('j') /* lower right corner */", "#define ACS_LTEE\tNCURSES_ACS('t') /* tee pointing right */", "#define ACS_RTEE\tNCURSES_ACS('u') /* tee pointing left */", "#define ACS_BTEE\tNCURSES_ACS('v') /* tee pointing up */", "#define ACS_TTEE\tNCURSES_ACS('w') /* tee pointing down */", "#define ACS_HLINE\tNCURSES_ACS('q') /* horizontal line */", "#define ACS_VLINE\tNCURSES_ACS('x') /* vertical line */", "#define ACS_PLUS\tNCURSES_ACS('n') /* large plus or crossover */", "#define ACS_S1\t\tNCURSES_ACS('o') /* scan line 1 */", "#define ACS_S9\t\tNCURSES_ACS('s') /* scan line 9 */", "#define ACS_DIAMOND\tNCURSES_ACS('`') /* diamond */", "#define ACS_CKBOARD\tNCURSES_ACS('a') /* checker board (stipple) */", "#define ACS_DEGREE\tNCURSES_ACS('f') /* degree symbol */", "#define ACS_PLMINUS\tNCURSES_ACS('g') /* plus/minus */", "#define ACS_BULLET\tNCURSES_ACS('~') /* bullet */", "/* Teletype 5410v1 symbols begin here */", "#define ACS_LARROW\tNCURSES_ACS(',') /* arrow pointing left */", "#define ACS_RARROW\tNCURSES_ACS('+') /* arrow pointing right */", "#define ACS_DARROW\tNCURSES_ACS('.') /* arrow pointing down */", "#define ACS_UARROW\tNCURSES_ACS('-') /* arrow pointing up */", "#define ACS_BOARD\tNCURSES_ACS('h') /* board of squares */", "#define ACS_LANTERN\tNCURSES_ACS('i') /* lantern symbol */", "#define ACS_BLOCK\tNCURSES_ACS('0') /* solid square block */", "/*", " * These aren't documented, but a lot of System Vs have them anyway", " * (you can spot pprryyzz{{||}} in a lot of AT&T terminfo strings).", " * The ACS_names may not match AT&T's, our source didn't know them.", " */", "#define ACS_S3\t\tNCURSES_ACS('p') /* scan line 3 */", "#define ACS_S7\t\tNCURSES_ACS('r') /* scan line 7 */", "#define ACS_LEQUAL\tNCURSES_ACS('y') /* less/equal */", "#define ACS_GEQUAL\tNCURSES_ACS('z') /* greater/equal */", "#define ACS_PI\t\tNCURSES_ACS('{') /* Pi */", "#define ACS_NEQUAL\tNCURSES_ACS('|') /* not equal */", "#define ACS_STERLING\tNCURSES_ACS('}') /* UK pound sign */", "", "/*", " * Line drawing ACS names are of the form ACS_trbl, where t is the top, r", " * is the right, b is the bottom, and l is the left.  t, r, b, and l might", " * be B (blank), S (single), D (double), or T (thick).  The subset defined", " * here only uses B and S.", " */", "#define ACS_BSSB\tACS_ULCORNER", "#define ACS_SSBB\tACS_LLCORNER", "#define ACS_BBSS\tACS_URCORNER", "#define ACS_SBBS\tACS_LRCORNER", "#define ACS_SBSS\tACS_RTEE", "#define ACS_SSSB\tACS_LTEE", "#define ACS_SSBS\tACS_BTEE", "#define ACS_BSSS\tACS_TTEE", "#define ACS_BSBS\tACS_HLINE", "#define ACS_SBSB\tACS_VLINE", "#define ACS_SSSS\tACS_PLUS", "", "#undef\tERR", "#define ERR     (-1)", "", "#undef\tOK", "#define OK      (0)", "", "/* values for the _flags member */", "#define _SUBWIN         0x01\t/* is this a sub-window? */", "#define _ENDLINE        0x02\t/* is the window flush right? */", "#define _FULLWIN        0x04\t/* is the window full-screen? */", "#define _SCROLLWIN      0x08\t/* bottom edge is at screen bottom? */", "#define _ISPAD\t        0x10\t/* is this window a pad? */", "#define _HASMOVED       0x20\t/* has cursor moved since last refresh? */", "#define _WRAPPED        0x40\t/* cursor was just wrappped */", "", "/*", " * this value is used in the firstchar and lastchar fields to mark", " * unchanged lines", " */", "#define _NOCHANGE       -1", "", "/*", " * this value is used in the oldindex field to mark lines created by insertions", " * and scrolls.", " */", "#define _NEWINDEX\t-1", "", "typedef struct screen  SCREEN;", "typedef struct _win_st WINDOW;", "", "typedef\tchtype\tattr_t;\t\t/* ...must be at least as wide as chtype */", "", "#ifdef _XOPEN_SOURCE_EXTENDED", "", "#if 0", "#ifdef mblen\t\t\t/* libutf8.h defines it w/o undefining first */", "#undef mblen", "#endif", "#include <libutf8.h>", "#endif", "", "#if 1", "#include <wchar.h>\t\t/* ...to get mbstate_t, etc. */", "#endif", "", "#if 0", "typedef unsigned short wchar_t1;", "#endif", "", "#if 0", "typedef unsigned int wint_t1;", "#endif", "", "#define CCHARW_MAX\t5", "typedef struct", "{", "    attr_t\tattr;", "    wchar_t\tchars[CCHARW_MAX];", "#if 0", "#undef NCURSES_EXT_COLORS", "#define NCURSES_EXT_COLORS 20081102", "    int\t\text_color;\t/* color pair, must be more than 16-bits */", "#endif", "}", "cchar_t;", "", "#endif /* _XOPEN_SOURCE_EXTENDED */", "", "#if !NCURSES_OPAQUE", "struct ldat;", "", "struct _win_st", "{", "\tNCURSES_SIZE_T _cury, _curx; /* current cursor position */", "", "\t/* window location and size */", "\tNCURSES_SIZE_T _maxy, _maxx; /* maximums of x and y, NOT window size */", "\tNCURSES_SIZE_T _begy, _begx; /* screen coords of upper-left-hand corner */", "", "\tshort   _flags;\t\t/* window state flags */", "", "\t/* attribute tracking */", "\tattr_t  _attrs;\t\t/* current attribute for non-space character */", "\tchtype  _bkgd;\t\t/* current background char/attribute pair */", "", "\t/* option values set by user */", "\tbool\t_notimeout;\t/* no time out on function-key entry? */", "\tbool\t_clear;\t\t/* consider all data in the window invalid? */", "\tbool\t_leaveok;\t/* OK to not reset cursor on exit? */", "\tbool\t_scroll;\t/* OK to scroll this window? */", "\tbool\t_idlok;\t\t/* OK to use insert/delete line? */", "\tbool\t_idcok;\t\t/* OK to use insert/delete char? */", "\tbool\t_immed;\t\t/* window in immed mode? (not yet used) */", "\tbool\t_sync;\t\t/* window in sync mode? */", "\tbool\t_use_keypad;\t/* process function keys into KEY_ symbols? */", "\tint\t_delay;\t\t/* 0 = nodelay, <0 = blocking, >0 = delay */", "", "\tstruct ldat *_line;\t/* the actual line data */", "", "\t/* global screen state */", "\tNCURSES_SIZE_T _regtop;\t/* top line of scrolling region */", "\tNCURSES_SIZE_T _regbottom; /* bottom line of scrolling region */", "", "\t/* these are used only if this is a sub-window */", "\tint\t_parx;\t\t/* x coordinate of this window in parent */", "\tint\t_pary;\t\t/* y coordinate of this window in parent */", "\tWINDOW\t*_parent;\t/* pointer to parent if a sub-window */", "", "\t/* these are used only if this is a pad */", "\tstruct pdat", "\t{", "\t    NCURSES_SIZE_T _pad_y,      _pad_x;", "\t    NCURSES_SIZE_T _pad_top,    _pad_left;", "\t    NCURSES_SIZE_T _pad_bottom, _pad_right;", "\t} _pad;", "", "\tNCURSES_SIZE_T _yoffset; /* real begy is _begy + _yoffset */", "", "#ifdef _XOPEN_SOURCE_EXTENDED", "\tcchar_t  _bkgrnd;\t/* current background char/attribute pair */", "#if 0", "\tint\t_color;\t\t/* current color-pair for non-space character */", "#endif", "#endif", "};", "#endif /* NCURSES_OPAQUE */", "", "/*", " * This is an extension to support events...", " */", "#if 1", "#ifdef NCURSES_WGETCH_EVENTS", "#if !defined(__BEOS__) || defined(__HAIKU__)", "   /* Fix _nc_timed_wait() on BEOS... */", "#  define NCURSES_EVENT_VERSION\t1", "#endif\t/* !defined(__BEOS__) */", "", "/*", " * Bits to set in _nc_event.data.flags", " */", "#  define _NC_EVENT_TIMEOUT_MSEC\t1", "#  define _NC_EVENT_FILE\t\t2", "#  define _NC_EVENT_FILE_READABLE\t2", "#  if 0\t\t\t\t\t/* Not supported yet... */", "#    define _NC_EVENT_FILE_WRITABLE\t4", "#    define _NC_EVENT_FILE_EXCEPTION\t8", "#  endif", "", "typedef struct", "{", "    int type;", "    union", "    {", "\tlong timeout_msec;\t/* _NC_EVENT_TIMEOUT_MSEC */", "\tstruct", "\t{", "\t    unsigned int flags;", "\t    int fd;", "\t    unsigned int result;", "\t} fev;\t\t\t\t/* _NC_EVENT_FILE */", "    } data;", "} _nc_event;", "", "typedef struct", "{", "    int count;", "    int result_flags;\t/* _NC_EVENT_TIMEOUT_MSEC or _NC_EVENT_FILE_READABLE */", "    _nc_event *events[1];", "} _nc_eventlist;", "", "extern NCURSES_EXPORT(int) wgetch_events(WINDOW *, _nc_eventlist *);\t/* experimental */", "extern NCURSES_EXPORT(int) wgetnstr_events(WINDOW *,char *,int,_nc_eventlist *);/* experimental */", "", "#endif /* NCURSES_WGETCH_EVENTS */", "#endif /* NCURSES_EXT_FUNCS */", "", "/*", " * GCC (and some other compilers) define '__attribute__'; we're using this", " * macro to alert the compiler to flag inconsistencies in printf/scanf-like", " * function calls.  Just in case '__attribute__' isn't defined, make a dummy.", " * Old versions of G++ do not accept it anyway, at least not consistently with", " * GCC.", " */", "#if !(defined(__GNUC__) || defined(__GNUG__) || defined(__attribute__))", "#define __attribute__(p) /* nothing */", "#endif", "", "/*", " * We cannot define these in ncurses_cfg.h, since they require parameters to be", " * passed (that is non-portable).  If you happen to be using gcc with warnings", " * enabled, define", " *\tGCC_PRINTF", " *\tGCC_SCANF", " * to improve checking of calls to printw(), etc.", " */", "#ifndef GCC_PRINTFLIKE", "#if defined(GCC_PRINTF) && !defined(printf)", "#define GCC_PRINTFLIKE(fmt,var) __attribute__((format(printf,fmt,var)))", "#else", "#define GCC_PRINTFLIKE(fmt,var) /*nothing*/", "#endif", "#endif", "", "#ifndef GCC_SCANFLIKE", "#if defined(GCC_SCANF) && !defined(scanf)", "#define GCC_SCANFLIKE(fmt,var)  __attribute__((format(scanf,fmt,var)))", "#else", "#define GCC_SCANFLIKE(fmt,var)  /*nothing*/", "#endif", "#endif", "", "#ifndef\tGCC_NORETURN", "#define\tGCC_NORETURN /* nothing */", "#endif", "", "#ifndef\tGCC_UNUSED", "#define\tGCC_UNUSED /* nothing */", "#endif", "", "/*", " * Function prototypes.  This is the complete X/Open Curses list of required", " * functions.  Those marked `generated' will have sources generated from the", " * macro definitions later in this file, in order to satisfy XPG4.2", " * requirements.", " */", "", "extern NCURSES_EXPORT(int) addch (const chtype);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) addchnstr (const chtype *, int);\t\t/* generated */", "extern NCURSES_EXPORT(int) addchstr (const chtype *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) addnstr (const char *, int);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) addstr (const char *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) attroff (NCURSES_ATTR_T);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) attron (NCURSES_ATTR_T);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) attrset (NCURSES_ATTR_T);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) attr_get (attr_t *, short *, void *);\t/* generated */", "extern NCURSES_EXPORT(int) attr_off (attr_t, void *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) attr_on (attr_t, void *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) attr_set (attr_t, short, void *);\t\t/* generated */", "extern NCURSES_EXPORT(int) baudrate (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) beep  (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) bkgd (chtype);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(void) bkgdset (chtype);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) border (chtype,chtype,chtype,chtype,chtype,chtype,chtype,chtype);\t/* generated */", "extern NCURSES_EXPORT(int) box (WINDOW *, chtype, chtype);\t\t/* generated */", "extern NCURSES_EXPORT(bool) can_change_color (void);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) cbreak (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) chgat (int, attr_t, short, const void *);\t/* generated */", "extern NCURSES_EXPORT(int) clear (void);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) clearok (WINDOW *,bool);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) clrtobot (void);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) clrtoeol (void);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) color_content (short,short*,short*,short*);\t/* implemented */", "extern NCURSES_EXPORT(int) color_set (short,void*);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) COLOR_PAIR (int);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) copywin (const WINDOW*,WINDOW*,int,int,int,int,int,int,int);\t/* implemented */", "extern NCURSES_EXPORT(int) curs_set (int);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) def_prog_mode (void);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) def_shell_mode (void);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) delay_output (int);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) delch (void);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(void) delscreen (SCREEN *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) delwin (WINDOW *);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) deleteln (void);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(WINDOW *) derwin (WINDOW *,int,int,int,int);\t/* implemented */", "extern NCURSES_EXPORT(int) doupdate (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(WINDOW *) dupwin (WINDOW *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) echo (void);\t\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) echochar (const chtype);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) erase (void);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) endwin (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(char) erasechar (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(void) filter (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) flash (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) flushinp (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(chtype) getbkgd (WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) getch (void);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) getnstr (char *, int);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) getstr (char *);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(WINDOW *) getwin (FILE *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) halfdelay (int);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(bool) has_colors (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(bool) has_ic (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(bool) has_il (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) hline (chtype, int);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(void) idcok (WINDOW *, bool);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) idlok (WINDOW *, bool);\t\t\t/* implemented */", "extern NCURSES_EXPORT(void) immedok (WINDOW *, bool);\t\t\t/* implemented */", "extern NCURSES_EXPORT(chtype) inch (void);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) inchnstr (chtype *, int);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) inchstr (chtype *);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(WINDOW *) initscr (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) init_color (short,short,short,short);\t/* implemented */", "extern NCURSES_EXPORT(int) init_pair (short,short,short);\t\t/* implemented */", "extern NCURSES_EXPORT(int) innstr (char *, int);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) insch (chtype);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) insdelln (int);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) insertln (void);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) insnstr (const char *, int);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) insstr (const char *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) instr (char *);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) intrflush (WINDOW *,bool);\t\t\t/* implemented */", "extern NCURSES_EXPORT(bool) isendwin (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(bool) is_linetouched (WINDOW *,int);\t\t/* implemented */", "extern NCURSES_EXPORT(bool) is_wintouched (WINDOW *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(NCURSES_CONST char *) keyname (int);\t\t/* implemented */", "extern NCURSES_EXPORT(int) keypad (WINDOW *,bool);\t\t\t/* implemented */", "extern NCURSES_EXPORT(char) killchar (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) leaveok (WINDOW *,bool);\t\t\t/* implemented */", "extern NCURSES_EXPORT(char *) longname (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) meta (WINDOW *,bool);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) move (int, int);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) mvaddch (int, int, const chtype);\t\t/* generated */", "extern NCURSES_EXPORT(int) mvaddchnstr (int, int, const chtype *, int);\t/* generated */", "extern NCURSES_EXPORT(int) mvaddchstr (int, int, const chtype *);\t/* generated */", "extern NCURSES_EXPORT(int) mvaddnstr (int, int, const char *, int);\t/* generated */", "extern NCURSES_EXPORT(int) mvaddstr (int, int, const char *);\t\t/* generated */", "extern NCURSES_EXPORT(int) mvchgat (int, int, int, attr_t, short, const void *);\t/* generated */", "extern NCURSES_EXPORT(int) mvcur (int,int,int,int);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) mvdelch (int, int);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) mvderwin (WINDOW *, int, int);\t\t/* implemented */", "extern NCURSES_EXPORT(int) mvgetch (int, int);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) mvgetnstr (int, int, char *, int);\t\t/* generated */", "extern NCURSES_EXPORT(int) mvgetstr (int, int, char *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) mvhline (int, int, chtype, int);\t\t/* generated */", "extern NCURSES_EXPORT(chtype) mvinch (int, int);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) mvinchnstr (int, int, chtype *, int);\t/* generated */", "extern NCURSES_EXPORT(int) mvinchstr (int, int, chtype *);\t\t/* generated */", "extern NCURSES_EXPORT(int) mvinnstr (int, int, char *, int);\t\t/* generated */", "extern NCURSES_EXPORT(int) mvinsch (int, int, chtype);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) mvinsnstr (int, int, const char *, int);\t/* generated */", "extern NCURSES_EXPORT(int) mvinsstr (int, int, const char *);\t\t/* generated */", "extern NCURSES_EXPORT(int) mvinstr (int, int, char *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) mvprintw (int,int, const char *,...)\t\t/* implemented */", "\t\tGCC_PRINTFLIKE(3,4);", "extern NCURSES_EXPORT(int) mvscanw (int,int, NCURSES_CONST char *,...)\t/* implemented */", "\t\tGCC_SCANFLIKE(3,4);", "extern NCURSES_EXPORT(int) mvvline (int, int, chtype, int);\t\t/* generated */", "extern NCURSES_EXPORT(int) mvwaddch (WINDOW *, int, int, const chtype);\t/* generated */", "extern NCURSES_EXPORT(int) mvwaddchnstr (WINDOW *, int, int, const chtype *, int);/* generated */", "extern NCURSES_EXPORT(int) mvwaddchstr (WINDOW *, int, int, const chtype *);\t/* generated */", "extern NCURSES_EXPORT(int) mvwaddnstr (WINDOW *, int, int, const char *, int);\t/* generated */", "extern NCURSES_EXPORT(int) mvwaddstr (WINDOW *, int, int, const char *);\t/* generated */", "extern NCURSES_EXPORT(int) mvwchgat (WINDOW *, int, int, int, attr_t, short, const void *);/* generated */", "extern NCURSES_EXPORT(int) mvwdelch (WINDOW *, int, int);\t\t/* generated */", "extern NCURSES_EXPORT(int) mvwgetch (WINDOW *, int, int);\t\t/* generated */", "extern NCURSES_EXPORT(int) mvwgetnstr (WINDOW *, int, int, char *, int);\t/* generated */", "extern NCURSES_EXPORT(int) mvwgetstr (WINDOW *, int, int, char *);\t/* generated */", "extern NCURSES_EXPORT(int) mvwhline (WINDOW *, int, int, chtype, int);\t/* generated */", "extern NCURSES_EXPORT(int) mvwin (WINDOW *,int,int);\t\t\t/* implemented */", "extern NCURSES_EXPORT(chtype) mvwinch (WINDOW *, int, int);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) mvwinchnstr (WINDOW *, int, int, chtype *, int);\t/* generated */", "extern NCURSES_EXPORT(int) mvwinchstr (WINDOW *, int, int, chtype *);\t\t/* generated */", "extern NCURSES_EXPORT(int) mvwinnstr (WINDOW *, int, int, char *, int);\t\t/* generated */", "extern NCURSES_EXPORT(int) mvwinsch (WINDOW *, int, int, chtype);\t\t/* generated */", "extern NCURSES_EXPORT(int) mvwinsnstr (WINDOW *, int, int, const char *, int);\t/* generated */", "extern NCURSES_EXPORT(int) mvwinsstr (WINDOW *, int, int, const char *);\t\t/* generated */", "extern NCURSES_EXPORT(int) mvwinstr (WINDOW *, int, int, char *);\t\t/* generated */", "extern NCURSES_EXPORT(int) mvwprintw (WINDOW*,int,int, const char *,...)\t/* implemented */", "\t\tGCC_PRINTFLIKE(4,5);", "extern NCURSES_EXPORT(int) mvwscanw (WINDOW *,int,int, NCURSES_CONST char *,...)\t/* implemented */", "\t\tGCC_SCANFLIKE(4,5);", "extern NCURSES_EXPORT(int) mvwvline (WINDOW *,int, int, chtype, int);\t/* generated */", "extern NCURSES_EXPORT(int) napms (int);\t\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(WINDOW *) newpad (int,int);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(SCREEN *) newterm (NCURSES_CONST char *,FILE *,FILE *);\t/* implemented */", "extern NCURSES_EXPORT(WINDOW *) newwin (int,int,int,int);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) nl (void);\t\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) nocbreak (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) nodelay (WINDOW *,bool);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) noecho (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) nonl (void);\t\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(void) noqiflush (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) noraw (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) notimeout (WINDOW *,bool);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) overlay (const WINDOW*,WINDOW *);\t\t/* implemented */", "extern NCURSES_EXPORT(int) overwrite (const WINDOW*,WINDOW *);\t\t/* implemented */", "extern NCURSES_EXPORT(int) pair_content (short,short*,short*);\t\t/* implemented */", "extern NCURSES_EXPORT(int) PAIR_NUMBER (int);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) pechochar (WINDOW *, const chtype);\t\t/* implemented */", "extern NCURSES_EXPORT(int) pnoutrefresh (WINDOW*,int,int,int,int,int,int);/* implemented */", "extern NCURSES_EXPORT(int) prefresh (WINDOW *,int,int,int,int,int,int);\t/* implemented */", "extern NCURSES_EXPORT(int) printw (const char *,...)\t\t\t/* implemented */", "\t\tGCC_PRINTFLIKE(1,2);", "extern NCURSES_EXPORT(int) putwin (WINDOW *, FILE *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(void) qiflush (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) raw (void);\t\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) redrawwin (WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) refresh (void);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) resetty (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) reset_prog_mode (void);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) reset_shell_mode (void);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) ripoffline (int, int (*)(WINDOW *, int));\t/* implemented */", "extern NCURSES_EXPORT(int) savetty (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) scanw (NCURSES_CONST char *,...)\t\t/* implemented */", "\t\tGCC_SCANFLIKE(1,2);", "extern NCURSES_EXPORT(int) scr_dump (const char *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) scr_init (const char *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) scrl (int);\t\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) scroll (WINDOW *);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) scrollok (WINDOW *,bool);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) scr_restore (const char *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) scr_set (const char *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) setscrreg (int,int);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(SCREEN *) set_term (SCREEN *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) slk_attroff (const chtype);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) slk_attr_off (const attr_t, void *);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) slk_attron (const chtype);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) slk_attr_on (attr_t,void*);\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) slk_attrset (const chtype);\t\t\t/* implemented */", "extern NCURSES_EXPORT(attr_t) slk_attr (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) slk_attr_set (const attr_t,short,void*);\t/* implemented */", "extern NCURSES_EXPORT(int) slk_clear (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) slk_color (short);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) slk_init (int);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(char *) slk_label (int);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) slk_noutrefresh (void);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) slk_refresh (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) slk_restore (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) slk_set (int,const char *,int);\t\t/* implemented */", "extern NCURSES_EXPORT(int) slk_touch (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) standout (void);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) standend (void);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) start_color (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(WINDOW *) subpad (WINDOW *, int, int, int, int);\t/* implemented */", "extern NCURSES_EXPORT(WINDOW *) subwin (WINDOW *, int, int, int, int);\t/* implemented */", "extern NCURSES_EXPORT(int) syncok (WINDOW *, bool);\t\t\t/* implemented */", "extern NCURSES_EXPORT(chtype) termattrs (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(char *) termname (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(void) timeout (int);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) touchline (WINDOW *, int, int);\t\t/* generated */", "extern NCURSES_EXPORT(int) touchwin (WINDOW *);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) typeahead (int);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) ungetch (int);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) untouchwin (WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(void) use_env (bool);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) vidattr (chtype);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) vidputs (chtype, int (*)(int));\t\t/* implemented */", "extern NCURSES_EXPORT(int) vline (chtype, int);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) vwprintw (WINDOW *, const char *,va_list);\t/* implemented */", "extern NCURSES_EXPORT(int) vw_printw (WINDOW *, const char *,va_list);\t/* generated */", "extern NCURSES_EXPORT(int) vwscanw (WINDOW *, NCURSES_CONST char *,va_list);\t/* implemented */", "extern NCURSES_EXPORT(int) vw_scanw (WINDOW *, NCURSES_CONST char *,va_list);\t/* generated */", "extern NCURSES_EXPORT(int) waddch (WINDOW *, const chtype);\t\t/* implemented */", "extern NCURSES_EXPORT(int) waddchnstr (WINDOW *,const chtype *,int);\t/* implemented */", "extern NCURSES_EXPORT(int) waddchstr (WINDOW *,const chtype *);\t\t/* generated */", "extern NCURSES_EXPORT(int) waddnstr (WINDOW *,const char *,int);\t/* implemented */", "extern NCURSES_EXPORT(int) waddstr (WINDOW *,const char *);\t\t/* generated */", "extern NCURSES_EXPORT(int) wattron (WINDOW *, int);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) wattroff (WINDOW *, int);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) wattrset (WINDOW *, int);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) wattr_get (WINDOW *, attr_t *, short *, void *);\t/* generated */", "extern NCURSES_EXPORT(int) wattr_on (WINDOW *, attr_t, void *);\t\t/* implemented */", "extern NCURSES_EXPORT(int) wattr_off (WINDOW *, attr_t, void *);\t/* implemented */", "extern NCURSES_EXPORT(int) wattr_set (WINDOW *, attr_t, short, void *);\t/* generated */", "extern NCURSES_EXPORT(int) wbkgd (WINDOW *, chtype);\t\t\t/* implemented */", "extern NCURSES_EXPORT(void) wbkgdset (WINDOW *,chtype);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) wborder (WINDOW *,chtype,chtype,chtype,chtype,chtype,chtype,chtype,chtype);\t/* implemented */", "extern NCURSES_EXPORT(int) wchgat (WINDOW *, int, attr_t, short, const void *);/* implemented */", "extern NCURSES_EXPORT(int) wclear (WINDOW *);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) wclrtobot (WINDOW *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) wclrtoeol (WINDOW *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) wcolor_set (WINDOW*,short,void*);\t\t/* implemented */", "extern NCURSES_EXPORT(void) wcursyncup (WINDOW *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) wdelch (WINDOW *);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) wdeleteln (WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) wechochar (WINDOW *, const chtype);\t\t/* implemented */", "extern NCURSES_EXPORT(int) werase (WINDOW *);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) wgetch (WINDOW *);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) wgetnstr (WINDOW *,char *,int);\t\t/* implemented */", "extern NCURSES_EXPORT(int) wgetstr (WINDOW *, char *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) whline (WINDOW *, chtype, int);\t\t/* implemented */", "extern NCURSES_EXPORT(chtype) winch (WINDOW *);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) winchnstr (WINDOW *, chtype *, int);\t\t/* implemented */", "extern NCURSES_EXPORT(int) winchstr (WINDOW *, chtype *);\t\t/* generated */", "extern NCURSES_EXPORT(int) winnstr (WINDOW *, char *, int);\t\t/* implemented */", "extern NCURSES_EXPORT(int) winsch (WINDOW *, chtype);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) winsdelln (WINDOW *,int);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) winsertln (WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) winsnstr (WINDOW *, const char *,int);\t/* implemented */", "extern NCURSES_EXPORT(int) winsstr (WINDOW *, const char *);\t\t/* generated */", "extern NCURSES_EXPORT(int) winstr (WINDOW *, char *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) wmove (WINDOW *,int,int);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) wnoutrefresh (WINDOW *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) wprintw (WINDOW *, const char *,...)\t\t/* implemented */", "\t\tGCC_PRINTFLIKE(2,3);", "extern NCURSES_EXPORT(int) wredrawln (WINDOW *,int,int);\t\t/* implemented */", "extern NCURSES_EXPORT(int) wrefresh (WINDOW *);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) wscanw (WINDOW *, NCURSES_CONST char *,...)\t/* implemented */", "\t\tGCC_SCANFLIKE(2,3);", "extern NCURSES_EXPORT(int) wscrl (WINDOW *,int);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) wsetscrreg (WINDOW *,int,int);\t\t/* implemented */", "extern NCURSES_EXPORT(int) wstandout (WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) wstandend (WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(void) wsyncdown (WINDOW *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(void) wsyncup (WINDOW *);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(void) wtimeout (WINDOW *,int);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) wtouchln (WINDOW *,int,int,int);\t\t/* implemented */", "extern NCURSES_EXPORT(int) wvline (WINDOW *,chtype,int);\t\t/* implemented */", "", "/*", " * These are also declared in <term.h>:", " */", "extern NCURSES_EXPORT(int) tigetflag (NCURSES_CONST char *);\t\t/* implemented */", "extern NCURSES_EXPORT(int) tigetnum (NCURSES_CONST char *);\t\t/* implemented */", "extern NCURSES_EXPORT(char *) tigetstr (NCURSES_CONST char *);\t\t/* implemented */", "extern NCURSES_EXPORT(int) putp (const char *);\t\t\t\t/* implemented */", "", "#if NCURSES_TPARM_VARARGS", "extern NCURSES_EXPORT(char *) tparm (NCURSES_CONST char *, ...);\t/* special */", "#else", "extern NCURSES_EXPORT(char *) tparm (NCURSES_CONST char *, long,long,long,long,long,long,long,long,long);\t/* special */", "extern NCURSES_EXPORT(char *) tparm_varargs (NCURSES_CONST char *, ...);\t/* special */", "#endif", "", "/*", " * These functions are not in X/Open, but we use them in macro definitions:", " */", "extern NCURSES_EXPORT(int) getattrs (const WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) getcurx (const WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) getcury (const WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) getbegx (const WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) getbegy (const WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) getmaxx (const WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) getmaxy (const WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) getparx (const WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) getpary (const WINDOW *);\t\t\t/* generated */", "", "/*", " * vid_attr() was implemented originally based on a draft of X/Open curses.", " */", "#ifndef _XOPEN_SOURCE_EXTENDED", "#define vid_attr(a,pair,opts) vidattr(a)", "#endif", "", "/*", " * These functions are extensions - not in X/Open Curses.", " */", "#if 1", "#undef  NCURSES_EXT_FUNCS", "#define NCURSES_EXT_FUNCS 20081102", "typedef int (*NCURSES_WINDOW_CB)(WINDOW *, void *);", "typedef int (*NCURSES_SCREEN_CB)(SCREEN *, void *);", "extern NCURSES_EXPORT(bool) is_term_resized (int, int);", "extern NCURSES_EXPORT(char *) keybound (int, int);", "extern NCURSES_EXPORT(const char *) curses_version (void);", "extern NCURSES_EXPORT(int) assume_default_colors (int, int);", "extern NCURSES_EXPORT(int) define_key (const char *, int);", "extern NCURSES_EXPORT(int) key_defined (const char *);", "extern NCURSES_EXPORT(int) keyok (int, bool);", "extern NCURSES_EXPORT(int) resize_term (int, int);", "extern NCURSES_EXPORT(int) resizeterm (int, int);", "extern NCURSES_EXPORT(int) set_escdelay (int);", "extern NCURSES_EXPORT(int) set_tabsize (int);", "extern NCURSES_EXPORT(int) use_default_colors (void);", "extern NCURSES_EXPORT(int) use_extended_names (bool);", "extern NCURSES_EXPORT(int) use_legacy_coding (int);", "extern NCURSES_EXPORT(int) use_screen (SCREEN *, NCURSES_SCREEN_CB, void *);", "extern NCURSES_EXPORT(int) use_window (WINDOW *, NCURSES_WINDOW_CB, void *);", "extern NCURSES_EXPORT(int) wresize (WINDOW *, int, int);", "extern NCURSES_EXPORT(void) nofilter(void);", "", "/*", " * These extensions provide access to information stored in the WINDOW even", " * when NCURSES_OPAQUE is set:", " */", "extern NCURSES_EXPORT(WINDOW *) wgetparent (const WINDOW *);\t/* generated */", "extern NCURSES_EXPORT(bool) is_cleared (const WINDOW *);\t/* generated */", "extern NCURSES_EXPORT(bool) is_idcok (const WINDOW *);\t\t/* generated */", "extern NCURSES_EXPORT(bool) is_idlok (const WINDOW *);\t\t/* generated */", "extern NCURSES_EXPORT(bool) is_immedok (const WINDOW *);\t/* generated */", "extern NCURSES_EXPORT(bool) is_keypad (const WINDOW *);\t\t/* generated */", "extern NCURSES_EXPORT(bool) is_leaveok (const WINDOW *);\t/* generated */", "extern NCURSES_EXPORT(bool) is_nodelay (const WINDOW *);\t/* generated */", "extern NCURSES_EXPORT(bool) is_notimeout (const WINDOW *);\t/* generated */", "extern NCURSES_EXPORT(bool) is_scrollok (const WINDOW *);\t/* generated */", "extern NCURSES_EXPORT(bool) is_syncok (const WINDOW *);\t\t/* generated */", "extern NCURSES_EXPORT(int) wgetscrreg (const WINDOW *, int *, int *); /* generated */", "", "#else", "#define curses_version() NCURSES_VERSION", "#endif", "", "/* attributes */", "", "#define NCURSES_ATTR_SHIFT       8", "#define NCURSES_BITS(mask,shift) ((mask) << ((shift) + NCURSES_ATTR_SHIFT))", "", "#define A_NORMAL\t(1U - 1U)", "#define A_ATTRIBUTES\tNCURSES_BITS(~(1U - 1U),0)", "#define A_CHARTEXT\t(NCURSES_BITS(1U,0) - 1U)", "#define A_COLOR\t\tNCURSES_BITS(((1U) << 8) - 1U,0)", "#define A_STANDOUT\tNCURSES_BITS(1U,8)", "#define A_UNDERLINE\tNCURSES_BITS(1U,9)", "#define A_REVERSE\tNCURSES_BITS(1U,10)", "#define A_BLINK\t\tNCURSES_BITS(1U,11)", "#define A_DIM\t\tNCURSES_BITS(1U,12)", "#define A_BOLD\t\tNCURSES_BITS(1U,13)", "#define A_ALTCHARSET\tNCURSES_BITS(1U,14)", "#define A_INVIS\t\tNCURSES_BITS(1U,15)", "#define A_PROTECT\tNCURSES_BITS(1U,16)", "#define A_HORIZONTAL\tNCURSES_BITS(1U,17)", "#define A_LEFT\t\tNCURSES_BITS(1U,18)", "#define A_LOW\t\tNCURSES_BITS(1U,19)", "#define A_RIGHT\t\tNCURSES_BITS(1U,20)", "#define A_TOP\t\tNCURSES_BITS(1U,21)", "#define A_VERTICAL\tNCURSES_BITS(1U,22)", "", "/*", " * Most of the pseudo functions are macros that either provide compatibility", " * with older versions of curses, or provide inline functionality to improve", " * performance.", " */", "", "/*", " * These pseudo functions are always implemented as macros:", " */", "", "#define getyx(win,y,x)   \t(y = getcury(win), x = getcurx(win))", "#define getbegyx(win,y,x)\t(y = getbegy(win), x = getbegx(win))", "#define getmaxyx(win,y,x)\t(y = getmaxy(win), x = getmaxx(win))", "#define getparyx(win,y,x)\t(y = getpary(win), x = getparx(win))", "", "#define getsyx(y,x) do { if (newscr) { \\", "\t\t\t     if (is_leaveok(newscr)) \\", "\t\t\t\t(y) = (x) = -1; \\", "\t\t\t     else \\", "\t\t\t\t getyx(newscr,(y), (x)); \\", "\t\t\t} \\", "\t\t    } while(0)", "", "#define setsyx(y,x) do { if (newscr) { \\", "\t\t\t    if ((y) == -1 && (x) == -1) \\", "\t\t\t\tleaveok(newscr, TRUE); \\", "\t\t\t    else { \\", "\t\t\t\tleaveok(newscr, FALSE); \\", "\t\t\t\twmove(newscr, (y), (x)); \\", "\t\t\t    } \\", "\t\t\t} \\", "\t\t    } while(0)", "", "#ifndef NCURSES_NOMACROS", "", "/*", " * These miscellaneous pseudo functions are provided for compatibility:", " */", "", "#define wgetstr(w, s)\t\twgetnstr(w, s, -1)", "#define getnstr(s, n)\t\twgetnstr(stdscr, s, n)", "", "#define setterm(term)\t\tsetupterm(term, 1, (int *)0)", "", "#define fixterm()\t\treset_prog_mode()", "#define resetterm()\t\treset_shell_mode()", "#define saveterm()\t\tdef_prog_mode()", "#define crmode()\t\tcbreak()", "#define nocrmode()\t\tnocbreak()", "#define gettmode()", "", "/* It seems older SYSV curses versions define these */", "#if !NCURSES_OPAQUE", "#define getattrs(win)\t\t((win) ? (win)->_attrs : A_NORMAL)", "#define getcurx(win)\t\t((win) ? (win)->_curx : ERR)", "#define getcury(win)\t\t((win) ? (win)->_cury : ERR)", "#define getbegx(win)\t\t((win) ? (win)->_begx : ERR)", "#define getbegy(win)\t\t((win) ? (win)->_begy : ERR)", "#define getmaxx(win)\t\t((win) ? ((win)->_maxx + 1) : ERR)", "#define getmaxy(win)\t\t((win) ? ((win)->_maxy + 1) : ERR)", "#define getparx(win)\t\t((win) ? (win)->_parx : ERR)", "#define getpary(win)\t\t((win) ? (win)->_pary : ERR)", "#endif /* NCURSES_OPAQUE */", "", "#define wstandout(win)      \t(wattrset(win,A_STANDOUT))", "#define wstandend(win)      \t(wattrset(win,A_NORMAL))", "", "#define wattron(win,at)\t\twattr_on(win, NCURSES_CAST(attr_t, at), NULL)", "#define wattroff(win,at)\twattr_off(win, NCURSES_CAST(attr_t, at), NULL)", "", "#if !NCURSES_OPAQUE", "#if defined(_XOPEN_SOURCE_EXTENDED) && 0", "#define wattrset(win,at)\t((win)->_color = PAIR_NUMBER(at), \\", "\t\t\t\t (win)->_attrs = (at))", "#else", "#define wattrset(win,at)\t((win)->_attrs = (at))", "#endif", "#endif /* NCURSES_OPAQUE */", "", "#define scroll(win)\t\twscrl(win,1)", "", "#define touchwin(win)\t\twtouchln((win), 0, getmaxy(win), 1)", "#define touchline(win, s, c)\twtouchln((win), s, c, 1)", "#define untouchwin(win)\t\twtouchln((win), 0, getmaxy(win), 0)", "", "#define box(win, v, h)\t\twborder(win, v, v, h, h, 0, 0, 0, 0)", "#define border(ls, rs, ts, bs, tl, tr, bl, br)\twborder(stdscr, ls, rs, ts, bs, tl, tr, bl, br)", "#define hline(ch, n)\t\twhline(stdscr, ch, n)", "#define vline(ch, n)\t\twvline(stdscr, ch, n)", "", "#define winstr(w, s)\t\twinnstr(w, s, -1)", "#define winchstr(w, s)\t\twinchnstr(w, s, -1)", "#define winsstr(w, s)\t\twinsnstr(w, s, -1)", "", "#if !NCURSES_OPAQUE", "#define redrawwin(win)\t\twredrawln(win, 0, (win)->_maxy+1)", "#endif /* NCURSES_OPAQUE */", "", "#define waddstr(win,str)\twaddnstr(win,str,-1)", "#define waddchstr(win,str)\twaddchnstr(win,str,-1)", "", "/*", " * These apply to the first 256 color pairs.", " */", "#define COLOR_PAIR(n)\tNCURSES_BITS(n, 0)", "#define PAIR_NUMBER(a)\t(NCURSES_CAST(int,(((a) & A_COLOR) >> NCURSES_ATTR_SHIFT)))", "", "/*", " * pseudo functions for standard screen", " */", "", "#define addch(ch)\t\twaddch(stdscr,ch)", "#define addchnstr(str,n)\twaddchnstr(stdscr,str,n)", "#define addchstr(str)\t\twaddchstr(stdscr,str)", "#define addnstr(str,n)\t\twaddnstr(stdscr,str,n)", "#define addstr(str)\t\twaddnstr(stdscr,str,-1)", "#define attroff(at)\t\twattroff(stdscr,at)", "#define attron(at)\t\twattron(stdscr,at)", "#define attrset(at)\t\twattrset(stdscr,at)", "#define attr_get(ap,cp,o)\twattr_get(stdscr,ap,cp,o)", "#define attr_off(a,o)\t\twattr_off(stdscr,a,o)", "#define attr_on(a,o)\t\twattr_on(stdscr,a,o)", "#define attr_set(a,c,o)\t\twattr_set(stdscr,a,c,o)", "#define bkgd(ch)\t\twbkgd(stdscr,ch)", "#define bkgdset(ch)\t\twbkgdset(stdscr,ch)", "#define chgat(n,a,c,o)\t\twchgat(stdscr,n,a,c,o)", "#define clear()\t\t\twclear(stdscr)", "#define clrtobot()\t\twclrtobot(stdscr)", "#define clrtoeol()\t\twclrtoeol(stdscr)", "#define color_set(c,o)\t\twcolor_set(stdscr,c,o)", "#define delch()\t\t\twdelch(stdscr)", "#define deleteln()\t\twinsdelln(stdscr,-1)", "#define echochar(c)\t\twechochar(stdscr,c)", "#define erase()\t\t\twerase(stdscr)", "#define getch()\t\t\twgetch(stdscr)", "#define getstr(str)\t\twgetstr(stdscr,str)", "#define inch()\t\t\twinch(stdscr)", "#define inchnstr(s,n)\t\twinchnstr(stdscr,s,n)", "#define inchstr(s)\t\twinchstr(stdscr,s)", "#define innstr(s,n)\t\twinnstr(stdscr,s,n)", "#define insch(c)\t\twinsch(stdscr,c)", "#define insdelln(n)\t\twinsdelln(stdscr,n)", "#define insertln()\t\twinsdelln(stdscr,1)", "#define insnstr(s,n)\t\twinsnstr(stdscr,s,n)", "#define insstr(s)\t\twinsstr(stdscr,s)", "#define instr(s)\t\twinstr(stdscr,s)", "#define move(y,x)\t\twmove(stdscr,y,x)", "#define refresh()\t\twrefresh(stdscr)", "#define scrl(n)\t\t\twscrl(stdscr,n)", "#define setscrreg(t,b)\t\twsetscrreg(stdscr,t,b)", "#define standend()\t\twstandend(stdscr)", "#define standout()\t\twstandout(stdscr)", "#define timeout(delay)\t\twtimeout(stdscr,delay)", "#define wdeleteln(win)\t\twinsdelln(win,-1)", "#define winsertln(win)\t\twinsdelln(win,1)", "", "/*", " * mv functions", " */", "", "#define mvwaddch(win,y,x,ch)\t\t(wmove(win,y,x) == ERR ? ERR : waddch(win,ch))", "#define mvwaddchnstr(win,y,x,str,n)\t(wmove(win,y,x) == ERR ? ERR : waddchnstr(win,str,n))", "#define mvwaddchstr(win,y,x,str)\t(wmove(win,y,x) == ERR ? ERR : waddchnstr(win,str,-1))", "#define mvwaddnstr(win,y,x,str,n)\t(wmove(win,y,x) == ERR ? ERR : waddnstr(win,str,n))", "#define mvwaddstr(win,y,x,str)\t\t(wmove(win,y,x) == ERR ? ERR : waddnstr(win,str,-1))", "#define mvwdelch(win,y,x)\t\t(wmove(win,y,x) == ERR ? ERR : wdelch(win))", "#define mvwchgat(win,y,x,n,a,c,o)\t(wmove(win,y,x) == ERR ? ERR : wchgat(win,n,a,c,o))", "#define mvwgetch(win,y,x)\t\t(wmove(win,y,x) == ERR ? ERR : wgetch(win))", "#define mvwgetnstr(win,y,x,str,n)\t(wmove(win,y,x) == ERR ? ERR : wgetnstr(win,str,n))", "#define mvwgetstr(win,y,x,str)\t\t(wmove(win,y,x) == ERR ? ERR : wgetstr(win,str))", "#define mvwhline(win,y,x,c,n)\t\t(wmove(win,y,x) == ERR ? ERR : whline(win,c,n))", "#define mvwinch(win,y,x)\t\t(wmove(win,y,x) == ERR ? NCURSES_CAST(chtype, ERR) : winch(win))", "#define mvwinchnstr(win,y,x,s,n)\t(wmove(win,y,x) == ERR ? ERR : winchnstr(win,s,n))", "#define mvwinchstr(win,y,x,s)\t\t(wmove(win,y,x) == ERR ? ERR : winchstr(win,s))", "#define mvwinnstr(win,y,x,s,n)\t\t(wmove(win,y,x) == ERR ? ERR : winnstr(win,s,n))", "#define mvwinsch(win,y,x,c)\t\t(wmove(win,y,x) == ERR ? ERR : winsch(win,c))", "#define mvwinsnstr(win,y,x,s,n)\t\t(wmove(win,y,x) == ERR ? ERR : winsnstr(win,s,n))", "#define mvwinsstr(win,y,x,s)\t\t(wmove(win,y,x) == ERR ? ERR : winsstr(win,s))", "#define mvwinstr(win,y,x,s)\t\t(wmove(win,y,x) == ERR ? ERR : winstr(win,s))", "#define mvwvline(win,y,x,c,n)\t\t(wmove(win,y,x) == ERR ? ERR : wvline(win,c,n))", "", "#define mvaddch(y,x,ch)\t\t\tmvwaddch(stdscr,y,x,ch)", "#define mvaddchnstr(y,x,str,n)\t\tmvwaddchnstr(stdscr,y,x,str,n)", "#define mvaddchstr(y,x,str)\t\tmvwaddchstr(stdscr,y,x,str)", "#define mvaddnstr(y,x,str,n)\t\tmvwaddnstr(stdscr,y,x,str,n)", "#define mvaddstr(y,x,str)\t\tmvwaddstr(stdscr,y,x,str)", "#define mvchgat(y,x,n,a,c,o)\t\tmvwchgat(stdscr,y,x,n,a,c,o)", "#define mvdelch(y,x)\t\t\tmvwdelch(stdscr,y,x)", "#define mvgetch(y,x)\t\t\tmvwgetch(stdscr,y,x)", "#define mvgetnstr(y,x,str,n)\t\tmvwgetnstr(stdscr,y,x,str,n)", "#define mvgetstr(y,x,str)\t\tmvwgetstr(stdscr,y,x,str)", "#define mvhline(y,x,c,n)\t\tmvwhline(stdscr,y,x,c,n)", "#define mvinch(y,x)\t\t\tmvwinch(stdscr,y,x)", "#define mvinchnstr(y,x,s,n)\t\tmvwinchnstr(stdscr,y,x,s,n)", "#define mvinchstr(y,x,s)\t\tmvwinchstr(stdscr,y,x,s)", "#define mvinnstr(y,x,s,n)\t\tmvwinnstr(stdscr,y,x,s,n)", "#define mvinsch(y,x,c)\t\t\tmvwinsch(stdscr,y,x,c)", "#define mvinsnstr(y,x,s,n)\t\tmvwinsnstr(stdscr,y,x,s,n)", "#define mvinsstr(y,x,s)\t\t\tmvwinsstr(stdscr,y,x,s)", "#define mvinstr(y,x,s)\t\t\tmvwinstr(stdscr,y,x,s)", "#define mvvline(y,x,c,n)\t\tmvwvline(stdscr,y,x,c,n)", "", "/*", " * Some wide-character functions can be implemented without the extensions.", " */", "#if !NCURSES_OPAQUE", "#define getbkgd(win)                    ((win)->_bkgd)", "#endif /* NCURSES_OPAQUE */", "", "#define slk_attr_off(a,v)\t\t((v) ? ERR : slk_attroff(a))", "#define slk_attr_on(a,v)\t\t((v) ? ERR : slk_attron(a))", "", "#if !NCURSES_OPAQUE", "#if defined(_XOPEN_SOURCE_EXTENDED) && 0", "#define wattr_set(win,a,p,opts)\t\t((win)->_attrs = ((a) & ~A_COLOR), \\", "\t\t\t\t\t (win)->_color = (p), \\", "\t\t\t\t\t OK)", "#define wattr_get(win,a,p,opts)\t\t((void)((a) != (void *)0 && (*(a) = (win)->_attrs)), \\", "\t\t\t\t\t (void)((p) != (void *)0 && (*(p) = (win)->_color)), \\", "\t\t\t\t\t OK)", "#else", "#define wattr_set(win,a,p,opts)\t\t((win)->_attrs = (((a) & ~A_COLOR) | COLOR_PAIR(p)), OK)", "#define wattr_get(win,a,p,opts)\t\t((void)((a) != (void *)0 && (*(a) = (win)->_attrs)), \\", "\t\t\t\t\t (void)((p) != (void *)0 && (*(p) = PAIR_NUMBER((win)->_attrs))), \\", "\t\t\t\t\t OK)", "#endif", "#endif /* NCURSES_OPAQUE */", "", "/*", " * X/Open curses deprecates SVr4 vwprintw/vwscanw, which are supposed to use", " * varargs.h.  It adds new calls vw_printw/vw_scanw, which are supposed to", " * use POSIX stdarg.h.  The ncurses versions of vwprintw/vwscanw already", " * use stdarg.h, so...", " */", "#define vw_printw\t\tvwprintw", "#define vw_scanw\t\tvwscanw", "", "/*", " * Export fallback function for use in C++ binding.", " */", "#if !1", "#define vsscanf(a,b,c) _nc_vsscanf(a,b,c)", "NCURSES_EXPORT(int) vsscanf(const char *, const char *, va_list);", "#endif", "", "/*", " * These macros are extensions - not in X/Open Curses.", " */", "#if 1", "#if !NCURSES_OPAQUE", "#define is_cleared(win)\t\t((win)->_clear)", "#define is_idcok(win)\t\t((win)->_idcok)", "#define is_idlok(win)\t\t((win)->_idlok)", "#define is_immedok(win)\t\t((win)->_immed)", "#define is_keypad(win)\t\t((win)->_use_keypad)", "#define is_leaveok(win)\t\t((win)->_leaveok)", "#define is_nodelay(win)\t\t((win)->_delay == 0)", "#define is_notimeout(win)\t((win)->_notimeout)", "#define is_scrollok(win)\t((win)->_scroll)", "#define is_syncok(win)\t\t((win)->_sync)", "#define wgetparent(win)\t\t((win) ? (win)->_parent : 0)", "#define wgetscrreg(win,t,b)\t((win) ? (*(t) = (win)->_regtop, *(b) = (win)->_regbottom, OK) : ERR)", "#endif", "#endif", "", "#endif /* NCURSES_NOMACROS */", "", "/*", " * Public variables.", " *", " * Notes:", " *\ta. ESCDELAY was an undocumented feature under AIX curses.", " *\t   It gives the ESC expire time in milliseconds.", " *\tb. ttytype is needed for backward compatibility", " */", "#if 0", "", "NCURSES_WRAPPED_VAR(WINDOW *, curscr);", "NCURSES_WRAPPED_VAR(WINDOW *, newscr);", "NCURSES_WRAPPED_VAR(WINDOW *, stdscr);", "NCURSES_WRAPPED_VAR(char *, ttytype);", "NCURSES_WRAPPED_VAR(int, COLORS);", "NCURSES_WRAPPED_VAR(int, COLOR_PAIRS);", "NCURSES_WRAPPED_VAR(int, COLS);", "NCURSES_WRAPPED_VAR(int, ESCDELAY);", "NCURSES_WRAPPED_VAR(int, LINES);", "NCURSES_WRAPPED_VAR(int, TABSIZE);", "", "#define curscr      NCURSES_PUBLIC_VAR(curscr())", "#define newscr      NCURSES_PUBLIC_VAR(newscr())", "#define stdscr      NCURSES_PUBLIC_VAR(stdscr())", "#define ttytype     NCURSES_PUBLIC_VAR(ttytype())", "#define COLORS      NCURSES_PUBLIC_VAR(COLORS())", "#define COLOR_PAIRS NCURSES_PUBLIC_VAR(COLOR_PAIRS())", "#define COLS        NCURSES_PUBLIC_VAR(COLS())", "#define ESCDELAY    NCURSES_PUBLIC_VAR(ESCDELAY())", "#define LINES       NCURSES_PUBLIC_VAR(LINES())", "#define TABSIZE     NCURSES_PUBLIC_VAR(TABSIZE())", "", "#else", "", "extern NCURSES_EXPORT_VAR(WINDOW *) curscr;", "extern NCURSES_EXPORT_VAR(WINDOW *) newscr;", "extern NCURSES_EXPORT_VAR(WINDOW *) stdscr;", "extern NCURSES_EXPORT_VAR(char) ttytype[];", "extern NCURSES_EXPORT_VAR(int) COLORS;", "extern NCURSES_EXPORT_VAR(int) COLOR_PAIRS;", "extern NCURSES_EXPORT_VAR(int) COLS;", "extern NCURSES_EXPORT_VAR(int) ESCDELAY;", "extern NCURSES_EXPORT_VAR(int) LINES;", "extern NCURSES_EXPORT_VAR(int) TABSIZE;", "", "#endif", "", "/*", " * Pseudo-character tokens outside ASCII range.  The curses wgetch() function", " * will return any given one of these only if the corresponding k- capability", " * is defined in your terminal's terminfo entry.", " *", " * Some keys (KEY_A1, etc) are arranged like this:", " *\ta1     up    a3", " *\tleft   b2    right", " *\tc1     down  c3", " *", " * A few key codes do not depend upon the terminfo entry.", " */", "#define KEY_CODE_YES\t0400\t\t/* A wchar_t contains a key code */", "#define KEY_MIN\t\t0401\t\t/* Minimum curses key */", "#define KEY_BREAK\t0401\t\t/* Break key (unreliable) */", "#define KEY_SRESET\t0530\t\t/* Soft (partial) reset (unreliable) */", "#define KEY_RESET\t0531\t\t/* Reset or hard reset (unreliable) */", "/*", " * These definitions were generated by /SourceCache/ncurses/ncurses-42/ncurses/include/MKkey_defs.sh /SourceCache/ncurses/ncurses-42/ncurses/include/Caps", " */", "#define KEY_DOWN\t0402\t\t/* down-arrow key */", "#define KEY_UP\t\t0403\t\t/* up-arrow key */", "#define KEY_LEFT\t0404\t\t/* left-arrow key */", "#define KEY_RIGHT\t0405\t\t/* right-arrow key */", "#define KEY_HOME\t0406\t\t/* home key */", "#define KEY_BACKSPACE\t0407\t\t/* backspace key */", "#define KEY_F0\t\t0410\t\t/* Function keys.  Space for 64 */", "#define KEY_F(n)\t(KEY_F0+(n))\t/* Value of function key n */", "#define KEY_DL\t\t0510\t\t/* delete-line key */", "#define KEY_IL\t\t0511\t\t/* insert-line key */", "#define KEY_DC\t\t0512\t\t/* delete-character key */", "#define KEY_IC\t\t0513\t\t/* insert-character key */", "#define KEY_EIC\t\t0514\t\t/* sent by rmir or smir in insert mode */", "#define KEY_CLEAR\t0515\t\t/* clear-screen or erase key */", "#define KEY_EOS\t\t0516\t\t/* clear-to-end-of-screen key */", "#define KEY_EOL\t\t0517\t\t/* clear-to-end-of-line key */", "#define KEY_SF\t\t0520\t\t/* scroll-forward key */", "#define KEY_SR\t\t0521\t\t/* scroll-backward key */", "#define KEY_NPAGE\t0522\t\t/* next-page key */", "#define KEY_PPAGE\t0523\t\t/* previous-page key */", "#define KEY_STAB\t0524\t\t/* set-tab key */", "#define KEY_CTAB\t0525\t\t/* clear-tab key */", "#define KEY_CATAB\t0526\t\t/* clear-all-tabs key */", "#define KEY_ENTER\t0527\t\t/* enter/send key */", "#define KEY_PRINT\t0532\t\t/* print key */", "#define KEY_LL\t\t0533\t\t/* lower-left key (home down) */", "#define KEY_A1\t\t0534\t\t/* upper left of keypad */", "#define KEY_A3\t\t0535\t\t/* upper right of keypad */", "#define KEY_B2\t\t0536\t\t/* center of keypad */", "#define KEY_C1\t\t0537\t\t/* lower left of keypad */", "#define KEY_C3\t\t0540\t\t/* lower right of keypad */", "#define KEY_BTAB\t0541\t\t/* back-tab key */", "#define KEY_BEG\t\t0542\t\t/* begin key */", "#define KEY_CANCEL\t0543\t\t/* cancel key */", "#define KEY_CLOSE\t0544\t\t/* close key */", "#define KEY_COMMAND\t0545\t\t/* command key */", "#define KEY_COPY\t0546\t\t/* copy key */", "#define KEY_CREATE\t0547\t\t/* create key */", "#define KEY_END\t\t0550\t\t/* end key */", "#define KEY_EXIT\t0551\t\t/* exit key */", "#define KEY_FIND\t0552\t\t/* find key */", "#define KEY_HELP\t0553\t\t/* help key */", "#define KEY_MARK\t0554\t\t/* mark key */", "#define KEY_MESSAGE\t0555\t\t/* message key */", "#define KEY_MOVE\t0556\t\t/* move key */", "#define KEY_NEXT\t0557\t\t/* next key */", "#define KEY_OPEN\t0560\t\t/* open key */", "#define KEY_OPTIONS\t0561\t\t/* options key */", "#define KEY_PREVIOUS\t0562\t\t/* previous key */", "#define KEY_REDO\t0563\t\t/* redo key */", "#define KEY_REFERENCE\t0564\t\t/* reference key */", "#define KEY_REFRESH\t0565\t\t/* refresh key */", "#define KEY_REPLACE\t0566\t\t/* replace key */", "#define KEY_RESTART\t0567\t\t/* restart key */", "#define KEY_RESUME\t0570\t\t/* resume key */", "#define KEY_SAVE\t0571\t\t/* save key */", "#define KEY_SBEG\t0572\t\t/* shifted begin key */", "#define KEY_SCANCEL\t0573\t\t/* shifted cancel key */", "#define KEY_SCOMMAND\t0574\t\t/* shifted command key */", "#define KEY_SCOPY\t0575\t\t/* shifted copy key */", "#define KEY_SCREATE\t0576\t\t/* shifted create key */", "#define KEY_SDC\t\t0577\t\t/* shifted delete-character key */", "#define KEY_SDL\t\t0600\t\t/* shifted delete-line key */", "#define KEY_SELECT\t0601\t\t/* select key */", "#define KEY_SEND\t0602\t\t/* shifted end key */", "#define KEY_SEOL\t0603\t\t/* shifted clear-to-end-of-line key */", "#define KEY_SEXIT\t0604\t\t/* shifted exit key */", "#define KEY_SFIND\t0605\t\t/* shifted find key */", "#define KEY_SHELP\t0606\t\t/* shifted help key */", "#define KEY_SHOME\t0607\t\t/* shifted home key */", "#define KEY_SIC\t\t0610\t\t/* shifted insert-character key */", "#define KEY_SLEFT\t0611\t\t/* shifted left-arrow key */", "#define KEY_SMESSAGE\t0612\t\t/* shifted message key */", "#define KEY_SMOVE\t0613\t\t/* shifted move key */", "#define KEY_SNEXT\t0614\t\t/* shifted next key */", "#define KEY_SOPTIONS\t0615\t\t/* shifted options key */", "#define KEY_SPREVIOUS\t0616\t\t/* shifted previous key */", "#define KEY_SPRINT\t0617\t\t/* shifted print key */", "#define KEY_SREDO\t0620\t\t/* shifted redo key */", "#define KEY_SREPLACE\t0621\t\t/* shifted replace key */", "#define KEY_SRIGHT\t0622\t\t/* shifted right-arrow key */", "#define KEY_SRSUME\t0623\t\t/* shifted resume key */", "#define KEY_SSAVE\t0624\t\t/* shifted save key */", "#define KEY_SSUSPEND\t0625\t\t/* shifted suspend key */", "#define KEY_SUNDO\t0626\t\t/* shifted undo key */", "#define KEY_SUSPEND\t0627\t\t/* suspend key */", "#define KEY_UNDO\t0630\t\t/* undo key */", "#define KEY_MOUSE\t0631\t\t/* Mouse event has occurred */", "#define KEY_RESIZE\t0632\t\t/* Terminal resize event */", "#define KEY_EVENT\t0633\t\t/* We were interrupted by an event */", "", "#define KEY_MAX\t\t0777\t\t/* Maximum key value is 0633 */", "/* $Id: curses.wide,v 1.34 2007/03/10 17:52:23 tom Exp $ */", "/*", " * vile:cmode:", " * This file is part of ncurses, designed to be appended after curses.h.in", " * (see that file for the relevant copyright).", " */", "#ifdef _XOPEN_SOURCE_EXTENDED", "", "extern NCURSES_EXPORT_VAR(cchar_t *) _nc_wacs;", "", "#define NCURSES_WACS(c)\t(&_nc_wacs[(unsigned char)c])", "", "#define WACS_BSSB\tNCURSES_WACS('l')", "#define WACS_SSBB\tNCURSES_WACS('m')", "#define WACS_BBSS\tNCURSES_WACS('k')", "#define WACS_SBBS\tNCURSES_WACS('j')", "#define WACS_SBSS\tNCURSES_WACS('u')", "#define WACS_SSSB\tNCURSES_WACS('t')", "#define WACS_SSBS\tNCURSES_WACS('v')", "#define WACS_BSSS\tNCURSES_WACS('w')", "#define WACS_BSBS\tNCURSES_WACS('q')", "#define WACS_SBSB\tNCURSES_WACS('x')", "#define WACS_SSSS\tNCURSES_WACS('n')", "", "#define WACS_ULCORNER\tWACS_BSSB", "#define WACS_LLCORNER\tWACS_SSBB", "#define WACS_URCORNER\tWACS_BBSS", "#define WACS_LRCORNER\tWACS_SBBS", "#define WACS_RTEE\tWACS_SBSS", "#define WACS_LTEE\tWACS_SSSB", "#define WACS_BTEE\tWACS_SSBS", "#define WACS_TTEE\tWACS_BSSS", "#define WACS_HLINE\tWACS_BSBS", "#define WACS_VLINE\tWACS_SBSB", "#define WACS_PLUS\tWACS_SSSS", "", "#define WACS_S1\t\tNCURSES_WACS('o') /* scan line 1 */", "#define WACS_S9 \tNCURSES_WACS('s') /* scan line 9 */", "#define WACS_DIAMOND\tNCURSES_WACS('`') /* diamond */", "#define WACS_CKBOARD\tNCURSES_WACS('a') /* checker board */", "#define WACS_DEGREE\tNCURSES_WACS('f') /* degree symbol */", "#define WACS_PLMINUS\tNCURSES_WACS('g') /* plus/minus */", "#define WACS_BULLET\tNCURSES_WACS('~') /* bullet */", "", "\t/* Teletype 5410v1 symbols */", "#define WACS_LARROW\tNCURSES_WACS(',') /* arrow left */", "#define WACS_RARROW\tNCURSES_WACS('+') /* arrow right */", "#define WACS_DARROW\tNCURSES_WACS('.') /* arrow down */", "#define WACS_UARROW\tNCURSES_WACS('-') /* arrow up */", "#define WACS_BOARD\tNCURSES_WACS('h') /* board of squares */", "#define WACS_LANTERN\tNCURSES_WACS('i') /* lantern symbol */", "#define WACS_BLOCK\tNCURSES_WACS('0') /* solid square block */", "", "\t/* ncurses extensions */", "#define WACS_S3\t\tNCURSES_WACS('p') /* scan line 3 */", "#define WACS_S7\t\tNCURSES_WACS('r') /* scan line 7 */", "#define WACS_LEQUAL\tNCURSES_WACS('y') /* less/equal */", "#define WACS_GEQUAL\tNCURSES_WACS('z') /* greater/equal */", "#define WACS_PI\t\tNCURSES_WACS('{') /* Pi */", "#define WACS_NEQUAL\tNCURSES_WACS('|') /* not equal */", "#define WACS_STERLING\tNCURSES_WACS('}') /* UK pound sign */", "", "/*", " * Function prototypes for wide-character operations.", " *", ' * "generated" comments should include ":WIDEC" to make the corresponding', " * functions ifdef'd in lib_gen.c", " *", ' * "implemented" comments do not need this marker.', " */", "", "extern NCURSES_EXPORT(int) add_wch (const cchar_t *);\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) add_wchnstr (const cchar_t *, int);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) add_wchstr (const cchar_t *);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) addnwstr (const wchar_t *, int);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) addwstr (const wchar_t *);\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) bkgrnd (const cchar_t *);\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(void) bkgrndset (const cchar_t *);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) border_set (const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*); /* generated:WIDEC */", "extern NCURSES_EXPORT(int) box_set (WINDOW *, const cchar_t *, const cchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) echo_wchar (const cchar_t *);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) erasewchar (wchar_t*);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) get_wch (wint_t *);\t\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) get_wstr (wint_t *);\t\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) getbkgrnd (cchar_t *);\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) getcchar (const cchar_t *, wchar_t*, attr_t*, short*, void*);\t/* implemented */", "extern NCURSES_EXPORT(int) getn_wstr (wint_t *, int);\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) hline_set (const cchar_t *, int);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) in_wch (cchar_t *);\t\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) in_wchnstr (cchar_t *, int);\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) in_wchstr (cchar_t *);\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) innwstr (wchar_t *, int);\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) ins_nwstr (const wchar_t *, int);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) ins_wch (const cchar_t *);\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) ins_wstr (const wchar_t *);\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) inwstr (wchar_t *);\t\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(NCURSES_CONST char*) key_name (wchar_t);\t\t/* implemented */", "extern NCURSES_EXPORT(int) killwchar (wchar_t *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) mvadd_wch (int, int, const cchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvadd_wchnstr (int, int, const cchar_t *, int);/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvadd_wchstr (int, int, const cchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvaddnwstr (int, int, const wchar_t *, int);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvaddwstr (int, int, const wchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvget_wch (int, int, wint_t *);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvget_wstr (int, int, wint_t *);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvgetn_wstr (int, int, wint_t *, int);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvhline_set (int, int, const cchar_t *, int);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvin_wch (int, int, cchar_t *);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvin_wchnstr (int, int, cchar_t *, int);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvin_wchstr (int, int, cchar_t *);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvinnwstr (int, int, wchar_t *, int);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvins_nwstr (int, int, const wchar_t *, int);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvins_wch (int, int, const cchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvins_wstr (int, int, const wchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvinwstr (int, int, wchar_t *);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvvline_set (int, int, const cchar_t *, int);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwadd_wch (WINDOW *, int, int, const cchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwadd_wchnstr (WINDOW *, int, int, const cchar_t *, int); /* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwadd_wchstr (WINDOW *, int, int, const cchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwaddnwstr (WINDOW *, int, int, const wchar_t *, int);/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwaddwstr (WINDOW *, int, int, const wchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwget_wch (WINDOW *, int, int, wint_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwget_wstr (WINDOW *, int, int, wint_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwgetn_wstr (WINDOW *, int, int, wint_t *, int);/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwhline_set (WINDOW *, int, int, const cchar_t *, int);/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwin_wch (WINDOW *, int, int, cchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwin_wchnstr (WINDOW *, int,int, cchar_t *,int);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwin_wchstr (WINDOW *, int, int, cchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwinnwstr (WINDOW *, int, int, wchar_t *, int);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwins_nwstr (WINDOW *, int,int, const wchar_t *,int); /* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwins_wch (WINDOW *, int, int, const cchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwins_wstr (WINDOW *, int, int, const wchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwinwstr (WINDOW *, int, int, wchar_t *);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwvline_set (WINDOW *, int,int, const cchar_t *,int); /* generated:WIDEC */", "extern NCURSES_EXPORT(int) pecho_wchar (WINDOW *, const cchar_t *);\t/* implemented */", "extern NCURSES_EXPORT(int) setcchar (cchar_t *, const wchar_t *, const attr_t, short, const void *);\t/* implemented */", "extern NCURSES_EXPORT(int) slk_wset (int, const wchar_t *, int);\t/* implemented */", "extern NCURSES_EXPORT(attr_t) term_attrs (void);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) unget_wch (const wchar_t);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) vid_attr (attr_t, short, void *);\t\t/* implemented */", "extern NCURSES_EXPORT(int) vid_puts (attr_t, short, void *, int (*)(int)); /* implemented */", "extern NCURSES_EXPORT(int) vline_set (const cchar_t *, int);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) wadd_wch (WINDOW *,const cchar_t *);\t\t/* implemented */", "extern NCURSES_EXPORT(int) wadd_wchnstr (WINDOW *,const cchar_t *,int);\t/* implemented */", "extern NCURSES_EXPORT(int) wadd_wchstr (WINDOW *,const cchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) waddnwstr (WINDOW *,const wchar_t *,int);\t/* implemented */", "extern NCURSES_EXPORT(int) waddwstr (WINDOW *,const wchar_t *);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) wbkgrnd (WINDOW *,const cchar_t *);\t\t/* implemented */", "extern NCURSES_EXPORT(void) wbkgrndset (WINDOW *,const cchar_t *);\t/* implemented */", "extern NCURSES_EXPORT(int) wborder_set (WINDOW *,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*);\t/* implemented */", "extern NCURSES_EXPORT(int) wecho_wchar (WINDOW *, const cchar_t *);\t/* implemented */", "extern NCURSES_EXPORT(int) wget_wch (WINDOW *, wint_t *);\t\t/* implemented */", "extern NCURSES_EXPORT(int) wget_wstr (WINDOW *, wint_t *);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) wgetbkgrnd (WINDOW *, cchar_t *);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) wgetn_wstr (WINDOW *,wint_t *, int);\t\t/* implemented */", "extern NCURSES_EXPORT(int) whline_set (WINDOW *, const cchar_t *, int);\t/* implemented */", "extern NCURSES_EXPORT(int) win_wch (WINDOW *, cchar_t *);\t\t/* implemented */", "extern NCURSES_EXPORT(int) win_wchnstr (WINDOW *, cchar_t *, int);\t/* implemented */", "extern NCURSES_EXPORT(int) win_wchstr (WINDOW *, cchar_t *);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) winnwstr (WINDOW *, wchar_t *, int);\t\t/* implemented */", "extern NCURSES_EXPORT(int) wins_nwstr (WINDOW *, const wchar_t *, int);\t/* implemented */", "extern NCURSES_EXPORT(int) wins_wch (WINDOW *, const cchar_t *);\t/* implemented */", "extern NCURSES_EXPORT(int) wins_wstr (WINDOW *, const wchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) winwstr (WINDOW *, wchar_t *);\t\t/* implemented */", "extern NCURSES_EXPORT(wchar_t*) wunctrl (cchar_t *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) wvline_set (WINDOW *, const cchar_t *, int);\t/* implemented */", "", "#ifndef NCURSES_NOMACROS", "", "/*", " * XSI curses macros for XPG4 conformance.", " */", "#define add_wch(c)\t\t\twadd_wch(stdscr,c)", "#define add_wchnstr(str,n)\t\twadd_wchnstr(stdscr,str,n)", "#define add_wchstr(str)\t\t\twadd_wchstr(stdscr,str)", "#define addnwstr(wstr,n)\t\twaddnwstr(stdscr,wstr,n)", "#define addwstr(wstr)\t\t\twaddwstr(stdscr,wstr)", "#define bkgrnd(c)\t\t\twbkgrnd(stdscr,c)", "#define bkgrndset(c)\t\t\twbkgrndset(stdscr,c)", "#define border_set(l,r,t,b,tl,tr,bl,br) wborder_set(stdscr,l,r,t,b,tl,tr,bl,br)", "#define box_set(w,v,h)\t\t\twborder_set(w,v,v,h,h,0,0,0,0)", "#define echo_wchar(c)\t\t\twecho_wchar(stdscr,c)", "#define get_wch(c)\t\t\twget_wch(stdscr,c)", "#define get_wstr(t)\t\t\twget_wstr(stdscr,t)", "#define getbkgrnd(wch)\t\t\twgetbkgrnd(stdscr,wch)", "#define getn_wstr(t,n)\t\t\twgetn_wstr(stdscr,t,n)", "#define hline_set(c,n)\t\t\twhline_set(stdscr,c,n)", "#define in_wch(c)\t\t\twin_wch(stdscr,c)", "#define in_wchnstr(c,n)\t\t\twin_wchnstr(stdscr,c,n)", "#define in_wchstr(c)\t\t\twin_wchstr(stdscr,c)", "#define innwstr(c,n)\t\t\twinnwstr(stdscr,c,n)", "#define ins_nwstr(t,n)\t\t\twins_nwstr(stdscr,t,n)", "#define ins_wch(c)\t\t\twins_wch(stdscr,c)", "#define ins_wstr(t)\t\t\twins_wstr(stdscr,t)", "#define inwstr(c)\t\t\twinwstr(stdscr,c)", "#define vline_set(c,n)\t\t\twvline_set(stdscr,c,n)", "#define wadd_wchstr(win,str)\t\twadd_wchnstr(win,str,-1)", "#define waddwstr(win,wstr)\t\twaddnwstr(win,wstr,-1)", "#define wget_wstr(w,t)\t\t\twgetn_wstr(w,t,-1)", "#define win_wchstr(w,c)\t\t\twin_wchnstr(w,c,-1)", "#define wins_wstr(w,t)\t\t\twins_nwstr(w,t,-1)", "", "#if !NCURSES_OPAQUE", "#define wgetbkgrnd(win,wch)\t\t(*wch = win->_bkgrnd, OK)", "#endif", "", "#define mvadd_wch(y,x,c)\t\tmvwadd_wch(stdscr,y,x,c)", "#define mvadd_wchnstr(y,x,s,n)\t\tmvwadd_wchnstr(stdscr,y,x,s,n)", "#define mvadd_wchstr(y,x,s)\t\tmvwadd_wchstr(stdscr,y,x,s)", "#define mvaddnwstr(y,x,wstr,n)\t\tmvwaddnwstr(stdscr,y,x,wstr,n)", "#define mvaddwstr(y,x,wstr)\t\tmvwaddwstr(stdscr,y,x,wstr)", "#define mvget_wch(y,x,c)\t\tmvwget_wch(stdscr,y,x,c)", "#define mvget_wstr(y,x,t)\t\tmvwget_wstr(stdscr,y,x,t)", "#define mvgetn_wstr(y,x,t,n)\t\tmvwgetn_wstr(stdscr,y,x,t,n)", "#define mvhline_set(y,x,c,n)\t\tmvwhline_set(stdscr,y,x,c,n)", "#define mvin_wch(y,x,c)\t\t\tmvwin_wch(stdscr,y,x,c)", "#define mvin_wchnstr(y,x,c,n)\t\tmvwin_wchnstr(stdscr,y,x,c,n)", "#define mvin_wchstr(y,x,c)\t\tmvwin_wchstr(stdscr,y,x,c)", "#define mvinnwstr(y,x,c,n)\t\tmvwinnwstr(stdscr,y,x,c,n)", "#define mvins_nwstr(y,x,t,n)\t\tmvwins_nwstr(stdscr,y,x,t,n)", "#define mvins_wch(y,x,c)\t\tmvwins_wch(stdscr,y,x,c)", "#define mvins_wstr(y,x,t)\t\tmvwins_wstr(stdscr,y,x,t)", "#define mvinwstr(y,x,c)\t\t\tmvwinwstr(stdscr,y,x,c)", "#define mvvline_set(y,x,c,n)\t\tmvwvline_set(stdscr,y,x,c,n)", "", "#define mvwadd_wch(win,y,x,c)\t\t(wmove(win,y,x) == ERR ? ERR : wadd_wch(win,c))", "#define mvwadd_wchnstr(win,y,x,s,n)\t(wmove(win,y,x) == ERR ? ERR : wadd_wchnstr(win,s,n))", "#define mvwadd_wchstr(win,y,x,s)\t(wmove(win,y,x) == ERR ? ERR : wadd_wchstr(win,s))", "#define mvwaddnwstr(win,y,x,wstr,n)\t(wmove(win,y,x) == ERR ? ERR : waddnwstr(win,wstr,n))", "#define mvwaddwstr(win,y,x,wstr)\t(wmove(win,y,x) == ERR ? ERR : waddwstr(win,wstr))", "#define mvwget_wch(win,y,x,c)\t\t(wmove(win,y,x) == ERR ? ERR : wget_wch(win,c))", "#define mvwget_wstr(win,y,x,t)\t\t(wmove(win,y,x) == ERR ? ERR : wget_wstr(win,t))", "#define mvwgetn_wstr(win,y,x,t,n)\t(wmove(win,y,x) == ERR ? ERR : wgetn_wstr(win,t,n))", "#define mvwhline_set(win,y,x,c,n)\t(wmove(win,y,x) == ERR ? ERR : whline_set(win,c,n))", "#define mvwin_wch(win,y,x,c)\t\t(wmove(win,y,x) == ERR ? ERR : win_wch(win,c))", "#define mvwin_wchnstr(win,y,x,c,n)\t(wmove(win,y,x) == ERR ? ERR : win_wchnstr(win,c,n))", "#define mvwin_wchstr(win,y,x,c)\t\t(wmove(win,y,x) == ERR ? ERR : win_wchstr(win,c))", "#define mvwinnwstr(win,y,x,c,n)\t\t(wmove(win,y,x) == ERR ? ERR : winnwstr(win,c,n))", "#define mvwins_nwstr(win,y,x,t,n)\t(wmove(win,y,x) == ERR ? ERR : wins_nwstr(win,t,n))", "#define mvwins_wch(win,y,x,c)\t\t(wmove(win,y,x) == ERR ? ERR : wins_wch(win,c))", "#define mvwins_wstr(win,y,x,t)\t\t(wmove(win,y,x) == ERR ? ERR : wins_wstr(win,t))", "#define mvwinwstr(win,y,x,c)\t\t(wmove(win,y,x) == ERR ? ERR : winwstr(win,c))", "#define mvwvline_set(win,y,x,c,n)\t(wmove(win,y,x) == ERR ? ERR : wvline_set(win,c,n))", "", "#endif /* NCURSES_NOMACROS */", "", "#if defined(TRACE) || defined(NCURSES_TEST)", "extern NCURSES_EXPORT(const char *) _nc_viswbuf(const wchar_t *);", "extern NCURSES_EXPORT(const char *) _nc_viswibuf(const wint_t *);", "#endif", "", "#endif /* _XOPEN_SOURCE_EXTENDED */", "/* $Id: curses.tail,v 1.16 2008/07/05 20:20:38 tom Exp $ */", "/*", " * vile:cmode:", " * This file is part of ncurses, designed to be appended after curses.h.in", " * (see that file for the relevant copyright).", " */", "", "/* mouse interface */", "", "#if NCURSES_MOUSE_VERSION > 1", "#define NCURSES_MOUSE_MASK(b,m) ((m) << (((b) - 1) * 5))", "#else", "#define NCURSES_MOUSE_MASK(b,m) ((m) << (((b) - 1) * 6))", "#endif", "", "#define\tNCURSES_BUTTON_RELEASED\t001L", "#define\tNCURSES_BUTTON_PRESSED\t002L", "#define\tNCURSES_BUTTON_CLICKED\t004L", "#define\tNCURSES_DOUBLE_CLICKED\t010L", "#define\tNCURSES_TRIPLE_CLICKED\t020L", "#define\tNCURSES_RESERVED_EVENT\t040L", "", "/* event masks */", "#define\tBUTTON1_RELEASED\tNCURSES_MOUSE_MASK(1, NCURSES_BUTTON_RELEASED)", "#define\tBUTTON1_PRESSED\t\tNCURSES_MOUSE_MASK(1, NCURSES_BUTTON_PRESSED)", "#define\tBUTTON1_CLICKED\t\tNCURSES_MOUSE_MASK(1, NCURSES_BUTTON_CLICKED)", "#define\tBUTTON1_DOUBLE_CLICKED\tNCURSES_MOUSE_MASK(1, NCURSES_DOUBLE_CLICKED)", "#define\tBUTTON1_TRIPLE_CLICKED\tNCURSES_MOUSE_MASK(1, NCURSES_TRIPLE_CLICKED)", "", "#define\tBUTTON2_RELEASED\tNCURSES_MOUSE_MASK(2, NCURSES_BUTTON_RELEASED)", "#define\tBUTTON2_PRESSED\t\tNCURSES_MOUSE_MASK(2, NCURSES_BUTTON_PRESSED)", "#define\tBUTTON2_CLICKED\t\tNCURSES_MOUSE_MASK(2, NCURSES_BUTTON_CLICKED)", "#define\tBUTTON2_DOUBLE_CLICKED\tNCURSES_MOUSE_MASK(2, NCURSES_DOUBLE_CLICKED)", "#define\tBUTTON2_TRIPLE_CLICKED\tNCURSES_MOUSE_MASK(2, NCURSES_TRIPLE_CLICKED)", "", "#define\tBUTTON3_RELEASED\tNCURSES_MOUSE_MASK(3, NCURSES_BUTTON_RELEASED)", "#define\tBUTTON3_PRESSED\t\tNCURSES_MOUSE_MASK(3, NCURSES_BUTTON_PRESSED)", "#define\tBUTTON3_CLICKED\t\tNCURSES_MOUSE_MASK(3, NCURSES_BUTTON_CLICKED)", "#define\tBUTTON3_DOUBLE_CLICKED\tNCURSES_MOUSE_MASK(3, NCURSES_DOUBLE_CLICKED)", "#define\tBUTTON3_TRIPLE_CLICKED\tNCURSES_MOUSE_MASK(3, NCURSES_TRIPLE_CLICKED)", "", "#define\tBUTTON4_RELEASED\tNCURSES_MOUSE_MASK(4, NCURSES_BUTTON_RELEASED)", "#define\tBUTTON4_PRESSED\t\tNCURSES_MOUSE_MASK(4, NCURSES_BUTTON_PRESSED)", "#define\tBUTTON4_CLICKED\t\tNCURSES_MOUSE_MASK(4, NCURSES_BUTTON_CLICKED)", "#define\tBUTTON4_DOUBLE_CLICKED\tNCURSES_MOUSE_MASK(4, NCURSES_DOUBLE_CLICKED)", "#define\tBUTTON4_TRIPLE_CLICKED\tNCURSES_MOUSE_MASK(4, NCURSES_TRIPLE_CLICKED)", "", "/*", " * In 32 bits the version-1 scheme does not provide enough space for a 5th", " * button, unless we choose to change the ABI by omitting the reserved-events.", " */", "#if NCURSES_MOUSE_VERSION > 1", "", "#define\tBUTTON5_RELEASED\tNCURSES_MOUSE_MASK(5, NCURSES_BUTTON_RELEASED)", "#define\tBUTTON5_PRESSED\t\tNCURSES_MOUSE_MASK(5, NCURSES_BUTTON_PRESSED)", "#define\tBUTTON5_CLICKED\t\tNCURSES_MOUSE_MASK(5, NCURSES_BUTTON_CLICKED)", "#define\tBUTTON5_DOUBLE_CLICKED\tNCURSES_MOUSE_MASK(5, NCURSES_DOUBLE_CLICKED)", "#define\tBUTTON5_TRIPLE_CLICKED\tNCURSES_MOUSE_MASK(5, NCURSES_TRIPLE_CLICKED)", "", "#define\tBUTTON_CTRL\t\tNCURSES_MOUSE_MASK(6, 0001L)", "#define\tBUTTON_SHIFT\t\tNCURSES_MOUSE_MASK(6, 0002L)", "#define\tBUTTON_ALT\t\tNCURSES_MOUSE_MASK(6, 0004L)", "#define\tREPORT_MOUSE_POSITION\tNCURSES_MOUSE_MASK(6, 0010L)", "", "#else", "", "#define\tBUTTON1_RESERVED_EVENT\tNCURSES_MOUSE_MASK(1, NCURSES_RESERVED_EVENT)", "#define\tBUTTON2_RESERVED_EVENT\tNCURSES_MOUSE_MASK(2, NCURSES_RESERVED_EVENT)", "#define\tBUTTON3_RESERVED_EVENT\tNCURSES_MOUSE_MASK(3, NCURSES_RESERVED_EVENT)", "#define\tBUTTON4_RESERVED_EVENT\tNCURSES_MOUSE_MASK(4, NCURSES_RESERVED_EVENT)", "", "#define\tBUTTON_CTRL\t\tNCURSES_MOUSE_MASK(5, 0001L)", "#define\tBUTTON_SHIFT\t\tNCURSES_MOUSE_MASK(5, 0002L)", "#define\tBUTTON_ALT\t\tNCURSES_MOUSE_MASK(5, 0004L)", "#define\tREPORT_MOUSE_POSITION\tNCURSES_MOUSE_MASK(5, 0010L)", "", "#endif", "", "#define\tALL_MOUSE_EVENTS\t(REPORT_MOUSE_POSITION - 1)", "", "/* macros to extract single event-bits from masks */", "#define\tBUTTON_RELEASE(e, x)\t\t((e) & NCURSES_MOUSE_MASK(x, 001))", "#define\tBUTTON_PRESS(e, x)\t\t((e) & NCURSES_MOUSE_MASK(x, 002))", "#define\tBUTTON_CLICK(e, x)\t\t((e) & NCURSES_MOUSE_MASK(x, 004))", "#define\tBUTTON_DOUBLE_CLICK(e, x)\t((e) & NCURSES_MOUSE_MASK(x, 010))", "#define\tBUTTON_TRIPLE_CLICK(e, x)\t((e) & NCURSES_MOUSE_MASK(x, 020))", "#define\tBUTTON_RESERVED_EVENT(e, x)\t((e) & NCURSES_MOUSE_MASK(x, 040))", "", "typedef struct", "{", "    short id;\t\t/* ID to distinguish multiple devices */", "    int x, y, z;\t/* event coordinates (character-cell) */", "    mmask_t bstate;\t/* button state bits */", "}", "MEVENT;", "", "extern NCURSES_EXPORT(int) getmouse (MEVENT *);", "extern NCURSES_EXPORT(int) ungetmouse (MEVENT *);", "extern NCURSES_EXPORT(mmask_t) mousemask (mmask_t, mmask_t *);", "extern NCURSES_EXPORT(bool) wenclose (const WINDOW *, int, int);", "extern NCURSES_EXPORT(int) mouseinterval (int);", "extern NCURSES_EXPORT(bool) wmouse_trafo (const WINDOW*, int*, int*, bool);", "extern NCURSES_EXPORT(bool) mouse_trafo (int*, int*, bool);              /* generated */", "", "#define mouse_trafo(y,x,to_screen) wmouse_trafo(stdscr,y,x,to_screen)", "", "/* other non-XSI functions */", "", "extern NCURSES_EXPORT(int) mcprint (char *, int);\t/* direct data to printer */", "extern NCURSES_EXPORT(int) has_key (int);\t\t/* do we have given key? */", "", "/* Debugging : use with libncurses_g.a */", "", "extern NCURSES_EXPORT(void) _tracef (const char *, ...) GCC_PRINTFLIKE(1,2);", "extern NCURSES_EXPORT(void) _tracedump (const char *, WINDOW *);", "extern NCURSES_EXPORT(char *) _traceattr (attr_t);", "extern NCURSES_EXPORT(char *) _traceattr2 (int, chtype);", "extern NCURSES_EXPORT(char *) _nc_tracebits (void);", "extern NCURSES_EXPORT(char *) _tracechar (int);", "extern NCURSES_EXPORT(char *) _tracechtype (chtype);", "extern NCURSES_EXPORT(char *) _tracechtype2 (int, chtype);", "#ifdef _XOPEN_SOURCE_EXTENDED", "#define _tracech_t\t\t_tracecchar_t", "extern NCURSES_EXPORT(char *) _tracecchar_t (const cchar_t *);", "#define _tracech_t2\t\t_tracecchar_t2", "extern NCURSES_EXPORT(char *) _tracecchar_t2 (int, const cchar_t *);", "#else", "#define _tracech_t\t\t_tracechtype", "#define _tracech_t2\t\t_tracechtype2", "#endif", "extern NCURSES_EXPORT(char *) _tracemouse (const MEVENT *);", "extern NCURSES_EXPORT(void) trace (const unsigned int);", "", "/* trace masks */", "#define TRACE_DISABLE\t0x0000\t/* turn off tracing */", "#define TRACE_TIMES\t0x0001\t/* trace user and system times of updates */", "#define TRACE_TPUTS\t0x0002\t/* trace tputs calls */", "#define TRACE_UPDATE\t0x0004\t/* trace update actions, old & new screens */", "#define TRACE_MOVE\t0x0008\t/* trace cursor moves and scrolls */", "#define TRACE_CHARPUT\t0x0010\t/* trace all character outputs */", "#define TRACE_ORDINARY\t0x001F\t/* trace all update actions */", "#define TRACE_CALLS\t0x0020\t/* trace all curses calls */", "#define TRACE_VIRTPUT\t0x0040\t/* trace virtual character puts */", "#define TRACE_IEVENT\t0x0080\t/* trace low-level input processing */", "#define TRACE_BITS\t0x0100\t/* trace state of TTY control bits */", "#define TRACE_ICALLS\t0x0200\t/* trace internal/nested calls */", "#define TRACE_CCALLS\t0x0400\t/* trace per-character calls */", "#define TRACE_DATABASE\t0x0800\t/* trace read/write of terminfo/termcap data */", "#define TRACE_ATTRS\t0x1000\t/* trace attribute updates */", "", "#define TRACE_SHIFT\t13\t/* number of bits in the trace masks */", "#define TRACE_MAXIMUM\t((1 << TRACE_SHIFT) - 1) /* maximum trace level */", "", "#if defined(TRACE) || defined(NCURSES_TEST)", "extern NCURSES_EXPORT_VAR(int) _nc_optimize_enable;\t\t/* enable optimizations */", "extern NCURSES_EXPORT(const char *) _nc_visbuf (const char *);", "#define OPTIMIZE_MVCUR\t\t0x01\t/* cursor movement optimization */", "#define OPTIMIZE_HASHMAP\t0x02\t/* diff hashing to detect scrolls */", "#define OPTIMIZE_SCROLL\t\t0x04\t/* scroll optimization */", "#define OPTIMIZE_ALL\t\t0xff\t/* enable all optimizations (dflt) */", "#endif", "", "#ifdef __cplusplus", "", "#ifndef NCURSES_NOMACROS", "", "/* these names conflict with STL */", "#undef box", "#undef clear", "#undef erase", "#undef move", "#undef refresh", "", "#endif /* NCURSES_NOMACROS */", "", "}", "#endif", "", "#endif /* __NCURSES_H */" },
    ["cxxabi.h"] = { "//===--------------------------- cxxabi.h ---------------------------------===//", "//", "//                     The LLVM Compiler Infrastructure", "//", "// This file is dual licensed under the MIT and the University of Illinois Open", "// Source Licenses. See LICENSE.TXT for details.", "//", "//===----------------------------------------------------------------------===//", "", "#ifndef __CXXABI_H", "#define __CXXABI_H ", "", "/*", " * This header provides the interface to the C++ ABI as defined at:", " *       http://www.codesourcery.com/cxx-abi/", " */", "", "#include <stddef.h>", "#include <stdint.h>", "", "#define _LIBCPPABI_VERSION 1001", "#define LIBCXXABI_NORETURN  __attribute__((noreturn))", "", "#ifdef __cplusplus", "", "namespace std {", "    class type_info; // forward declaration", "}", "", "", "// runtime routines use C calling conventions, but are in __cxxabiv1 namespace", "namespace __cxxabiv1 {  ", '  extern "C"  {', "", "// 2.4.2 Allocating the Exception Object", "extern void * __cxa_allocate_exception(size_t thrown_size) throw();", "extern void __cxa_free_exception(void * thrown_exception) throw();", "", "// 2.4.3 Throwing the Exception Object", "extern LIBCXXABI_NORETURN void __cxa_throw(void * thrown_exception, ", "        std::type_info * tinfo, void (*dest)(void *));", "", "// 2.5.3 Exception Handlers", "extern void * __cxa_get_exception_ptr(void * exceptionObject) throw();", "extern void * __cxa_begin_catch(void * exceptionObject) throw();", "extern void __cxa_end_catch();", "extern std::type_info * __cxa_current_exception_type();", "", "// 2.5.4 Rethrowing Exceptions", "extern LIBCXXABI_NORETURN void __cxa_rethrow();", "", "", "", "// 2.6 Auxiliary Runtime APIs", "extern LIBCXXABI_NORETURN void __cxa_bad_cast(void);", "extern LIBCXXABI_NORETURN void __cxa_bad_typeid(void);", "", "", "", "// 3.2.6 Pure Virtual Function API", "extern LIBCXXABI_NORETURN void __cxa_pure_virtual(void);", "", "// 3.2.7 Deleted Virtual Function API", "extern LIBCXXABI_NORETURN void __cxa_deleted_virtual(void);", "", "// 3.3.2 One-time Construction API", "#if __arm__", "extern int  __cxa_guard_acquire(uint32_t*);", "extern void __cxa_guard_release(uint32_t*);", "extern void __cxa_guard_abort(uint32_t*);", "#else", "extern int  __cxa_guard_acquire(uint64_t*);", "extern void __cxa_guard_release(uint64_t*);", "extern void __cxa_guard_abort(uint64_t*);", "#endif", "", "// 3.3.3 Array Construction and Destruction API", "extern void* __cxa_vec_new(size_t element_count, ", "                           size_t element_size, ", "                           size_t padding_size, ", "                           void (*constructor)(void*),", "                           void (*destructor)(void*) );", "", "extern void* __cxa_vec_new2(size_t element_count,", "                            size_t element_size, ", "                            size_t padding_size,", "                            void  (*constructor)(void*),", "                            void  (*destructor)(void*),", "                            void* (*alloc)(size_t), ", "                            void  (*dealloc)(void*) );", "", "extern void* __cxa_vec_new3(size_t element_count,", "                            size_t element_size, ", "                            size_t padding_size,", "                            void  (*constructor)(void*),", "                            void  (*destructor)(void*),", "                            void* (*alloc)(size_t), ", "                            void  (*dealloc)(void*, size_t) );", "  ", "extern void __cxa_vec_ctor(void*  array_address, ", "                           size_t element_count,", "                           size_t element_size, ", "                           void (*constructor)(void*),", "                           void (*destructor)(void*) );", "", "", "extern void __cxa_vec_dtor(void*  array_address, ", "                           size_t element_count,", "                           size_t element_size, ", "                           void (*destructor)(void*) );", "", "", "extern void __cxa_vec_cleanup(void* array_address, ", "                             size_t element_count,", "                             size_t element_size, ", "                             void  (*destructor)(void*) );", "", "", "extern void __cxa_vec_delete(void*  array_address, ", "                             size_t element_size, ", "                             size_t padding_size, ", "                             void  (*destructor)(void*) );", "", "", "extern void __cxa_vec_delete2(void* array_address, ", "                             size_t element_size, ", "                             size_t padding_size, ", "                             void  (*destructor)(void*),", "                             void  (*dealloc)(void*) );", "  ", "", "extern void __cxa_vec_delete3(void* __array_address, ", "                             size_t element_size, ", "                             size_t padding_size, ", "                             void  (*destructor)(void*),", "                             void  (*dealloc) (void*, size_t));", "", "", "extern void __cxa_vec_cctor(void*  dest_array, ", "                            void*  src_array, ", "                            size_t element_count, ", "                            size_t element_size, ", "                            void  (*constructor) (void*, void*), ", "                            void  (*destructor)(void*) );", "", "", "// 3.3.5.3 Runtime API", "extern int __cxa_atexit(void (*f)(void*), void* p, void* d);", "extern int __cxa_finalize(void*);", "", "", "// 3.4 Demangler API", "extern char* __cxa_demangle(const char* mangled_name, ", "                            char*       output_buffer,", "                            size_t*     length, ", "                            int*        status);", "", "// Apple additions to support C++ 0x exception_ptr class", "// These are primitives to wrap a smart pointer around an exception object", "extern void * __cxa_current_primary_exception() throw();", "extern void __cxa_rethrow_primary_exception(void* primary_exception);", "extern void __cxa_increment_exception_refcount(void* primary_exception) throw();", "extern void __cxa_decrement_exception_refcount(void* primary_exception) throw();", "", "// Apple addition to support std::uncaught_exception()", "extern bool __cxa_uncaught_exception() throw();", "", '  } // extern "C"', "} // namespace __cxxabiv1", "", "#endif // __cplusplus", "", "namespace abi = __cxxabiv1;", "", "#endif // __CXXABI_H " },
    ["db.h"] = { "/*-", " * Copyright (c) 1990, 1993, 1994", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)db.h\t8.7 (Berkeley) 6/16/94", " * $FreeBSD: src/include/db.h,v 1.5 2002/03/26 01:35:05 bde Exp $", " */", "", "#ifndef _DB_H_", "#define\t_DB_H_", "", "#include <sys/types.h>", "#include <sys/cdefs.h>", "", "#include <limits.h>", "", "#define\tRET_ERROR\t-1\t\t/* Return values. */", "#define\tRET_SUCCESS\t 0", "#define\tRET_SPECIAL\t 1", "", "#define\tMAX_PAGE_NUMBER\t0xffffffff\t/* >= # of pages in a file */", "typedef u_int32_t\tpgno_t;", "#define\tMAX_PAGE_OFFSET\t65535\t\t/* >= # of bytes in a page */", "typedef u_int16_t\tindx_t;", "#define\tMAX_REC_NUMBER\t0xffffffff\t/* >= # of records in a tree */", "typedef u_int32_t\trecno_t;", "", "/* Key/data structure -- a Data-Base Thang. */", "typedef struct {", "\tvoid\t*data;\t\t\t/* data */", "\tsize_t\t size;\t\t\t/* data length */", "} DBT;", "", "/* Routine flags. */", "#define\tR_CURSOR\t1\t\t/* del, put, seq */", "#define\t__R_UNUSED\t2\t\t/* UNUSED */", "#define\tR_FIRST\t\t3\t\t/* seq */", "#define\tR_IAFTER\t4\t\t/* put (RECNO) */", "#define\tR_IBEFORE\t5\t\t/* put (RECNO) */", "#define\tR_LAST\t\t6\t\t/* seq (BTREE, RECNO) */", "#define\tR_NEXT\t\t7\t\t/* seq */", "#define\tR_NOOVERWRITE\t8\t\t/* put */", "#define\tR_PREV\t\t9\t\t/* seq (BTREE, RECNO) */", "#define\tR_SETCURSOR\t10\t\t/* put (RECNO) */", "#define\tR_RECNOSYNC\t11\t\t/* sync (RECNO) */", "", "typedef enum { DB_BTREE, DB_HASH, DB_RECNO } DBTYPE;", "", "/*", " * !!!", " * The following flags are included in the dbopen(3) call as part of the", " * open(2) flags.  In order to avoid conflicts with the open flags, start", " * at the top of the 16 or 32-bit number space and work our way down.  If", " * the open flags were significantly expanded in the future, it could be", " * a problem.  Wish I'd left another flags word in the dbopen call.", " *", " * !!!", " * None of this stuff is implemented yet.  The only reason that it's here", " * is so that the access methods can skip copying the key/data pair when", " * the DB_LOCK flag isn't set.", " */", "#if UINT_MAX > 65535", "#define\tDB_LOCK\t\t0x20000000\t/* Do locking. */", "#define\tDB_SHMEM\t0x40000000\t/* Use shared memory. */", "#define\tDB_TXN\t\t0x80000000\t/* Do transactions. */", "#else", "#define\tDB_LOCK\t\t    0x2000\t/* Do locking. */", "#define\tDB_SHMEM\t    0x4000\t/* Use shared memory. */", "#define\tDB_TXN\t\t    0x8000\t/* Do transactions. */", "#endif", "", "/* Access method description structure. */", "typedef struct __db {", "\tDBTYPE type;\t\t\t/* Underlying db type. */", "\tint (*close)(struct __db *);", "\tint (*del)(const struct __db *, const DBT *, unsigned int);", "\tint (*get)(const struct __db *, const DBT *, DBT *, unsigned int);", "\tint (*put)(const struct __db *, DBT *, const DBT *, unsigned int);", "\tint (*seq)(const struct __db *, DBT *, DBT *, unsigned int);", "\tint (*sync)(const struct __db *, unsigned int);", "\tvoid *internal;\t\t\t/* Access method private. */", "\tint (*fd)(const struct __db *);", "} DB;", "", "#define\tBTREEMAGIC\t0x053162", "#define\tBTREEVERSION\t3", "", "/* Structure used to pass parameters to the btree routines. */", "typedef struct {", "#define\tR_DUP\t\t0x01\t/* duplicate keys */", "\tunsigned long\tflags;", "\tunsigned int\tcachesize;\t/* bytes to cache */", "\tint\t\tmaxkeypage;\t/* maximum keys per page */", "\tint\t\tminkeypage;\t/* minimum keys per page */", "\tunsigned int\tpsize;\t\t/* page size */", "\tint\t\t(*compare)\t/* comparison function */", "\t\t\t(const DBT *, const DBT *);", "\tsize_t\t\t(*prefix)\t/* prefix function */", "\t    \t\t(const DBT *, const DBT *);", "\tint\t\tlorder;\t\t/* byte order */", "} BTREEINFO;", "", "#define\tHASHMAGIC\t0x061561", "#define\tHASHVERSION\t2", "", "/* Structure used to pass parameters to the hashing routines. */", "typedef struct {", "\tunsigned int\tbsize;\t\t/* bucket size */", "\tunsigned int\tffactor;\t/* fill factor */", "\tunsigned int\tnelem;\t\t/* number of elements */", "\tunsigned int\tcachesize;\t/* bytes to cache */", "\tu_int32_t\t\t/* hash function */", "\t\t(*hash)(const void *, size_t);", "\tint\tlorder;\t\t/* byte order */", "} HASHINFO;", "", "/* Structure used to pass parameters to the record routines. */", "typedef struct {", "#define\tR_FIXEDLEN\t0x01\t/* fixed-length records */", "#define\tR_NOKEY\t\t0x02\t/* key not required */", "#define\tR_SNAPSHOT\t0x04\t/* snapshot the input */", "\tunsigned long\tflags;", "\tunsigned int\tcachesize;\t/* bytes to cache */", "\tunsigned int\tpsize;\t\t/* page size */", "\tint\t\tlorder;\t\t/* byte order */", "\tsize_t\t\treclen;\t\t/* record length (fixed-length records) */", "\tunsigned char\tbval;\t\t/* delimiting byte (variable-length records */", "\tchar\t*bfname;\t/* btree file name */ ", "} RECNOINFO;", "", "#ifdef __DBINTERFACE_PRIVATE", "/*", " * Little endian <==> big endian 32-bit swap macros.", " *\tM_32_SWAP\tswap a memory location", " *\tP_32_SWAP\tswap a referenced memory location", " *\tP_32_COPY\tswap from one location to another", " */", "#define\tM_32_SWAP(a) {\t\t\t\t\t\t\t\\", "\tu_int32_t _tmp = a;\t\t\t\t\t\t\\", "\t((char *)&a)[0] = ((char *)&_tmp)[3];\t\t\t\t\\", "\t((char *)&a)[1] = ((char *)&_tmp)[2];\t\t\t\t\\", "\t((char *)&a)[2] = ((char *)&_tmp)[1];\t\t\t\t\\", "\t((char *)&a)[3] = ((char *)&_tmp)[0];\t\t\t\t\\", "}", "#define\tP_32_SWAP(a) {\t\t\t\t\t\t\t\\", "\tu_int32_t _tmp = *(u_int32_t *)a;\t\t\t\t\\", "\t((char *)a)[0] = ((char *)&_tmp)[3];\t\t\t\t\\", "\t((char *)a)[1] = ((char *)&_tmp)[2];\t\t\t\t\\", "\t((char *)a)[2] = ((char *)&_tmp)[1];\t\t\t\t\\", "\t((char *)a)[3] = ((char *)&_tmp)[0];\t\t\t\t\\", "}", "#define\tP_32_COPY(a, b) {\t\t\t\t\t\t\\", "\t((char *)&(b))[0] = ((char *)&(a))[3];\t\t\t\t\\", "\t((char *)&(b))[1] = ((char *)&(a))[2];\t\t\t\t\\", "\t((char *)&(b))[2] = ((char *)&(a))[1];\t\t\t\t\\", "\t((char *)&(b))[3] = ((char *)&(a))[0];\t\t\t\t\\", "}", "", "/*", " * Little endian <==> big endian 16-bit swap macros.", " *\tM_16_SWAP\tswap a memory location", " *\tP_16_SWAP\tswap a referenced memory location", " *\tP_16_COPY\tswap from one location to another", " */", "#define\tM_16_SWAP(a) {\t\t\t\t\t\t\t\\", "\tu_int16_t _tmp = a;\t\t\t\t\t\t\\", "\t((char *)&a)[0] = ((char *)&_tmp)[1];\t\t\t\t\\", "\t((char *)&a)[1] = ((char *)&_tmp)[0];\t\t\t\t\\", "}", "#define\tP_16_SWAP(a) {\t\t\t\t\t\t\t\\", "\tu_int16_t _tmp = *(u_int16_t *)a;\t\t\t\t\\", "\t((char *)a)[0] = ((char *)&_tmp)[1];\t\t\t\t\\", "\t((char *)a)[1] = ((char *)&_tmp)[0];\t\t\t\t\\", "}", "#define\tP_16_COPY(a, b) {\t\t\t\t\t\t\\", "\t((char *)&(b))[0] = ((char *)&(a))[1];\t\t\t\t\\", "\t((char *)&(b))[1] = ((char *)&(a))[0];\t\t\t\t\\", "}", "#endif", "", "__BEGIN_DECLS", "DB *dbopen(const char *, int, int, DBTYPE, const void *);", "", "#ifdef __DBINTERFACE_PRIVATE", "DB\t*__bt_open(const char *, int, int, const BTREEINFO *, int);", "DB\t*__hash_open(const char *, int, int, const HASHINFO *, int);", "DB\t*__rec_open(const char *, int, int, const RECNOINFO *, int);", "void\t __dbpanic(DB *dbp);", "#endif", "__END_DECLS", "#endif /* !_DB_H_ */" },
    ["dirent.h"] = { "/*", " * Copyright (c) 2000, 2002-2008 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/*-", " * Copyright (c) 1989, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)dirent.h\t8.2 (Berkeley) 7/28/94", " */", "", "#ifndef _DIRENT_H_", "#define _DIRENT_H_", "", "/*", " * The kernel defines the format of directory entries", " */", "#include <_types.h>", "#include <sys/dirent.h>", "#include <sys/cdefs.h>", "#include <Availability.h>", "", "struct _telldir;\t\t/* forward reference */", "", "/* structure describing an open directory. */", "typedef struct {", "\tint\t__dd_fd;\t/* file descriptor associated with directory */", "\tlong\t__dd_loc;\t/* offset in current buffer */", "\tlong\t__dd_size;\t/* amount of data returned */", "\tchar\t*__dd_buf;\t/* data buffer */", "\tint\t__dd_len;\t/* size of data buffer */", "\tlong\t__dd_seek;\t/* magic cookie returned */", "\tlong\t__dd_rewind;\t/* magic cookie for rewinding */", "\tint\t__dd_flags;\t/* flags for readdir */", "\t__darwin_pthread_mutex_t __dd_lock; /* for thread locking */", "\tstruct _telldir *__dd_td; /* telldir position recording */", "} DIR;", "", "#if __DARWIN_C_LEVEL >= __DARWIN_C_FULL", "", "/* definitions for library routines operating on directories. */", "#define\tDIRBLKSIZ\t1024", "", "/* flags for opendir2 */", "#define DTF_HIDEW\t0x0001\t/* hide whiteout entries */", "#define DTF_NODUP\t0x0002\t/* don't return duplicate names */", "#define DTF_REWIND\t0x0004\t/* rewind after reading union stack */", "#define __DTF_READALL\t0x0008\t/* everything has been read */", "", "#endif /* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */", "", "#ifndef KERNEL", "", "__BEGIN_DECLS", "", "int closedir(DIR *) __DARWIN_ALIAS(closedir);", "", "DIR *opendir(const char *) __DARWIN_ALIAS_I(opendir);", "", "struct dirent *readdir(DIR *) __DARWIN_INODE64(readdir);", "int readdir_r(DIR *, struct dirent *, struct dirent **) __DARWIN_INODE64(readdir_r);", "", "void rewinddir(DIR *) __DARWIN_ALIAS_I(rewinddir);", "", "void seekdir(DIR *, long) __DARWIN_ALIAS_I(seekdir);", "", "long telldir(DIR *) __DARWIN_ALIAS_I(telldir);", "", "__END_DECLS", "", "", "/* Additional functionality provided by:", " * POSIX.1-2008", " */", "", "#if __DARWIN_C_LEVEL >= 200809L", "__BEGIN_DECLS", "", "int alphasort(const struct dirent **, const struct dirent **) __DARWIN_INODE64(alphasort);", "", "#if (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_8) || (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_6_0)", "#include <errno.h>", "#include <stdlib.h>", "#define dirfd(dirp) ({                         \\", "    DIR *_dirp = (dirp);                       \\", "    int ret = -1;                              \\", "    if (_dirp == NULL || _dirp->__dd_fd < 0)   \\", "        errno = EINVAL;                        \\", "    else                                       \\", "       ret = _dirp->__dd_fd;                   \\", "    ret;                                       \\", "})", "#else", "int dirfd(DIR *dirp) __OSX_AVAILABLE_STARTING(__MAC_10_8, __IPHONE_6_0);", "#endif", "", "int scandir(const char *, struct dirent ***,", "    int (*)(const struct dirent *), int (*)(const struct dirent **, const struct dirent **)) __DARWIN_INODE64(scandir);", "#ifdef __BLOCKS__", "int scandir_b(const char *, struct dirent ***,", "    int (^)(const struct dirent *), int (^)(const struct dirent **, const struct dirent **)) __DARWIN_INODE64(scandir_b) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);", "#endif /* __BLOCKS__ */", "", "__END_DECLS", "#endif /* __DARWIN_C_LEVEL >= 200809L */", "", "", "#if __DARWIN_C_LEVEL >= __DARWIN_C_FULL", "__BEGIN_DECLS", "", "int getdirentries(int, char *, int, long *)", "", "#if __DARWIN_64_BIT_INO_T", "/*", " * getdirentries() doesn't work when 64-bit inodes is in effect, so we", " * generate a link error.", " */", '\t\t\t\t\t\t__asm("_getdirentries_is_not_available_when_64_bit_inodes_are_in_effect")', "#else /* !__DARWIN_64_BIT_INO_T */", "\t\t\t\t\t\t__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0,__MAC_10_6, __IPHONE_2_0,__IPHONE_2_0)", "#endif /* __DARWIN_64_BIT_INO_T */", ";", "", "DIR *__opendir2(const char *, int) __DARWIN_ALIAS_I(__opendir2);", "", "__END_DECLS", "#endif /* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */", "", "#endif /* !KERNEL */", "", "#endif /* !_DIRENT_H_ */" },
    ["disktab.h"] = { "/*", " * Copyright (c) 1983, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)disktab.h\t8.1 (Berkeley) 6/2/93", " */", "", "#ifndef\t_DISKTAB_H_", "#define\t_DISKTAB_H_", "", "/*", " * Disk description table, see disktab(5)", " */", '#define\tDISKTAB\t\t"/etc/disktab"', "", "struct\tdisktab {", "\tchar\t*d_name;\t\t/* drive name */", "\tchar\t*d_type;\t\t/* drive type */", "\tint\td_secsize;\t\t/* sector size in bytes */", "\tint\td_ntracks;\t\t/* # tracks/cylinder */", "\tint\td_nsectors;\t\t/* # sectors/track */", "\tint\td_ncylinders;\t\t/* # cylinders */", "\tint\td_rpm;\t\t\t/* revolutions/minute */", "\tint\td_badsectforw;\t\t/* supports DEC bad144 std */", "\tint\td_sectoffset;\t\t/* use sect rather than cyl offsets */", "\tstruct\tpartition {", "\t\tint\tp_size;\t\t/* #sectors in partition */", "\t\tshort\tp_bsize;\t/* block size in bytes */", "\t\tshort\tp_fsize;\t/* frag size in bytes */", "\t} d_partitions[8];", "};", "", "#endif /* !_DISKTAB_H_ */" },
    ["dlfcn.h"] = { "/*", " * Copyright (c) 2004-2008 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "", "/*", "  Based on the dlcompat work done by:", "\t\tJorge Acereda  <jacereda@users.sourceforge.net> &", "\t\tPeter O'Gorman <ogorman@users.sourceforge.net>", "*/", "", "#ifndef _DLFCN_H_", "#define _DLFCN_H_", "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "", "#include <sys/cdefs.h>", "", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "#include <stdbool.h>", "#include <Availability.h>", "/*", " * Structure filled in by dladdr().", " */", "typedef struct dl_info {", "        const char      *dli_fname;     /* Pathname of shared object */", "        void            *dli_fbase;     /* Base address of shared object */", "        const char      *dli_sname;     /* Name of nearest symbol */", "        void            *dli_saddr;     /* Address of nearest symbol */", "} Dl_info;", "", "extern int dladdr(const void *, Dl_info *);", "#endif /* not POSIX */", "", "extern int dlclose(void * __handle);", "extern char * dlerror(void);", "extern void * dlopen(const char * __path, int __mode);", "extern void * dlsym(void * __handle, const char * __symbol);", "", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "extern bool dlopen_preflight(const char* __path) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "#endif /* not POSIX */", "", "", "#define RTLD_LAZY\t0x1", "#define RTLD_NOW\t0x2", "#define RTLD_LOCAL\t0x4", "#define RTLD_GLOBAL\t0x8", "", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "#define RTLD_NOLOAD\t0x10", "#define RTLD_NODELETE\t0x80", "#define RTLD_FIRST\t0x100\t/* Mac OS X 10.5 and later */", "", "/*", " * Special handle arguments for dlsym().", " */", "#define\tRTLD_NEXT\t((void *) -1)\t/* Search subsequent objects. */", "#define\tRTLD_DEFAULT\t((void *) -2)\t/* Use default search algorithm. */", "#define\tRTLD_SELF\t((void *) -3)\t/* Search this and subsequent objects (Mac OS X 10.5 and later) */", "#define\tRTLD_MAIN_ONLY\t((void *) -5)\t/* Search main executable only (Mac OS X 10.5 and later) */", "#endif /* not POSIX */", "", "#ifdef __cplusplus", "}", "#endif", "", "#endif /* _DLFCN_H_ */" },
    ["dns.h"] = { "/*", " * Copyright (c) 2003-2006 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "", "#ifndef __DNS_H__", "#define __DNS_H__", "", "#include <sys/cdefs.h>", "#include <sys/types.h>", "#include <stdint.h>", "#include <sys/socket.h>", "", "/*", " * The functions described in this access layer support multiple DNS", " * client configurations.  Each DNS client has its own set of nameserver", " * addresses and its own set of operational parameters.  Each client", " * can perform DNS queries and searches independent of other clients.", " * Each client has a symbolic name which is of the same format as a", ' * domain name, e.g. "apple.com".  A special meta-client, known as the', ' * "Super" DNS client, acts as a router for DNS queries.  The Super', " * client chooses among all available clients by finding a best match", " * between the domain name given in a query and the names of all known", " * clients.", " *", " * The configuration for a particular client may be read from a file", ' * having the same format as the traditional "/etc/resolv.conf" file.', " * However, client configurations are not limited to being stored in", " * files.  The implementation of the library may also locate client", " * configuratins in other data sources, such as the System Configuration", " * Database.  Users of this API should make no assumptions about the", " * source of the configuration data.", " */", "", "typedef const struct __dns_handle_private_struct *dns_handle_t;", "", "", "__BEGIN_DECLS", "", "/*", " * Create a client handle for DNS access.", " *", ' * "Super" DNS client', " *", ' * dns_open(NULL) returns a "super" client that routes DNS queries', " * among all DNS configurations known to the system.", " *", " * Queries for qualified names are sent using a client configuration that", " * best matches the domain name given in the query. For example, if there", ' * is a client named "apple.com", a search for "foo.apple.com" would use the', " * resolver configuration specified for that client.  The matching algorithm", " * chooses the client with the maximum number of matching domain components.", ' * For example, if there are clients named "a.b.c", and "b.c", a search for', ' * "x.a.b.c" would use the "a.b.c" resolver configuration, while a search', ' * for "x.y.b.c" would use the "b.c" client.  If there are no matches, the ', " * configuration settings in the default client - generally corresponding to", ' * the /etc/resolv.conf file or to the "primary" DNS configuration on the', " * system are used for the query.", " *", ' * The domain search list defined in the "default" client is used to search', " * for unqualified names, by appending each domain in the search list and", " * then following the logic for matching qualified names described above.", " *", " * The DNS access APIs may be used by multiple threads.  Each thread must", " * use a separate DNS client handle created by calling dns_open().", " *", " * A simple DNS client handle may be obtained by providing a non-NULL value", ' * for the "name" parameter.  Simple clients correspond to a single DNS', " * configuration, derived from a resolv.conf format file or from some other", " * source of configurations known to the system.", " * The name parameter may be a full or relative path name (starting with '/'", " * or '.'), in which case the client's configuration is read from the", " * named file.  If the name parameter is not a file path name, the routine", " * will search through all known sources of DNS configuration data on the", " * system to locate DNS configuration data corresponding to the name supplied,", " * or NULL if none can be found.", " *", " * Use _PATH_RESCONF to open /etc/resolv.conf.", " */", "extern dns_handle_t dns_open(const char *name);", "", "/*", " * Close a client and free its resources.", " */", "extern void dns_free(dns_handle_t dns);", "", "/*", " * Enable / Disable debug logging.", " */", "extern void dns_set_debug(dns_handle_t dns, uint32_t flag);", "", "/*", " * Returns the number of names in the search list.", " */", "extern uint32_t dns_search_list_domain_count(dns_handle_t dns);", "", "/* ", " * Returns the domain name at index i in the search list.", " * Returns NULL if there are no names in the search list,", " * or if i is out of range.", " * Caller must free the returned value.", " */", "extern char *dns_search_list_domain(dns_handle_t dns, uint32_t i);", "", "/*", " * Resolve a name.", " * The name is considered fully-qualified (the search list is not used).", " * Caller must supply buffer space for the reply message and the server address.", " */", "extern int32_t dns_query(dns_handle_t dns, const char *name, uint32_t dnsclass, uint32_t dnstype, char *buf, uint32_t len, struct sockaddr *from, uint32_t *fromlen);", "", "/*", " * Search for a name.", " * Caller must supply buffer space for the reply message and the server address.", " */", "extern int32_t dns_search(dns_handle_t dns, const char *name, uint32_t dnsclass, uint32_t dnstype, char *buf, uint32_t len, struct sockaddr *from, uint32_t *fromlen);", "", "__END_DECLS", "", "#endif /* __DNS_H__ */" },
    ["dns_sd.h"] = { "/* -*- Mode: C; tab-width: 4 -*-", " *", " * Copyright (c) 2003-2013 Apple Computer, Inc. All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions are met:", " *", " * 1.  Redistributions of source code must retain the above copyright notice,", " *     this list of conditions and the following disclaimer.", " * 2.  Redistributions in binary form must reproduce the above copyright notice,", " *     this list of conditions and the following disclaimer in the documentation", " *     and/or other materials provided with the distribution.", ' * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of its', " *     contributors may be used to endorse or promote products derived from this", " *     software without specific prior written permission.", " *", ' * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY', " * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED", " * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE", " * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY", " * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES", " * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;", " * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND", " * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT", " * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS", " * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.", " */", "", "", "/*! @header     DNS Service Discovery", " *", " * @discussion  This section describes the functions, callbacks, and data structures", " *              that make up the DNS Service Discovery API.", " *", " *              The DNS Service Discovery API is part of Bonjour, Apple's implementation", " *              of zero-configuration networking (ZEROCONF).", " *", " *              Bonjour allows you to register a network service, such as a", " *              printer or file server, so that it can be found by name or browsed", " *              for by service type and domain. Using Bonjour, applications can", " *              discover what services are available on the network, along with", " *              all the information -- such as name, IP address, and port --", " *              necessary to access a particular service.", " *", " *              In effect, Bonjour combines the functions of a local DNS server and", " *              AppleTalk. Bonjour allows applications to provide user-friendly printer", " *              and server browsing, among other things, over standard IP networks.", " *              This behavior is a result of combining protocols such as multicast and", " *              DNS to add new functionality to the network (such as multicast DNS).", " *", " *              Bonjour gives applications easy access to services over local IP", " *              networks without requiring the service or the application to support", " *              an AppleTalk or a Netbeui stack, and without requiring a DNS server", " *              for the local network.", " */", "", "", "/* _DNS_SD_H contains the mDNSResponder version number for this header file, formatted as follows:", " *   Major part of the build number * 10000 +", " *   minor part of the build number *   100", " * For example, Mac OS X 10.4.9 has mDNSResponder-108.4, which would be represented as", " * version 1080400. This allows C code to do simple greater-than and less-than comparisons:", " * e.g. an application that requires the DNSServiceGetProperty() call (new in mDNSResponder-126) can check:", " *", " *   #if _DNS_SD_H+0 >= 1260000", " *   ... some C code that calls DNSServiceGetProperty() ...", " *   #endif", " *", " * The version defined in this header file symbol allows for compile-time", " * checking, so that C code building with earlier versions of the header file", " * can avoid compile errors trying to use functions that aren't even defined", " * in those earlier versions. Similar checks may also be performed at run-time:", " *  => weak linking -- to avoid link failures if run with an earlier", " *     version of the library that's missing some desired symbol, or", " *  => DNSServiceGetProperty(DaemonVersion) -- to verify whether the running daemon", ' *     ("system service" on Windows) meets some required minimum functionality level.', " */", "", "#ifndef _DNS_SD_H", "#define _DNS_SD_H 5229002", "", "#ifdef  __cplusplus", 'extern "C" {', "#endif", "", "/* Set to 1 if libdispatch is supported", " * Note: May also be set by project and/or Makefile", " */", "#ifndef _DNS_SD_LIBDISPATCH", "#define _DNS_SD_LIBDISPATCH  1", "#endif /* ndef _DNS_SD_LIBDISPATCH */", "", "/* standard calling convention under Win32 is __stdcall */", "/* Note: When compiling Intel EFI (Extensible Firmware Interface) under MS Visual Studio, the */", "/* _WIN32 symbol is defined by the compiler even though it's NOT compiling code for Windows32 */", "#if defined(_WIN32) && !defined(EFI32) && !defined(EFI64)", "#define DNSSD_API __stdcall", "#else", "#define DNSSD_API", "#endif", "", "/* stdint.h does not exist on FreeBSD 4.x; its types are defined in sys/types.h instead */", "#if defined(__FreeBSD__) && (__FreeBSD__ < 5)", "#include <sys/types.h>", "", "/* Likewise, on Sun, standard integer types are in sys/types.h */", "#elif defined(__sun__)", "#include <sys/types.h>", "", "/* EFI does not have stdint.h, or anything else equivalent */", "#elif defined(EFI32) || defined(EFI64) || defined(EFIX64)", '#include "Tiano.h"', "#if !defined(_STDINT_H_)", "typedef UINT8 uint8_t;", "typedef INT8 int8_t;", "typedef UINT16 uint16_t;", "typedef INT16 int16_t;", "typedef UINT32 uint32_t;", "typedef INT32 int32_t;", "#endif", "/* Windows has its own differences */", "#elif defined(_WIN32)", "#include <windows.h>", "#define _UNUSED", "#ifndef _MSL_STDINT_H", "typedef UINT8 uint8_t;", "typedef INT8 int8_t;", "typedef UINT16 uint16_t;", "typedef INT16 int16_t;", "typedef UINT32 uint32_t;", "typedef INT32 int32_t;", "#endif", "", "/* All other Posix platforms use stdint.h */", "#else", "#include <stdint.h>", "#endif", "", "#if _DNS_SD_LIBDISPATCH", "#include <dispatch/dispatch.h>", "#endif", "", "/* DNSServiceRef, DNSRecordRef", " *", " * Opaque internal data types.", " * Note: client is responsible for serializing access to these structures if", " * they are shared between concurrent threads.", " */", "", "typedef struct _DNSServiceRef_t *DNSServiceRef;", "typedef struct _DNSRecordRef_t *DNSRecordRef;", "", "struct sockaddr;", "", "/*! @enum General flags", " * Most DNS-SD API functions and callbacks include a DNSServiceFlags parameter.", " * As a general rule, any given bit in the 32-bit flags field has a specific fixed meaning,", " * regardless of the function or callback being used. For any given function or callback,", " * typically only a subset of the possible flags are meaningful, and all others should be zero.", " * The discussion section for each API call describes which flags are valid for that call", " * and callback. In some cases, for a particular call, it may be that no flags are currently", " * defined, in which case the DNSServiceFlags parameter exists purely to allow future expansion.", " * In all cases, developers should expect that in future releases, it is possible that new flag", " * values will be defined, and write code with this in mind. For example, code that tests", " *     if (flags == kDNSServiceFlagsAdd) ...", " * will fail if, in a future release, another bit in the 32-bit flags field is also set.", " * The reliable way to test whether a particular bit is set is not with an equality test,", " * but with a bitwise mask:", " *     if (flags & kDNSServiceFlagsAdd) ...", " * With the exception of kDNSServiceFlagsValidate, each flag can be valid(be set) ", " * EITHER only as an input to one of the DNSService*() APIs OR only as an output", " * (provide status) through any of the callbacks used. For example, kDNSServiceFlagsAdd", " * can be set only as an output in the callback, whereas the kDNSServiceFlagsIncludeP2P", " * can be set only as an input to the DNSService*() APIs. See comments on kDNSServiceFlagsValidate  ", " * defined in enum below.", " */", "enum", "{", "    kDNSServiceFlagsMoreComing          = 0x1,", "    /* MoreComing indicates to a callback that at least one more result is", "     * queued and will be delivered following immediately after this one.", "     * When the MoreComing flag is set, applications should not immediately", "     * update their UI, because this can result in a great deal of ugly flickering", "     * on the screen, and can waste a great deal of CPU time repeatedly updating", "     * the screen with content that is then immediately erased, over and over.", "     * Applications should wait until MoreComing is not set, and then", "     * update their UI when no more changes are imminent.", "     * When MoreComing is not set, that doesn't mean there will be no more", "     * answers EVER, just that there are no more answers immediately", "     * available right now at this instant. If more answers become available", "     * in the future they will be delivered as usual.", "     */", "", "    kDNSServiceFlagsAdd                 = 0x2,", "    kDNSServiceFlagsDefault             = 0x4,", "    /* Flags for domain enumeration and browse/query reply callbacks.", '     * "Default" applies only to enumeration and is only valid in', '     * conjunction with "Add". An enumeration callback with the "Add"', '     * flag NOT set indicates a "Remove", i.e. the domain is no longer', "     * valid.", "     */", "", "    kDNSServiceFlagsNoAutoRename        = 0x8,", "    /* Flag for specifying renaming behavior on name conflict when registering", "     * non-shared records. By default, name conflicts are automatically handled", "     * by renaming the service. NoAutoRename overrides this behavior - with this", "     * flag set, name conflicts will result in a callback. The NoAutorename flag", "     * is only valid if a name is explicitly specified when registering a service", "     * (i.e. the default name is not used.)", "     */", "", "    kDNSServiceFlagsShared              = 0x10,", "    kDNSServiceFlagsUnique              = 0x20,", "    /* Flag for registering individual records on a connected", "     * DNSServiceRef. Shared indicates that there may be multiple records", "     * with this name on the network (e.g. PTR records). Unique indicates that the", "     * record's name is to be unique on the network (e.g. SRV records).", "     */", "", "    kDNSServiceFlagsBrowseDomains       = 0x40,", "    kDNSServiceFlagsRegistrationDomains = 0x80,", "    /* Flags for specifying domain enumeration type in DNSServiceEnumerateDomains.", "     * BrowseDomains enumerates domains recommended for browsing, RegistrationDomains", "     * enumerates domains recommended for registration.", "     */", "", "    kDNSServiceFlagsLongLivedQuery      = 0x100,", "    /* Flag for creating a long-lived unicast query for the DNSServiceQueryRecord call. */", "", "    kDNSServiceFlagsAllowRemoteQuery    = 0x200,", "    /* Flag for creating a record for which we will answer remote queries", "     * (queries from hosts more than one hop away; hosts not directly connected to the local link).", "     */", "", "    kDNSServiceFlagsForceMulticast      = 0x400,", "    /* Flag for signifying that a query or registration should be performed exclusively via multicast", "     * DNS, even for a name in a domain (e.g. foo.apple.com.) that would normally imply unicast DNS.", "     */", "", "    kDNSServiceFlagsForce               = 0x800,    // This flag is deprecated.", "", "    kDNSServiceFlagsKnownUnique         = 0x800,", "    /* ", "     * Client guarantees that record names are unique, so we can skip sending out initial", "     * probe messages.  Standard name conflict resolution is still done if a conflict is discovered.", "     * Currently only valid for a DNSServiceRegister call.", "     */", "", "    kDNSServiceFlagsReturnIntermediates = 0x1000,", "    /* Flag for returning intermediate results.", "     * For example, if a query results in an authoritative NXDomain (name does not exist)", "     * then that result is returned to the client. However the query is not implicitly", "     * cancelled -- it remains active and if the answer subsequently changes", "     * (e.g. because a VPN tunnel is subsequently established) then that positive", "     * result will still be returned to the client.", "     * Similarly, if a query results in a CNAME record, then in addition to following", "     * the CNAME referral, the intermediate CNAME result is also returned to the client.", "     * When this flag is not set, NXDomain errors are not returned, and CNAME records", "     * are followed silently without informing the client of the intermediate steps.", "     * (In earlier builds this flag was briefly calledkDNSServiceFlagsReturnCNAME)", "     */", "", "    kDNSServiceFlagsNonBrowsable        = 0x2000,", "    /* A service registered with the NonBrowsable flag set can be resolved using", "     * DNSServiceResolve(), but will not be discoverable using DNSServiceBrowse().", "     * This is for cases where the name is actually a GUID; it is found by other means;", "     * there is no end-user benefit to browsing to find a long list of opaque GUIDs.", "     * Using the NonBrowsable flag creates SRV+TXT without the cost of also advertising", "     * an associated PTR record.", "     */", "", "    kDNSServiceFlagsShareConnection     = 0x4000,", "    /* For efficiency, clients that perform many concurrent operations may want to use a", "     * single Unix Domain Socket connection with the background daemon, instead of having a", "     * separate connection for each independent operation. To use this mode, clients first", "     * call DNSServiceCreateConnection(&MainRef) to initialize the main DNSServiceRef.", "     * For each subsequent operation that is to share that same connection, the client copies", "     * the MainRef, and then passes the address of that copy, setting the ShareConnection flag", "     * to tell the library that this DNSServiceRef is not a typical uninitialized DNSServiceRef;", "     * it's a copy of an existing DNSServiceRef whose connection information should be reused.", "     *", "     * For example:", "     *", "     * DNSServiceErrorType error;", "     * DNSServiceRef MainRef;", "     * error = DNSServiceCreateConnection(&MainRef);", "     * if (error) ...", "     * DNSServiceRef BrowseRef = MainRef;  // Important: COPY the primary DNSServiceRef first...", "     * error = DNSServiceBrowse(&BrowseRef, kDNSServiceFlagsShareConnection, ...); // then use the copy", "     * if (error) ...", "     * ...", "     * DNSServiceRefDeallocate(BrowseRef); // Terminate the browse operation", "     * DNSServiceRefDeallocate(MainRef);   // Terminate the shared connection", "     *", "     * Notes:", "     *", "     * 1. Collective kDNSServiceFlagsMoreComing flag", "     * When callbacks are invoked using a shared DNSServiceRef, the", "     * kDNSServiceFlagsMoreComing flag applies collectively to *all* active", "     * operations sharing the same parent DNSServiceRef. If the MoreComing flag is", "     * set it means that there are more results queued on this parent DNSServiceRef,", "     * but not necessarily more results for this particular callback function.", "     * The implication of this for client programmers is that when a callback", "     * is invoked with the MoreComing flag set, the code should update its", "     * internal data structures with the new result, and set a variable indicating", "     * that its UI needs to be updated. Then, later when a callback is eventually", "     * invoked with the MoreComing flag not set, the code should update *all*", "     * stale UI elements related to that shared parent DNSServiceRef that need", "     * updating, not just the UI elements related to the particular callback", "     * that happened to be the last one to be invoked.", "     *", "     * 2. Canceling operations and kDNSServiceFlagsMoreComing", "     * Whenever you cancel any operation for which you had deferred UI updates", "     * waiting because of a kDNSServiceFlagsMoreComing flag, you should perform", "     * those deferred UI updates. This is because, after cancelling the operation,", "     * you can no longer wait for a callback *without* MoreComing set, to tell", "     * you do perform your deferred UI updates (the operation has been canceled,", "     * so there will be no more callbacks). An implication of the collective", "     * kDNSServiceFlagsMoreComing flag for shared connections is that this", "     * guideline applies more broadly -- any time you cancel an operation on", "     * a shared connection, you should perform all deferred UI updates for all", "     * operations sharing that connection. This is because the MoreComing flag", "     * might have been referring to events coming for the operation you canceled,", "     * which will now not be coming because the operation has been canceled.", "     *", "     * 3. Only share DNSServiceRef's created with DNSServiceCreateConnection", "     * Calling DNSServiceCreateConnection(&ref) creates a special shareable DNSServiceRef.", "     * DNSServiceRef's created by other calls like DNSServiceBrowse() or DNSServiceResolve()", "     * cannot be shared by copying them and using kDNSServiceFlagsShareConnection.", "     *", "     * 4. Don't Double-Deallocate", "     * Calling DNSServiceRefDeallocate(ref) for a particular operation's DNSServiceRef terminates", "     * just that operation. Calling DNSServiceRefDeallocate(ref) for the main shared DNSServiceRef", "     * (the parent DNSServiceRef, originally created by DNSServiceCreateConnection(&ref))", "     * automatically terminates the shared connection and all operations that were still using it.", "     * After doing this, DO NOT then attempt to deallocate any remaining subordinate DNSServiceRef's.", "     * The memory used by those subordinate DNSServiceRef's has already been freed, so any attempt", "     * to do a DNSServiceRefDeallocate (or any other operation) on them will result in accesses", "     * to freed memory, leading to crashes or other equally undesirable results.", "     *", "     * 5. Thread Safety", "     * The dns_sd.h API does not presuppose any particular threading model, and consequently", "     * does no locking of its own (which would require linking some specific threading library).", "     * If client code calls API routines on the same DNSServiceRef concurrently", "     * from multiple threads, it is the client's responsibility to use a mutext", "     * lock or take similar appropriate precautions to serialize those calls.", "     */", "", "    kDNSServiceFlagsSuppressUnusable    = 0x8000,", "    /*", "     * This flag is meaningful only in DNSServiceQueryRecord which suppresses unusable queries on the", '     * wire. If "hostname" is a wide-area unicast DNS hostname (i.e. not a ".local." name)', "     * but this host has no routable IPv6 address, then the call will not try to look up IPv6 addresses", '     * for "hostname", since any addresses it found would be unlikely to be of any use anyway. Similarly,', "     * if this host has no routable IPv4 address, the call will not try to look up IPv4 addresses for", '     * "hostname".', "     */", "", "    kDNSServiceFlagsTimeout            = 0x10000,", "    /*", "     * When kDNServiceFlagsTimeout is passed to DNSServiceQueryRecord or DNSServiceGetAddrInfo, the query is", "     * stopped after a certain number of seconds have elapsed. The time at which the query will be stopped", "     * is determined by the system and cannot be configured by the user. The query will be stopped irrespective", "     * of whether a response was given earlier or not. When the query is stopped, the callback will be called", "     * with an error code of kDNSServiceErr_Timeout and a NULL sockaddr will be returned for DNSServiceGetAddrInfo", "     * and zero length rdata will be returned for DNSServiceQueryRecord.", "     */", "", "    kDNSServiceFlagsIncludeP2P          = 0x20000,", "    /*", "     * Include P2P interfaces when kDNSServiceInterfaceIndexAny is specified.", "     * By default, specifying kDNSServiceInterfaceIndexAny does not include P2P interfaces.", "     */", "", "    kDNSServiceFlagsWakeOnResolve      = 0x40000,", "    /*", "    * This flag is meaningful only in DNSServiceResolve. When set, it tries to send a magic packet", "    * to wake up the client.", "    */", "", "    kDNSServiceFlagsBackgroundTrafficClass  = 0x80000,", "    /*", "    * This flag is meaningful in DNSServiceBrowse, DNSServiceGetAddrInfo, DNSServiceQueryRecord, ", "    * and DNSServiceResolve. When set, it uses the background traffic ", "    * class for packets that service the request.", "    */", "", "    kDNSServiceFlagsIncludeAWDL      = 0x100000,", "   /*", "    * Include AWDL interface when kDNSServiceInterfaceIndexAny is specified.", "    */", "", "    kDNSServiceFlagsValidate               = 0x200000,", "   /*", "    * This flag is meaningful in DNSServiceGetAddrInfo and DNSServiceQueryRecord. This is the ONLY flag to be valid ", "    * as an input to the APIs and also an output through the callbacks in the APIs.", "    *", "    * When this flag is passed to DNSServiceQueryRecord and DNSServiceGetAddrInfo to resolve unicast names, ", "    * the response  will be validated using DNSSEC. The validation results are delivered using the flags field in ", "    * the callback and kDNSServiceFlagsValidate is marked in the flags to indicate that DNSSEC status is also available.", "    * When the callback is called to deliver the query results, the validation results may or may not be available. ", "    * If it is not delivered along with the results, the validation status is delivered when the validation completes.", "    * ", "    * When the validation results are delivered in the callback, it is indicated by marking the flags with", "    * kDNSServiceFlagsValidate and kDNSServiceFlagsAdd along with the DNSSEC status flags (described below) and a NULL", "    * sockaddr will be returned for DNSServiceGetAddrInfo and zero length rdata will be returned for DNSServiceQueryRecord.", "    * DNSSEC validation results are for the whole RRSet and not just individual records delivered in the callback. When", "    * kDNSServiceFlagsAdd is not set in the flags, applications should implicitly assume that the DNSSEC status of the ", "    * RRSet that has been delivered up until that point is not valid anymore, till another callback is called with", "    * kDNSServiceFlagsAdd and kDNSServiceFlagsValidate.", "    *", "    * The following four flags indicate the status of the DNSSEC validation and marked in the flags field of the callback.", "    * When any of the four flags is set, kDNSServiceFlagsValidate will also be set. To check the validation status, the ", "    * other applicable output flags should be masked. See kDNSServiceOutputFlags below.", "    */", "", "    kDNSServiceFlagsSecure                 = 0x200010,", "   /*", "    * The response has been validated by verifying all the signaures in the response and was able to", "    * build a successful authentication chain starting from a known trust anchor.   ", "    */", "", "    kDNSServiceFlagsInsecure               = 0x200020,", "   /*", "    * A chain of trust cannot be built starting from a known trust anchor to the response.", "    */", "", "    kDNSServiceFlagsBogus                  = 0x200040,", "   /*", "    * If the response cannot be verified to be secure due to expired signatures, missing signatures etc.,", "    * then the results are considered to be bogus.", "    */", "", "    kDNSServiceFlagsIndeterminate          = 0x200080,", "   /*", "    * There is no valid trust anchor that can be used to determine whether a response is secure or not.", "    */", "", "    kDNSServiceFlagsUnicastResponse        = 0x400000,", "   /*", "    * Request unicast response to query.", "    */", "    kDNSServiceFlagsValidateOptional       = 0x800000,", "", "    /*", "     * This flag is identical to kDNSServiceFlagsValidate except for the case where the response", "     * cannot be validated. If this flag is set in DNSServiceQueryRecord or DNSServiceGetAddrInfo,", "     * the DNSSEC records will be requested for validation. If they cannot be received for some reason", "     * during the validation (e.g., zone is not signed, zone is signed but cannot be traced back to", "     * root, recursive server does not understand DNSSEC etc.), then this will fallback to the default", "     * behavior where the validation will not be performed and no DNSSEC results will be provided.", "     *", "     * If the zone is signed and there is a valid path to a known trust anchor configured in the system", "     * and the application requires DNSSEC validation irrespective of the DNSSEC awareness in the current", "     * network, then this option MUST not be used. This is only intended to be used during the transition", "     * period where the different nodes participating in the DNS resolution may not understand DNSSEC or", "     * managed properly (e.g. missing DS record) but still want to be able to resolve DNS successfully.", "     */", "", "    kDNSServiceFlagsWakeOnlyService        = 0x1000000,", "    /*", "     * This flag is meaningful only in DNSServiceRegister. When set, the service will not be registered", "     * with sleep proxy server during sleep.", "     */", "", "    kDNSServiceFlagsThresholdOne           = 0x2000000,", "    kDNSServiceFlagsThresholdFinder        = 0x4000000,", "    kDNSServiceFlagsThresholdReached       = kDNSServiceFlagsThresholdOne,", "    /*", "     * kDNSServiceFlagsThresholdOne is meaningful only in DNSServiceBrowse. When set,", "     * the system will stop issuing browse queries on the network once the number", "     * of answers returned is one or more.  It will issue queries on the network", "     * again if the number of answers drops to zero.", "     * This flag is for Apple internal use only. Third party developers", "     * should not rely on this behavior being supported in any given software release.", "     *", "     * kDNSServiceFlagsThresholdFinder is meaningful only in DNSServiceBrowse. When set,", "     * the system will stop issuing browse queries on the network once the number", "     * of answers has reached the threshold set for Finder.", "     * It will issue queries on the network again if the number of answers drops below", "     * this threshold.", "     * This flag is for Apple internal use only. Third party developers", "     * should not rely on this behavior being supported in any given software release.", "     *", "     * When kDNSServiceFlagsThresholdReached is set in the client callback add or remove event,", "     * it indicates that the browse answer threshold has been reached and no ", "     * browse requests will be generated on the network until the number of answers falls", "     * below the threshold value.  Add and remove events can still occur based", "     * on incoming Bonjour traffic observed by the system.", "     * The set of services return to the client is not guaranteed to represent the ", "     * entire set of services present on the network once the threshold has been reached.", "     *", "     * Note, while kDNSServiceFlagsThresholdReached and kDNSServiceFlagsThresholdOne", "     * have the same value, there  isn't a conflict because kDNSServiceFlagsThresholdReached", "     * is only set in the callbacks and kDNSServiceFlagsThresholdOne is only set on", "     * input to a DNSServiceBrowse call.", "     */", "};", "", "#define kDNSServiceOutputFlags (kDNSServiceFlagsValidate | kDNSServiceFlagsValidateOptional | kDNSServiceFlagsMoreComing | kDNSServiceFlagsAdd | kDNSServiceFlagsDefault)", "   /* All the output flags excluding the DNSSEC Status flags. Typically used to check DNSSEC Status */", "", "/* Possible protocol values */", "enum", "{", "    /* for DNSServiceGetAddrInfo() */", "    kDNSServiceProtocol_IPv4 = 0x01,", "    kDNSServiceProtocol_IPv6 = 0x02,", "    /* 0x04 and 0x08 reserved for future internetwork protocols */", "", "    /* for DNSServiceNATPortMappingCreate() */", "    kDNSServiceProtocol_UDP  = 0x10,", "    kDNSServiceProtocol_TCP  = 0x20", "                               /* 0x40 and 0x80 reserved for future transport protocols, e.g. SCTP [RFC 2960]", "                                * or DCCP [RFC 4340]. If future NAT gateways are created that support port", "                                * mappings for these protocols, new constants will be defined here.", "                                */", "};", "", "/*", " * The values for DNS Classes and Types are listed in RFC 1035, and are available", " * on every OS in its DNS header file. Unfortunately every OS does not have the", " * same header file containing DNS Class and Type constants, and the names of", ' * the constants are not consistent. For example, BIND 8 uses "T_A",', ' * BIND 9 uses "ns_t_a", Windows uses "DNS_TYPE_A", etc.', " * For this reason, these constants are also listed here, so that code using", " * the DNS-SD programming APIs can use these constants, so that the same code", " * can compile on all our supported platforms.", " */", "", "enum", "{", "    kDNSServiceClass_IN       = 1       /* Internet */", "};", "", "enum", "{", "    kDNSServiceType_A          = 1,      /* Host address. */", "    kDNSServiceType_NS         = 2,      /* Authoritative server. */", "    kDNSServiceType_MD         = 3,      /* Mail destination. */", "    kDNSServiceType_MF         = 4,      /* Mail forwarder. */", "    kDNSServiceType_CNAME      = 5,      /* Canonical name. */", "    kDNSServiceType_SOA        = 6,      /* Start of authority zone. */", "    kDNSServiceType_MB         = 7,      /* Mailbox domain name. */", "    kDNSServiceType_MG         = 8,      /* Mail group member. */", "    kDNSServiceType_MR         = 9,      /* Mail rename name. */", "    kDNSServiceType_NULL       = 10,     /* Null resource record. */", "    kDNSServiceType_WKS        = 11,     /* Well known service. */", "    kDNSServiceType_PTR        = 12,     /* Domain name pointer. */", "    kDNSServiceType_HINFO      = 13,     /* Host information. */", "    kDNSServiceType_MINFO      = 14,     /* Mailbox information. */", "    kDNSServiceType_MX         = 15,     /* Mail routing information. */", '    kDNSServiceType_TXT        = 16,     /* One or more text strings (NOT "zero or more..."). */', "    kDNSServiceType_RP         = 17,     /* Responsible person. */", "    kDNSServiceType_AFSDB      = 18,     /* AFS cell database. */", "    kDNSServiceType_X25        = 19,     /* X_25 calling address. */", "    kDNSServiceType_ISDN       = 20,     /* ISDN calling address. */", "    kDNSServiceType_RT         = 21,     /* Router. */", "    kDNSServiceType_NSAP       = 22,     /* NSAP address. */", "    kDNSServiceType_NSAP_PTR   = 23,     /* Reverse NSAP lookup (deprecated). */", "    kDNSServiceType_SIG        = 24,     /* Security signature. */", "    kDNSServiceType_KEY        = 25,     /* Security key. */", "    kDNSServiceType_PX         = 26,     /* X.400 mail mapping. */", "    kDNSServiceType_GPOS       = 27,     /* Geographical position (withdrawn). */", "    kDNSServiceType_AAAA       = 28,     /* IPv6 Address. */", "    kDNSServiceType_LOC        = 29,     /* Location Information. */", "    kDNSServiceType_NXT        = 30,     /* Next domain (security). */", "    kDNSServiceType_EID        = 31,     /* Endpoint identifier. */", "    kDNSServiceType_NIMLOC     = 32,     /* Nimrod Locator. */", "    kDNSServiceType_SRV        = 33,     /* Server Selection. */", "    kDNSServiceType_ATMA       = 34,     /* ATM Address */", "    kDNSServiceType_NAPTR      = 35,     /* Naming Authority PoinTeR */", "    kDNSServiceType_KX         = 36,     /* Key Exchange */", "    kDNSServiceType_CERT       = 37,     /* Certification record */", "    kDNSServiceType_A6         = 38,     /* IPv6 Address (deprecated) */", "    kDNSServiceType_DNAME      = 39,     /* Non-terminal DNAME (for IPv6) */", "    kDNSServiceType_SINK       = 40,     /* Kitchen sink (experimental) */", "    kDNSServiceType_OPT        = 41,     /* EDNS0 option (meta-RR) */", "    kDNSServiceType_APL        = 42,     /* Address Prefix List */", "    kDNSServiceType_DS         = 43,     /* Delegation Signer */", "    kDNSServiceType_SSHFP      = 44,     /* SSH Key Fingerprint */", "    kDNSServiceType_IPSECKEY   = 45,     /* IPSECKEY */", "    kDNSServiceType_RRSIG      = 46,     /* RRSIG */", "    kDNSServiceType_NSEC       = 47,     /* Denial of Existence */", "    kDNSServiceType_DNSKEY     = 48,     /* DNSKEY */", "    kDNSServiceType_DHCID      = 49,     /* DHCP Client Identifier */", "    kDNSServiceType_NSEC3      = 50,     /* Hashed Authenticated Denial of Existence */", "    kDNSServiceType_NSEC3PARAM = 51,     /* Hashed Authenticated Denial of Existence */", "", "    kDNSServiceType_HIP        = 55,     /* Host Identity Protocol */", "", "    kDNSServiceType_SPF        = 99,     /* Sender Policy Framework for E-Mail */", "    kDNSServiceType_UINFO      = 100,    /* IANA-Reserved */", "    kDNSServiceType_UID        = 101,    /* IANA-Reserved */", "    kDNSServiceType_GID        = 102,    /* IANA-Reserved */", "    kDNSServiceType_UNSPEC     = 103,    /* IANA-Reserved */", "", "    kDNSServiceType_TKEY       = 249,    /* Transaction key */", "    kDNSServiceType_TSIG       = 250,    /* Transaction signature. */", "    kDNSServiceType_IXFR       = 251,    /* Incremental zone transfer. */", "    kDNSServiceType_AXFR       = 252,    /* Transfer zone of authority. */", "    kDNSServiceType_MAILB      = 253,    /* Transfer mailbox records. */", "    kDNSServiceType_MAILA      = 254,    /* Transfer mail agent records. */", "    kDNSServiceType_ANY        = 255     /* Wildcard match. */", "};", "", "/* possible error code values */", "enum", "{", "    kDNSServiceErr_NoError                   = 0,", "    kDNSServiceErr_Unknown                   = -65537,  /* 0xFFFE FFFF */", "    kDNSServiceErr_NoSuchName                = -65538,", "    kDNSServiceErr_NoMemory                  = -65539,", "    kDNSServiceErr_BadParam                  = -65540,", "    kDNSServiceErr_BadReference              = -65541,", "    kDNSServiceErr_BadState                  = -65542,", "    kDNSServiceErr_BadFlags                  = -65543,", "    kDNSServiceErr_Unsupported               = -65544,", "    kDNSServiceErr_NotInitialized            = -65545,", "    kDNSServiceErr_AlreadyRegistered         = -65547,", "    kDNSServiceErr_NameConflict              = -65548,", "    kDNSServiceErr_Invalid                   = -65549,", "    kDNSServiceErr_Firewall                  = -65550,", "    kDNSServiceErr_Incompatible              = -65551,  /* client library incompatible with daemon */", "    kDNSServiceErr_BadInterfaceIndex         = -65552,", "    kDNSServiceErr_Refused                   = -65553,", "    kDNSServiceErr_NoSuchRecord              = -65554,", "    kDNSServiceErr_NoAuth                    = -65555,", "    kDNSServiceErr_NoSuchKey                 = -65556,", "    kDNSServiceErr_NATTraversal              = -65557,", "    kDNSServiceErr_DoubleNAT                 = -65558,", "    kDNSServiceErr_BadTime                   = -65559,  /* Codes up to here existed in Tiger */", "    kDNSServiceErr_BadSig                    = -65560,", "    kDNSServiceErr_BadKey                    = -65561,", "    kDNSServiceErr_Transient                 = -65562,", "    kDNSServiceErr_ServiceNotRunning         = -65563,  /* Background daemon not running */", "    kDNSServiceErr_NATPortMappingUnsupported = -65564,  /* NAT doesn't support PCP, NAT-PMP or UPnP */", "    kDNSServiceErr_NATPortMappingDisabled    = -65565,  /* NAT supports PCP, NAT-PMP or UPnP, but it's disabled by the administrator */", "    kDNSServiceErr_NoRouter                  = -65566,  /* No router currently configured (probably no network connectivity) */", "    kDNSServiceErr_PollingMode               = -65567,", "    kDNSServiceErr_Timeout                   = -65568", "", "                                               /* mDNS Error codes are in the range", "                                                * FFFE FF00 (-65792) to FFFE FFFF (-65537) */", "};", "", "/* Maximum length, in bytes, of a service name represented as a */", "/* literal C-String, including the terminating NULL at the end. */", "", "#define kDNSServiceMaxServiceName 64", "", "/* Maximum length, in bytes, of a domain name represented as an *escaped* C-String */", "/* including the final trailing dot, and the C-String terminating NULL at the end. */", "", "#define kDNSServiceMaxDomainName 1009", "", "/*", " * Notes on DNS Name Escaping", " *   -- or --", ' * "Why is kDNSServiceMaxDomainName 1009, when the maximum legal domain name is 256 bytes?"', " *", " * All strings used in the DNS-SD APIs are UTF-8 strings. Apart from the exceptions noted below,", " * the APIs expect the strings to be properly escaped, using the conventional DNS escaping rules:", " *", " *   '\\\\' represents a single literal '\\' in the name", " *   '\\.' represents a single literal '.' in the name", " *   '\\ddd', where ddd is a three-digit decimal value from 000 to 255,", " *        represents a single literal byte with that value.", " *   A bare unescaped '.' is a label separator, marking a boundary between domain and subdomain.", " *", " * The exceptions, that do not use escaping, are the routines where the full", " * DNS name of a resource is broken, for convenience, into servicename/regtype/domain.", ' * In these routines, the "servicename" is NOT escaped. It does not need to be, since', " * it is, by definition, just a single literal string. Any characters in that string", ' * represent exactly what they are. The "regtype" portion is, technically speaking,', " * escaped, but since legal regtypes are only allowed to contain letters, digits,", ' * and hyphens, there is nothing to escape, so the issue is moot. The "domain"', " * portion is also escaped, though most domains in use on the public Internet", " * today, like regtypes, don't contain any characters that need to be escaped.", " * As DNS-SD becomes more popular, rich-text domains for service discovery will", " * become common, so software should be written to cope with domains with escaping.", " *", " * The servicename may be up to 63 bytes of UTF-8 text (not counting the C-String", " * terminating NULL at the end). The regtype is of the form _service._tcp or", ' * _service._udp, where the "service" part is 1-15 characters, which may be', " * letters, digits, or hyphens. The domain part of the three-part name may be", " * any legal domain, providing that the resulting servicename+regtype+domain", " * name does not exceed 256 bytes.", " *", " * For most software, these issues are transparent. When browsing, the discovered", " * servicenames should simply be displayed as-is. When resolving, the discovered", " * servicename/regtype/domain are simply passed unchanged to DNSServiceResolve().", " * When a DNSServiceResolve() succeeds, the returned fullname is already in", " * the correct format to pass to standard system DNS APIs such as res_query().", " * For converting from servicename/regtype/domain to a single properly-escaped", " * full DNS name, the helper function DNSServiceConstructFullName() is provided.", " *", " * The following (highly contrived) example illustrates the escaping process.", ' * Suppose you have an service called "Dr. Smith\\Dr. Johnson", of type "_ftp._tcp"', ' * in subdomain "4th. Floor" of subdomain "Building 2" of domain "apple.com."', " * The full (escaped) DNS name of this service's SRV record would be:", " * Dr\\.\\032Smith\\\\Dr\\.\\032Johnson._ftp._tcp.4th\\.\\032Floor.Building\\0322.apple.com.", " */", "", "", "/*", " * Constants for specifying an interface index", " *", " * Specific interface indexes are identified via a 32-bit unsigned integer returned", " * by the if_nametoindex() family of calls.", " *", ' * If the client passes 0 for interface index, that means "do the right thing",', ' * which (at present) means, "if the name is in an mDNS local multicast domain', " * (e.g. 'local.', '254.169.in-addr.arpa.', '{8,9,A,B}.E.F.ip6.arpa.') then multicast", " * on all applicable interfaces, otherwise send via unicast to the appropriate", ' * DNS server." Normally, most clients will use 0 for interface index to', " * automatically get the default sensible behaviour.", " *", " * If the client passes a positive interface index, then for multicast names that", " * indicates to do the operation only on that one interface. For unicast names the", " * interface index is ignored unless kDNSServiceFlagsForceMulticast is also set.", " *", " * If the client passes kDNSServiceInterfaceIndexLocalOnly when registering", " * a service, then that service will be found *only* by other local clients", " * on the same machine that are browsing using kDNSServiceInterfaceIndexLocalOnly", " * or kDNSServiceInterfaceIndexAny.", " * If a client has a 'private' service, accessible only to other processes", " * running on the same machine, this allows the client to advertise that service", " * in a way such that it does not inadvertently appear in service lists on", " * all the other machines on the network.", " *", " * If the client passes kDNSServiceInterfaceIndexLocalOnly when browsing", " * then it will find *all* records registered on that same local machine.", " * Clients explicitly wishing to discover *only* LocalOnly services can", " * accomplish this by inspecting the interfaceIndex of each service reported", " * to their DNSServiceBrowseReply() callback function, and discarding those", " * where the interface index is not kDNSServiceInterfaceIndexLocalOnly.", " *", " * kDNSServiceInterfaceIndexP2P is meaningful only in Browse, QueryRecord, Register,", " * and Resolve operations. It should not be used in other DNSService APIs.", " *", " * - If kDNSServiceInterfaceIndexP2P is passed to DNSServiceBrowse or", " *   DNSServiceQueryRecord, it restricts the operation to P2P.", " *", " * - If kDNSServiceInterfaceIndexP2P is passed to DNSServiceRegister, it is", " *   mapped internally to kDNSServiceInterfaceIndexAny with the kDNSServiceFlagsIncludeP2P", " *   set.", " *", " * - If kDNSServiceInterfaceIndexP2P is passed to DNSServiceResolve, it is", " *   mapped internally to kDNSServiceInterfaceIndexAny with the kDNSServiceFlagsIncludeP2P", " *   set, because resolving a P2P service may create and/or enable an interface whose ", " *   index is not known a priori. The resolve callback will indicate the index of the", " *   interface via which the service can be accessed.", " *", " * If applications pass kDNSServiceInterfaceIndexAny to DNSServiceBrowse", " * or DNSServiceQueryRecord, they must set the kDNSServiceFlagsIncludeP2P flag", " * to include P2P. In this case, if a service instance or the record being queried", " * is found over P2P, the resulting ADD event will indicate kDNSServiceInterfaceIndexP2P", " * as the interface index.", " */", "", "#define kDNSServiceInterfaceIndexAny 0", "#define kDNSServiceInterfaceIndexLocalOnly ((uint32_t)-1)", "#define kDNSServiceInterfaceIndexUnicast   ((uint32_t)-2)", "#define kDNSServiceInterfaceIndexP2P       ((uint32_t)-3)", "", "typedef uint32_t DNSServiceFlags;", "typedef uint32_t DNSServiceProtocol;", "typedef int32_t DNSServiceErrorType;", "", "", "/*********************************************************************************************", "*", "* Version checking", "*", "*********************************************************************************************/", "", "/* DNSServiceGetProperty() Parameters:", " *", " * property:        The requested property.", " *                  Currently the only property defined is kDNSServiceProperty_DaemonVersion.", " *", " * result:          Place to store result.", " *                  For retrieving DaemonVersion, this should be the address of a uint32_t.", " *", " * size:            Pointer to uint32_t containing size of the result location.", " *                  For retrieving DaemonVersion, this should be sizeof(uint32_t).", " *                  On return the uint32_t is updated to the size of the data returned.", " *                  For DaemonVersion, the returned size is always sizeof(uint32_t), but", " *                  future properties could be defined which return variable-sized results.", " *", " * return value:    Returns kDNSServiceErr_NoError on success, or kDNSServiceErr_ServiceNotRunning", ' *                  if the daemon (or "system service" on Windows) is not running.', " */", "", "DNSServiceErrorType DNSSD_API DNSServiceGetProperty", "(", "    const char *property,  /* Requested property (i.e. kDNSServiceProperty_DaemonVersion) */", "    void       *result,    /* Pointer to place to store result */", "    uint32_t   *size       /* size of result location */", ");", "", "/*", " * When requesting kDNSServiceProperty_DaemonVersion, the result pointer must point", " * to a 32-bit unsigned integer, and the size parameter must be set to sizeof(uint32_t).", " *", " * On return, the 32-bit unsigned integer contains the version number, formatted as follows:", " *   Major part of the build number * 10000 +", " *   minor part of the build number *   100", " *", " * For example, Mac OS X 10.4.9 has mDNSResponder-108.4, which would be represented as", " * version 1080400. This allows applications to do simple greater-than and less-than comparisons:", " * e.g. an application that requires at least mDNSResponder-108.4 can check:", " *", " *   if (version >= 1080400) ...", " *", " * Example usage:", " *", " * uint32_t version;", " * uint32_t size = sizeof(version);", " * DNSServiceErrorType err = DNSServiceGetProperty(kDNSServiceProperty_DaemonVersion, &version, &size);", ' * if (!err) printf("Bonjour version is %d.%d\\n", version / 10000, version / 100 % 100);', " */", "", '#define kDNSServiceProperty_DaemonVersion "DaemonVersion"', "", "", "// Map the source port of the local UDP socket that was opened for sending the DNS query", "// to the process ID of the application that triggered the DNS resolution.", "//", "/* DNSServiceGetPID() Parameters:", " *", " * srcport:         Source port (in network byte order) of the UDP socket that was created by", " *                  mDNSResponder to send the DNS query on the wire.", " *", " * pid:             Process ID of the application that started the name resolution which triggered", " *                  mDNSResponder to send the query on the wire. The value can be -1 if the srcport", " *                  cannot be mapped.", " *", " * return value:    Returns kDNSServiceErr_NoError on success, or kDNSServiceErr_ServiceNotRunning", " *                  if the daemon is not running. The value of the pid is undefined if the return", " *                  value has error.", " */", "DNSServiceErrorType DNSSD_API DNSServiceGetPID", "(", "    uint16_t srcport,", "    int32_t *pid", ");", "", "/*********************************************************************************************", "*", "* Unix Domain Socket access, DNSServiceRef deallocation, and data processing functions", "*", "*********************************************************************************************/", "", "/* DNSServiceRefSockFD()", " *", " * Access underlying Unix domain socket for an initialized DNSServiceRef.", " * The DNS Service Discovery implementation uses this socket to communicate between the client and", " * the mDNSResponder daemon. The application MUST NOT directly read from or write to this socket.", " * Access to the socket is provided so that it can be used as a kqueue event source, a CFRunLoop", " * event source, in a select() loop, etc. When the underlying event management subsystem (kqueue/", " * select/CFRunLoop etc.) indicates to the client that data is available for reading on the", " * socket, the client should call DNSServiceProcessResult(), which will extract the daemon's", " * reply from the socket, and pass it to the appropriate application callback. By using a run", " * loop or select(), results from the daemon can be processed asynchronously. Alternatively,", ' * a client can choose to fork a thread and have it loop calling "DNSServiceProcessResult(ref);"', " * If DNSServiceProcessResult() is called when no data is available for reading on the socket, it", " * will block until data does become available, and then process the data and return to the caller.", " * When data arrives on the socket, the client is responsible for calling DNSServiceProcessResult(ref)", " * in a timely fashion -- if the client allows a large backlog of data to build up the daemon", " * may terminate the connection.", " *", " * sdRef:           A DNSServiceRef initialized by any of the DNSService calls.", " *", " * return value:    The DNSServiceRef's underlying socket descriptor, or -1 on", " *                  error.", " */", "", "int DNSSD_API DNSServiceRefSockFD(DNSServiceRef sdRef);", "", "", "/* DNSServiceProcessResult()", " *", " * Read a reply from the daemon, calling the appropriate application callback. This call will", " * block until the daemon's response is received. Use DNSServiceRefSockFD() in", " * conjunction with a run loop or select() to determine the presence of a response from the", " * server before calling this function to process the reply without blocking. Call this function", " * at any point if it is acceptable to block until the daemon's response arrives. Note that the", " * client is responsible for ensuring that DNSServiceProcessResult() is called whenever there is", " * a reply from the daemon - the daemon may terminate its connection with a client that does not", " * process the daemon's responses.", " *", " * sdRef:           A DNSServiceRef initialized by any of the DNSService calls", " *                  that take a callback parameter.", " *", " * return value:    Returns kDNSServiceErr_NoError on success, otherwise returns", " *                  an error code indicating the specific failure that occurred.", " */", "", "DNSServiceErrorType DNSSD_API DNSServiceProcessResult(DNSServiceRef sdRef);", "", "", "/* DNSServiceRefDeallocate()", " *", " * Terminate a connection with the daemon and free memory associated with the DNSServiceRef.", " * Any services or records registered with this DNSServiceRef will be deregistered. Any", " * Browse, Resolve, or Query operations called with this reference will be terminated.", " *", " * Note: If the reference's underlying socket is used in a run loop or select() call, it should", " * be removed BEFORE DNSServiceRefDeallocate() is called, as this function closes the reference's", " * socket.", " *", " * Note: If the reference was initialized with DNSServiceCreateConnection(), any DNSRecordRefs", " * created via this reference will be invalidated by this call - the resource records are", " * deregistered, and their DNSRecordRefs may not be used in subsequent functions. Similarly,", " * if the reference was initialized with DNSServiceRegister, and an extra resource record was", " * added to the service via DNSServiceAddRecord(), the DNSRecordRef created by the Add() call", " * is invalidated when this function is called - the DNSRecordRef may not be used in subsequent", " * functions.", " *", " * Note: This call is to be used only with the DNSServiceRef defined by this API.", " *", " * sdRef:           A DNSServiceRef initialized by any of the DNSService calls.", " *", " */", "", "void DNSSD_API DNSServiceRefDeallocate(DNSServiceRef sdRef);", "", "", "/*********************************************************************************************", "*", "* Domain Enumeration", "*", "*********************************************************************************************/", "", "/* DNSServiceEnumerateDomains()", " *", " * Asynchronously enumerate domains available for browsing and registration.", " *", " * The enumeration MUST be cancelled via DNSServiceRefDeallocate() when no more domains", " * are to be found.", " *", " * Note that the names returned are (like all of DNS-SD) UTF-8 strings,", " * and are escaped using standard DNS escaping rules.", ' * (See "Notes on DNS Name Escaping" earlier in this file for more details.)', " * A graphical browser displaying a hierarchical tree-structured view should cut", " * the names at the bare dots to yield individual labels, then de-escape each", " * label according to the escaping rules, and then display the resulting UTF-8 text.", " *", " * DNSServiceDomainEnumReply Callback Parameters:", " *", " * sdRef:           The DNSServiceRef initialized by DNSServiceEnumerateDomains().", " *", " * flags:           Possible values are:", " *                  kDNSServiceFlagsMoreComing", " *                  kDNSServiceFlagsAdd", " *                  kDNSServiceFlagsDefault", " *", " * interfaceIndex:  Specifies the interface on which the domain exists. (The index for a given", " *                  interface is determined via the if_nametoindex() family of calls.)", " *", " * errorCode:       Will be kDNSServiceErr_NoError (0) on success, otherwise indicates", " *                  the failure that occurred (other parameters are undefined if errorCode is nonzero).", " *", " * replyDomain:     The name of the domain.", " *", " * context:         The context pointer passed to DNSServiceEnumerateDomains.", " *", " */", "", "typedef void (DNSSD_API *DNSServiceDomainEnumReply)", "(", "    DNSServiceRef sdRef,", "    DNSServiceFlags flags,", "    uint32_t interfaceIndex,", "    DNSServiceErrorType errorCode,", "    const char                          *replyDomain,", "    void                                *context", ");", "", "", "/* DNSServiceEnumerateDomains() Parameters:", " *", " * sdRef:           A pointer to an uninitialized DNSServiceRef. If the call succeeds", " *                  then it initializes the DNSServiceRef, returns kDNSServiceErr_NoError,", " *                  and the enumeration operation will run indefinitely until the client", " *                  terminates it by passing this DNSServiceRef to DNSServiceRefDeallocate().", " *", " * flags:           Possible values are:", " *                  kDNSServiceFlagsBrowseDomains to enumerate domains recommended for browsing.", " *                  kDNSServiceFlagsRegistrationDomains to enumerate domains recommended", " *                  for registration.", " *", " * interfaceIndex:  If non-zero, specifies the interface on which to look for domains.", " *                  (the index for a given interface is determined via the if_nametoindex()", " *                  family of calls.) Most applications will pass 0 to enumerate domains on", ' *                  all interfaces. See "Constants for specifying an interface index" for more details.', " *", " * callBack:        The function to be called when a domain is found or the call asynchronously", " *                  fails.", " *", " * context:         An application context pointer which is passed to the callback function", " *                  (may be NULL).", " *", " * return value:    Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous", " *                  errors are delivered to the callback), otherwise returns an error code indicating", " *                  the error that occurred (the callback is not invoked and the DNSServiceRef", " *                  is not initialized).", " */", "", "DNSServiceErrorType DNSSD_API DNSServiceEnumerateDomains", "(", "    DNSServiceRef                       *sdRef,", "    DNSServiceFlags flags,", "    uint32_t interfaceIndex,", "    DNSServiceDomainEnumReply callBack,", "    void                                *context  /* may be NULL */", ");", "", "", "/*********************************************************************************************", "*", "*  Service Registration", "*", "*********************************************************************************************/", "", "/* Register a service that is discovered via Browse() and Resolve() calls.", " *", " * DNSServiceRegisterReply() Callback Parameters:", " *", " * sdRef:           The DNSServiceRef initialized by DNSServiceRegister().", " *", " * flags:           When a name is successfully registered, the callback will be", " *                  invoked with the kDNSServiceFlagsAdd flag set. When Wide-Area", " *                  DNS-SD is in use, it is possible for a single service to get", ' *                  more than one success callback (e.g. one in the "local" multicast', " *                  DNS domain, and another in a wide-area unicast DNS domain).", " *                  If a successfully-registered name later suffers a name conflict", " *                  or similar problem and has to be deregistered, the callback will", " *                  be invoked with the kDNSServiceFlagsAdd flag not set. The callback", " *                  is *not* invoked in the case where the caller explicitly terminates", " *                  the service registration by calling DNSServiceRefDeallocate(ref);", " *", " * errorCode:       Will be kDNSServiceErr_NoError on success, otherwise will", " *                  indicate the failure that occurred (including name conflicts,", " *                  if the kDNSServiceFlagsNoAutoRename flag was used when registering.)", " *                  Other parameters are undefined if errorCode is nonzero.", " *", " * name:            The service name registered (if the application did not specify a name in", " *                  DNSServiceRegister(), this indicates what name was automatically chosen).", " *", " * regtype:         The type of service registered, as it was passed to the callout.", " *", " * domain:          The domain on which the service was registered (if the application did not", " *                  specify a domain in DNSServiceRegister(), this indicates the default domain", " *                  on which the service was registered).", " *", " * context:         The context pointer that was passed to the callout.", " *", " */", "", "typedef void (DNSSD_API *DNSServiceRegisterReply)", "(", "    DNSServiceRef sdRef,", "    DNSServiceFlags flags,", "    DNSServiceErrorType errorCode,", "    const char                          *name,", "    const char                          *regtype,", "    const char                          *domain,", "    void                                *context", ");", "", "", "/* DNSServiceRegister() Parameters:", " *", " * sdRef:           A pointer to an uninitialized DNSServiceRef. If the call succeeds", " *                  then it initializes the DNSServiceRef, returns kDNSServiceErr_NoError,", " *                  and the registration will remain active indefinitely until the client", " *                  terminates it by passing this DNSServiceRef to DNSServiceRefDeallocate().", " *", " * interfaceIndex:  If non-zero, specifies the interface on which to register the service", " *                  (the index for a given interface is determined via the if_nametoindex()", " *                  family of calls.) Most applications will pass 0 to register on all", ' *                  available interfaces. See "Constants for specifying an interface index" for more details.', " *", " * flags:           Indicates the renaming behavior on name conflict (most applications", " *                  will pass 0). See flag definitions above for details.", " *", " * name:            If non-NULL, specifies the service name to be registered.", " *                  Most applications will not specify a name, in which case the computer", " *                  name is used (this name is communicated to the client via the callback).", " *                  If a name is specified, it must be 1-63 bytes of UTF-8 text.", " *                  If the name is longer than 63 bytes it will be automatically truncated", " *                  to a legal length, unless the NoAutoRename flag is set,", " *                  in which case kDNSServiceErr_BadParam will be returned.", " *", " * regtype:         The service type followed by the protocol, separated by a dot", ' *                  (e.g. "_ftp._tcp"). The service type must be an underscore, followed', " *                  by 1-15 characters, which may be letters, digits, or hyphens.", ' *                  The transport protocol must be "_tcp" or "_udp". New service types', " *                  should be registered at <http://www.dns-sd.org/ServiceTypes.html>.", " *", " *                  Additional subtypes of the primary service type (where a service", " *                  type has defined subtypes) follow the primary service type in a", " *                  comma-separated list, with no additional spaces, e.g.", ' *                      "_primarytype._tcp,_subtype1,_subtype2,_subtype3"', " *                  Subtypes provide a mechanism for filtered browsing: A client browsing", ' *                  for "_primarytype._tcp" will discover all instances of this type;', ' *                  a client browsing for "_primarytype._tcp,_subtype2" will discover only', ' *                  those instances that were registered with "_subtype2" in their list of', " *                  registered subtypes.", " *", " *                  The subtype mechanism can be illustrated with some examples using the", " *                  dns-sd command-line tool:", " *", ' *                  % dns-sd -R Simple _test._tcp "" 1001 &', ' *                  % dns-sd -R Better _test._tcp,HasFeatureA "" 1002 &', ' *                  % dns-sd -R Best   _test._tcp,HasFeatureA,HasFeatureB "" 1003 &', " *", " *                  Now:", " *                  % dns-sd -B _test._tcp             # will find all three services", ' *                  % dns-sd -B _test._tcp,HasFeatureA # finds "Better" and "Best"', ' *                  % dns-sd -B _test._tcp,HasFeatureB # finds only "Best"', " *", " *                  Subtype labels may be up to 63 bytes long, and may contain any eight-", " *                  bit byte values, including zero bytes. However, due to the nature of", " *                  using a C-string-based API, conventional DNS escaping must be used for", " *                  dots ('.'), commas (','), backslashes ('\\') and zero bytes, as shown below:", " *", " *                  % dns-sd -R Test '_test._tcp,s\\.one,s\\,two,s\\\\three,s\\000four' local 123", " *", " *                  When a service is registered, all the clients browsing for the registered", ' *                  type ("regtype") will discover it. If the discovery should be', " *                  restricted to a smaller set of well known peers, the service can be", " *                  registered with additional data (group identifier) that is known", " *                  only to a smaller set of peers. The group identifier should follow primary", ' *                  service type using a colon (":") as a delimeter. If subtypes are also present,', " *                  it should be given before the subtype as shown below.", " *", " *                  % dns-sd -R _test1 _http._tcp:mygroup1 local 1001 ", " *                  % dns-sd -R _test2 _http._tcp:mygroup2 local 1001 ", " *                  % dns-sd -R _test3 _http._tcp:mygroup3,HasFeatureA local 1001 ", " *", " *                  Now:", ' *                  % dns-sd -B _http._tcp:"mygroup1"                # will discover only test1', ' *                  % dns-sd -B _http._tcp:"mygroup2"                # will discover only test2', ' *                  % dns-sd -B _http._tcp:"mygroup3",HasFeatureA    # will discover only test3', " *                  ", " *                  By specifying the group information, only the members of that group are", " *                  discovered.", " *", " *                  The group identifier itself is not sent in clear. Only a hash of the group", " *                  identifier is sent and the clients discover them anonymously. The group identifier", " *                  may be up to 256 bytes long and may contain any eight bit values except comma which", " *                  should be escaped.", " *", " * domain:          If non-NULL, specifies the domain on which to advertise the service.", " *                  Most applications will not specify a domain, instead automatically", " *                  registering in the default domain(s).", " *", " * host:            If non-NULL, specifies the SRV target host name. Most applications", " *                  will not specify a host, instead automatically using the machine's", " *                  default host name(s). Note that specifying a non-NULL host does NOT", " *                  create an address record for that host - the application is responsible", " *                  for ensuring that the appropriate address record exists, or creating it", " *                  via DNSServiceRegisterRecord().", " *", " * port:            The port, in network byte order, on which the service accepts connections.", ' *                  Pass 0 for a "placeholder" service (i.e. a service that will not be discovered', " *                  by browsing, but will cause a name conflict if another client tries to", " *                  register that same name). Most clients will not use placeholder services.", " *", " * txtLen:          The length of the txtRecord, in bytes. Must be zero if the txtRecord is NULL.", " *", " * txtRecord:       The TXT record rdata. A non-NULL txtRecord MUST be a properly formatted DNS", " *                  TXT record, i.e. <length byte> <data> <length byte> <data> ...", ' *                  Passing NULL for the txtRecord is allowed as a synonym for txtLen=1, txtRecord="",', " *                  i.e. it creates a TXT record of length one containing a single empty string.", " *                  RFC 1035 doesn't allow a TXT record to contain *zero* strings, so a single empty", " *                  string is the smallest legal DNS TXT record.", " *                  As with the other parameters, the DNSServiceRegister call copies the txtRecord", " *                  data; e.g. if you allocated the storage for the txtRecord parameter with malloc()", " *                  then you can safely free that memory right after the DNSServiceRegister call returns.", " *", " * callBack:        The function to be called when the registration completes or asynchronously", " *                  fails. The client MAY pass NULL for the callback -  The client will NOT be notified", " *                  of the default values picked on its behalf, and the client will NOT be notified of any", " *                  asynchronous errors (e.g. out of memory errors, etc.) that may prevent the registration", " *                  of the service. The client may NOT pass the NoAutoRename flag if the callback is NULL.", " *                  The client may still deregister the service at any time via DNSServiceRefDeallocate().", " *", " * context:         An application context pointer which is passed to the callback function", " *                  (may be NULL).", " *", " * return value:    Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous", " *                  errors are delivered to the callback), otherwise returns an error code indicating", " *                  the error that occurred (the callback is never invoked and the DNSServiceRef", " *                  is not initialized).", " */", "", "DNSServiceErrorType DNSSD_API DNSServiceRegister", "(", "    DNSServiceRef                       *sdRef,", "    DNSServiceFlags flags,", "    uint32_t interfaceIndex,", "    const char                          *name,         /* may be NULL */", "    const char                          *regtype,", "    const char                          *domain,       /* may be NULL */", "    const char                          *host,         /* may be NULL */", "    uint16_t port,                                     /* In network byte order */", "    uint16_t txtLen,", "    const void                          *txtRecord,    /* may be NULL */", "    DNSServiceRegisterReply callBack,                  /* may be NULL */", "    void                                *context       /* may be NULL */", ");", "", "", "/* DNSServiceAddRecord()", " *", " * Add a record to a registered service. The name of the record will be the same as the", " * registered service's name.", " * The record can later be updated or deregistered by passing the RecordRef initialized", " * by this function to DNSServiceUpdateRecord() or DNSServiceRemoveRecord().", " *", " * Note that the DNSServiceAddRecord/UpdateRecord/RemoveRecord are *NOT* thread-safe", " * with respect to a single DNSServiceRef. If you plan to have multiple threads", " * in your program simultaneously add, update, or remove records from the same", " * DNSServiceRef, then it's the caller's responsibility to use a mutext lock", " * or take similar appropriate precautions to serialize those calls.", " *", " * Parameters;", " *", " * sdRef:           A DNSServiceRef initialized by DNSServiceRegister().", " *", " * RecordRef:       A pointer to an uninitialized DNSRecordRef. Upon succesfull completion of this", " *                  call, this ref may be passed to DNSServiceUpdateRecord() or DNSServiceRemoveRecord().", " *                  If the above DNSServiceRef is passed to DNSServiceRefDeallocate(), RecordRef is also", " *                  invalidated and may not be used further.", " *", " * flags:           Currently ignored, reserved for future use.", " *", " * rrtype:          The type of the record (e.g. kDNSServiceType_TXT, kDNSServiceType_SRV, etc)", " *", " * rdlen:           The length, in bytes, of the rdata.", " *", " * rdata:           The raw rdata to be contained in the added resource record.", " *", " * ttl:             The time to live of the resource record, in seconds.", " *                  Most clients should pass 0 to indicate that the system should", " *                  select a sensible default value.", " *", " * return value:    Returns kDNSServiceErr_NoError on success, otherwise returns an", " *                  error code indicating the error that occurred (the RecordRef is not initialized).", " */", "", "DNSServiceErrorType DNSSD_API DNSServiceAddRecord", "(", "    DNSServiceRef sdRef,", "    DNSRecordRef                        *RecordRef,", "    DNSServiceFlags flags,", "    uint16_t rrtype,", "    uint16_t rdlen,", "    const void                          *rdata,", "    uint32_t ttl", ");", "", "", "/* DNSServiceUpdateRecord", " *", " * Update a registered resource record. The record must either be:", " *   - The primary txt record of a service registered via DNSServiceRegister()", " *   - A record added to a registered service via DNSServiceAddRecord()", " *   - An individual record registered by DNSServiceRegisterRecord()", " *", " * Parameters:", " *", " * sdRef:           A DNSServiceRef that was initialized by DNSServiceRegister()", " *                  or DNSServiceCreateConnection().", " *", " * RecordRef:       A DNSRecordRef initialized by DNSServiceAddRecord, or NULL to update the", " *                  service's primary txt record.", " *", " * flags:           Currently ignored, reserved for future use.", " *", " * rdlen:           The length, in bytes, of the new rdata.", " *", " * rdata:           The new rdata to be contained in the updated resource record.", " *", " * ttl:             The time to live of the updated resource record, in seconds.", " *                  Most clients should pass 0 to indicate that the system should", " *                  select a sensible default value.", " *", " * return value:    Returns kDNSServiceErr_NoError on success, otherwise returns an", " *                  error code indicating the error that occurred.", " */", "", "DNSServiceErrorType DNSSD_API DNSServiceUpdateRecord", "(", "    DNSServiceRef sdRef,", "    DNSRecordRef RecordRef,                            /* may be NULL */", "    DNSServiceFlags flags,", "    uint16_t rdlen,", "    const void                          *rdata,", "    uint32_t ttl", ");", "", "", "/* DNSServiceRemoveRecord", " *", " * Remove a record previously added to a service record set via DNSServiceAddRecord(), or deregister", " * an record registered individually via DNSServiceRegisterRecord().", " *", " * Parameters:", " *", " * sdRef:           A DNSServiceRef initialized by DNSServiceRegister() (if the", " *                  record being removed was registered via DNSServiceAddRecord()) or by", " *                  DNSServiceCreateConnection() (if the record being removed was registered via", " *                  DNSServiceRegisterRecord()).", " *", " * recordRef:       A DNSRecordRef initialized by a successful call to DNSServiceAddRecord()", " *                  or DNSServiceRegisterRecord().", " *", " * flags:           Currently ignored, reserved for future use.", " *", " * return value:    Returns kDNSServiceErr_NoError on success, otherwise returns an", " *                  error code indicating the error that occurred.", " */", "", "DNSServiceErrorType DNSSD_API DNSServiceRemoveRecord", "(", "    DNSServiceRef sdRef,", "    DNSRecordRef RecordRef,", "    DNSServiceFlags flags", ");", "", "", "/*********************************************************************************************", "*", "*  Service Discovery", "*", "*********************************************************************************************/", "", "/* Browse for instances of a service.", " *", " * DNSServiceBrowseReply() Parameters:", " *", " * sdRef:           The DNSServiceRef initialized by DNSServiceBrowse().", " *", " * flags:           Possible values are kDNSServiceFlagsMoreComing and kDNSServiceFlagsAdd.", " *                  See flag definitions for details.", " *", " * interfaceIndex:  The interface on which the service is advertised. This index should", " *                  be passed to DNSServiceResolve() when resolving the service.", " *", " * errorCode:       Will be kDNSServiceErr_NoError (0) on success, otherwise will", " *                  indicate the failure that occurred. Other parameters are undefined if", " *                  the errorCode is nonzero.", " *", " * serviceName:     The discovered service name. This name should be displayed to the user,", " *                  and stored for subsequent use in the DNSServiceResolve() call.", " *", " * regtype:         The service type, which is usually (but not always) the same as was passed", " *                  to DNSServiceBrowse(). One case where the discovered service type may", " *                  not be the same as the requested service type is when using subtypes:", " *                  The client may want to browse for only those ftp servers that allow", ' *                  anonymous connections. The client will pass the string "_ftp._tcp,_anon"', " *                  to DNSServiceBrowse(), but the type of the service that's discovered", ' *                  is simply "_ftp._tcp". The regtype for each discovered service instance', " *                  should be stored along with the name, so that it can be passed to", " *                  DNSServiceResolve() when the service is later resolved.", " *", " * domain:          The domain of the discovered service instance. This may or may not be the", " *                  same as the domain that was passed to DNSServiceBrowse(). The domain for each", " *                  discovered service instance should be stored along with the name, so that", " *                  it can be passed to DNSServiceResolve() when the service is later resolved.", " *", " * context:         The context pointer that was passed to the callout.", " *", " */", "", "typedef void (DNSSD_API *DNSServiceBrowseReply)", "(", "    DNSServiceRef sdRef,", "    DNSServiceFlags flags,", "    uint32_t interfaceIndex,", "    DNSServiceErrorType errorCode,", "    const char                          *serviceName,", "    const char                          *regtype,", "    const char                          *replyDomain,", "    void                                *context", ");", "", "", "/* DNSServiceBrowse() Parameters:", " *", " * sdRef:           A pointer to an uninitialized DNSServiceRef. If the call succeeds", " *                  then it initializes the DNSServiceRef, returns kDNSServiceErr_NoError,", " *                  and the browse operation will run indefinitely until the client", " *                  terminates it by passing this DNSServiceRef to DNSServiceRefDeallocate().", " *", " * flags:           Currently ignored, reserved for future use.", " *", " * interfaceIndex:  If non-zero, specifies the interface on which to browse for services", " *                  (the index for a given interface is determined via the if_nametoindex()", " *                  family of calls.) Most applications will pass 0 to browse on all available", ' *                  interfaces. See "Constants for specifying an interface index" for more details.', " *", " * regtype:         The service type being browsed for followed by the protocol, separated by a", ' *                  dot (e.g. "_ftp._tcp"). The transport protocol must be "_tcp" or "_udp".', " *                  A client may optionally specify a single subtype to perform filtered browsing:", ' *                  e.g. browsing for "_primarytype._tcp,_subtype" will discover only those', ' *                  instances of "_primarytype._tcp" that were registered specifying "_subtype"', " *                  in their list of registered subtypes. Additionally, a group identifier may", " *                  also be specified before the subtype e.g., _primarytype._tcp:GroupID, which", " *                  will discover only the members that register the service with GroupID. See", " *                  DNSServiceRegister for more details.", " *", " * domain:          If non-NULL, specifies the domain on which to browse for services.", " *                  Most applications will not specify a domain, instead browsing on the", " *                  default domain(s).", " *", " * callBack:        The function to be called when an instance of the service being browsed for", " *                  is found, or if the call asynchronously fails.", " *", " * context:         An application context pointer which is passed to the callback function", " *                  (may be NULL).", " *", " * return value:    Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous", " *                  errors are delivered to the callback), otherwise returns an error code indicating", " *                  the error that occurred (the callback is not invoked and the DNSServiceRef", " *                  is not initialized).", " */", "", "DNSServiceErrorType DNSSD_API DNSServiceBrowse", "(", "    DNSServiceRef                       *sdRef,", "    DNSServiceFlags flags,", "    uint32_t interfaceIndex,", "    const char                          *regtype,", "    const char                          *domain,    /* may be NULL */", "    DNSServiceBrowseReply callBack,", "    void                                *context    /* may be NULL */", ");", "", "", "/* DNSServiceResolve()", " *", " * Resolve a service name discovered via DNSServiceBrowse() to a target host name, port number, and", " * txt record.", " *", " * Note: Applications should NOT use DNSServiceResolve() solely for txt record monitoring - use", " * DNSServiceQueryRecord() instead, as it is more efficient for this task.", " *", " * Note: When the desired results have been returned, the client MUST terminate the resolve by calling", " * DNSServiceRefDeallocate().", " *", " * Note: DNSServiceResolve() behaves correctly for typical services that have a single SRV record", " * and a single TXT record. To resolve non-standard services with multiple SRV or TXT records,", " * DNSServiceQueryRecord() should be used.", " *", " * DNSServiceResolveReply Callback Parameters:", " *", " * sdRef:           The DNSServiceRef initialized by DNSServiceResolve().", " *", " * flags:           Possible values: kDNSServiceFlagsMoreComing", " *", " * interfaceIndex:  The interface on which the service was resolved.", " *", " * errorCode:       Will be kDNSServiceErr_NoError (0) on success, otherwise will", " *                  indicate the failure that occurred. Other parameters are undefined if", " *                  the errorCode is nonzero.", " *", " * fullname:        The full service domain name, in the form <servicename>.<protocol>.<domain>.", " *                  (This name is escaped following standard DNS rules, making it suitable for", " *                  passing to standard system DNS APIs such as res_query(), or to the", " *                  special-purpose functions included in this API that take fullname parameters.", ' *                  See "Notes on DNS Name Escaping" earlier in this file for more details.)', " *", " * hosttarget:      The target hostname of the machine providing the service. This name can", " *                  be passed to functions like gethostbyname() to identify the host's IP address.", " *", " * port:            The port, in network byte order, on which connections are accepted for this service.", " *", " * txtLen:          The length of the txt record, in bytes.", " *", " * txtRecord:       The service's primary txt record, in standard txt record format.", " *", " * context:         The context pointer that was passed to the callout.", " *", ' * NOTE: In earlier versions of this header file, the txtRecord parameter was declared "const char *"', " * This is incorrect, since it contains length bytes which are values in the range 0 to 255, not -128 to +127.", " * Depending on your compiler settings, this change may cause signed/unsigned mismatch warnings.", " * These should be fixed by updating your own callback function definition to match the corrected", ' * function signature using "const unsigned char *txtRecord". Making this change may also fix inadvertent', " * bugs in your callback function, where it could have incorrectly interpreted a length byte with value 250", " * as being -6 instead, with various bad consequences ranging from incorrect operation to software crashes.", " * If you need to maintain portable code that will compile cleanly with both the old and new versions of", " * this header file, you should update your callback function definition to use the correct unsigned value,", " * and then in the place where you pass your callback function to DNSServiceResolve(), use a cast to eliminate", " * the compiler warning, e.g.:", " *   DNSServiceResolve(sd, flags, index, name, regtype, domain, (DNSServiceResolveReply)MyCallback, context);", " * This will ensure that your code compiles cleanly without warnings (and more importantly, works correctly)", " * with both the old header and with the new corrected version.", " *", " */", "", "typedef void (DNSSD_API *DNSServiceResolveReply)", "(", "    DNSServiceRef sdRef,", "    DNSServiceFlags flags,", "    uint32_t interfaceIndex,", "    DNSServiceErrorType errorCode,", "    const char                          *fullname,", "    const char                          *hosttarget,", "    uint16_t port,                                   /* In network byte order */", "    uint16_t txtLen,", "    const unsigned char                 *txtRecord,", "    void                                *context", ");", "", "", "/* DNSServiceResolve() Parameters", " *", " * sdRef:           A pointer to an uninitialized DNSServiceRef. If the call succeeds", " *                  then it initializes the DNSServiceRef, returns kDNSServiceErr_NoError,", " *                  and the resolve operation will run indefinitely until the client", " *                  terminates it by passing this DNSServiceRef to DNSServiceRefDeallocate().", " *", " * flags:           Specifying kDNSServiceFlagsForceMulticast will cause query to be", " *                  performed with a link-local mDNS query, even if the name is an", ' *                  apparently non-local name (i.e. a name not ending in ".local.")', " *", " * interfaceIndex:  The interface on which to resolve the service. If this resolve call is", " *                  as a result of a currently active DNSServiceBrowse() operation, then the", " *                  interfaceIndex should be the index reported in the DNSServiceBrowseReply", " *                  callback. If this resolve call is using information previously saved", " *                  (e.g. in a preference file) for later use, then use interfaceIndex 0, because", " *                  the desired service may now be reachable via a different physical interface.", ' *                  See "Constants for specifying an interface index" for more details.', " *", " * name:            The name of the service instance to be resolved, as reported to the", " *                  DNSServiceBrowseReply() callback.", " *", " * regtype:         The type of the service instance to be resolved, as reported to the", " *                  DNSServiceBrowseReply() callback.", " *", " * domain:          The domain of the service instance to be resolved, as reported to the", " *                  DNSServiceBrowseReply() callback.", " *", " * callBack:        The function to be called when a result is found, or if the call", " *                  asynchronously fails.", " *", " * context:         An application context pointer which is passed to the callback function", " *                  (may be NULL).", " *", " * return value:    Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous", " *                  errors are delivered to the callback), otherwise returns an error code indicating", " *                  the error that occurred (the callback is never invoked and the DNSServiceRef", " *                  is not initialized).", " */", "", "DNSServiceErrorType DNSSD_API DNSServiceResolve", "(", "    DNSServiceRef                       *sdRef,", "    DNSServiceFlags flags,", "    uint32_t interfaceIndex,", "    const char                          *name,", "    const char                          *regtype,", "    const char                          *domain,", "    DNSServiceResolveReply callBack,", "    void                                *context  /* may be NULL */", ");", "", "", "/*********************************************************************************************", "*", "*  Querying Individual Specific Records", "*", "*********************************************************************************************/", "", "/* DNSServiceQueryRecord", " *", " * Query for an arbitrary DNS record.", " *", " * DNSServiceQueryRecordReply() Callback Parameters:", " *", " * sdRef:           The DNSServiceRef initialized by DNSServiceQueryRecord().", " *", " * flags:           Possible values are kDNSServiceFlagsMoreComing and", " *                  kDNSServiceFlagsAdd. The Add flag is NOT set for PTR records", ' *                  with a ttl of 0, i.e. "Remove" events.', " *", " * interfaceIndex:  The interface on which the query was resolved (the index for a given", " *                  interface is determined via the if_nametoindex() family of calls).", ' *                  See "Constants for specifying an interface index" for more details.', " *", " * errorCode:       Will be kDNSServiceErr_NoError on success, otherwise will", " *                  indicate the failure that occurred. Other parameters are undefined if", " *                  errorCode is nonzero.", " *", " * fullname:        The resource record's full domain name.", " *", " * rrtype:          The resource record's type (e.g. kDNSServiceType_PTR, kDNSServiceType_SRV, etc)", " *", " * rrclass:         The class of the resource record (usually kDNSServiceClass_IN).", " *", " * rdlen:           The length, in bytes, of the resource record rdata.", " *", " * rdata:           The raw rdata of the resource record.", " *", " * ttl:             If the client wishes to cache the result for performance reasons,", " *                  the TTL indicates how long the client may legitimately hold onto", " *                  this result, in seconds. After the TTL expires, the client should", " *                  consider the result no longer valid, and if it requires this data", " *                  again, it should be re-fetched with a new query. Of course, this", " *                  only applies to clients that cancel the asynchronous operation when", " *                  they get a result. Clients that leave the asynchronous operation", " *                  running can safely assume that the data remains valid until they", " *                  get another callback telling them otherwise.", " *", " * context:         The context pointer that was passed to the callout.", " *", " */", "", "typedef void (DNSSD_API *DNSServiceQueryRecordReply)", "(", "    DNSServiceRef sdRef,", "    DNSServiceFlags flags,", "    uint32_t interfaceIndex,", "    DNSServiceErrorType errorCode,", "    const char                          *fullname,", "    uint16_t rrtype,", "    uint16_t rrclass,", "    uint16_t rdlen,", "    const void                          *rdata,", "    uint32_t ttl,", "    void                                *context", ");", "", "", "/* DNSServiceQueryRecord() Parameters:", " *", " * sdRef:           A pointer to an uninitialized DNSServiceRef. If the call succeeds", " *                  then it initializes the DNSServiceRef, returns kDNSServiceErr_NoError,", " *                  and the query operation will run indefinitely until the client", " *                  terminates it by passing this DNSServiceRef to DNSServiceRefDeallocate().", " *", " * flags:           kDNSServiceFlagsForceMulticast or kDNSServiceFlagsLongLivedQuery.", ' *                  Pass kDNSServiceFlagsLongLivedQuery to create a "long-lived" unicast', " *                  query to a unicast DNS server that implements the protocol. This flag", " *                  has no effect on link-local multicast queries.", " *", " * interfaceIndex:  If non-zero, specifies the interface on which to issue the query", " *                  (the index for a given interface is determined via the if_nametoindex()", " *                  family of calls.) Passing 0 causes the name to be queried for on all", ' *                  interfaces. See "Constants for specifying an interface index" for more details.', " *", " * fullname:        The full domain name of the resource record to be queried for.", " *", " * rrtype:          The numerical type of the resource record to be queried for", " *                  (e.g. kDNSServiceType_PTR, kDNSServiceType_SRV, etc)", " *", " * rrclass:         The class of the resource record (usually kDNSServiceClass_IN).", " *", " * callBack:        The function to be called when a result is found, or if the call", " *                  asynchronously fails.", " *", " * context:         An application context pointer which is passed to the callback function", " *                  (may be NULL).", " *", " * return value:    Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous", " *                  errors are delivered to the callback), otherwise returns an error code indicating", " *                  the error that occurred (the callback is never invoked and the DNSServiceRef", " *                  is not initialized).", " */", "", "DNSServiceErrorType DNSSD_API DNSServiceQueryRecord", "(", "    DNSServiceRef                       *sdRef,", "    DNSServiceFlags flags,", "    uint32_t interfaceIndex,", "    const char                          *fullname,", "    uint16_t rrtype,", "    uint16_t rrclass,", "    DNSServiceQueryRecordReply callBack,", "    void                                *context  /* may be NULL */", ");", "", "", "/*********************************************************************************************", "*", "*  Unified lookup of both IPv4 and IPv6 addresses for a fully qualified hostname", "*", "*********************************************************************************************/", "", "/* DNSServiceGetAddrInfo", " *", " * Queries for the IP address of a hostname by using either Multicast or Unicast DNS.", " *", " * DNSServiceGetAddrInfoReply() parameters:", " *", " * sdRef:           The DNSServiceRef initialized by DNSServiceGetAddrInfo().", " *", " * flags:           Possible values are kDNSServiceFlagsMoreComing and", " *                  kDNSServiceFlagsAdd.", " *", " * interfaceIndex:  The interface to which the answers pertain.", " *", " * errorCode:       Will be kDNSServiceErr_NoError on success, otherwise will", " *                  indicate the failure that occurred.  Other parameters are", " *                  undefined if errorCode is nonzero.", " *", " * hostname:        The fully qualified domain name of the host to be queried for.", " *", " * address:         IPv4 or IPv6 address.", " *", " * ttl:             If the client wishes to cache the result for performance reasons,", " *                  the TTL indicates how long the client may legitimately hold onto", " *                  this result, in seconds. After the TTL expires, the client should", " *                  consider the result no longer valid, and if it requires this data", " *                  again, it should be re-fetched with a new query. Of course, this", " *                  only applies to clients that cancel the asynchronous operation when", " *                  they get a result. Clients that leave the asynchronous operation", " *                  running can safely assume that the data remains valid until they", " *                  get another callback telling them otherwise.", " *", " * context:         The context pointer that was passed to the callout.", " *", " */", "", "typedef void (DNSSD_API *DNSServiceGetAddrInfoReply)", "(", "    DNSServiceRef sdRef,", "    DNSServiceFlags flags,", "    uint32_t interfaceIndex,", "    DNSServiceErrorType errorCode,", "    const char                       *hostname,", "    const struct sockaddr            *address,", "    uint32_t ttl,", "    void                             *context", ");", "", "", "/* DNSServiceGetAddrInfo() Parameters:", " *", " * sdRef:           A pointer to an uninitialized DNSServiceRef. If the call succeeds then it", " *                  initializes the DNSServiceRef, returns kDNSServiceErr_NoError, and the query", " *                  begins and will last indefinitely until the client terminates the query", " *                  by passing this DNSServiceRef to DNSServiceRefDeallocate().", " *", " * flags:           kDNSServiceFlagsForceMulticast or kDNSServiceFlagsLongLivedQuery.", ' *                  Pass kDNSServiceFlagsLongLivedQuery to create a "long-lived" unicast', " *                  query to a unicast DNS server that implements the protocol. This flag", " *                  has no effect on link-local multicast queries.", " *", " * interfaceIndex:  The interface on which to issue the query.  Passing 0 causes the query to be", " *                  sent on all active interfaces via Multicast or the primary interface via Unicast.", " *", " * protocol:        Pass in kDNSServiceProtocol_IPv4 to look up IPv4 addresses, or kDNSServiceProtocol_IPv6", " *                  to look up IPv6 addresses, or both to look up both kinds. If neither flag is", " *                  set, the system will apply an intelligent heuristic, which is (currently)", " *                  that it will attempt to look up both, except:", " *", ' *                   * If "hostname" is a wide-area unicast DNS hostname (i.e. not a ".local." name)', " *                     but this host has no routable IPv6 address, then the call will not try to", ' *                     look up IPv6 addresses for "hostname", since any addresses it found would be', " *                     unlikely to be of any use anyway. Similarly, if this host has no routable", ' *                     IPv4 address, the call will not try to look up IPv4 addresses for "hostname".', " *", " * hostname:        The fully qualified domain name of the host to be queried for.", " *", " * callBack:        The function to be called when the query succeeds or fails asynchronously.", " *", " * context:         An application context pointer which is passed to the callback function", " *                  (may be NULL).", " *", " * return value:    Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous", " *                  errors are delivered to the callback), otherwise returns an error code indicating", " *                  the error that occurred.", " */", "", "DNSServiceErrorType DNSSD_API DNSServiceGetAddrInfo", "(", "    DNSServiceRef                    *sdRef,", "    DNSServiceFlags flags,", "    uint32_t interfaceIndex,", "    DNSServiceProtocol protocol,", "    const char                       *hostname,", "    DNSServiceGetAddrInfoReply callBack,", "    void                             *context          /* may be NULL */", ");", "", "", "/*********************************************************************************************", "*", "*  Special Purpose Calls:", "*  DNSServiceCreateConnection(), DNSServiceRegisterRecord(), DNSServiceReconfirmRecord()", "*  (most applications will not use these)", "*", "*********************************************************************************************/", "", "/* DNSServiceCreateConnection()", " *", " * Create a connection to the daemon allowing efficient registration of", " * multiple individual records.", " *", " * Parameters:", " *", " * sdRef:           A pointer to an uninitialized DNSServiceRef. Deallocating", " *                  the reference (via DNSServiceRefDeallocate()) severs the", " *                  connection and deregisters all records registered on this connection.", " *", " * return value:    Returns kDNSServiceErr_NoError on success, otherwise returns", " *                  an error code indicating the specific failure that occurred (in which", " *                  case the DNSServiceRef is not initialized).", " */", "", "DNSServiceErrorType DNSSD_API DNSServiceCreateConnection(DNSServiceRef *sdRef);", "", "/* DNSServiceRegisterRecord", " *", " * Register an individual resource record on a connected DNSServiceRef.", " *", " * Note that name conflicts occurring for records registered via this call must be handled", " * by the client in the callback.", " *", " * DNSServiceRegisterRecordReply() parameters:", " *", " * sdRef:           The connected DNSServiceRef initialized by", " *                  DNSServiceCreateConnection().", " *", " * RecordRef:       The DNSRecordRef initialized by DNSServiceRegisterRecord(). If the above", " *                  DNSServiceRef is passed to DNSServiceRefDeallocate(), this DNSRecordRef is", " *                  invalidated, and may not be used further.", " *", " * flags:           Currently unused, reserved for future use.", " *", " * errorCode:       Will be kDNSServiceErr_NoError on success, otherwise will", " *                  indicate the failure that occurred (including name conflicts.)", " *                  Other parameters are undefined if errorCode is nonzero.", " *", " * context:         The context pointer that was passed to the callout.", " *", " */", "", "typedef void (DNSSD_API *DNSServiceRegisterRecordReply)", "(", "    DNSServiceRef sdRef,", "    DNSRecordRef RecordRef,", "    DNSServiceFlags flags,", "    DNSServiceErrorType errorCode,", "    void                                *context", ");", "", "", "/* DNSServiceRegisterRecord() Parameters:", " *", " * sdRef:           A DNSServiceRef initialized by DNSServiceCreateConnection().", " *", " * RecordRef:       A pointer to an uninitialized DNSRecordRef. Upon succesfull completion of this", " *                  call, this ref may be passed to DNSServiceUpdateRecord() or DNSServiceRemoveRecord().", " *                  (To deregister ALL records registered on a single connected DNSServiceRef", " *                  and deallocate each of their corresponding DNSServiceRecordRefs, call", " *                  DNSServiceRefDeallocate()).", " *", " * flags:           Possible values are kDNSServiceFlagsShared or kDNSServiceFlagsUnique", " *                  (see flag type definitions for details).", " *", " * interfaceIndex:  If non-zero, specifies the interface on which to register the record", " *                  (the index for a given interface is determined via the if_nametoindex()", " *                  family of calls.) Passing 0 causes the record to be registered on all interfaces.", ' *                  See "Constants for specifying an interface index" for more details.', " *", " * fullname:        The full domain name of the resource record.", " *", " * rrtype:          The numerical type of the resource record (e.g. kDNSServiceType_PTR, kDNSServiceType_SRV, etc)", " *", " * rrclass:         The class of the resource record (usually kDNSServiceClass_IN)", " *", " * rdlen:           Length, in bytes, of the rdata.", " *", " * rdata:           A pointer to the raw rdata, as it is to appear in the DNS record.", " *", " * ttl:             The time to live of the resource record, in seconds.", " *                  Most clients should pass 0 to indicate that the system should", " *                  select a sensible default value.", " *", " * callBack:        The function to be called when a result is found, or if the call", " *                  asynchronously fails (e.g. because of a name conflict.)", " *", " * context:         An application context pointer which is passed to the callback function", " *                  (may be NULL).", " *", " * return value:    Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous", " *                  errors are delivered to the callback), otherwise returns an error code indicating", " *                  the error that occurred (the callback is never invoked and the DNSRecordRef is", " *                  not initialized).", " */", "", "DNSServiceErrorType DNSSD_API DNSServiceRegisterRecord", "(", "    DNSServiceRef sdRef,", "    DNSRecordRef                        *RecordRef,", "    DNSServiceFlags flags,", "    uint32_t interfaceIndex,", "    const char                          *fullname,", "    uint16_t rrtype,", "    uint16_t rrclass,", "    uint16_t rdlen,", "    const void                          *rdata,", "    uint32_t ttl,", "    DNSServiceRegisterRecordReply callBack,", "    void                                *context    /* may be NULL */", ");", "", "", "/* DNSServiceReconfirmRecord", " *", " * Instruct the daemon to verify the validity of a resource record that appears", " * to be out of date (e.g. because TCP connection to a service's target failed.)", " * Causes the record to be flushed from the daemon's cache (as well as all other", " * daemons' caches on the network) if the record is determined to be invalid.", " * Use this routine conservatively. Reconfirming a record necessarily consumes", " * network bandwidth, so this should not be done indiscriminately.", " *", " * Parameters:", " *", " * flags:           Not currently used.", " *", " * interfaceIndex:  Specifies the interface of the record in question.", " *                  The caller must specify the interface.", " *                  This API (by design) causes increased network traffic, so it requires", " *                  the caller to be precise about which record should be reconfirmed.", " *                  It is not possible to pass zero for the interface index to perform", ' *                  a "wildcard" reconfirmation, where *all* matching records are reconfirmed.', " *", " * fullname:        The resource record's full domain name.", " *", " * rrtype:          The resource record's type (e.g. kDNSServiceType_PTR, kDNSServiceType_SRV, etc)", " *", " * rrclass:         The class of the resource record (usually kDNSServiceClass_IN).", " *", " * rdlen:           The length, in bytes, of the resource record rdata.", " *", " * rdata:           The raw rdata of the resource record.", " *", " */", "", "DNSServiceErrorType DNSSD_API DNSServiceReconfirmRecord", "(", "    DNSServiceFlags flags,", "    uint32_t interfaceIndex,", "    const char                         *fullname,", "    uint16_t rrtype,", "    uint16_t rrclass,", "    uint16_t rdlen,", "    const void                         *rdata", ");", "", "#ifndef __OPEN_SOURCE__", "", "/* PeerConnectionRelease() Parameters", " *", " * Release P2P connection resources associated with the service instance.", " * When a service is resolved over a P2P interface, a connection is brought up to the", " * peer advertising the service instance.  This call will free the resources associated", " * with that connection.  Note that the reference to the service instance will only", " * be maintained by the mDNSResponder daemon while the browse for the service type is still ", " * running.  Thus the sequence of calls to discover, resolve, and then terminate the connection ", " * associated with a given P2P service instance would be:", " *", " *   DNSServiceRef BrowseRef, ResolveRef;", " *      DNSServiceBrowse(&BrowseRef, ...)    // browse for all instances of the service", " *      DNSServiceResolve(&ResolveRef, ...)  // resolving a service instance creates a ", " *                                           // connection to the peer device advertising that service", " *      DNSServiceRefDeallocate(ResolveRef)  // Stop the resolve, which does not close the peer connection", " *", " *          // Communicate with the peer application.", " *         ", " *      PeerConnectionRelease()  // release the connection to the peer device for the specified service instance", " *", " *      DNSServiceRefDeallocate(BrowseRef)  // stop the browse  ", " *          // Any further calls to PeerConnectionRelease() will have no affect since the", " *          // service instance to peer connection relationship is only maintained by the ", " *          // mDNSResponder daemon while the browse is running.", " *", " *", " * flags:           Not currently used.", " *", " * name:            The name of the service instance to be resolved, as reported to the", " *                  DNSServiceBrowseReply() callback.", " *", " * regtype:         The type of the service instance to be resolved, as reported to the", " *                  DNSServiceBrowseReply() callback.", " *", " * domain:          The domain of the service instance to be resolved, as reported to the", " *                  DNSServiceBrowseReply() callback.", " *", " * return value:    Returns kDNSServiceErr_NoError on success or the error that occurred.", " */", "", "DNSServiceErrorType DNSSD_API PeerConnectionRelease", "(", "    DNSServiceFlags flags,", "    const char      *name,", "    const char      *regtype,", "    const char      *domain", ");", "", "#endif // __OPEN_SOURCE__", "", "/*********************************************************************************************", "*", "*  NAT Port Mapping", "*", "*********************************************************************************************/", "", "/* DNSServiceNATPortMappingCreate", " *", " * Request a port mapping in the NAT gateway, which maps a port on the local machine", " * to an external port on the NAT. The NAT should support either PCP, NAT-PMP or the", " * UPnP/IGD protocol for this API to create a successful mapping. Note that this API", " * currently supports IPv4 addresses/mappings only. If the NAT gateway supports PCP and", " * returns an IPv6 address (incorrectly, since this API specifically requests IPv4", " * addresses), the DNSServiceNATPortMappingReply callback will be invoked with errorCode", " * kDNSServiceErr_NATPortMappingUnsupported.", " *", " * The port mapping will be renewed indefinitely until the client process exits, or", " * explicitly terminates the port mapping request by calling DNSServiceRefDeallocate().", " * The client callback will be invoked, informing the client of the NAT gateway's", " * external IP address and the external port that has been allocated for this client.", " * The client should then record this external IP address and port using whatever", " * directory service mechanism it is using to enable peers to connect to it.", " * (Clients advertising services using Wide-Area DNS-SD DO NOT need to use this API", " * -- when a client calls DNSServiceRegister() NAT mappings are automatically created", " * and the external IP address and port for the service are recorded in the global DNS.", " * Only clients using some directory mechanism other than Wide-Area DNS-SD need to use", " * this API to explicitly map their own ports.)", " *", " * It's possible that the client callback could be called multiple times, for example", " * if the NAT gateway's IP address changes, or if a configuration change results in a", " * different external port being mapped for this client. Over the lifetime of any long-lived", " * port mapping, the client should be prepared to handle these notifications of changes", " * in the environment, and should update its recorded address and/or port as appropriate.", " *", " * NOTE: There are two unusual aspects of how the DNSServiceNATPortMappingCreate API works,", " * which were intentionally designed to help simplify client code:", " *", " *  1. It's not an error to request a NAT mapping when the machine is not behind a NAT gateway.", " *     In other NAT mapping APIs, if you request a NAT mapping and the machine is not behind a NAT", " *     gateway, then the API returns an error code -- it can't get you a NAT mapping if there's no", " *     NAT gateway. The DNSServiceNATPortMappingCreate API takes a different view. Working out", " *     whether or not you need a NAT mapping can be tricky and non-obvious, particularly on", " *     a machine with multiple active network interfaces. Rather than make every client recreate", " *     this logic for deciding whether a NAT mapping is required, the PortMapping API does that", " *     work for you. If the client calls the PortMapping API when the machine already has a", " *     routable public IP address, then instead of complaining about it and giving an error,", " *     the PortMapping API just invokes your callback, giving the machine's public address", " *     and your own port number. This means you don't need to write code to work out whether", " *     your client needs to call the PortMapping API -- just call it anyway, and if it wasn't", " *     necessary, no harm is done:", " *", " *     - If the machine already has a routable public IP address, then your callback", " *       will just be invoked giving your own address and port.", " *     - If a NAT mapping is required and obtained, then your callback will be invoked", " *       giving you the external address and port.", " *     - If a NAT mapping is required but not obtained from the local NAT gateway,", " *       or the machine has no network connectivity, then your callback will be", " *       invoked giving zero address and port.", " *", " *  2. In other NAT mapping APIs, if a laptop computer is put to sleep and woken up on a new", " *     network, it's the client's job to notice this, and work out whether a NAT mapping", " *     is required on the new network, and make a new NAT mapping request if necessary.", " *     The DNSServiceNATPortMappingCreate API does this for you, automatically.", " *     The client just needs to make one call to the PortMapping API, and its callback will", " *     be invoked any time the mapping state changes. This property complements point (1) above.", " *     If the client didn't make a NAT mapping request just because it determined that one was", " *     not required at that particular moment in time, the client would then have to monitor", " *     for network state changes to determine if a NAT port mapping later became necessary.", " *     By unconditionally making a NAT mapping request, even when a NAT mapping not to be", " *     necessary, the PortMapping API will then begin monitoring network state changes on behalf of", " *     the client, and if a NAT mapping later becomes necessary, it will automatically create a NAT", " *     mapping and inform the client with a new callback giving the new address and port information.", " *", " * DNSServiceNATPortMappingReply() parameters:", " *", " * sdRef:           The DNSServiceRef initialized by DNSServiceNATPortMappingCreate().", " *", " * flags:           Currently unused, reserved for future use.", " *", " * interfaceIndex:  The interface through which the NAT gateway is reached.", " *", " * errorCode:       Will be kDNSServiceErr_NoError on success.", " *                  Will be kDNSServiceErr_DoubleNAT when the NAT gateway is itself behind one or", " *                  more layers of NAT, in which case the other parameters have the defined values.", " *                  For other failures, will indicate the failure that occurred, and the other", " *                  parameters are undefined.", " *", " * externalAddress: Four byte IPv4 address in network byte order.", " *", " * protocol:        Will be kDNSServiceProtocol_UDP or kDNSServiceProtocol_TCP or both.", " *", " * internalPort:    The port on the local machine that was mapped.", " *", " * externalPort:    The actual external port in the NAT gateway that was mapped.", " *                  This is likely to be different than the requested external port.", " *", " * ttl:             The lifetime of the NAT port mapping created on the gateway.", " *                  This controls how quickly stale mappings will be garbage-collected", " *                  if the client machine crashes, suffers a power failure, is disconnected", " *                  from the network, or suffers some other unfortunate demise which", " *                  causes it to vanish without explicitly removing its NAT port mapping.", " *                  It's possible that the ttl value will differ from the requested ttl value.", " *", " * context:         The context pointer that was passed to the callout.", " *", " */", "", "typedef void (DNSSD_API *DNSServiceNATPortMappingReply)", "(", "    DNSServiceRef sdRef,", "    DNSServiceFlags flags,", "    uint32_t interfaceIndex,", "    DNSServiceErrorType errorCode,", "    uint32_t externalAddress,                           /* four byte IPv4 address in network byte order */", "    DNSServiceProtocol protocol,", "    uint16_t internalPort,                              /* In network byte order */", "    uint16_t externalPort,                              /* In network byte order and may be different than the requested port */", "    uint32_t ttl,                                       /* may be different than the requested ttl */", "    void                             *context", ");", "", "", "/* DNSServiceNATPortMappingCreate() Parameters:", " *", " * sdRef:           A pointer to an uninitialized DNSServiceRef. If the call succeeds then it", " *                  initializes the DNSServiceRef, returns kDNSServiceErr_NoError, and the nat", " *                  port mapping will last indefinitely until the client terminates the port", " *                  mapping request by passing this DNSServiceRef to DNSServiceRefDeallocate().", " *", " * flags:           Currently ignored, reserved for future use.", " *", " * interfaceIndex:  The interface on which to create port mappings in a NAT gateway. Passing 0 causes", " *                  the port mapping request to be sent on the primary interface.", " *", " * protocol:        To request a port mapping, pass in kDNSServiceProtocol_UDP, or kDNSServiceProtocol_TCP,", " *                  or (kDNSServiceProtocol_UDP | kDNSServiceProtocol_TCP) to map both.", " *                  The local listening port number must also be specified in the internalPort parameter.", " *                  To just discover the NAT gateway's external IP address, pass zero for protocol,", " *                  internalPort, externalPort and ttl.", " *", " * internalPort:    The port number in network byte order on the local machine which is listening for packets.", " *", " * externalPort:    The requested external port in network byte order in the NAT gateway that you would", " *                  like to map to the internal port. Pass 0 if you don't care which external port is chosen for you.", " *", " * ttl:             The requested renewal period of the NAT port mapping, in seconds.", " *                  If the client machine crashes, suffers a power failure, is disconnected from", " *                  the network, or suffers some other unfortunate demise which causes it to vanish", " *                  unexpectedly without explicitly removing its NAT port mappings, then the NAT gateway", " *                  will garbage-collect old stale NAT port mappings when their lifetime expires.", " *                  Requesting a short TTL causes such orphaned mappings to be garbage-collected", " *                  more promptly, but consumes system resources and network bandwidth with", " *                  frequent renewal packets to keep the mapping from expiring.", " *                  Requesting a long TTL is more efficient on the network, but in the event of the", " *                  client vanishing, stale NAT port mappings will not be garbage-collected as quickly.", " *                  Most clients should pass 0 to use a system-wide default value.", " *", " * callBack:        The function to be called when the port mapping request succeeds or fails asynchronously.", " *", " * context:         An application context pointer which is passed to the callback function", " *                  (may be NULL).", " *", " * return value:    Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous", " *                  errors are delivered to the callback), otherwise returns an error code indicating", " *                  the error that occurred.", " *", " *                  If you don't actually want a port mapped, and are just calling the API", " *                  because you want to find out the NAT's external IP address (e.g. for UI", " *                  display) then pass zero for protocol, internalPort, externalPort and ttl.", " */", "", "DNSServiceErrorType DNSSD_API DNSServiceNATPortMappingCreate", "(", "    DNSServiceRef                    *sdRef,", "    DNSServiceFlags flags,", "    uint32_t interfaceIndex,", "    DNSServiceProtocol protocol,                        /* TCP and/or UDP          */", "    uint16_t internalPort,                              /* network byte order      */", "    uint16_t externalPort,                              /* network byte order      */", "    uint32_t ttl,                                       /* time to live in seconds */", "    DNSServiceNATPortMappingReply callBack,", "    void                             *context           /* may be NULL             */", ");", "", "", "/*********************************************************************************************", "*", "*  General Utility Functions", "*", "*********************************************************************************************/", "", "/* DNSServiceConstructFullName()", " *", " * Concatenate a three-part domain name (as returned by the above callbacks) into a", " * properly-escaped full domain name. Note that callbacks in the above functions ALREADY ESCAPE", " * strings where necessary.", " *", " * Parameters:", " *", " * fullName:        A pointer to a buffer that where the resulting full domain name is to be written.", " *                  The buffer must be kDNSServiceMaxDomainName (1009) bytes in length to", " *                  accommodate the longest legal domain name without buffer overrun.", " *", " * service:         The service name - any dots or backslashes must NOT be escaped.", " *                  May be NULL (to construct a PTR record name, e.g.", ' *                  "_ftp._tcp.apple.com.").', " *", " * regtype:         The service type followed by the protocol, separated by a dot", ' *                  (e.g. "_ftp._tcp").', " *", ' * domain:          The domain name, e.g. "apple.com.". Literal dots or backslashes,', ' *                  if any, must be escaped, e.g. "1st\\. Floor.apple.com."', " *", " * return value:    Returns kDNSServiceErr_NoError (0) on success, kDNSServiceErr_BadParam on error.", " *", " */", "", "DNSServiceErrorType DNSSD_API DNSServiceConstructFullName", "(", "    char                            * const fullName,", "    const char                      * const service,      /* may be NULL */", "    const char                      * const regtype,", "    const char                      * const domain", ");", "", "", "/*********************************************************************************************", "*", "*   TXT Record Construction Functions", "*", "*********************************************************************************************/", "", "/*", " * A typical calling sequence for TXT record construction is something like:", " *", " * Client allocates storage for TXTRecord data (e.g. declare buffer on the stack)", " * TXTRecordCreate();", " * TXTRecordSetValue();", " * TXTRecordSetValue();", " * TXTRecordSetValue();", " * ...", " * DNSServiceRegister( ... TXTRecordGetLength(), TXTRecordGetBytesPtr() ... );", " * TXTRecordDeallocate();", " * Explicitly deallocate storage for TXTRecord data (if not allocated on the stack)", " */", "", "", "/* TXTRecordRef", " *", " * Opaque internal data type.", " * Note: Represents a DNS-SD TXT record.", " */", "", "typedef union _TXTRecordRef_t { char PrivateData[16]; char *ForceNaturalAlignment; } TXTRecordRef;", "", "", "/* TXTRecordCreate()", " *", " * Creates a new empty TXTRecordRef referencing the specified storage.", " *", " * If the buffer parameter is NULL, or the specified storage size is not", " * large enough to hold a key subsequently added using TXTRecordSetValue(),", " * then additional memory will be added as needed using malloc().", " *", " * On some platforms, when memory is low, malloc() may fail. In this", " * case, TXTRecordSetValue() will return kDNSServiceErr_NoMemory, and this", " * error condition will need to be handled as appropriate by the caller.", " *", " * You can avoid the need to handle this error condition if you ensure", " * that the storage you initially provide is large enough to hold all", " * the key/value pairs that are to be added to the record.", " * The caller can precompute the exact length required for all of the", " * key/value pairs to be added, or simply provide a fixed-sized buffer", " * known in advance to be large enough.", " * A no-value (key-only) key requires  (1 + key length) bytes.", " * A key with empty value requires     (1 + key length + 1) bytes.", " * A key with non-empty value requires (1 + key length + 1 + value length).", " * For most applications, DNS-SD TXT records are generally", " * less than 100 bytes, so in most cases a simple fixed-sized", " * 256-byte buffer will be more than sufficient.", " * Recommended size limits for DNS-SD TXT Records are discussed in", " * <http://files.dns-sd.org/draft-cheshire-dnsext-dns-sd.txt>", " *", " * Note: When passing parameters to and from these TXT record APIs,", " * the key name does not include the '=' character. The '=' character", " * is the separator between the key and value in the on-the-wire", " * packet format; it is not part of either the key or the value.", " *", " * txtRecord:       A pointer to an uninitialized TXTRecordRef.", " *", ' * bufferLen:       The size of the storage provided in the "buffer" parameter.', " *", " * buffer:          Optional caller-supplied storage used to hold the TXTRecord data.", " *                  This storage must remain valid for as long as", " *                  the TXTRecordRef.", " */", "", "void DNSSD_API TXTRecordCreate", "(", "    TXTRecordRef     *txtRecord,", "    uint16_t bufferLen,", "    void             *buffer", ");", "", "", "/* TXTRecordDeallocate()", " *", " * Releases any resources allocated in the course of preparing a TXT Record", " * using TXTRecordCreate()/TXTRecordSetValue()/TXTRecordRemoveValue().", " * Ownership of the buffer provided in TXTRecordCreate() returns to the client.", " *", " * txtRecord:           A TXTRecordRef initialized by calling TXTRecordCreate().", " *", " */", "", "void DNSSD_API TXTRecordDeallocate", "(", "    TXTRecordRef     *txtRecord", ");", "", "", "/* TXTRecordSetValue()", " *", ' * Adds a key (optionally with value) to a TXTRecordRef. If the "key" already', " * exists in the TXTRecordRef, then the current value will be replaced with", " * the new value.", " * Keys may exist in four states with respect to a given TXT record:", " *  - Absent (key does not appear at all)", ' *  - Present with no value ("key" appears alone)', ' *  - Present with empty value ("key=" appears in TXT record)', ' *  - Present with non-empty value ("key=value" appears in TXT record)', ' * For more details refer to "Data Syntax for DNS-SD TXT Records" in', " * <http://files.dns-sd.org/draft-cheshire-dnsext-dns-sd.txt>", " *", " * txtRecord:       A TXTRecordRef initialized by calling TXTRecordCreate().", " *", " * key:             A null-terminated string which only contains printable ASCII", " *                  values (0x20-0x7E), excluding '=' (0x3D). Keys should be", " *                  9 characters or fewer (not counting the terminating null).", " *", " * valueSize:       The size of the value.", " *", " * value:           Any binary value. For values that represent", " *                  textual data, UTF-8 is STRONGLY recommended.", " *                  For values that represent textual data, valueSize", " *                  should NOT include the terminating null (if any)", " *                  at the end of the string.", ' *                  If NULL, then "key" will be added with no value.', ' *                  If non-NULL but valueSize is zero, then "key=" will be', " *                  added with empty value.", " *", " * return value:    Returns kDNSServiceErr_NoError on success.", ' *                  Returns kDNSServiceErr_Invalid if the "key" string contains', " *                  illegal characters.", " *                  Returns kDNSServiceErr_NoMemory if adding this key would", " *                  exceed the available storage.", " */", "", "DNSServiceErrorType DNSSD_API TXTRecordSetValue", "(", "    TXTRecordRef     *txtRecord,", "    const char       *key,", "    uint8_t valueSize,                 /* may be zero */", "    const void       *value            /* may be NULL */", ");", "", "", "/* TXTRecordRemoveValue()", " *", ' * Removes a key from a TXTRecordRef. The "key" must be an', " * ASCII string which exists in the TXTRecordRef.", " *", " * txtRecord:       A TXTRecordRef initialized by calling TXTRecordCreate().", " *", " * key:             A key name which exists in the TXTRecordRef.", " *", " * return value:    Returns kDNSServiceErr_NoError on success.", ' *                  Returns kDNSServiceErr_NoSuchKey if the "key" does not', " *                  exist in the TXTRecordRef.", " */", "", "DNSServiceErrorType DNSSD_API TXTRecordRemoveValue", "(", "    TXTRecordRef     *txtRecord,", "    const char       *key", ");", "", "", "/* TXTRecordGetLength()", " *", " * Allows you to determine the length of the raw bytes within a TXTRecordRef.", " *", " * txtRecord:       A TXTRecordRef initialized by calling TXTRecordCreate().", " *", " * return value:    Returns the size of the raw bytes inside a TXTRecordRef", " *                  which you can pass directly to DNSServiceRegister() or", " *                  to DNSServiceUpdateRecord().", " *                  Returns 0 if the TXTRecordRef is empty.", " */", "", "uint16_t DNSSD_API TXTRecordGetLength", "(", "    const TXTRecordRef *txtRecord", ");", "", "", "/* TXTRecordGetBytesPtr()", " *", " * Allows you to retrieve a pointer to the raw bytes within a TXTRecordRef.", " *", " * txtRecord:       A TXTRecordRef initialized by calling TXTRecordCreate().", " *", " * return value:    Returns a pointer to the raw bytes inside the TXTRecordRef", " *                  which you can pass directly to DNSServiceRegister() or", " *                  to DNSServiceUpdateRecord().", " */", "", "const void * DNSSD_API TXTRecordGetBytesPtr", "(", "    const TXTRecordRef *txtRecord", ");", "", "", "/*********************************************************************************************", "*", "*   TXT Record Parsing Functions", "*", "*********************************************************************************************/", "", "/*", " * A typical calling sequence for TXT record parsing is something like:", " *", " * Receive TXT record data in DNSServiceResolve() callback", ' * if (TXTRecordContainsKey(txtLen, txtRecord, "key")) then do something', ' * val1ptr = TXTRecordGetValuePtr(txtLen, txtRecord, "key1", &len1);', ' * val2ptr = TXTRecordGetValuePtr(txtLen, txtRecord, "key2", &len2);', " * ...", " * memcpy(myval1, val1ptr, len1);", " * memcpy(myval2, val2ptr, len2);", " * ...", " * return;", " *", " * If you wish to retain the values after return from the DNSServiceResolve()", " * callback, then you need to copy the data to your own storage using memcpy()", " * or similar, as shown in the example above.", " *", " * If for some reason you need to parse a TXT record you built yourself", " * using the TXT record construction functions above, then you can do", " * that using TXTRecordGetLength and TXTRecordGetBytesPtr calls:", " * TXTRecordGetValue(TXTRecordGetLength(x), TXTRecordGetBytesPtr(x), key, &len);", " *", " * Most applications only fetch keys they know about from a TXT record and", " * ignore the rest.", " * However, some debugging tools wish to fetch and display all keys.", " * To do that, use the TXTRecordGetCount() and TXTRecordGetItemAtIndex() calls.", " */", "", "/* TXTRecordContainsKey()", " *", " * Allows you to determine if a given TXT Record contains a specified key.", " *", " * txtLen:          The size of the received TXT Record.", " *", " * txtRecord:       Pointer to the received TXT Record bytes.", " *", " * key:             A null-terminated ASCII string containing the key name.", " *", " * return value:    Returns 1 if the TXT Record contains the specified key.", " *                  Otherwise, it returns 0.", " */", "", "int DNSSD_API TXTRecordContainsKey", "(", "    uint16_t txtLen,", "    const void       *txtRecord,", "    const char       *key", ");", "", "", "/* TXTRecordGetValuePtr()", " *", " * Allows you to retrieve the value for a given key from a TXT Record.", " *", " * txtLen:          The size of the received TXT Record", " *", " * txtRecord:       Pointer to the received TXT Record bytes.", " *", " * key:             A null-terminated ASCII string containing the key name.", " *", ' * valueLen:        On output, will be set to the size of the "value" data.', " *", " * return value:    Returns NULL if the key does not exist in this TXT record,", " *                  or exists with no value (to differentiate between", " *                  these two cases use TXTRecordContainsKey()).", " *                  Returns pointer to location within TXT Record bytes", " *                  if the key exists with empty or non-empty value.", " *                  For empty value, valueLen will be zero.", " *                  For non-empty value, valueLen will be length of value data.", " */", "", "const void * DNSSD_API TXTRecordGetValuePtr", "(", "    uint16_t txtLen,", "    const void       *txtRecord,", "    const char       *key,", "    uint8_t          *valueLen", ");", "", "", "/* TXTRecordGetCount()", " *", " * Returns the number of keys stored in the TXT Record. The count", " * can be used with TXTRecordGetItemAtIndex() to iterate through the keys.", " *", " * txtLen:          The size of the received TXT Record.", " *", " * txtRecord:       Pointer to the received TXT Record bytes.", " *", " * return value:    Returns the total number of keys in the TXT Record.", " *", " */", "", "uint16_t DNSSD_API TXTRecordGetCount", "(", "    uint16_t txtLen,", "    const void       *txtRecord", ");", "", "", "/* TXTRecordGetItemAtIndex()", " *", " * Allows you to retrieve a key name and value pointer, given an index into", " * a TXT Record. Legal index values range from zero to TXTRecordGetCount()-1.", " * It's also possible to iterate through keys in a TXT record by simply", " * calling TXTRecordGetItemAtIndex() repeatedly, beginning with index zero", " * and increasing until TXTRecordGetItemAtIndex() returns kDNSServiceErr_Invalid.", " *", " * On return:", " * For keys with no value, *value is set to NULL and *valueLen is zero.", " * For keys with empty value, *value is non-NULL and *valueLen is zero.", " * For keys with non-empty value, *value is non-NULL and *valueLen is non-zero.", " *", " * txtLen:          The size of the received TXT Record.", " *", " * txtRecord:       Pointer to the received TXT Record bytes.", " *", " * itemIndex:       An index into the TXT Record.", " *", " * keyBufLen:       The size of the string buffer being supplied.", " *", " * key:             A string buffer used to store the key name.", " *                  On return, the buffer contains a null-terminated C string", " *                  giving the key name. DNS-SD TXT keys are usually", " *                  9 characters or fewer. To hold the maximum possible", " *                  key name, the buffer should be 256 bytes long.", " *", ' * valueLen:        On output, will be set to the size of the "value" data.', " *", " * value:           On output, *value is set to point to location within TXT", " *                  Record bytes that holds the value data.", " *", " * return value:    Returns kDNSServiceErr_NoError on success.", " *                  Returns kDNSServiceErr_NoMemory if keyBufLen is too short.", " *                  Returns kDNSServiceErr_Invalid if index is greater than", " *                  TXTRecordGetCount()-1.", " */", "", "DNSServiceErrorType DNSSD_API TXTRecordGetItemAtIndex", "(", "    uint16_t txtLen,", "    const void       *txtRecord,", "    uint16_t itemIndex,", "    uint16_t keyBufLen,", "    char             *key,", "    uint8_t          *valueLen,", "    const void       **value", ");", "", "#if _DNS_SD_LIBDISPATCH", "/*", " * DNSServiceSetDispatchQueue", " *", " * Allows you to schedule a DNSServiceRef on a serial dispatch queue for receiving asynchronous", " * callbacks.  It's the clients responsibility to ensure that the provided dispatch queue is running.", " *", " * A typical application that uses CFRunLoopRun or dispatch_main on its main thread will", " * usually schedule DNSServiceRefs on its main queue (which is always a serial queue)", ' * using "DNSServiceSetDispatchQueue(sdref, dispatch_get_main_queue());"', " *", " * If there is any error during the processing of events, the application callback will", " * be called with an error code. For shared connections, each subordinate DNSServiceRef", " * will get its own error callback. Currently these error callbacks only happen", " * if the mDNSResponder daemon is manually terminated or crashes, and the error", " * code in this case is kDNSServiceErr_ServiceNotRunning. The application must call", " * DNSServiceRefDeallocate to free the DNSServiceRef when it gets such an error code.", " * These error callbacks are rare and should not normally happen on customer machines,", " * but application code should be written defensively to handle such error callbacks", " * gracefully if they occur.", " *", " * After using DNSServiceSetDispatchQueue on a DNSServiceRef, calling DNSServiceProcessResult", " * on the same DNSServiceRef will result in undefined behavior and should be avoided.", " *", " * Once the application successfully schedules a DNSServiceRef on a serial dispatch queue using", " * DNSServiceSetDispatchQueue, it cannot remove the DNSServiceRef from the dispatch queue, or use", " * DNSServiceSetDispatchQueue a second time to schedule the DNSServiceRef onto a different serial dispatch", " * queue. Once scheduled onto a dispatch queue a DNSServiceRef will deliver events to that queue until", " * the application no longer requires that operation and terminates it using DNSServiceRefDeallocate.", " *", " * service:         DNSServiceRef that was allocated and returned to the application, when the", " *                  application calls one of the DNSService API.", " *", " * queue:           dispatch queue where the application callback will be scheduled", " *", " * return value:    Returns kDNSServiceErr_NoError on success.", " *                  Returns kDNSServiceErr_NoMemory if it cannot create a dispatch source", " *                  Returns kDNSServiceErr_BadParam if the service param is invalid or the", " *                  queue param is invalid", " */", "", "DNSServiceErrorType DNSSD_API DNSServiceSetDispatchQueue", "(", "    DNSServiceRef service,", "    dispatch_queue_t queue", ");", "#endif //_DNS_SD_LIBDISPATCH", "", "#if !defined(_WIN32)", "typedef void (DNSSD_API *DNSServiceSleepKeepaliveReply)", "(", "    DNSServiceRef sdRef,", "    DNSServiceErrorType errorCode,", "    void                                *context", ");", "DNSServiceErrorType DNSSD_API DNSServiceSleepKeepalive", "(", "    DNSServiceRef                       *sdRef,", "    DNSServiceFlags flags,", "    int fd,", "    unsigned int timeout,", "    DNSServiceSleepKeepaliveReply callBack,", "    void                                *context", ");", "#endif", "", "#ifdef APPLE_OSX_mDNSResponder", "/* DNSServiceCreateDelegateConnection()", " *", " * Create a delegate connection to the daemon allowing efficient registration of", " * multiple individual records.", " *", " * Parameters:", " *", " * sdRef:           A pointer to an uninitialized DNSServiceRef. Deallocating", " *                  the reference (via DNSServiceRefDeallocate()) severs the", " *                  connection and deregisters all records registered on this connection.", " *", " * pid :            Process ID of the delegate", " *", " * uuid:            UUID of the delegate", " *", " *                  Note that only one of the two arguments (pid or uuid) can be specified. If pid", " *                  is zero, uuid will be assumed to be a valid value; otherwise pid will be used.", " *", " * return value:    Returns kDNSServiceErr_NoError on success, otherwise returns", " *                  an error code indicating the specific failure that occurred (in which", " *                  case the DNSServiceRef is not initialized). kDNSServiceErr_NotAuth is", " *                  returned to indicate that the calling process does not have entitlements", " *                  to use this API.", " */", "DNSServiceErrorType DNSSD_API DNSServiceCreateDelegateConnection(DNSServiceRef *sdRef, int32_t pid, uuid_t uuid);", "#endif", "", "#ifdef __APPLE_API_PRIVATE", "", '#define kDNSServiceCompPrivateDNS   "PrivateDNS"', '#define kDNSServiceCompMulticastDNS "MulticastDNS"', "", "#endif //__APPLE_API_PRIVATE", "", "/* Some C compiler cleverness. We can make the compiler check certain things for us,", " * and report errors at compile-time if anything is wrong. The usual way to do this would", ' * be to use a run-time "if" statement or the conventional run-time "assert" mechanism, but', " * then you don't find out what's wrong until you run the software. This way, if the assertion", " * condition is false, the array size is negative, and the complier complains immediately.", " */", "", "struct CompileTimeAssertionChecks_DNS_SD", "{", "    char assert0[(sizeof(union _TXTRecordRef_t) == 16) ? 1 : -1];", "};", "", "#ifdef  __cplusplus", "}", "#endif", "", "#endif  /* _DNS_SD_H */" },
    ["dns_util.h"] = { "/*", " * Copyright (c) 2003-2006 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "", "#ifndef __DNS_UTIL_H__", "#define __DNS_UTIL_H__", "", "#include <sys/cdefs.h>", "#include <sys/types.h>", "#include <sys/socket.h>", "#include <sys/time.h>", "#include <netinet/in.h>", "#include <arpa/inet.h>", "#include <dns.h>", "", "/*", " * Status returned in a dns_reply_t", " */", "#define DNS_STATUS_OK\t\t\t\t\t0", "#define DNS_STATUS_BAD_HANDLE\t\t\t1", "#define DNS_STATUS_MALFORMED_QUERY\t\t2", "#define DNS_STATUS_TIMEOUT\t\t\t\t3", "#define DNS_STATUS_SEND_FAILED\t\t\t4", "#define DNS_STATUS_RECEIVE_FAILED\t\t5", "#define DNS_STATUS_CONNECTION_FAILED\t6", "#define DNS_STATUS_WRONG_SERVER\t\t\t7", "#define DNS_STATUS_WRONG_XID\t\t\t8", "#define DNS_STATUS_WRONG_QUESTION\t\t9", "", "/*", " * dns_print_reply mask", " */", "#define DNS_PRINT_XID        0x0001", "#define DNS_PRINT_QR         0x0002", "#define DNS_PRINT_OPCODE     0x0004", "#define DNS_PRINT_AA         0x0008", "#define DNS_PRINT_TC         0x0010", "#define DNS_PRINT_RD         0x0020", "#define DNS_PRINT_RA         0x0040", "#define DNS_PRINT_PR         0x0080", "#define DNS_PRINT_RCODE      0x0100", "#define DNS_PRINT_QUESTION   0x0200", "#define DNS_PRINT_ANSWER     0x0400", "#define DNS_PRINT_AUTHORITY  0x0800", "#define DNS_PRINT_ADDITIONAL 0x1000", "#define DNS_PRINT_SERVER     0x2000", "", "/*", " * DNS query / reply header", " */", "typedef struct {", "\tuint16_t xid;", "\tuint16_t flags;", "\tuint16_t qdcount;", "\tuint16_t ancount;", "\tuint16_t nscount;", "\tuint16_t arcount;", "} dns_header_t;", "", "/*", " * DNS query", " */", "typedef struct", "{", "\tchar *name;", "\tuint16_t dnstype;", "\tuint16_t dnsclass;", "} dns_question_t;", "", "/*", " * Resource Record types", " * dns_parse_packet() creates resourse records of these types.", " */", "typedef struct", "{", "\tuint16_t length;", "\tchar *data;", "} dns_raw_resource_record_t;", "", "typedef struct", "{", "\tstruct in_addr addr;", "} dns_address_record_t;", "", "typedef struct", "{", "\tstruct in6_addr addr;", "} dns_in6_address_record_t;", "", "typedef struct", "{", "\tchar *name;", "} dns_domain_name_record_t;", "", "typedef struct", "{", "\tchar *mname;", "\tchar *rname;", "\tuint32_t serial;", "\tuint32_t refresh;", "\tuint32_t retry;", "\tuint32_t expire;", "\tuint32_t minimum;", "} dns_SOA_record_t;", "", "typedef struct", "{", "\tchar *cpu;", "\tchar *os;", "} dns_HINFO_record_t;", "", "typedef struct", "{", "\tchar *rmailbx;", "\tchar *emailbx;", "} dns_MINFO_record_t;", "", "typedef struct", "{", "\tuint16_t preference;", "\tchar *name;", "} dns_MX_record_t;", "", "typedef struct", "{", "\tuint32_t string_count;", "\tchar **strings;", "} dns_TXT_record_t;", "", "typedef struct", "{", "\tstruct in_addr addr;", "\tuint8_t protocol;", "\tuint32_t maplength;", "\tuint8_t *map;", "} dns_WKS_record_t;", "", "typedef struct", "{", "\tchar *mailbox;", "\tchar *txtdname;", "} dns_RP_record_t;", "", "typedef struct", "{", "\tuint32_t subtype;", "\tchar *hostname;", "} dns_AFSDB_record_t;", "", "typedef struct", "{", "\tchar *psdn_address;", "} dns_X25_record_t;", "", "typedef struct", "{", "\tchar *isdn_address;", "\tchar *subaddress;", "} dns_ISDN_record_t;", "", "typedef struct", "{", "\tuint16_t preference;", "\tchar * intermediate;", "} dns_RT_record_t;", "", "typedef struct", "{", "\tuint8_t version;", "\tuint8_t size;", "\tuint8_t horizontal_precision;", "\tuint8_t vertical_precision;", "\tuint32_t latitude;", "\tuint32_t longitude;", "\tuint32_t altitude;", "} dns_LOC_record_t;", "", "typedef struct", "{", "\tuint16_t priority;", "\tuint16_t weight;", "\tuint16_t port;", "\tchar *target;", "} dns_SRV_record_t;", "", "/*", " * DNS Resource Record", " *", " * Data contained in unsupported or obsolete Resource Record types", " * may be accessed via DNSNULL as a dns_raw_resource_record_t. ", " */", "typedef struct", "{", "\tchar *name;", "\tuint16_t dnstype;", "\tuint16_t dnsclass;", "\tuint32_t ttl;", "\tunion", "\t{", "\t\tdns_address_record_t *A;", "\t\tdns_domain_name_record_t *NS;", "\t\tdns_domain_name_record_t *MD;\t\t/* Obsolete */", "\t\tdns_domain_name_record_t *MF;\t\t/* Obsolete */", "\t\tdns_domain_name_record_t *CNAME;", "\t\tdns_SOA_record_t *SOA;", "\t\tdns_domain_name_record_t *MB;", "\t\tdns_domain_name_record_t *MG;", "\t\tdns_domain_name_record_t *MR;", "\t\tdns_raw_resource_record_t *DNSNULL;", "\t\tdns_WKS_record_t *WKS;", "\t\tdns_domain_name_record_t *PTR;", "\t\tdns_HINFO_record_t *HINFO;", "\t\tdns_MINFO_record_t *MINFO;", "\t\tdns_MX_record_t *MX;", "\t\tdns_TXT_record_t *TXT;", "\t\tdns_RP_record_t *RP;", "\t\tdns_AFSDB_record_t *AFSDB;", "\t\tdns_X25_record_t *X25;", "\t\tdns_ISDN_record_t *ISDN;", "\t\tdns_RT_record_t *RT;", "\t\tdns_in6_address_record_t *AAAA;", "\t\tdns_LOC_record_t *LOC;", "\t\tdns_SRV_record_t *SRV;", "\t} data;", "} dns_resource_record_t;", "", "/*", " * A parsed DNS record.  Returned by dns_parse_packet() and dns_lookup().", " * The contents may be printed using dns_print_reply().", " */", "typedef struct", "{", "\tuint32_t status;", "\tstruct sockaddr *server;", "\tdns_header_t *header;", "\tdns_question_t **question;", "\tdns_resource_record_t **answer;", "\tdns_resource_record_t **authority;", "\tdns_resource_record_t **additional;", "} dns_reply_t;", "", "", "__BEGIN_DECLS", "", "/*", " * High-level lookup performs a search (using dns_search), parses the ", " * reply and returns a dns_reply_t structure.", " *", " * The DNS handle contains an internal buffer used for fetching replies.", " * The buffer is reused for each query, and is released with the DNS client", " * handle when dns_free() is called.  The default buffer size is 1024 bytes.", " * The size may be changed with dns_set_buffer_size.", " *", " * Note that in a multithreaded application, each thread using this API must", " * open a separate handle.", " */", "extern dns_reply_t *dns_lookup(dns_handle_t dns, const char *name, uint32_t dnsclass, uint32_t dnstype);", "", "/*", " * Get / Set the size of the internal receive buffer used by dns_lookup()", " */", "extern uint32_t dns_get_buffer_size(dns_handle_t d);", "extern void dns_set_buffer_size(dns_handle_t d, uint32_t len);", "", "/*", " * Parse a reply packet into a reply structure.", " */", "extern dns_reply_t *dns_parse_packet(const char *buf, uint32_t len);", "", "/*", " * Free a reply structure.", " */", "extern void dns_free_reply(dns_reply_t *r);", "", "/*", " * Parse a query packet into a question structure.", " */", "extern dns_question_t *dns_parse_question(const char *buf, uint32_t len);", "", "/*", " * Free a question structure.", " */", "extern void dns_free_question(dns_question_t *q);", "", "/*", " * Parse a resource record into a structure.", " */", "extern dns_resource_record_t *dns_parse_resource_record(const char *buf, uint32_t len);", "", "/*", " * Free a resource record structure.", " */", "extern void dns_free_resource_record(dns_resource_record_t *rr);", "", "/*", " * String / number representation of a DNS class", " * dns_class_number returns 0 if the string is recognized,", " * non-zero if the class string is unknown.", " */", "extern const char *dns_class_string(uint16_t dnsclass);", "extern int32_t dns_class_number(const char *c, uint16_t *n);", "", "/*", " * String / number representation of a DNS type", " * dns_type_number returns 0 if the string is recognized,", " * non-zero if the class string is unknown.", " */", "extern const char *dns_type_string(uint16_t dnstype);", "extern int32_t dns_type_number(const char *t, uint16_t *n);", "", "/*", " * Print a dns handle.", " */", "extern void dns_print_handle(dns_handle_t d, FILE *f);", "", "/*", " * Print the contents of a question structure.", " */", "extern void dns_print_question(const dns_question_t *q, FILE *f);", "", "/*", " * Print the contents of a resource record structure.", " */", "extern void dns_print_resource_record(const dns_resource_record_t *r, FILE *f);", "", "/*", " * Print the contents of a reply structure.", " */", "extern void dns_print_reply(const dns_reply_t *r, FILE *f, uint16_t mask);", "", "__END_DECLS", "", "#endif /* __DNS_UTIL_H__ */" },
    ["dtrace.h"] = { "/*", " * CDDL HEADER START", " *", " * The contents of this file are subject to the terms of the", ' * Common Development and Distribution License (the "License").', " * You may not use this file except in compliance with the License.", " *", " * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE", " * or http://www.opensolaris.org/os/licensing.", " * See the License for the specific language governing permissions", " * and limitations under the License.", " *", " * When distributing Covered Code, include this CDDL HEADER in each", " * file and include the License file at usr/src/OPENSOLARIS.LICENSE.", " * If applicable, add the following below this CDDL HEADER, with the", ' * fields enclosed by brackets "[]" replaced with your own identifying', " * information: Portions Copyright [yyyy] [name of copyright owner]", " *", " * CDDL HEADER END", " */", "", "/*", " * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.", " * Use is subject to license terms.", " */", "", "#ifndef\t_DTRACE_H", "#define\t_DTRACE_H", "", "#if !defined(__APPLE__)", "/*", " * clang does not understand this pragma, and it is included in system headers", " */", '#pragma ident\t"@(#)dtrace.h\t1.17\t07/11/12 SMI"', "#endif", "", "#if !defined(__APPLE__)", "#include <sys/dtrace.h>", "#include <stdarg.h>", "#include <stdio.h>", "#include <gelf.h>", "#else /* is Apple Mac OS X */", "", "#if defined(__LP64__)", "#if !defined(_LP64)", "#define _LP64 /* Solaris vs. Darwin */", "#endif", "#else", "#if !defined(_ILP32)", "#define _ILP32 /* Solaris vs. Darwin */", "#endif", "#endif", "", "#include <mach/machine.h>", "#include <sys/dtrace.h>", "#include <stdarg.h>", "#include <stdio.h>", "", "/*", " * In lieu of gelf.h. ", " * dtrace.h is a publicly exported header.", " * It makes glancing reference to some GElf types.", " * Rather than haul in all the undelying Elf typing machinery, we'll", " * #define the GElf stuff that's referenced here onto suitable simple types.", " */", "#define GElf_Addr\t__GElf_Addr", "#define GElf_Xword\t__GElf_Xword", "#define GElf_Sxword\t__GElf_Sxword", "#define GElf_Half\t__GElf_Half", "#define GElf_Word\t__GElf_Word", "#define GElf_Sym\t__GElf_Sym", "", "/*", " * GElf_Addr and GElf_Xword must accomodate 64-bit addresses, since a 32-bit ctf tool", " * may manipulate a 64-bit target. ", " */", "#if defined(_LP64)", "typedef unsigned long\t\tGElf_Addr;", "typedef\tunsigned long\t\tGElf_Xword;", "typedef long\t\t\tGElf_Sxword;", "#else", "typedef unsigned long long\tGElf_Addr;", "typedef\tunsigned long long\tGElf_Xword;", "typedef long long\t\tGElf_Sxword;", "#endif", "", "typedef unsigned short\t\tGElf_Half;", "typedef\tunsigned int\t\tGElf_Word;", "", "typedef struct {", "\tGElf_Sxword\tst_name;", "\tunsigned char\tst_info;\t/* bind, type: ELF_64_ST_... */", "\tunsigned char\tst_other;", "\tGElf_Half\tst_shndx;\t/* SHN_... */", "\tGElf_Addr\tst_value;", "\tGElf_Xword\tst_size;", "} GElf_Sym;", "", "extern char* demangleSymbolCString(const char*);", "", "#endif /* __APPLE__ */", "", "#ifdef\t__cplusplus", 'extern "C" {', "#endif", "", "/*", " * DTrace Dynamic Tracing Software: Library Interfaces", " *", " * Note: The contents of this file are private to the implementation of the", " * Solaris system and DTrace subsystem and are subject to change at any time", " * without notice.  Applications and drivers using these interfaces will fail", " * to run on future releases.  These interfaces should not be used for any", " * purpose except those expressly outlined in dtrace(7D) and libdtrace(3LIB).", ' * Please refer to the "Solaris Dynamic Tracing Guide" for more information.', " */", "", "#define\tDTRACE_VERSION\t3\t\t/* library ABI interface version */", "", "struct ps_prochandle;", "typedef struct dtrace_hdl dtrace_hdl_t;", "typedef struct dtrace_prog dtrace_prog_t;", "typedef struct dtrace_vector dtrace_vector_t;", "typedef struct dtrace_aggdata dtrace_aggdata_t;", "", "#define\tDTRACE_O_NODEV\t\t0x01\t/* do not open dtrace(7D) device */", "#define\tDTRACE_O_NOSYS\t\t0x02\t/* do not load /system/object modules */", "#define\tDTRACE_O_LP64\t\t0x04\t/* force D compiler to be LP64 */", "#define\tDTRACE_O_ILP32\t\t0x08\t/* force D compiler to be ILP32 */", "#define\tDTRACE_O_MASK\t\t0x0f\t/* mask of valid flags to dtrace_open */", "", "extern dtrace_hdl_t *dtrace_open(int, int, int *);", "extern dtrace_hdl_t *dtrace_vopen(int, int, int *,", "    const dtrace_vector_t *, void *);", "", "extern int dtrace_go(dtrace_hdl_t *);", "extern int dtrace_stop(dtrace_hdl_t *);", "extern void dtrace_sleep(dtrace_hdl_t *);", "extern void dtrace_close(dtrace_hdl_t *);", "", "extern int dtrace_errno(dtrace_hdl_t *);", "extern const char *dtrace_errmsg(dtrace_hdl_t *, int);", "extern const char *dtrace_faultstr(dtrace_hdl_t *, int);", "extern const char *dtrace_subrstr(dtrace_hdl_t *, int);", "", "extern int dtrace_setopt(dtrace_hdl_t *, const char *, const char *);", "extern int dtrace_getopt(dtrace_hdl_t *, const char *, dtrace_optval_t *);", "", "extern void dtrace_update(dtrace_hdl_t *);", "extern int dtrace_ctlfd(dtrace_hdl_t *);", "", "/*", " * DTrace Program Interface", " *", " * DTrace programs can be created by compiling ASCII text files containing", " * D programs or by compiling in-memory C strings that specify a D program.", " * Once created, callers can examine the list of program statements and", " * enable the probes and actions described by these statements.", " */", "", "typedef struct dtrace_proginfo {", "\tdtrace_attribute_t dpi_descattr; /* minimum probedesc attributes */", "\tdtrace_attribute_t dpi_stmtattr; /* minimum statement attributes */", "\tuint_t dpi_aggregates;\t/* number of aggregates specified in program */", "\tuint_t dpi_recgens;\t/* number of record generating probes in prog */", "\tuint_t dpi_matches;\t/* number of probes matched by program */", "\tuint_t dpi_speculations; /* number of speculations specified in prog */", "} dtrace_proginfo_t;", "", "#define\tDTRACE_C_DIFV\t0x0001\t/* DIF verbose mode: show each compiled DIFO */", "#define\tDTRACE_C_EMPTY\t0x0002\t/* Permit compilation of empty D source files */", "#define\tDTRACE_C_ZDEFS\t0x0004\t/* Permit probe defs that match zero probes */", "#define\tDTRACE_C_EATTR\t0x0008\t/* Error if program attributes less than min */", "#define\tDTRACE_C_CPP\t0x0010\t/* Preprocess input file with cpp(1) utility */", "#define\tDTRACE_C_KNODEF\t0x0020\t/* Permit unresolved kernel symbols in DIFO */", "#define\tDTRACE_C_UNODEF\t0x0040\t/* Permit unresolved user symbols in DIFO */", "#define\tDTRACE_C_PSPEC\t0x0080\t/* Intepret ambiguous specifiers as probes */", "#define\tDTRACE_C_ETAGS\t0x0100\t/* Prefix error messages with error tags */", "#define\tDTRACE_C_ARGREF\t0x0200\t/* Do not require all macro args to be used */", '#define\tDTRACE_C_DEFARG\t0x0800\t/* Use 0/"" as value for unspecified args */', "#define\tDTRACE_C_NOLIBS\t0x1000\t/* Do not process D system libraries */", "#define\tDTRACE_C_CTL\t0x2000\t/* Only process control directives */", "#define\tDTRACE_C_MASK\t0x3bff\t/* mask of all valid flags to dtrace_*compile */", "", "extern dtrace_prog_t *dtrace_program_strcompile(dtrace_hdl_t *,", "    const char *, dtrace_probespec_t, uint_t, int, char *const []);", "", "extern dtrace_prog_t *dtrace_program_fcompile(dtrace_hdl_t *,", "    FILE *, uint_t, int, char *const []);", "", "extern int dtrace_program_exec(dtrace_hdl_t *, dtrace_prog_t *,", "    dtrace_proginfo_t *);", "extern void dtrace_program_info(dtrace_hdl_t *, dtrace_prog_t *,", "    dtrace_proginfo_t *);", "", "#define\tDTRACE_D_STRIP\t0x01\t/* strip non-loadable sections from program */", "#define\tDTRACE_D_PROBES\t0x02\t/* include provider and probe definitions */", "#define\tDTRACE_D_MASK\t0x03\t/* mask of valid flags to dtrace_dof_create */", "", "extern int dtrace_program_link(dtrace_hdl_t *, dtrace_prog_t *,", "    uint_t, const char *, int, char *const []);", "", "extern int dtrace_program_header(dtrace_hdl_t *, FILE *, const char *);", "", "extern void *dtrace_dof_create(dtrace_hdl_t *, dtrace_prog_t *, uint_t);", "extern void dtrace_dof_destroy(dtrace_hdl_t *, void *);", "", "extern void *dtrace_getopt_dof(dtrace_hdl_t *);", "extern void *dtrace_geterr_dof(dtrace_hdl_t *);", "", "typedef struct dtrace_stmtdesc {", "\tdtrace_ecbdesc_t *dtsd_ecbdesc;\t\t/* ECB description */", "\tdtrace_actdesc_t *dtsd_action;\t\t/* action list */", "\tdtrace_actdesc_t *dtsd_action_last;\t/* last action in action list */", "\tvoid *dtsd_aggdata;\t\t\t/* aggregation data */", "\tvoid *dtsd_fmtdata;\t\t\t/* type-specific output data */", "\tvoid (*dtsd_callback)();\t\t/* callback function for EPID */", "\tvoid *dtsd_data;\t\t\t/* callback data pointer */", "\tdtrace_attribute_t dtsd_descattr;\t/* probedesc attributes */", "\tdtrace_attribute_t dtsd_stmtattr;\t/* statement attributes */", "} dtrace_stmtdesc_t;", "", "typedef int dtrace_stmt_f(dtrace_hdl_t *, dtrace_prog_t *,", "    dtrace_stmtdesc_t *, void *);", "", "extern dtrace_stmtdesc_t *dtrace_stmt_create(dtrace_hdl_t *,", "    dtrace_ecbdesc_t *);", "extern dtrace_actdesc_t *dtrace_stmt_action(dtrace_hdl_t *,", "    dtrace_stmtdesc_t *);", "extern int dtrace_stmt_add(dtrace_hdl_t *, dtrace_prog_t *,", "    dtrace_stmtdesc_t *);", "extern int dtrace_stmt_iter(dtrace_hdl_t *, dtrace_prog_t *,", "    dtrace_stmt_f *, void *);", "extern void dtrace_stmt_destroy(dtrace_hdl_t *, dtrace_stmtdesc_t *);", "", "/*", " * DTrace Data Consumption Interface", " */", "typedef enum {", "\tDTRACEFLOW_ENTRY,", "\tDTRACEFLOW_RETURN,", "\tDTRACEFLOW_NONE", "} dtrace_flowkind_t;", "", "#define\tDTRACE_CONSUME_ERROR\t\t-1\t/* error while processing */", "#define\tDTRACE_CONSUME_THIS\t\t0\t/* consume this probe/record */", "#define\tDTRACE_CONSUME_NEXT\t\t1\t/* advance to next probe/rec */", "#define\tDTRACE_CONSUME_ABORT\t\t2\t/* abort consumption */", "", "typedef struct dtrace_probedata {", "\tdtrace_hdl_t *dtpda_handle;\t\t/* handle to DTrace library */", "\tdtrace_eprobedesc_t *dtpda_edesc;\t/* enabled probe description */", "\tdtrace_probedesc_t *dtpda_pdesc;\t/* probe description */", "\tprocessorid_t dtpda_cpu;\t\t/* CPU for data */", "\tcaddr_t dtpda_data;\t\t\t/* pointer to raw data */", "\tdtrace_flowkind_t dtpda_flow;\t\t/* flow kind */", "\tconst char *dtpda_prefix;\t\t/* recommended flow prefix */", "\tint dtpda_indent;\t\t\t/* recommended flow indent */", "} dtrace_probedata_t;", "", "typedef int dtrace_consume_probe_f(const dtrace_probedata_t *, void *);", "typedef int dtrace_consume_rec_f(const dtrace_probedata_t *,", "    const dtrace_recdesc_t *, void *);", "", "extern int dtrace_consume(dtrace_hdl_t *, FILE *,", "    dtrace_consume_probe_f *, dtrace_consume_rec_f *, void *);", "", "#define\tDTRACE_STATUS_NONE\t0\t/* no status; not yet time */", "#define\tDTRACE_STATUS_OKAY\t1\t/* status okay */", "#define\tDTRACE_STATUS_EXITED\t2\t/* exit() was called; tracing stopped */", "#define\tDTRACE_STATUS_FILLED\t3\t/* fill buffer filled; tracing stoped */", "#define\tDTRACE_STATUS_STOPPED\t4\t/* tracing already stopped */", "", "extern int dtrace_status(dtrace_hdl_t *);", "", "/*", " * DTrace Formatted Output Interfaces", " *", " * To format output associated with a given dtrace_stmtdesc, the caller can", " * invoke one of the following functions, passing the opaque dtsd_fmtdata and a", " * list of record descriptions.  These functions return either -1 to indicate", " * an error, or a positive integer indicating the number of records consumed.", " * For anonymous enablings, the consumer can use the dtrd_format member of", " * the record description to obtain a format description.  The dtfd_string", " * member of the format description may be passed to dtrace_print{fa}_create()", " * to create the opaque format data.", " */", "extern void *dtrace_printf_create(dtrace_hdl_t *, const char *);", "extern void *dtrace_printa_create(dtrace_hdl_t *, const char *);", "extern size_t dtrace_printf_format(dtrace_hdl_t *, void *, char *, size_t);", "", "extern int dtrace_fprintf(dtrace_hdl_t *, FILE *, void *,", "    const dtrace_probedata_t *, const dtrace_recdesc_t *, uint_t,", "    const void *, size_t);", "", "extern int dtrace_fprinta(dtrace_hdl_t *, FILE *, void *,", "    const dtrace_probedata_t *, const dtrace_recdesc_t *, uint_t,", "    const void *, size_t);", "", "extern int dtrace_system(dtrace_hdl_t *, FILE *, void *,", "    const dtrace_probedata_t *, const dtrace_recdesc_t *, uint_t,", "    const void *, size_t);", "", "extern int dtrace_freopen(dtrace_hdl_t *, FILE *, void *,", "    const dtrace_probedata_t *, const dtrace_recdesc_t *, uint_t,", "    const void *, size_t);", "", "/*", " * DTrace Work Interface", " */", "typedef enum {", "\tDTRACE_WORKSTATUS_ERROR = -1,", "\tDTRACE_WORKSTATUS_OKAY,", "\tDTRACE_WORKSTATUS_DONE", "} dtrace_workstatus_t;", "", "extern dtrace_workstatus_t dtrace_work(dtrace_hdl_t *, FILE *,", "    dtrace_consume_probe_f *, dtrace_consume_rec_f *, void *);", "", "/*", " * DTrace Handler Interface", " */", "#define\tDTRACE_HANDLE_ABORT\t\t-1\t/* abort current operation */", "#define\tDTRACE_HANDLE_OK\t\t0\t/* handled okay; continue */", "", "typedef struct dtrace_errdata {", "\tdtrace_hdl_t *dteda_handle;\t\t/* handle to DTrace library */", "\tdtrace_eprobedesc_t *dteda_edesc;\t/* enabled probe inducing err */", "\tdtrace_probedesc_t *dteda_pdesc;\t/* probe inducing error */", "\tprocessorid_t dteda_cpu;\t\t/* CPU of error */", "\tint dteda_action;\t\t\t/* action inducing error */", "\tint dteda_offset;\t\t\t/* offset in DIFO of error */", "\tint dteda_fault;\t\t\t/* specific fault */", "\tuint64_t dteda_addr;\t\t\t/* address of fault, if any */", "\tconst char *dteda_msg;\t\t\t/* preconstructed message */", "} dtrace_errdata_t;", "", "typedef int dtrace_handle_err_f(const dtrace_errdata_t *, void *);", "extern int dtrace_handle_err(dtrace_hdl_t *, dtrace_handle_err_f *, void *);", "", "typedef enum {", "\tDTRACEDROP_PRINCIPAL,\t\t\t/* drop to principal buffer */", "\tDTRACEDROP_AGGREGATION,\t\t\t/* drop to aggregation buffer */", "\tDTRACEDROP_DYNAMIC,\t\t\t/* dynamic drop */", "\tDTRACEDROP_DYNRINSE,\t\t\t/* dyn drop due to rinsing */", "\tDTRACEDROP_DYNDIRTY,\t\t\t/* dyn drop due to dirty */", "\tDTRACEDROP_SPEC,\t\t\t/* speculative drop */", "\tDTRACEDROP_SPECBUSY,\t\t\t/* spec drop due to busy */", "\tDTRACEDROP_SPECUNAVAIL,\t\t\t/* spec drop due to unavail */", "\tDTRACEDROP_STKSTROVERFLOW,\t\t/* stack string tab overflow */", "\tDTRACEDROP_DBLERROR\t\t\t/* error in ERROR probe */", "} dtrace_dropkind_t;", "", "typedef struct dtrace_dropdata {", "\tdtrace_hdl_t *dtdda_handle;\t\t/* handle to DTrace library */", "\tprocessorid_t dtdda_cpu;\t\t/* CPU, if any */", "\tdtrace_dropkind_t dtdda_kind;\t\t/* kind of drop */", "\tuint64_t dtdda_drops;\t\t\t/* number of drops */", "\tuint64_t dtdda_total;\t\t\t/* total drops */", "\tconst char *dtdda_msg;\t\t\t/* preconstructed message */", "} dtrace_dropdata_t;", "", "typedef int dtrace_handle_drop_f(const dtrace_dropdata_t *, void *);", "extern int dtrace_handle_drop(dtrace_hdl_t *, dtrace_handle_drop_f *, void *);", "", "typedef void dtrace_handle_proc_f(struct ps_prochandle *, const char *, void *);", "extern int dtrace_handle_proc(dtrace_hdl_t *, dtrace_handle_proc_f *, void *);", "", "#define\tDTRACE_BUFDATA_AGGKEY\t\t0x0001\t/* aggregation key */", "#define\tDTRACE_BUFDATA_AGGVAL\t\t0x0002\t/* aggregation value */", "#define\tDTRACE_BUFDATA_AGGFORMAT\t0x0004\t/* aggregation format data */", "#define\tDTRACE_BUFDATA_AGGLAST\t\t0x0008\t/* last for this key/val */", "", "typedef struct dtrace_bufdata {", "\tdtrace_hdl_t *dtbda_handle;\t\t/* handle to DTrace library */", "\tconst char *dtbda_buffered;\t\t/* buffered output */", "\tdtrace_probedata_t *dtbda_probe;\t/* probe data */", "\tconst dtrace_recdesc_t *dtbda_recdesc;\t/* record description */", "\tconst dtrace_aggdata_t *dtbda_aggdata;\t/* aggregation data, if agg. */", "\tuint32_t dtbda_flags;\t\t\t/* flags; see above */", "} dtrace_bufdata_t;", "", "typedef int dtrace_handle_buffered_f(const dtrace_bufdata_t *, void *);", "extern int dtrace_handle_buffered(dtrace_hdl_t *,", "    dtrace_handle_buffered_f *, void *);", "", "typedef struct dtrace_setoptdata {", "\tdtrace_hdl_t *dtsda_handle;\t\t/* handle to DTrace library */", "\tconst dtrace_probedata_t *dtsda_probe;\t/* probe data */", "\tconst char *dtsda_option;\t\t/* option that was set */", "\tdtrace_optval_t dtsda_oldval;\t\t/* old value */", "\tdtrace_optval_t dtsda_newval;\t\t/* new value */", "} dtrace_setoptdata_t;", "", "typedef int dtrace_handle_setopt_f(const dtrace_setoptdata_t *, void *);", "extern int dtrace_handle_setopt(dtrace_hdl_t *,", "    dtrace_handle_setopt_f *, void *);", "", "/*", " * DTrace Aggregate Interface", " */", "", "#define\tDTRACE_A_PERCPU\t\t0x0001", "#define\tDTRACE_A_KEEPDELTA\t0x0002", "#define\tDTRACE_A_ANONYMOUS\t0x0004", "", "#define\tDTRACE_AGGWALK_ERROR\t\t-1\t/* error while processing */", "#define\tDTRACE_AGGWALK_NEXT\t\t0\t/* proceed to next element */", "#define\tDTRACE_AGGWALK_ABORT\t\t1\t/* abort aggregation walk */", "#define\tDTRACE_AGGWALK_CLEAR\t\t2\t/* clear this element */", "#define\tDTRACE_AGGWALK_NORMALIZE\t3\t/* normalize this element */", "#define\tDTRACE_AGGWALK_DENORMALIZE\t4\t/* denormalize this element */", "#define\tDTRACE_AGGWALK_REMOVE\t\t5\t/* remove this element */", "", "struct dtrace_aggdata {", "\tdtrace_hdl_t *dtada_handle;\t\t/* handle to DTrace library */", "\tdtrace_aggdesc_t *dtada_desc;\t\t/* aggregation description */", "\tdtrace_eprobedesc_t *dtada_edesc;\t/* enabled probe description */", "\tdtrace_probedesc_t *dtada_pdesc;\t/* probe description */", "\tcaddr_t dtada_data;\t\t\t/* pointer to raw data */", "\tuint64_t dtada_normal;\t\t\t/* the normal -- 1 for denorm */", "\tsize_t dtada_size;\t\t\t/* total size of the data */", "\tcaddr_t dtada_delta;\t\t\t/* delta data, if available */", "\tcaddr_t *dtada_percpu;\t\t\t/* per CPU data, if avail */", "\tcaddr_t *dtada_percpu_delta;\t\t/* per CPU delta, if avail */", "};", "", "typedef int dtrace_aggregate_f(const dtrace_aggdata_t *, void *);", "typedef int dtrace_aggregate_walk_f(dtrace_hdl_t *,", "    dtrace_aggregate_f *, void *);", "typedef int dtrace_aggregate_walk_joined_f(const dtrace_aggdata_t **,", "    const int, void *);", "", "extern void dtrace_aggregate_clear(dtrace_hdl_t *);", "extern int dtrace_aggregate_snap(dtrace_hdl_t *);", "extern int dtrace_aggregate_print(dtrace_hdl_t *, FILE *,", "    dtrace_aggregate_walk_f *);", "", "extern int dtrace_aggregate_walk(dtrace_hdl_t *, dtrace_aggregate_f *, void *);", "", "extern int dtrace_aggregate_walk_joined(dtrace_hdl_t *,", "    dtrace_aggvarid_t *, int, dtrace_aggregate_walk_joined_f *, void *);", "", "extern int dtrace_aggregate_walk_sorted(dtrace_hdl_t *,", "    dtrace_aggregate_f *, void *);", "", "extern int dtrace_aggregate_walk_keysorted(dtrace_hdl_t *,", "    dtrace_aggregate_f *, void *);", "", "extern int dtrace_aggregate_walk_valsorted(dtrace_hdl_t *,", "    dtrace_aggregate_f *, void *);", "", "extern int dtrace_aggregate_walk_keyvarsorted(dtrace_hdl_t *,", "    dtrace_aggregate_f *, void *);", "", "extern int dtrace_aggregate_walk_valvarsorted(dtrace_hdl_t *,", "    dtrace_aggregate_f *, void *);", "", "extern int dtrace_aggregate_walk_keyrevsorted(dtrace_hdl_t *,", "    dtrace_aggregate_f *, void *);", "", "extern int dtrace_aggregate_walk_valrevsorted(dtrace_hdl_t *,", "    dtrace_aggregate_f *, void *);", "", "extern int dtrace_aggregate_walk_keyvarrevsorted(dtrace_hdl_t *,", "    dtrace_aggregate_f *, void *);", "", "extern int dtrace_aggregate_walk_valvarrevsorted(dtrace_hdl_t *,", "    dtrace_aggregate_f *, void *);", "", "#define\tDTRACE_AGD_PRINTED\t0x1\t/* aggregation printed in program */", "", "/*", " * DTrace Process Control Interface", " *", " * Library clients who wish to have libdtrace create or grab processes for", " * monitoring of their symbol table changes may use these interfaces to", " * request that libdtrace obtain control of the process using libproc.", " */", "", "extern struct ps_prochandle *dtrace_proc_create(dtrace_hdl_t *,", "    const char *, char *const *);", "", "extern struct ps_prochandle *dtrace_proc_grab(dtrace_hdl_t *, pid_t, int);", "extern void dtrace_proc_release(dtrace_hdl_t *, struct ps_prochandle *);", "extern void dtrace_proc_continue(dtrace_hdl_t *, struct ps_prochandle *);", "", "/*", " * DTrace Object, Symbol, and Type Interfaces", " *", " * Library clients can use libdtrace to perform symbol and C type information", " * lookups by symbol name, symbol address, or C type name, or to lookup meta-", " * information cached for each of the program objects in use by DTrace.  The", " * resulting struct contain pointers to arbitrary-length strings, including", " * object, symbol, and type names, that are persistent until the next call to", " * dtrace_update().  Once dtrace_update() is called, any cached values must", " * be flushed and not used subsequently by the client program.", " */", "", "#define\tDTRACE_OBJ_EXEC\t ((const char *)0L)\t/* primary executable file */", "#define\tDTRACE_OBJ_RTLD\t ((const char *)1L)\t/* run-time link-editor */", "#define\tDTRACE_OBJ_CDEFS ((const char *)2L)\t/* C include definitions */", "#define\tDTRACE_OBJ_DDEFS ((const char *)3L)\t/* D program definitions */", "#define\tDTRACE_OBJ_EVERY ((const char *)-1L)\t/* all known objects */", "#define\tDTRACE_OBJ_KMODS ((const char *)-2L)\t/* all kernel objects */", "#define\tDTRACE_OBJ_UMODS ((const char *)-3L)\t/* all user objects */", "", "typedef struct dtrace_objinfo {", "\tconst char *dto_name;\t\t\t/* object file scope name */", "\tconst char *dto_file;\t\t\t/* object file path (if any) */", "\tint dto_id;\t\t\t\t/* object file id (if any) */", "\tuint_t dto_flags;\t\t\t/* object flags (see below) */", "\tGElf_Addr dto_text_va;\t\t\t/* address of text section */", "\tGElf_Xword dto_text_size;\t\t/* size of text section */", "\tGElf_Addr dto_data_va;\t\t\t/* address of data section */", "\tGElf_Xword dto_data_size;\t\t/* size of data section */", "\tGElf_Addr dto_bss_va;\t\t\t/* address of BSS */", "\tGElf_Xword dto_bss_size;\t\t/* size of BSS */", "} dtrace_objinfo_t;", "", "#define\tDTRACE_OBJ_F_KERNEL\t0x1\t\t/* object is a kernel module */", "#define\tDTRACE_OBJ_F_PRIMARY\t0x2\t\t/* object is a primary module */", "", "typedef int dtrace_obj_f(dtrace_hdl_t *, const dtrace_objinfo_t *, void *);", "", "extern int dtrace_object_iter(dtrace_hdl_t *, dtrace_obj_f *, void *);", "extern int dtrace_object_info(dtrace_hdl_t *, const char *, dtrace_objinfo_t *);", "", "typedef struct dtrace_syminfo {", "\tconst char *dts_object;\t\t\t/* object name */", "\tconst char *dts_name;\t\t\t/* symbol name */", "\tulong_t dts_id;\t\t\t\t/* symbol id */", "} dtrace_syminfo_t;", "", "extern int dtrace_lookup_by_name(dtrace_hdl_t *, const char *, const char *,", "    GElf_Sym *, dtrace_syminfo_t *);", "", "#if !defined (__APPLE__)", "extern int dtrace_lookup_by_addr(dtrace_hdl_t *, GElf_Addr addr,", "    GElf_Sym *, dtrace_syminfo_t *);", "#else", "extern int dtrace_lookup_by_addr(dtrace_hdl_t *dtp,", "                                 GElf_Addr addr, ", "                                 char *aux_sym_name_buffer,\t/* auxilary storage buffer for the symbol name */", "                                 size_t aux_bufsize,\t\t/* size of sym_name_buffer */", "                                 GElf_Sym *symp,", "                                 dtrace_syminfo_t *sip);", "#endif", "        ", "typedef struct dtrace_typeinfo {", "\tconst char *dtt_object;\t\t\t/* object containing type */", "\tctf_file_t *dtt_ctfp;\t\t\t/* CTF container handle */", "\tctf_id_t dtt_type;\t\t\t/* CTF type identifier */", "} dtrace_typeinfo_t;", "", "extern int dtrace_lookup_by_type(dtrace_hdl_t *, const char *, const char *,", "    dtrace_typeinfo_t *);", "", "extern int dtrace_symbol_type(dtrace_hdl_t *, const GElf_Sym *,", "    const dtrace_syminfo_t *, dtrace_typeinfo_t *);", "", "extern int dtrace_type_strcompile(dtrace_hdl_t *,", "    const char *, dtrace_typeinfo_t *);", "", "extern int dtrace_type_fcompile(dtrace_hdl_t *,", "    FILE *, dtrace_typeinfo_t *);", "", "/*", " * DTrace Probe Interface", " *", " * Library clients can use these functions to iterate over the set of available", " * probe definitions and inquire as to their attributes.  The probe iteration", " * interfaces report probes that are declared as well as those from dtrace(7D).", " */", "typedef struct dtrace_probeinfo {", "\tdtrace_attribute_t dtp_attr;\t\t/* name attributes */", "\tdtrace_attribute_t dtp_arga;\t\t/* arg attributes */", "\tconst dtrace_typeinfo_t *dtp_argv;\t/* arg types */", "\tint dtp_argc;\t\t\t\t/* arg count */", "} dtrace_probeinfo_t;", "", "typedef int dtrace_probe_f(dtrace_hdl_t *, const dtrace_probedesc_t *, void *);", "", "extern int dtrace_probe_iter(dtrace_hdl_t *,", "    const dtrace_probedesc_t *pdp, dtrace_probe_f *, void *);", "", "extern int dtrace_probe_info(dtrace_hdl_t *,", "    const dtrace_probedesc_t *, dtrace_probeinfo_t *);", "", "/*", " * DTrace Vector Interface", " *", " * The DTrace library normally speaks directly to dtrace(7D).  However,", " * this communication may be vectored elsewhere.  Consumers who wish to", " * perform a vectored open must fill in the vector, and use the dtrace_vopen()", " * entry point to obtain a library handle.", " */", "struct dtrace_vector {", "\tint (*dtv_ioctl)(void *, int, void *);", "\tint (*dtv_lookup_by_addr)(void *, GElf_Addr, GElf_Sym *,", "\t    dtrace_syminfo_t *);", "\tint (*dtv_status)(void *, processorid_t);", "\tlong (*dtv_sysconf)(void *, int);", "};", "", "/*", " * DTrace Utility Functions", " *", " * Library clients can use these functions to convert addresses strings, to", " * convert between string and integer probe descriptions and the", " * dtrace_probedesc_t representation, and to perform similar conversions on", " * stability attributes.", " */", "extern int dtrace_addr2str(dtrace_hdl_t *, uint64_t, char *, int);", "extern int dtrace_uaddr2str(dtrace_hdl_t *, pid_t, uint64_t, char *, int);", "", "extern int dtrace_xstr2desc(dtrace_hdl_t *, dtrace_probespec_t,", "    const char *, int, char *const [], dtrace_probedesc_t *);", "", "extern int dtrace_str2desc(dtrace_hdl_t *, dtrace_probespec_t,", "    const char *, dtrace_probedesc_t *);", "", "extern int dtrace_id2desc(dtrace_hdl_t *, dtrace_id_t, dtrace_probedesc_t *);", "", "#define\tDTRACE_DESC2STR_MAX\t1024\t/* min buf size for dtrace_desc2str() */", "", "extern char *dtrace_desc2str(const dtrace_probedesc_t *, char *, size_t);", "", "#define\tDTRACE_ATTR2STR_MAX\t64\t/* min buf size for dtrace_attr2str() */", "", "extern char *dtrace_attr2str(dtrace_attribute_t, char *, size_t);", "extern int dtrace_str2attr(const char *, dtrace_attribute_t *);", "", "extern const char *dtrace_stability_name(dtrace_stability_t);", "extern const char *dtrace_class_name(dtrace_class_t);", "", "extern int dtrace_provider_modules(dtrace_hdl_t *, const char **, int);", "", "extern const char *const _dtrace_version;", "extern int _dtrace_debug;", "#if defined(__APPLE__)", "extern int _dtrace_scanalzyer;", "extern int _dtrace_mangled;", "#endif /* __APPLE__ */", "\t", "#ifdef\t__cplusplus", "}", "#endif", "", "#if defined(__APPLE__)", "#undef GElf_Addr", "#undef GElf_Xword", "#undef GElf_Sxword", "#undef GElf_Half", "#undef GElf_Word", "#undef GElf_Sym", "#endif /* __APPLE__ */", "", "#endif\t/* _DTRACE_H */" },
    ["err.h"] = { "/*", " * Copyright (c) 2000, 2003, 2004, 2008 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/*-", " * Copyright (c) 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)err.h\t8.1 (Berkeley) 6/2/93", " */", "", "#ifndef _ERR_H_", "#define\t_ERR_H_", "", "/*", " * Don't use va_list in the err/warn prototypes.   Va_list is typedef'd in two", " * places (<machine/varargs.h> and <machine/stdarg.h>), so if we include one", " * of them here we may collide with the utility's includes.  It's unreasonable", " * for utilities to have to include one of them to include err.h, so we get", " * __darwin_va_list from <machine/_type.h> and use it.", " */", "#include <sys/cdefs.h>", "#include <_types.h>", "#include <Availability.h>", "", "__BEGIN_DECLS", "void\terr(int, const char *, ...) __dead2 __printflike(2, 3);", "void\tverr(int, const char *, __darwin_va_list) __dead2 __printflike(2, 0);", "void\terrc(int, int, const char *, ...) __dead2 __printflike(3, 4);", "void\tverrc(int, int, const char *, __darwin_va_list) __dead2 __printflike(3, 0);", "void\terrx(int, const char *, ...) __dead2 __printflike(2, 3);", "void\tverrx(int, const char *, __darwin_va_list) __dead2 __printflike(2, 0);", "void\twarn(const char *, ...) __printflike(1, 2);", "void\tvwarn(const char *, __darwin_va_list) __printflike(1, 0);", "void\twarnc(int, const char *, ...) __printflike(2, 3);", "void\tvwarnc(int, const char *, __darwin_va_list) __printflike(2, 0);", "void\twarnx(const char *, ...) __printflike(1, 2);", "void\tvwarnx(const char *, __darwin_va_list) __printflike(1, 0);", "void\terr_set_file(void *);", "void\terr_set_exit(void (*)(int));", "#ifdef __BLOCKS__", "void\terr_set_exit_b(void (^)(int)) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);", "#endif /* __BLOCKS__ */", "", "__END_DECLS", "", "#endif /* !_ERR_H_ */" },
    ["errno.h"] = { "/*", " * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "#include <sys/errno.h>", "" },
    ["eti.h"] = { "/****************************************************************************", " * Copyright (c) 1998-2002,2003 Free Software Foundation, Inc.              *", " *                                                                          *", " * Permission is hereby granted, free of charge, to any person obtaining a  *", " * copy of this software and associated documentation files (the            *", ' * "Software"), to deal in the Software without restriction, including      *', " * without limitation the rights to use, copy, modify, merge, publish,      *", " * distribute, distribute with modifications, sublicense, and/or sell       *", " * copies of the Software, and to permit persons to whom the Software is    *", " * furnished to do so, subject to the following conditions:                 *", " *                                                                          *", " * The above copyright notice and this permission notice shall be included  *", " * in all copies or substantial portions of the Software.                   *", " *                                                                          *", ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *', " * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *", " * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *", " * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *", " * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *", " * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *", " * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *", " *                                                                          *", " * Except as contained in this notice, the name(s) of the above copyright   *", " * holders shall not be used in advertising or otherwise to promote the     *", " * sale, use or other dealings in this Software without prior written       *", " * authorization.                                                           *", " ****************************************************************************/", "", "/****************************************************************************", " *   Author:  Juergen Pfeifer, 1995,1997                                    *", " ****************************************************************************/", "", "/* $Id: eti.h,v 1.8 2003/10/25 15:24:29 tom Exp $ */", "", "#ifndef NCURSES_ETI_H_incl", "#define NCURSES_ETI_H_incl 1", "", "#define\tE_OK\t\t\t(0)", "#define\tE_SYSTEM_ERROR\t \t(-1)", "#define\tE_BAD_ARGUMENT\t \t(-2)", "#define\tE_POSTED\t \t(-3)", "#define\tE_CONNECTED\t \t(-4)", "#define\tE_BAD_STATE\t \t(-5)", "#define\tE_NO_ROOM\t \t(-6)", "#define\tE_NOT_POSTED\t\t(-7)", "#define\tE_UNKNOWN_COMMAND\t(-8)", "#define\tE_NO_MATCH\t\t(-9)", "#define\tE_NOT_SELECTABLE\t(-10)", "#define\tE_NOT_CONNECTED\t        (-11)", "#define\tE_REQUEST_DENIED\t(-12)", "#define\tE_INVALID_FIELD\t        (-13)", "#define\tE_CURRENT\t\t(-14)", "", "#endif" },
    ["execinfo.h"] = { "/*", " * Copyright (c) 2007 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "#ifndef _EXECINFO_H_", "#define _EXECINFO_H_ 1", "", "#include <sys/cdefs.h>", "#include <Availability.h>", "", "__BEGIN_DECLS", "", "int backtrace(void**,int) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "char** backtrace_symbols(void* const*,int) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "void backtrace_symbols_fd(void* const*,int,int) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "", "__END_DECLS", "", "#endif /* !_EXECINFO_H_ */" },
    ["expat.h"] = { "/* Copyright (c) 1998, 1999, 2000 Thai Open Source Software Center Ltd", "   See the file COPYING for copying permission.", "*/", "", "#ifndef Expat_INCLUDED", "#define Expat_INCLUDED 1", "", "#ifdef __VMS", "/*      0        1         2         3      0        1         2         3", "        1234567890123456789012345678901     1234567890123456789012345678901 */", "#define XML_SetProcessingInstructionHandler XML_SetProcessingInstrHandler", "#define XML_SetUnparsedEntityDeclHandler    XML_SetUnparsedEntDeclHandler", "#define XML_SetStartNamespaceDeclHandler    XML_SetStartNamespcDeclHandler", "#define XML_SetExternalEntityRefHandlerArg  XML_SetExternalEntRefHandlerArg", "#endif", "", "#include <stdlib.h>", '#include "expat_external.h"', "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "", "struct XML_ParserStruct;", "typedef struct XML_ParserStruct *XML_Parser;", "", "/* Should this be defined using stdbool.h when C99 is available? */", "typedef unsigned char XML_Bool;", "#define XML_TRUE   ((XML_Bool) 1)", "#define XML_FALSE  ((XML_Bool) 0)", "", "/* The XML_Status enum gives the possible return values for several", "   API functions.  The preprocessor #defines are included so this", "   stanza can be added to code that still needs to support older", "   versions of Expat 1.95.x:", "", "   #ifndef XML_STATUS_OK", "   #define XML_STATUS_OK    1", "   #define XML_STATUS_ERROR 0", "   #endif", "", "   Otherwise, the #define hackery is quite ugly and would have been", "   dropped.", "*/", "enum XML_Status {", "  XML_STATUS_ERROR = 0,", "#define XML_STATUS_ERROR XML_STATUS_ERROR", "  XML_STATUS_OK = 1,", "#define XML_STATUS_OK XML_STATUS_OK", "  XML_STATUS_SUSPENDED = 2", "#define XML_STATUS_SUSPENDED XML_STATUS_SUSPENDED", "};", "", "enum XML_Error {", "  XML_ERROR_NONE,", "  XML_ERROR_NO_MEMORY,", "  XML_ERROR_SYNTAX,", "  XML_ERROR_NO_ELEMENTS,", "  XML_ERROR_INVALID_TOKEN,", "  XML_ERROR_UNCLOSED_TOKEN,", "  XML_ERROR_PARTIAL_CHAR,", "  XML_ERROR_TAG_MISMATCH,", "  XML_ERROR_DUPLICATE_ATTRIBUTE,", "  XML_ERROR_JUNK_AFTER_DOC_ELEMENT,", "  XML_ERROR_PARAM_ENTITY_REF,", "  XML_ERROR_UNDEFINED_ENTITY,", "  XML_ERROR_RECURSIVE_ENTITY_REF,", "  XML_ERROR_ASYNC_ENTITY,", "  XML_ERROR_BAD_CHAR_REF,", "  XML_ERROR_BINARY_ENTITY_REF,", "  XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF,", "  XML_ERROR_MISPLACED_XML_PI,", "  XML_ERROR_UNKNOWN_ENCODING,", "  XML_ERROR_INCORRECT_ENCODING,", "  XML_ERROR_UNCLOSED_CDATA_SECTION,", "  XML_ERROR_EXTERNAL_ENTITY_HANDLING,", "  XML_ERROR_NOT_STANDALONE,", "  XML_ERROR_UNEXPECTED_STATE,", "  XML_ERROR_ENTITY_DECLARED_IN_PE,", "  XML_ERROR_FEATURE_REQUIRES_XML_DTD,", "  XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING,", "  /* Added in 1.95.7. */", "  XML_ERROR_UNBOUND_PREFIX,", "  /* Added in 1.95.8. */", "  XML_ERROR_UNDECLARING_PREFIX,", "  XML_ERROR_INCOMPLETE_PE,", "  XML_ERROR_XML_DECL,", "  XML_ERROR_TEXT_DECL,", "  XML_ERROR_PUBLICID,", "  XML_ERROR_SUSPENDED,", "  XML_ERROR_NOT_SUSPENDED,", "  XML_ERROR_ABORTED,", "  XML_ERROR_FINISHED,", "  XML_ERROR_SUSPEND_PE,", "  /* Added in 2.0. */", "  XML_ERROR_RESERVED_PREFIX_XML,", "  XML_ERROR_RESERVED_PREFIX_XMLNS,", "  XML_ERROR_RESERVED_NAMESPACE_URI", "};", "", "enum XML_Content_Type {", "  XML_CTYPE_EMPTY = 1,", "  XML_CTYPE_ANY,", "  XML_CTYPE_MIXED,", "  XML_CTYPE_NAME,", "  XML_CTYPE_CHOICE,", "  XML_CTYPE_SEQ", "};", "", "enum XML_Content_Quant {", "  XML_CQUANT_NONE,", "  XML_CQUANT_OPT,", "  XML_CQUANT_REP,", "  XML_CQUANT_PLUS", "};", "", "/* If type == XML_CTYPE_EMPTY or XML_CTYPE_ANY, then quant will be", "   XML_CQUANT_NONE, and the other fields will be zero or NULL.", "   If type == XML_CTYPE_MIXED, then quant will be NONE or REP and", "   numchildren will contain number of elements that may be mixed in", "   and children point to an array of XML_Content cells that will be", "   all of XML_CTYPE_NAME type with no quantification.", "", "   If type == XML_CTYPE_NAME, then the name points to the name, and", "   the numchildren field will be zero and children will be NULL. The", "   quant fields indicates any quantifiers placed on the name.", "", "   CHOICE and SEQ will have name NULL, the number of children in", "   numchildren and children will point, recursively, to an array", "   of XML_Content cells.", "", "   The EMPTY, ANY, and MIXED types will only occur at top level.", "*/", "", "typedef struct XML_cp XML_Content;", "", "struct XML_cp {", "  enum XML_Content_Type         type;", "  enum XML_Content_Quant        quant;", "  XML_Char *                    name;", "  unsigned int                  numchildren;", "  XML_Content *                 children;", "};", "", "", "/* This is called for an element declaration. See above for", "   description of the model argument. It's the caller's responsibility", "   to free model when finished with it.", "*/", "typedef void (XMLCALL *XML_ElementDeclHandler) (void *userData,", "                                                const XML_Char *name,", "                                                XML_Content *model);", "", "XMLPARSEAPI(void)", "XML_SetElementDeclHandler(XML_Parser parser,", "                          XML_ElementDeclHandler eldecl);", "", "/* The Attlist declaration handler is called for *each* attribute. So", "   a single Attlist declaration with multiple attributes declared will", '   generate multiple calls to this handler. The "default" parameter', '   may be NULL in the case of the "#IMPLIED" or "#REQUIRED"', '   keyword. The "isrequired" parameter will be true and the default', '   value will be NULL in the case of "#REQUIRED". If "isrequired" is', '   true and default is non-NULL, then this is a "#FIXED" default.', "*/", "typedef void (XMLCALL *XML_AttlistDeclHandler) (", "                                    void            *userData,", "                                    const XML_Char  *elname,", "                                    const XML_Char  *attname,", "                                    const XML_Char  *att_type,", "                                    const XML_Char  *dflt,", "                                    int              isrequired);", "", "XMLPARSEAPI(void)", "XML_SetAttlistDeclHandler(XML_Parser parser,", "                          XML_AttlistDeclHandler attdecl);", "", "/* The XML declaration handler is called for *both* XML declarations", "   and text declarations. The way to distinguish is that the version", "   parameter will be NULL for text declarations. The encoding", "   parameter may be NULL for XML declarations. The standalone", "   parameter will be -1, 0, or 1 indicating respectively that there", "   was no standalone parameter in the declaration, that it was given", "   as no, or that it was given as yes.", "*/", "typedef void (XMLCALL *XML_XmlDeclHandler) (void           *userData,", "                                            const XML_Char *version,", "                                            const XML_Char *encoding,", "                                            int             standalone);", "", "XMLPARSEAPI(void)", "XML_SetXmlDeclHandler(XML_Parser parser,", "                      XML_XmlDeclHandler xmldecl);", "", "", "typedef struct {", "  void *(*malloc_fcn)(size_t size);", "  void *(*realloc_fcn)(void *ptr, size_t size);", "  void (*free_fcn)(void *ptr);", "} XML_Memory_Handling_Suite;", "", "/* Constructs a new parser; encoding is the encoding specified by the", "   external protocol or NULL if there is none specified.", "*/", "XMLPARSEAPI(XML_Parser)", "XML_ParserCreate(const XML_Char *encoding);", "", "/* Constructs a new parser and namespace processor.  Element type", "   names and attribute names that belong to a namespace will be", "   expanded; unprefixed attribute names are never expanded; unprefixed", "   element type names are expanded only if there is a default", "   namespace. The expanded name is the concatenation of the namespace", "   URI, the namespace separator character, and the local part of the", "   name.  If the namespace separator is '\\0' then the namespace URI", "   and the local part will be concatenated without any separator.", "   It is a programming error to use the separator '\\0' with namespace", "   triplets (see XML_SetReturnNSTriplet).", "*/", "XMLPARSEAPI(XML_Parser)", "XML_ParserCreateNS(const XML_Char *encoding, XML_Char namespaceSeparator);", "", "", "/* Constructs a new parser using the memory management suite referred to", "   by memsuite. If memsuite is NULL, then use the standard library memory", "   suite. If namespaceSeparator is non-NULL it creates a parser with", "   namespace processing as described above. The character pointed at", "   will serve as the namespace separator.", "", "   All further memory operations used for the created parser will come from", "   the given suite.", "*/", "XMLPARSEAPI(XML_Parser)", "XML_ParserCreate_MM(const XML_Char *encoding,", "                    const XML_Memory_Handling_Suite *memsuite,", "                    const XML_Char *namespaceSeparator);", "", "/* Prepare a parser object to be re-used.  This is particularly", "   valuable when memory allocation overhead is disproportionatly high,", "   such as when a large number of small documnents need to be parsed.", "   All handlers are cleared from the parser, except for the", "   unknownEncodingHandler. The parser's external state is re-initialized", "   except for the values of ns and ns_triplets.", "", "   Added in Expat 1.95.3.", "*/", "XMLPARSEAPI(XML_Bool)", "XML_ParserReset(XML_Parser parser, const XML_Char *encoding);", "", "/* atts is array of name/value pairs, terminated by 0;", "   names and values are 0 terminated.", "*/", "typedef void (XMLCALL *XML_StartElementHandler) (void *userData,", "                                                 const XML_Char *name,", "                                                 const XML_Char **atts);", "", "typedef void (XMLCALL *XML_EndElementHandler) (void *userData,", "                                               const XML_Char *name);", "", "", "/* s is not 0 terminated. */", "typedef void (XMLCALL *XML_CharacterDataHandler) (void *userData,", "                                                  const XML_Char *s,", "                                                  int len);", "", "/* target and data are 0 terminated */", "typedef void (XMLCALL *XML_ProcessingInstructionHandler) (", "                                                void *userData,", "                                                const XML_Char *target,", "                                                const XML_Char *data);", "", "/* data is 0 terminated */", "typedef void (XMLCALL *XML_CommentHandler) (void *userData,", "                                            const XML_Char *data);", "", "typedef void (XMLCALL *XML_StartCdataSectionHandler) (void *userData);", "typedef void (XMLCALL *XML_EndCdataSectionHandler) (void *userData);", "", "/* This is called for any characters in the XML document for which", "   there is no applicable handler.  This includes both characters that", "   are part of markup which is of a kind that is not reported", "   (comments, markup declarations), or characters that are part of a", "   construct which could be reported but for which no handler has been", "   supplied. The characters are passed exactly as they were in the XML", "   document except that they will be encoded in UTF-8 or UTF-16.", "   Line boundaries are not normalized. Note that a byte order mark", "   character is not passed to the default handler. There are no", "   guarantees about how characters are divided between calls to the", "   default handler: for example, a comment might be split between", "   multiple calls.", "*/", "typedef void (XMLCALL *XML_DefaultHandler) (void *userData,", "                                            const XML_Char *s,", "                                            int len);", "", "/* This is called for the start of the DOCTYPE declaration, before", "   any DTD or internal subset is parsed.", "*/", "typedef void (XMLCALL *XML_StartDoctypeDeclHandler) (", "                                            void *userData,", "                                            const XML_Char *doctypeName,", "                                            const XML_Char *sysid,", "                                            const XML_Char *pubid,", "                                            int has_internal_subset);", "", "/* This is called for the start of the DOCTYPE declaration when the", "   closing > is encountered, but after processing any external", "   subset.", "*/", "typedef void (XMLCALL *XML_EndDoctypeDeclHandler)(void *userData);", "", "/* This is called for entity declarations. The is_parameter_entity", "   argument will be non-zero if the entity is a parameter entity, zero", "   otherwise.", "", '   For internal entities (<!ENTITY foo "bar">), value will', "   be non-NULL and systemId, publicID, and notationName will be NULL.", "   The value string is NOT nul-terminated; the length is provided in", "   the value_length argument. Since it is legal to have zero-length", "   values, do not use this argument to test for internal entities.", "", "   For external entities, value will be NULL and systemId will be", "   non-NULL. The publicId argument will be NULL unless a public", "   identifier was provided. The notationName argument will have a", "   non-NULL value only for unparsed entity declarations.", "", "   Note that is_parameter_entity can't be changed to XML_Bool, since", "   that would break binary compatibility.", "*/", "typedef void (XMLCALL *XML_EntityDeclHandler) (", "                              void *userData,", "                              const XML_Char *entityName,", "                              int is_parameter_entity,", "                              const XML_Char *value,", "                              int value_length,", "                              const XML_Char *base,", "                              const XML_Char *systemId,", "                              const XML_Char *publicId,", "                              const XML_Char *notationName);", "", "XMLPARSEAPI(void)", "XML_SetEntityDeclHandler(XML_Parser parser,", "                         XML_EntityDeclHandler handler);", "", "/* OBSOLETE -- OBSOLETE -- OBSOLETE", "   This handler has been superceded by the EntityDeclHandler above.", "   It is provided here for backward compatibility.", "", "   This is called for a declaration of an unparsed (NDATA) entity.", "   The base argument is whatever was set by XML_SetBase. The", "   entityName, systemId and notationName arguments will never be", "   NULL. The other arguments may be.", "*/", "typedef void (XMLCALL *XML_UnparsedEntityDeclHandler) (", "                                    void *userData,", "                                    const XML_Char *entityName,", "                                    const XML_Char *base,", "                                    const XML_Char *systemId,", "                                    const XML_Char *publicId,", "                                    const XML_Char *notationName);", "", "/* This is called for a declaration of notation.  The base argument is", "   whatever was set by XML_SetBase. The notationName will never be", "   NULL.  The other arguments can be.", "*/", "typedef void (XMLCALL *XML_NotationDeclHandler) (", "                                    void *userData,", "                                    const XML_Char *notationName,", "                                    const XML_Char *base,", "                                    const XML_Char *systemId,", "                                    const XML_Char *publicId);", "", "/* When namespace processing is enabled, these are called once for", "   each namespace declaration. The call to the start and end element", "   handlers occur between the calls to the start and end namespace", "   declaration handlers. For an xmlns attribute, prefix will be", '   NULL.  For an xmlns="" attribute, uri will be NULL.', "*/", "typedef void (XMLCALL *XML_StartNamespaceDeclHandler) (", "                                    void *userData,", "                                    const XML_Char *prefix,", "                                    const XML_Char *uri);", "", "typedef void (XMLCALL *XML_EndNamespaceDeclHandler) (", "                                    void *userData,", "                                    const XML_Char *prefix);", "", "/* This is called if the document is not standalone, that is, it has an", "   external subset or a reference to a parameter entity, but does not", '   have standalone="yes". If this handler returns XML_STATUS_ERROR,', "   then processing will not continue, and the parser will return a", "   XML_ERROR_NOT_STANDALONE error.", "   If parameter entity parsing is enabled, then in addition to the", "   conditions above this handler will only be called if the referenced", "   entity was actually read.", "*/", "typedef int (XMLCALL *XML_NotStandaloneHandler) (void *userData);", "", "/* This is called for a reference to an external parsed general", "   entity.  The referenced entity is not automatically parsed.  The", "   application can parse it immediately or later using", "   XML_ExternalEntityParserCreate.", "", "   The parser argument is the parser parsing the entity containing the", "   reference; it can be passed as the parser argument to", "   XML_ExternalEntityParserCreate.  The systemId argument is the", "   system identifier as specified in the entity declaration; it will", "   not be NULL.", "", "   The base argument is the system identifier that should be used as", "   the base for resolving systemId if systemId was relative; this is", "   set by XML_SetBase; it may be NULL.", "", "   The publicId argument is the public identifier as specified in the", "   entity declaration, or NULL if none was specified; the whitespace", "   in the public identifier will have been normalized as required by", "   the XML spec.", "", "   The context argument specifies the parsing context in the format", "   expected by the context argument to XML_ExternalEntityParserCreate;", "   context is valid only until the handler returns, so if the", "   referenced entity is to be parsed later, it must be copied.", "   context is NULL only when the entity is a parameter entity.", "", "   The handler should return XML_STATUS_ERROR if processing should not", "   continue because of a fatal error in the handling of the external", "   entity.  In this case the calling parser will return an", "   XML_ERROR_EXTERNAL_ENTITY_HANDLING error.", "", "   Note that unlike other handlers the first argument is the parser,", "   not userData.", "*/", "typedef int (XMLCALL *XML_ExternalEntityRefHandler) (", "                                    XML_Parser parser,", "                                    const XML_Char *context,", "                                    const XML_Char *base,", "                                    const XML_Char *systemId,", "                                    const XML_Char *publicId);", "", "/* This is called in two situations:", "   1) An entity reference is encountered for which no declaration", "      has been read *and* this is not an error.", "   2) An internal entity reference is read, but not expanded, because", "      XML_SetDefaultHandler has been called.", "   Note: skipped parameter entities in declarations and skipped general", "         entities in attribute values cannot be reported, because", "         the event would be out of sync with the reporting of the", "         declarations or attribute values", "*/", "typedef void (XMLCALL *XML_SkippedEntityHandler) (", "                                    void *userData,", "                                    const XML_Char *entityName,", "                                    int is_parameter_entity);", "", "/* This structure is filled in by the XML_UnknownEncodingHandler to", "   provide information to the parser about encodings that are unknown", "   to the parser.", "", "   The map[b] member gives information about byte sequences whose", "   first byte is b.", "", "   If map[b] is c where c is >= 0, then b by itself encodes the", "   Unicode scalar value c.", "", "   If map[b] is -1, then the byte sequence is malformed.", "", "   If map[b] is -n, where n >= 2, then b is the first byte of an", "   n-byte sequence that encodes a single Unicode scalar value.", "", "   The data member will be passed as the first argument to the convert", "   function.", "", "   The convert function is used to convert multibyte sequences; s will", "   point to a n-byte sequence where map[(unsigned char)*s] == -n.  The", "   convert function must return the Unicode scalar value represented", "   by this byte sequence or -1 if the byte sequence is malformed.", "", "   The convert function may be NULL if the encoding is a single-byte", "   encoding, that is if map[b] >= -1 for all bytes b.", "", "   When the parser is finished with the encoding, then if release is", "   not NULL, it will call release passing it the data member; once", "   release has been called, the convert function will not be called", "   again.", "", "   Expat places certain restrictions on the encodings that are supported", "   using this mechanism.", "", "   1. Every ASCII character that can appear in a well-formed XML document,", "      other than the characters", "", "      $@\\^`{}~", "", "      must be represented by a single byte, and that byte must be the", "      same byte that represents that character in ASCII.", "", "   2. No character may require more than 4 bytes to encode.", "", "   3. All characters encoded must have Unicode scalar values <=", "      0xFFFF, (i.e., characters that would be encoded by surrogates in", "      UTF-16 are  not allowed).  Note that this restriction doesn't", "      apply to the built-in support for UTF-8 and UTF-16.", "", "   4. No Unicode character may be encoded by more than one distinct", "      sequence of bytes.", "*/", "typedef struct {", "  int map[256];", "  void *data;", "  int (XMLCALL *convert)(void *data, const char *s);", "  void (XMLCALL *release)(void *data);", "} XML_Encoding;", "", "/* This is called for an encoding that is unknown to the parser.", "", "   The encodingHandlerData argument is that which was passed as the", "   second argument to XML_SetUnknownEncodingHandler.", "", "   The name argument gives the name of the encoding as specified in", "   the encoding declaration.", "", "   If the callback can provide information about the encoding, it must", "   fill in the XML_Encoding structure, and return XML_STATUS_OK.", "   Otherwise it must return XML_STATUS_ERROR.", "", "   If info does not describe a suitable encoding, then the parser will", "   return an XML_UNKNOWN_ENCODING error.", "*/", "typedef int (XMLCALL *XML_UnknownEncodingHandler) (", "                                    void *encodingHandlerData,", "                                    const XML_Char *name,", "                                    XML_Encoding *info);", "", "XMLPARSEAPI(void)", "XML_SetElementHandler(XML_Parser parser,", "                      XML_StartElementHandler start,", "                      XML_EndElementHandler end);", "", "XMLPARSEAPI(void)", "XML_SetStartElementHandler(XML_Parser parser,", "                           XML_StartElementHandler handler);", "", "XMLPARSEAPI(void)", "XML_SetEndElementHandler(XML_Parser parser,", "                         XML_EndElementHandler handler);", "", "XMLPARSEAPI(void)", "XML_SetCharacterDataHandler(XML_Parser parser,", "                            XML_CharacterDataHandler handler);", "", "XMLPARSEAPI(void)", "XML_SetProcessingInstructionHandler(XML_Parser parser,", "                                    XML_ProcessingInstructionHandler handler);", "XMLPARSEAPI(void)", "XML_SetCommentHandler(XML_Parser parser,", "                      XML_CommentHandler handler);", "", "XMLPARSEAPI(void)", "XML_SetCdataSectionHandler(XML_Parser parser,", "                           XML_StartCdataSectionHandler start,", "                           XML_EndCdataSectionHandler end);", "", "XMLPARSEAPI(void)", "XML_SetStartCdataSectionHandler(XML_Parser parser,", "                                XML_StartCdataSectionHandler start);", "", "XMLPARSEAPI(void)", "XML_SetEndCdataSectionHandler(XML_Parser parser,", "                              XML_EndCdataSectionHandler end);", "", "/* This sets the default handler and also inhibits expansion of", "   internal entities. These entity references will be passed to the", "   default handler, or to the skipped entity handler, if one is set.", "*/", "XMLPARSEAPI(void)", "XML_SetDefaultHandler(XML_Parser parser,", "                      XML_DefaultHandler handler);", "", "/* This sets the default handler but does not inhibit expansion of", "   internal entities.  The entity reference will not be passed to the", "   default handler.", "*/", "XMLPARSEAPI(void)", "XML_SetDefaultHandlerExpand(XML_Parser parser,", "                            XML_DefaultHandler handler);", "", "XMLPARSEAPI(void)", "XML_SetDoctypeDeclHandler(XML_Parser parser,", "                          XML_StartDoctypeDeclHandler start,", "                          XML_EndDoctypeDeclHandler end);", "", "XMLPARSEAPI(void)", "XML_SetStartDoctypeDeclHandler(XML_Parser parser,", "                               XML_StartDoctypeDeclHandler start);", "", "XMLPARSEAPI(void)", "XML_SetEndDoctypeDeclHandler(XML_Parser parser,", "                             XML_EndDoctypeDeclHandler end);", "", "XMLPARSEAPI(void)", "XML_SetUnparsedEntityDeclHandler(XML_Parser parser,", "                                 XML_UnparsedEntityDeclHandler handler);", "", "XMLPARSEAPI(void)", "XML_SetNotationDeclHandler(XML_Parser parser,", "                           XML_NotationDeclHandler handler);", "", "XMLPARSEAPI(void)", "XML_SetNamespaceDeclHandler(XML_Parser parser,", "                            XML_StartNamespaceDeclHandler start,", "                            XML_EndNamespaceDeclHandler end);", "", "XMLPARSEAPI(void)", "XML_SetStartNamespaceDeclHandler(XML_Parser parser,", "                                 XML_StartNamespaceDeclHandler start);", "", "XMLPARSEAPI(void)", "XML_SetEndNamespaceDeclHandler(XML_Parser parser,", "                               XML_EndNamespaceDeclHandler end);", "", "XMLPARSEAPI(void)", "XML_SetNotStandaloneHandler(XML_Parser parser,", "                            XML_NotStandaloneHandler handler);", "", "XMLPARSEAPI(void)", "XML_SetExternalEntityRefHandler(XML_Parser parser,", "                                XML_ExternalEntityRefHandler handler);", "", "/* If a non-NULL value for arg is specified here, then it will be", "   passed as the first argument to the external entity ref handler", "   instead of the parser object.", "*/", "XMLPARSEAPI(void)", "XML_SetExternalEntityRefHandlerArg(XML_Parser parser,", "                                   void *arg);", "", "XMLPARSEAPI(void)", "XML_SetSkippedEntityHandler(XML_Parser parser,", "                            XML_SkippedEntityHandler handler);", "", "XMLPARSEAPI(void)", "XML_SetUnknownEncodingHandler(XML_Parser parser,", "                              XML_UnknownEncodingHandler handler,", "                              void *encodingHandlerData);", "", "/* This can be called within a handler for a start element, end", "   element, processing instruction or character data.  It causes the", "   corresponding markup to be passed to the default handler.", "*/", "XMLPARSEAPI(void)", "XML_DefaultCurrent(XML_Parser parser);", "", "/* If do_nst is non-zero, and namespace processing is in effect, and", "   a name has a prefix (i.e. an explicit namespace qualifier) then", "   that name is returned as a triplet in a single string separated by", "   the separator character specified when the parser was created: URI", "   + sep + local_name + sep + prefix.", "", "   If do_nst is zero, then namespace information is returned in the", "   default manner (URI + sep + local_name) whether or not the name", "   has a prefix.", "", "   Note: Calling XML_SetReturnNSTriplet after XML_Parse or", "     XML_ParseBuffer has no effect.", "*/", "", "XMLPARSEAPI(void)", "XML_SetReturnNSTriplet(XML_Parser parser, int do_nst);", "", "/* This value is passed as the userData argument to callbacks. */", "XMLPARSEAPI(void)", "XML_SetUserData(XML_Parser parser, void *userData);", "", "/* Returns the last value set by XML_SetUserData or NULL. */", "#define XML_GetUserData(parser) (*(void **)(parser))", "", "/* This is equivalent to supplying an encoding argument to", "   XML_ParserCreate. On success XML_SetEncoding returns non-zero,", "   zero otherwise.", "   Note: Calling XML_SetEncoding after XML_Parse or XML_ParseBuffer", "     has no effect and returns XML_STATUS_ERROR.", "*/", "XMLPARSEAPI(enum XML_Status)", "XML_SetEncoding(XML_Parser parser, const XML_Char *encoding);", "", "/* If this function is called, then the parser will be passed as the", "   first argument to callbacks instead of userData.  The userData will", "   still be accessible using XML_GetUserData.", "*/", "XMLPARSEAPI(void)", "XML_UseParserAsHandlerArg(XML_Parser parser);", "", "/* If useDTD == XML_TRUE is passed to this function, then the parser", "   will assume that there is an external subset, even if none is", "   specified in the document. In such a case the parser will call the", "   externalEntityRefHandler with a value of NULL for the systemId", "   argument (the publicId and context arguments will be NULL as well).", "   Note: For the purpose of checking WFC: Entity Declared, passing", "     useDTD == XML_TRUE will make the parser behave as if the document", "     had a DTD with an external subset.", "   Note: If this function is called, then this must be done before", "     the first call to XML_Parse or XML_ParseBuffer, since it will", "     have no effect after that.  Returns", "     XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING.", "   Note: If the document does not have a DOCTYPE declaration at all,", "     then startDoctypeDeclHandler and endDoctypeDeclHandler will not", "     be called, despite an external subset being parsed.", "   Note: If XML_DTD is not defined when Expat is compiled, returns", "     XML_ERROR_FEATURE_REQUIRES_XML_DTD.", "*/", "XMLPARSEAPI(enum XML_Error)", "XML_UseForeignDTD(XML_Parser parser, XML_Bool useDTD);", "", "", "/* Sets the base to be used for resolving relative URIs in system", "   identifiers in declarations.  Resolving relative identifiers is", "   left to the application: this value will be passed through as the", "   base argument to the XML_ExternalEntityRefHandler,", "   XML_NotationDeclHandler and XML_UnparsedEntityDeclHandler. The base", "   argument will be copied.  Returns XML_STATUS_ERROR if out of memory,", "   XML_STATUS_OK otherwise.", "*/", "XMLPARSEAPI(enum XML_Status)", "XML_SetBase(XML_Parser parser, const XML_Char *base);", "", "XMLPARSEAPI(const XML_Char *)", "XML_GetBase(XML_Parser parser);", "", "/* Returns the number of the attribute/value pairs passed in last call", "   to the XML_StartElementHandler that were specified in the start-tag", "   rather than defaulted. Each attribute/value pair counts as 2; thus", "   this correspondds to an index into the atts array passed to the", "   XML_StartElementHandler.", "*/", "XMLPARSEAPI(int)", "XML_GetSpecifiedAttributeCount(XML_Parser parser);", "", "/* Returns the index of the ID attribute passed in the last call to", "   XML_StartElementHandler, or -1 if there is no ID attribute.  Each", "   attribute/value pair counts as 2; thus this correspondds to an", "   index into the atts array passed to the XML_StartElementHandler.", "*/", "XMLPARSEAPI(int)", "XML_GetIdAttributeIndex(XML_Parser parser);", "", "/* Parses some input. Returns XML_STATUS_ERROR if a fatal error is", "   detected.  The last call to XML_Parse must have isFinal true; len", "   may be zero for this call (or any other).", "", "   Though the return values for these functions has always been", "   described as a Boolean value, the implementation, at least for the", "   1.95.x series, has always returned exactly one of the XML_Status", "   values.", "*/", "XMLPARSEAPI(enum XML_Status)", "XML_Parse(XML_Parser parser, const char *s, int len, int isFinal);", "", "XMLPARSEAPI(void *)", "XML_GetBuffer(XML_Parser parser, int len);", "", "XMLPARSEAPI(enum XML_Status)", "XML_ParseBuffer(XML_Parser parser, int len, int isFinal);", "", "/* Stops parsing, causing XML_Parse() or XML_ParseBuffer() to return.", "   Must be called from within a call-back handler, except when aborting", "   (resumable = 0) an already suspended parser. Some call-backs may", "   still follow because they would otherwise get lost. Examples:", "   - endElementHandler() for empty elements when stopped in", "     startElementHandler(), ", "   - endNameSpaceDeclHandler() when stopped in endElementHandler(), ", "   and possibly others.", "", "   Can be called from most handlers, including DTD related call-backs,", "   except when parsing an external parameter entity and resumable != 0.", "   Returns XML_STATUS_OK when successful, XML_STATUS_ERROR otherwise.", "   Possible error codes: ", "   - XML_ERROR_SUSPENDED: when suspending an already suspended parser.", "   - XML_ERROR_FINISHED: when the parser has already finished.", "   - XML_ERROR_SUSPEND_PE: when suspending while parsing an external PE.", "", "   When resumable != 0 (true) then parsing is suspended, that is, ", "   XML_Parse() and XML_ParseBuffer() return XML_STATUS_SUSPENDED. ", "   Otherwise, parsing is aborted, that is, XML_Parse() and XML_ParseBuffer()", "   return XML_STATUS_ERROR with error code XML_ERROR_ABORTED.", "", "   *Note*:", "   This will be applied to the current parser instance only, that is, if", "   there is a parent parser then it will continue parsing when the", "   externalEntityRefHandler() returns. It is up to the implementation of", "   the externalEntityRefHandler() to call XML_StopParser() on the parent", "   parser (recursively), if one wants to stop parsing altogether.", "", "   When suspended, parsing can be resumed by calling XML_ResumeParser(). ", "*/", "XMLPARSEAPI(enum XML_Status)", "XML_StopParser(XML_Parser parser, XML_Bool resumable);", "", "/* Resumes parsing after it has been suspended with XML_StopParser().", "   Must not be called from within a handler call-back. Returns same", "   status codes as XML_Parse() or XML_ParseBuffer().", "   Additional error code XML_ERROR_NOT_SUSPENDED possible.   ", "", "   *Note*:", "   This must be called on the most deeply nested child parser instance", "   first, and on its parent parser only after the child parser has finished,", "   to be applied recursively until the document entity's parser is restarted.", "   That is, the parent parser will not resume by itself and it is up to the", "   application to call XML_ResumeParser() on it at the appropriate moment.", "*/", "XMLPARSEAPI(enum XML_Status)", "XML_ResumeParser(XML_Parser parser);", "", "enum XML_Parsing {", "  XML_INITIALIZED,", "  XML_PARSING,", "  XML_FINISHED,", "  XML_SUSPENDED", "};", "", "typedef struct {", "  enum XML_Parsing parsing;", "  XML_Bool finalBuffer;", "} XML_ParsingStatus;", "", "/* Returns status of parser with respect to being initialized, parsing,", "   finished, or suspended and processing the final buffer.", "   XXX XML_Parse() and XML_ParseBuffer() should return XML_ParsingStatus,", "   XXX with XML_FINISHED_OK or XML_FINISHED_ERROR replacing XML_FINISHED", "*/", "XMLPARSEAPI(void)", "XML_GetParsingStatus(XML_Parser parser, XML_ParsingStatus *status);", "", "/* Creates an XML_Parser object that can parse an external general", "   entity; context is a '\\0'-terminated string specifying the parse", "   context; encoding is a '\\0'-terminated string giving the name of", "   the externally specified encoding, or NULL if there is no", "   externally specified encoding.  The context string consists of a", "   sequence of tokens separated by formfeeds (\\f); a token consisting", "   of a name specifies that the general entity of the name is open; a", "   token of the form prefix=uri specifies the namespace for a", "   particular prefix; a token of the form =uri specifies the default", "   namespace.  This can be called at any point after the first call to", "   an ExternalEntityRefHandler so longer as the parser has not yet", "   been freed.  The new parser is completely independent and may", "   safely be used in a separate thread.  The handlers and userData are", "   initialized from the parser argument.  Returns NULL if out of memory.", "   Otherwise returns a new XML_Parser object.", "*/", "XMLPARSEAPI(XML_Parser)", "XML_ExternalEntityParserCreate(XML_Parser parser,", "                               const XML_Char *context,", "                               const XML_Char *encoding);", "", "enum XML_ParamEntityParsing {", "  XML_PARAM_ENTITY_PARSING_NEVER,", "  XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE,", "  XML_PARAM_ENTITY_PARSING_ALWAYS", "};", "", "/* Controls parsing of parameter entities (including the external DTD", "   subset). If parsing of parameter entities is enabled, then", "   references to external parameter entities (including the external", "   DTD subset) will be passed to the handler set with", "   XML_SetExternalEntityRefHandler.  The context passed will be 0.", "", "   Unlike external general entities, external parameter entities can", "   only be parsed synchronously.  If the external parameter entity is", "   to be parsed, it must be parsed during the call to the external", "   entity ref handler: the complete sequence of", "   XML_ExternalEntityParserCreate, XML_Parse/XML_ParseBuffer and", "   XML_ParserFree calls must be made during this call.  After", "   XML_ExternalEntityParserCreate has been called to create the parser", "   for the external parameter entity (context must be 0 for this", "   call), it is illegal to make any calls on the old parser until", "   XML_ParserFree has been called on the newly created parser.", "   If the library has been compiled without support for parameter", "   entity parsing (ie without XML_DTD being defined), then", "   XML_SetParamEntityParsing will return 0 if parsing of parameter", "   entities is requested; otherwise it will return non-zero.", "   Note: If XML_SetParamEntityParsing is called after XML_Parse or", "      XML_ParseBuffer, then it has no effect and will always return 0.", "*/", "XMLPARSEAPI(int)", "XML_SetParamEntityParsing(XML_Parser parser,", "                          enum XML_ParamEntityParsing parsing);", "", "/* If XML_Parse or XML_ParseBuffer have returned XML_STATUS_ERROR, then", "   XML_GetErrorCode returns information about the error.", "*/", "XMLPARSEAPI(enum XML_Error)", "XML_GetErrorCode(XML_Parser parser);", "", "/* These functions return information about the current parse", "   location.  They may be called from any callback called to report", "   some parse event; in this case the location is the location of the", "   first of the sequence of characters that generated the event.  When", "   called from callbacks generated by declarations in the document", "   prologue, the location identified isn't as neatly defined, but will", "   be within the relevant markup.  When called outside of the callback", "   functions, the position indicated will be just past the last parse", "   event (regardless of whether there was an associated callback).", "   ", "   They may also be called after returning from a call to XML_Parse", "   or XML_ParseBuffer.  If the return value is XML_STATUS_ERROR then", "   the location is the location of the character at which the error", "   was detected; otherwise the location is the location of the last", "   parse event, as described above.", "*/", "XMLPARSEAPI(XML_Size) XML_GetCurrentLineNumber(XML_Parser parser);", "XMLPARSEAPI(XML_Size) XML_GetCurrentColumnNumber(XML_Parser parser);", "XMLPARSEAPI(XML_Index) XML_GetCurrentByteIndex(XML_Parser parser);", "", "/* Return the number of bytes in the current event.", "   Returns 0 if the event is in an internal entity.", "*/", "XMLPARSEAPI(int)", "XML_GetCurrentByteCount(XML_Parser parser);", "", "/* If XML_CONTEXT_BYTES is defined, returns the input buffer, sets", "   the integer pointed to by offset to the offset within this buffer", "   of the current parse position, and sets the integer pointed to by size", "   to the size of this buffer (the number of input bytes). Otherwise", "   returns a NULL pointer. Also returns a NULL pointer if a parse isn't", "   active.", "", "   NOTE: The character pointer returned should not be used outside", "   the handler that makes the call.", "*/", "XMLPARSEAPI(const char *)", "XML_GetInputContext(XML_Parser parser,", "                    int *offset,", "                    int *size);", "", "/* For backwards compatibility with previous versions. */", "#define XML_GetErrorLineNumber   XML_GetCurrentLineNumber", "#define XML_GetErrorColumnNumber XML_GetCurrentColumnNumber", "#define XML_GetErrorByteIndex    XML_GetCurrentByteIndex", "", "/* Frees the content model passed to the element declaration handler */", "XMLPARSEAPI(void)", "XML_FreeContentModel(XML_Parser parser, XML_Content *model);", "", "/* Exposing the memory handling functions used in Expat */", "XMLPARSEAPI(void *)", "XML_MemMalloc(XML_Parser parser, size_t size);", "", "XMLPARSEAPI(void *)", "XML_MemRealloc(XML_Parser parser, void *ptr, size_t size);", "", "XMLPARSEAPI(void)", "XML_MemFree(XML_Parser parser, void *ptr);", "", "/* Frees memory used by the parser. */", "XMLPARSEAPI(void)", "XML_ParserFree(XML_Parser parser);", "", "/* Returns a string describing the error. */", "XMLPARSEAPI(const XML_LChar *)", "XML_ErrorString(enum XML_Error code);", "", "/* Return a string containing the version number of this expat */", "XMLPARSEAPI(const XML_LChar *)", "XML_ExpatVersion(void);", "", "typedef struct {", "  int major;", "  int minor;", "  int micro;", "} XML_Expat_Version;", "", "/* Return an XML_Expat_Version structure containing numeric version", "   number information for this version of expat.", "*/", "XMLPARSEAPI(XML_Expat_Version)", "XML_ExpatVersionInfo(void);", "", "/* Added in Expat 1.95.5. */", "enum XML_FeatureEnum {", "  XML_FEATURE_END = 0,", "  XML_FEATURE_UNICODE,", "  XML_FEATURE_UNICODE_WCHAR_T,", "  XML_FEATURE_DTD,", "  XML_FEATURE_CONTEXT_BYTES,", "  XML_FEATURE_MIN_SIZE,", "  XML_FEATURE_SIZEOF_XML_CHAR,", "  XML_FEATURE_SIZEOF_XML_LCHAR,", "  XML_FEATURE_NS,", "  XML_FEATURE_LARGE_SIZE", "  /* Additional features must be added to the end of this enum. */", "};", "", "typedef struct {", "  enum XML_FeatureEnum  feature;", "  const XML_LChar       *name;", "  long int              value;", "} XML_Feature;", "", "XMLPARSEAPI(const XML_Feature *)", "XML_GetFeatureList(void);", "", "", "/* Expat follows the GNU/Linux convention of odd number minor version for", "   beta/development releases and even number minor version for stable", "   releases. Micro is bumped with each release, and set to 0 with each", "   change to major or minor version.", "*/", "#define XML_MAJOR_VERSION 2", "#define XML_MINOR_VERSION 0", "#define XML_MICRO_VERSION 1", "", "#ifdef __cplusplus", "}", "#endif", "", "#endif /* not Expat_INCLUDED */" },
    ["expat_external.h"] = { "/* Copyright (c) 1998, 1999, 2000 Thai Open Source Software Center Ltd", "   See the file COPYING for copying permission.", "*/", "", "#ifndef Expat_External_INCLUDED", "#define Expat_External_INCLUDED 1", "", "/* External API definitions */", "", "#if defined(_MSC_EXTENSIONS) && !defined(__BEOS__) && !defined(__CYGWIN__)", "#define XML_USE_MSC_EXTENSIONS 1", "#endif", "", "/* Expat tries very hard to make the API boundary very specifically", "   defined.  There are two macros defined to control this boundary;", "   each of these can be defined before including this header to", "   achieve some different behavior, but doing so it not recommended or", "   tested frequently.", "", "   XMLCALL    - The calling convention to use for all calls across the", '                "library boundary."  This will default to cdecl, and', "                try really hard to tell the compiler that's what we", "                want.", "", "   XMLIMPORT  - Whatever magic is needed to note that a function is", "                to be imported from a dynamically loaded library", "                (.dll, .so, or .sl, depending on your platform).", "", "   The XMLCALL macro was added in Expat 1.95.7.  The only one which is", "   expected to be directly useful in client code is XMLCALL.", "", "   Note that on at least some Unix versions, the Expat library must be", "   compiled with the cdecl calling convention as the default since", "   system headers may assume the cdecl convention.", "*/", "#ifndef XMLCALL", "#if defined(_MSC_VER)", "#define XMLCALL __cdecl", "#elif defined(__GNUC__) && defined(__i386) && !defined(__INTEL_COMPILER)", "#define XMLCALL __attribute__((cdecl))", "#else", "/* For any platform which uses this definition and supports more than", "   one calling convention, we need to extend this definition to", "   declare the convention used on that platform, if it's possible to", "   do so.", "", "   If this is the case for your platform, please file a bug report", "   with information on how to identify your platform via the C", "   pre-processor and how to specify the same calling convention as the", "   platform's malloc() implementation.", "*/", "#define XMLCALL", "#endif", "#endif  /* not defined XMLCALL */", "", "", "#if !defined(XML_STATIC) && !defined(XMLIMPORT)", "#ifndef XML_BUILDING_EXPAT", "/* using Expat from an application */", "", "#ifdef XML_USE_MSC_EXTENSIONS", "#define XMLIMPORT __declspec(dllimport)", "#endif", "", "#endif", "#endif  /* not defined XML_STATIC */", "", "", "/* If we didn't define it above, define it away: */", "#ifndef XMLIMPORT", "#define XMLIMPORT", "#endif", "", "", "#define XMLPARSEAPI(type) XMLIMPORT type XMLCALL", "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "", "#ifdef XML_UNICODE_WCHAR_T", "#define XML_UNICODE", "#endif", "", "#ifdef XML_UNICODE     /* Information is UTF-16 encoded. */", "#ifdef XML_UNICODE_WCHAR_T", "typedef wchar_t XML_Char;", "typedef wchar_t XML_LChar;", "#else", "typedef unsigned short XML_Char;", "typedef char XML_LChar;", "#endif /* XML_UNICODE_WCHAR_T */", "#else                  /* Information is UTF-8 encoded. */", "typedef char XML_Char;", "typedef char XML_LChar;", "#endif /* XML_UNICODE */", "", "#ifdef XML_LARGE_SIZE  /* Use large integers for file/stream positions. */", "#if defined(XML_USE_MSC_EXTENSIONS) && _MSC_VER < 1400", "typedef __int64 XML_Index; ", "typedef unsigned __int64 XML_Size;", "#else", "typedef long long XML_Index;", "typedef unsigned long long XML_Size;", "#endif", "#else", "typedef long XML_Index;", "typedef unsigned long XML_Size;", "#endif /* XML_LARGE_SIZE */", "", "#ifdef __cplusplus", "}", "#endif", "", "#endif /* not Expat_External_INCLUDED */" },
    ["fcntl.h"] = { "/*", " * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "#include <sys/fcntl.h>" },
    ["fenv.h"] = { "/*", " * Copyright (c) 2002 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * The contents of this file constitute Original Code as defined in and", " * are subject to the Apple Public Source License Version 1.1 (the", ' * "License").  You may not use this file except in compliance with the', " * License.  Please obtain a copy of the License at", " * http://www.apple.com/publicsource and read it before using this file.", " * ", " * This Original Code and all software distributed under the License are", ' * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER', " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the", " * License for the specific language governing rights and limitations", " * under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", " ", "/******************************************************************************", " *                                                                            *", " *  File:  fenv.h                                                             *", " *                                                                            *", " *  Contains: typedefs and prototypes for C99 floating point environment.     *", " *                                                                            *", " *  A collection of functions designed to provide access to the floating      *", " *  point environment for numerical programming. It is compliant with the     *", " *  floating-point requirements in C99.                                       *", " *                                                                            *", " *  The file <fenv.h> declares many functions in support of numerical         *", " *  programming. Programs that test flags or run under non-default mode       *", ' *  must do so under the effect of an enabling "fenv_access" pragma:          *', " *                                                                            *", " *      #pragma STDC FENV_ACCESS on                                           *", " *                                                                            *", " ******************************************************************************/", "", "#ifndef __FENV_H__", "#define __FENV_H__", "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "    ", "/******************************************************************************", " *                                                                            *", " *  Architecture-specific types and macros.                                   *", " *                                                                            *", " *      fenv_t          a type for representing the entire floating-point     *", " *                      environment in a single object.                       *", " *                                                                            *", " *      fexcept_t       a type for representing the floating-point            *", " *                      exception flag state collectively.                    *", " *                                                                            *", " *      FE_INEXACT      macros representing the various floating-point        *", " *      FE_UNDERFLOW    exceptions.                                           *", " *      FE_OVERFLOW                                                           *", " *      FE_DIVBYZERO                                                          *", " *      FE_INVALID                                                            *", " *      FE_ALL_EXCEPT                                                         *", " *                                                                            *", " *      FE_TONEAREST    macros representing the various floating-point        *", " *      FE_UPWARD       rounding modes                                        *", " *      FE_DOWNWARD                                                           *", " *      FE_TOWARDZERO                                                         *", " *                                                                            *", " *      FE_DFL_ENV      a macro expanding to a pointer to an object           *", " *                      representing the default floating-point environemnt   *", " *                                                                            *", " ******************************************************************************/", "    ", "/******************************************************************************", " *  ARM definitions of architecture-specific types and macros.                *", " ******************************************************************************/", "     ", "#if defined __arm__ && !defined __SOFTFP__", "     ", "typedef struct {", "    unsigned int            __fpscr;    ", "    unsigned int            __reserved0;", "    unsigned int            __reserved1;", "    unsigned int            __reserved2;", "} fenv_t;", "", "typedef unsigned short fexcept_t;", "    ", "#define FE_INEXACT          0x0010", "#define FE_UNDERFLOW        0x0008", "#define FE_OVERFLOW         0x0004", "#define FE_DIVBYZERO        0x0002", "#define FE_INVALID          0x0001", "/*  FE_FLUSHTOZERO", "    An ARM-specific flag that is raised when a denormal is flushed to zero.", '    This is also called the "input denormal exception"                        */', "#define FE_FLUSHTOZERO      0x0080 ", "#define FE_ALL_EXCEPT       0x009f", "    ", "#define FE_TONEAREST        0x00000000", "#define FE_UPWARD           0x00400000", "#define FE_DOWNWARD         0x00800000", "#define FE_TOWARDZERO       0x00C00000", "", "/*  Masks for values that may be controlled in the FPSCR.  Modifying any other", "    bits invokes undefined behavior.                                          */", "enum {", "    __fpscr_trap_invalid   = 0x00000100,", "    __fpscr_trap_divbyzero = 0x00000200,", "    __fpscr_trap_overflow  = 0x00000400,", "    __fpscr_trap_underflow = 0x00000800,", "    __fpscr_trap_inexact   = 0x00001000,", "    __fpscr_trap_denormal  = 0x00008000,", "    __fpscr_flush_to_zero  = 0x01000000,", "    __fpscr_default_nan    = 0x02000000,", "    __fpscr_saturation     = 0x08000000,", "};", "", "extern const fenv_t _FE_DFL_ENV;", "#define FE_DFL_ENV &_FE_DFL_ENV", "", "/******************************************************************************", " *  x86 definitions of architecture-specific types and macros.                *", " ******************************************************************************/", "    ", "#elif defined __i386__ || defined __x86_64__", "", "typedef struct {", "    unsigned short          __control;      /* x87 control word               */", "    unsigned short          __status;       /* x87 status word                */", "    unsigned int            __mxcsr;        /* SSE status/control register    */", "    char                    __reserved[8];  /* Reserved for future expansion  */   ", "} fenv_t;", "", "typedef unsigned short fexcept_t;", "    ", "#define FE_INEXACT          0x0020", "#define FE_UNDERFLOW        0x0010", "#define FE_OVERFLOW         0x0008", "#define FE_DIVBYZERO        0x0004", "#define FE_INVALID          0x0001", "/*  FE_DENORMALOPERAND", "    An Intel-specific flag that is raised when an operand to a floating-point", "    arithmetic operation is denormal, or a single- or double-precision denormal", "    value is loaded on the x87 stack.  This flag is not raised by SSE", "    arithmetic when the DAZ control bit is set.                               */", "#define FE_DENORMALOPERAND  0x0002", "#define FE_ALL_EXCEPT       0x003f", "", "#define FE_TONEAREST        0x0000", "#define FE_DOWNWARD         0x0400", "#define FE_UPWARD           0x0800", "#define FE_TOWARDZERO       0x0c00", "", "extern const fenv_t _FE_DFL_ENV;", "#define FE_DFL_ENV &_FE_DFL_ENV", "", "/*  FE_DFL_DISABLE_SSE_DENORMS_ENV", " ", "    A pointer to a fenv_t object with the default floating-point state modifed", "    to set the DAZ and FZ bits in the SSE status/control register.  When using", "    this environment, denormals encountered by SSE based calculation (which", "    normally should be all single and double precision scalar floating point", "    calculations, and all SSE/SSE2/SSE3 computation) will be treated as zero.", "    Calculation results that are denormals will also be truncated to zero.", "    This calculation mode is not IEEE-754 compliant, but may prevent lengthy", "    stalls that occur in code that encounters denormals. It is suggested that", "    you do not use this mode unless you have established that denormals are", "    causing trouble for your code. Please use wisely.", "    ", "    CAUTION: The math library currently is not architected to do the right", "    thing in the face of DAZ + FZ mode.  For example, ceil( +denormal) might", "    return +denormal rather than 1.0 in some versions of MacOS X. In some", "    circumstances this may lead to unexpected application behavior. Use at", "    your own risk.", " ", "    It is not possible to disable denormal stalls for calculations performed", "    on the x87 FPU                                                            */", "extern const fenv_t _FE_DFL_DISABLE_SSE_DENORMS_ENV;", "#define FE_DFL_DISABLE_SSE_DENORMS_ENV  &_FE_DFL_DISABLE_SSE_DENORMS_ENV", "", "/******************************************************************************", " *  Totally generic definitions and macros if we don't know anything about    *", " *  the target platform, or if the platform does not have hardware floating-  *", " *  point support.                                                            *", " ******************************************************************************/", "    ", "#else /* Unknown architectures */", "", "typedef int fenv_t;", "typedef unsigned short fexcept_t;", "#define FE_ALL_EXCEPT       0", "#define FE_TONEAREST        0", "extern const fenv_t _FE_DFL_ENV;", "#define FE_DFL_ENV &_FE_DFL_ENV", "", "#endif", "", "/******************************************************************************", " *  The following functions provide high level access to the exception flags. *  ", ' *  The "int" input argument can be constructed by bitwise ORs of the         *', " *  exception macros: for example: FE_OVERFLOW | FE_INEXACT.                  *", " *                                                                            *", ' *  The function "feclearexcept" clears the supported floating point          *', " *  exceptions represented by its argument.                                   *", " *                                                                            *", ' *  The function "fegetexceptflag" stores a implementation-defined            *', " *  representation of the states of the floating-point status flags indicated *", " *  by its integer argument excepts in the object pointed to by the argument, * ", " *  flagp.                                                                    *", " *                                                                            *", ' *  The function "feraiseexcept" raises the supported floating-point          *', " *  exceptions represented by its argument. The order in which these          *", " *  floating-point exceptions are raised is unspecified.                      *", " *                                                                            *", ' *  The function "fesetexceptflag" sets or clears the floating point status   *', " *  flags indicated by the argument excepts to the states stored in the       *", " *  object pointed to by flagp. The value of the *flagp shall have been set   *", " *  by a previous call to fegetexceptflag whose second argument represented   *", " *  at least those floating-point exceptions represented by the argument      *", " *  excepts. This function does not raise floating-point exceptions; it just  *", " *  sets the state of the flags.                                              *", " *                                                                            *", ' *  The function "fetestexcept" determines which of the specified subset of   *', " *  the floating-point exception flags are currently set.  The excepts        *", " *  argument specifies the floating-point status flags to be queried. This    *", " *  function returns the value of the bitwise OR of the floating-point        *", " *  exception macros corresponding to the currently set floating-point        *", " *  exceptions included in excepts.                                           *", " ******************************************************************************/", "", "extern int feclearexcept(int /* excepts */);", "extern int fegetexceptflag(fexcept_t * /* flagp */, int /* excepts */);", "extern int feraiseexcept(int /* excepts */);", "extern int fesetexceptflag(const fexcept_t * /* flagp */, int /* excepts */);", "extern int fetestexcept(int /* excepts */);", "", "/******************************************************************************", " *  The following functions provide control of rounding direction modes.      *", " *                                                                            *", ' *  The function "fegetround" returns the value of the rounding direction     *', " *  macro which represents the current rounding direction, or a negative      *", " *  if there is no such rounding direction macro or the current rounding      *", " *  direction is not determinable.                                            *", " *                                                                            *", ' *  The function "fesetround" establishes the rounding direction represented  *', ' *  by its argument "round". If the argument is not equal to the value of a   *', " *  rounding direction macro, the rounding direction is not changed.  It      *", " *  returns zero if and only if the argument is equal to a rounding           *", " *  direction macro.                                                          *", " ******************************************************************************/", "    ", "extern int fegetround(void);", "extern int fesetround(int /* round */);", "", "/******************************************************************************", " *  The following functions manage the floating-point environment, exception  *", " *  flags and dynamic modes, as one entity.                                   *", " *                                                                            *", " *  The fegetenv function stores the current floating-point enviornment in    *", " *  the object pointed to by envp.                                            *", " *                                                                            *", " *  The feholdexcept function saves the current floating-point environment in *", " *  the object pointed to by envp, clears the floating-point status flags,    *", " *  and then installs a non-stop (continue on floating-point exceptions)      *", " *  mode, if available, for all floating-point exceptions. The feholdexcept   *", " *  function returns zero if and only if non-stop floating-point exceptions   *", " *  handling was successfully installed.                                      *", " *                                                                            *", " *  The fesetnv function establishes the floating-point environment           *", " *  represented by the object pointed to by envp. The argument envp shall     *", " *  point to an object set by a call to fegetenv or feholdexcept, or equal to *", " *  a floating-point environment macro to be C99 standard compliant and       *", " *  portable to other architectures. Note that fesetnv merely installs the    *", " *  state of the floating-point status flags represented through its          *", " *  argument, and does not raise these floating-point exceptions.             *", " *                                                                            *", " *  The feupdateenv function saves the currently raised floating-point        *", " *  exceptions in its automatic storage, installs the floating-point          *", " *  environment represented by the object pointed to by envp, and then raises *", " *  the saved floating-point exceptions. The argument envp shall point to an  *", " *  object set by a call to feholdexcept or fegetenv or equal a               *", " *  floating-point environment macro.                                         *", " ******************************************************************************/", "    ", "extern int fegetenv(fenv_t * /* envp */);", "extern int feholdexcept(fenv_t * /* envp */);", "extern int fesetenv(const fenv_t * /* envp */);", "extern int feupdateenv(const fenv_t * /* envp */);", "", "#ifdef __cplusplus", "}", "#endif", "", "#endif /* __FENV_H__ */", "" },
    ["fmtmsg.h"] = { "/*-", " * Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>", " * All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " *", " * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " * $FreeBSD: src/include/fmtmsg.h,v 1.2 2002/08/05 16:37:05 mike Exp $", " */", "", "#ifndef _FMTMSG_H_", "#define\t_FMTMSG_H_", "", "/* Source of condition is... */", "#define\tMM_HARD\t\t0x0001\t/* ...hardware. */", "#define\tMM_SOFT\t\t0x0002\t/* ...software. */", "#define\tMM_FIRM\t\t0x0004\t/* ...fireware. */", "", "/* Condition detected by... */", "#define\tMM_APPL\t\t0x0010\t/* ...application. */", "#define\tMM_UTIL\t\t0x0020\t/* ...utility. */", "#define\tMM_OPSYS\t0x0040\t/* ...operating system. */", "", "/* Display on... */", "#define\tMM_PRINT\t0x0100\t/* ...standard error. */", "#define\tMM_CONSOLE\t0x0200\t/* ...system console. */", "", "#define\tMM_RECOVER\t0x1000\t/* Recoverable error. */", "#define\tMM_NRECOV\t0x2000\t/* Non-recoverable error. */", "", "/* Severity levels. */", "#define\tMM_NOSEV\t0\t/* No severity level provided. */", "#define\tMM_HALT\t\t1\t/* Error causing application to halt. */", "#define\tMM_ERROR\t2\t/* Non-fault fault. */", "#define\tMM_WARNING\t3\t/* Unusual non-error condition. */", "#define\tMM_INFO\t\t4\t/* Informative message. */", "", "/* Null options. */", "#define\tMM_NULLLBL\t(char *)0", "#define\tMM_NULLSEV\t0", "#define\tMM_NULLMC\t0L", "#define\tMM_NULLTXT\t(char *)0", "#define\tMM_NULLACT\t(char *)0", "#define\tMM_NULLTAG\t(char *)0", "", "/* Return values. */", "#define\tMM_OK\t\t0\t/* Success. */", "#define\tMM_NOMSG\t1\t/* Failed to output to stderr. */", "#define\tMM_NOCON\t2\t/* Failed to output to console. */", "#define\tMM_NOTOK\t3\t/* Failed to output anything. */", "", "int\tfmtmsg(long, const char *, int, const char *, const char *,", "\t    const char *);", "", "#endif /* !_FMTMSG_H_ */" },
    ["fnmatch.h"] = { "/*", " * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/*-", " * Copyright (c) 1992, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)fnmatch.h\t8.1 (Berkeley) 6/2/93", " */", "", "#ifndef\t_FNMATCH_H_", "#define\t_FNMATCH_H_", "", "#include <sys/cdefs.h>", "", "#define\tFNM_NOMATCH\t1\t/* Match failed. */", "", "#define\tFNM_NOESCAPE\t0x01\t/* Disable backslash escaping. */", "#define\tFNM_PATHNAME\t0x02\t/* Slash must be matched by slash. */", "#define\tFNM_PERIOD\t0x04\t/* Period must be matched by period. */", "", "#define\tFNM_NOSYS\t(-1)\t/* Reserved. */", "", "#if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))", "#define\tFNM_LEADING_DIR\t0x08\t/* Ignore /<tail> after Imatch. */", "#define\tFNM_CASEFOLD\t0x10\t/* Case insensitive search. */", "#define\tFNM_IGNORECASE\tFNM_CASEFOLD", "#define\tFNM_FILE_NAME\tFNM_PATHNAME", "#endif", "", "__BEGIN_DECLS", "int\t fnmatch(const char *, const char *, int) __DARWIN_ALIAS(fnmatch);", "__END_DECLS", "", "#endif /* !_FNMATCH_H_ */" },
    ["form.h"] = { "/****************************************************************************", " * Copyright (c) 1998-2003,2004 Free Software Foundation, Inc.              *", " *                                                                          *", " * Permission is hereby granted, free of charge, to any person obtaining a  *", " * copy of this software and associated documentation files (the            *", ' * "Software"), to deal in the Software without restriction, including      *', " * without limitation the rights to use, copy, modify, merge, publish,      *", " * distribute, distribute with modifications, sublicense, and/or sell       *", " * copies of the Software, and to permit persons to whom the Software is    *", " * furnished to do so, subject to the following conditions:                 *", " *                                                                          *", " * The above copyright notice and this permission notice shall be included  *", " * in all copies or substantial portions of the Software.                   *", " *                                                                          *", ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *', " * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *", " * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *", " * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *", " * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *", " * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *", " * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *", " *                                                                          *", " * Except as contained in this notice, the name(s) of the above copyright   *", " * holders shall not be used in advertising or otherwise to promote the     *", " * sale, use or other dealings in this Software without prior written       *", " * authorization.                                                           *", " ****************************************************************************/", "", "/****************************************************************************", " *   Author:  Juergen Pfeifer, 1995,1997                                    *", " ****************************************************************************/", "", "/* $Id: form.h,v 0.20 2004/12/04 22:22:10 tom Exp $ */", "", "#ifndef FORM_H", "#define FORM_H", "", "#include <curses.h>", "#include <eti.h>", "", "#ifdef __cplusplus", '  extern "C" {', "#endif", "", "#ifndef FORM_PRIV_H", "typedef void *FIELD_CELL;", "#endif", "", "#ifndef NCURSES_FIELD_INTERNALS", "#define NCURSES_FIELD_INTERNALS /* nothing */", "#endif", "", "typedef int Form_Options;", "typedef int Field_Options;", "", "\t/**********", "\t*  _PAGE  *", "\t**********/", "", "typedef struct {", "  short pmin;\t\t/* index of first field on page\t\t\t*/", "  short pmax;\t\t/* index of last field on page\t\t\t*/", "  short smin;\t\t/* index of top leftmost field on page\t\t*/", "  short smax;\t\t/* index of bottom rightmost field on page\t*/", "} _PAGE;", "", "\t/**********", "\t*  FIELD  *", "\t**********/", "", "typedef struct fieldnode {", "  unsigned short\tstatus;\t\t/* flags\t\t\t*/", "  short\t\t\trows;\t\t/* size in rows\t\t\t*/", "  short\t\t\tcols;\t\t/* size in cols\t\t\t*/", "  short\t\t\tfrow;\t\t/* first row\t\t\t*/", "  short\t\t\tfcol;\t\t/* first col\t\t\t*/", "  int\t\t\tdrows;\t\t/* dynamic rows\t\t\t*/", "  int\t\t\tdcols;\t\t/* dynamic cols\t\t\t*/", "  int\t\t\tmaxgrow;\t/* maximum field growth\t\t*/", "  int\t\t\tnrow;\t\t/* off-screen rows\t\t*/", "  short\t\t\tnbuf;\t\t/* additional buffers\t\t*/", "  short\t\t\tjust;\t\t/* justification\t\t*/", "  short\t\t\tpage;\t\t/* page on form\t\t\t*/", "  short\t\t\tindex;\t\t/* into form -> field\t\t*/", "  int\t\t\tpad;\t\t/* pad character\t\t*/", "  chtype\t\tfore;\t\t/* foreground attribute\t\t*/", "  chtype\t\tback;\t\t/* background attribute\t\t*/", "  Field_Options\t\topts;\t\t/* options\t\t\t*/", "  struct fieldnode *\tsnext;\t\t/* sorted order pointer\t\t*/", "  struct fieldnode *\tsprev;\t\t/* sorted order pointer\t\t*/", "  struct fieldnode *\tlink;\t\t/* linked field chain\t\t*/", "  struct formnode *\tform;\t\t/* containing form\t\t*/", "  struct typenode *\ttype;\t\t/* field type\t\t\t*/", "  void *\t\targ;\t\t/* argument for type\t\t*/", "  FIELD_CELL *\t\tbuf;\t\t/* field buffers\t\t*/", "  void *\t\tusrptr;\t\t/* user pointer\t\t\t*/", "  /*", "   * The wide-character configuration requires extra information.  Because", "   * there are existing applications that manipulate the members of FIELD", "   * directly, we cannot make the struct opaque.  Offsets of members up to", "   * this point are the same in the narrow- and wide-character configuration.", "   * But note that the type of buf depends on the configuration, and is made", "   * opaque for that reason.", "   */", "  NCURSES_FIELD_INTERNALS", "} FIELD;", "", "\t/**************", "\t*  FIELDTYPE  *", "\t**************/", "", "typedef struct typenode {", "  unsigned short\tstatus;\t\t\t/* flags\t\t*/", "  long\t\t\tref;\t\t\t/* reference count\t*/", "  struct typenode *\tleft;\t\t\t/* ptr to operand for | */", "  struct typenode *\tright;\t\t\t/* ptr to operand for | */", "", "  void* (*makearg)(va_list *);\t\t\t/* make fieldtype arg\t*/", "  void* (*copyarg)(const void *);\t\t/* copy fieldtype arg\t*/", "  void\t(*freearg)(void *);\t\t\t/* free fieldtype arg\t*/", "", "  bool\t(*fcheck)(FIELD *,const void *);\t/* field validation\t*/", "  bool\t(*ccheck)(int,const void *);\t\t/* character validation */", "", "  bool\t(*next)(FIELD *,const void *);\t\t/* enumerate next value */", "  bool\t(*prev)(FIELD *,const void *);\t\t/* enumerate prev value */", "", "} FIELDTYPE;", "", "\t/*********", "\t*  FORM  *", "\t*********/", "", "typedef struct formnode {", "  unsigned short\tstatus;\t\t/* flags\t\t\t*/", "  short\t\t\trows;\t\t/* size in rows\t\t\t*/", "  short\t\t\tcols;\t\t/* size in cols\t\t\t*/", "  int\t\t\tcurrow;\t\t/* current row in field window\t*/", "  int\t\t\tcurcol;\t\t/* current col in field window\t*/", "  int\t\t\ttoprow;\t\t/* in scrollable field window\t*/", "  int\t\t\tbegincol;\t/* in horiz. scrollable field\t*/", "  short\t\t\tmaxfield;\t/* number of fields\t\t*/", "  short\t\t\tmaxpage;\t/* number of pages\t\t*/", "  short\t\t\tcurpage;\t/* index into page\t\t*/", "  Form_Options\t\topts;\t\t/* options\t\t\t*/", "  WINDOW *\t\twin;\t\t/* window\t\t\t*/", "  WINDOW *\t\tsub;\t\t/* subwindow\t\t\t*/", "  WINDOW *\t\tw;\t\t/* window for current field\t*/", "  FIELD **\t\tfield;\t\t/* field [maxfield]\t\t*/", "  FIELD *\t\tcurrent;\t/* current field\t\t*/", "  _PAGE *\t\tpage;\t\t/* page [maxpage]\t\t*/", "  void *\t\tusrptr;\t\t/* user pointer\t\t\t*/", "", "  void\t\t\t(*forminit)(struct formnode *);", "  void\t\t\t(*formterm)(struct formnode *);", "  void\t\t\t(*fieldinit)(struct formnode *);", "  void\t\t\t(*fieldterm)(struct formnode *);", "", "} FORM;", "", "typedef void (*Form_Hook)(FORM *);", "", "\t/***************************", "\t*  miscellaneous #defines  *", "\t***************************/", "", "/* field justification */", "#define NO_JUSTIFICATION\t(0)", "#define JUSTIFY_LEFT\t\t(1)", "#define JUSTIFY_CENTER\t\t(2)", "#define JUSTIFY_RIGHT\t\t(3)", "", "/* field options */", "#define O_VISIBLE\t\t(0x0001U)", "#define O_ACTIVE\t\t(0x0002U)", "#define O_PUBLIC\t\t(0x0004U)", "#define O_EDIT\t\t\t(0x0008U)", "#define O_WRAP\t\t\t(0x0010U)", "#define O_BLANK\t\t\t(0x0020U)", "#define O_AUTOSKIP\t\t(0x0040U)", "#define O_NULLOK\t\t(0x0080U)", "#define O_PASSOK\t\t(0x0100U)", "#define O_STATIC\t\t(0x0200U)", "", "/* form options */", "#define O_NL_OVERLOAD\t\t(0x0001U)", "#define O_BS_OVERLOAD\t\t(0x0002U)", "", "/* form driver commands */", "#define REQ_NEXT_PAGE\t (KEY_MAX + 1)\t/* move to next page\t\t*/", "#define REQ_PREV_PAGE\t (KEY_MAX + 2)\t/* move to previous page\t*/", "#define REQ_FIRST_PAGE\t (KEY_MAX + 3)\t/* move to first page\t\t*/", "#define REQ_LAST_PAGE\t (KEY_MAX + 4)\t/* move to last page\t\t*/", "", "#define REQ_NEXT_FIELD\t (KEY_MAX + 5)\t/* move to next field\t\t*/", "#define REQ_PREV_FIELD\t (KEY_MAX + 6)\t/* move to previous field\t*/", "#define REQ_FIRST_FIELD\t (KEY_MAX + 7)\t/* move to first field\t\t*/", "#define REQ_LAST_FIELD\t (KEY_MAX + 8)\t/* move to last field\t\t*/", "#define REQ_SNEXT_FIELD\t (KEY_MAX + 9)\t/* move to sorted next field\t*/", "#define REQ_SPREV_FIELD\t (KEY_MAX + 10)\t/* move to sorted prev field\t*/", "#define REQ_SFIRST_FIELD (KEY_MAX + 11)\t/* move to sorted first field\t*/", "#define REQ_SLAST_FIELD\t (KEY_MAX + 12)\t/* move to sorted last field\t*/", "#define REQ_LEFT_FIELD\t (KEY_MAX + 13)\t/* move to left to field\t*/", "#define REQ_RIGHT_FIELD\t (KEY_MAX + 14)\t/* move to right to field\t*/", "#define REQ_UP_FIELD\t (KEY_MAX + 15)\t/* move to up to field\t\t*/", "#define REQ_DOWN_FIELD\t (KEY_MAX + 16)\t/* move to down to field\t*/", "", "#define REQ_NEXT_CHAR\t (KEY_MAX + 17)\t/* move to next char in field\t*/", "#define REQ_PREV_CHAR\t (KEY_MAX + 18)\t/* move to prev char in field\t*/", "#define REQ_NEXT_LINE\t (KEY_MAX + 19)\t/* move to next line in field\t*/", "#define REQ_PREV_LINE\t (KEY_MAX + 20)\t/* move to prev line in field\t*/", "#define REQ_NEXT_WORD\t (KEY_MAX + 21)\t/* move to next word in field\t*/", "#define REQ_PREV_WORD\t (KEY_MAX + 22)\t/* move to prev word in field\t*/", "#define REQ_BEG_FIELD\t (KEY_MAX + 23)\t/* move to first char in field\t*/", "#define REQ_END_FIELD\t (KEY_MAX + 24)\t/* move after last char in fld\t*/", "#define REQ_BEG_LINE\t (KEY_MAX + 25)\t/* move to beginning of line\t*/", "#define REQ_END_LINE\t (KEY_MAX + 26)\t/* move after last char in line\t*/", "#define REQ_LEFT_CHAR\t (KEY_MAX + 27)\t/* move left in field\t\t*/", "#define REQ_RIGHT_CHAR\t (KEY_MAX + 28)\t/* move right in field\t\t*/", "#define REQ_UP_CHAR\t (KEY_MAX + 29)\t/* move up in field\t\t*/", "#define REQ_DOWN_CHAR\t (KEY_MAX + 30)\t/* move down in field\t\t*/", "", "#define REQ_NEW_LINE\t (KEY_MAX + 31)\t/* insert/overlay new line\t*/", "#define REQ_INS_CHAR\t (KEY_MAX + 32)\t/* insert blank char at cursor\t*/", "#define REQ_INS_LINE\t (KEY_MAX + 33)\t/* insert blank line at cursor\t*/", "#define REQ_DEL_CHAR\t (KEY_MAX + 34)\t/* delete char at cursor\t*/", "#define REQ_DEL_PREV\t (KEY_MAX + 35)\t/* delete char before cursor\t*/", "#define REQ_DEL_LINE\t (KEY_MAX + 36)\t/* delete line at cursor\t*/", "#define REQ_DEL_WORD\t (KEY_MAX + 37)\t/* delete word at cursor\t*/", "#define REQ_CLR_EOL\t (KEY_MAX + 38)\t/* clear to end of line\t\t*/", "#define REQ_CLR_EOF\t (KEY_MAX + 39)\t/* clear to end of field\t*/", "#define REQ_CLR_FIELD\t (KEY_MAX + 40)\t/* clear entire field\t\t*/", "#define REQ_OVL_MODE\t (KEY_MAX + 41)\t/* begin overlay mode\t\t*/", "#define REQ_INS_MODE\t (KEY_MAX + 42)\t/* begin insert mode\t\t*/", "#define REQ_SCR_FLINE\t (KEY_MAX + 43)\t/* scroll field forward a line\t*/", "#define REQ_SCR_BLINE\t (KEY_MAX + 44)\t/* scroll field backward a line\t*/", "#define REQ_SCR_FPAGE\t (KEY_MAX + 45)\t/* scroll field forward a page\t*/", "#define REQ_SCR_BPAGE\t (KEY_MAX + 46)\t/* scroll field backward a page\t*/", "#define REQ_SCR_FHPAGE\t (KEY_MAX + 47) /* scroll field forward\t half page */", "#define REQ_SCR_BHPAGE\t (KEY_MAX + 48) /* scroll field backward half page */", "#define REQ_SCR_FCHAR\t (KEY_MAX + 49) /* horizontal scroll char\t*/", "#define REQ_SCR_BCHAR\t (KEY_MAX + 50) /* horizontal scroll char\t*/", "#define REQ_SCR_HFLINE\t (KEY_MAX + 51) /* horizontal scroll line\t*/", "#define REQ_SCR_HBLINE\t (KEY_MAX + 52) /* horizontal scroll line\t*/", "#define REQ_SCR_HFHALF\t (KEY_MAX + 53) /* horizontal scroll half line\t*/", "#define REQ_SCR_HBHALF\t (KEY_MAX + 54) /* horizontal scroll half line\t*/", "", "#define REQ_VALIDATION\t (KEY_MAX + 55)\t/* validate field\t\t*/", "#define REQ_NEXT_CHOICE\t (KEY_MAX + 56)\t/* display next field choice\t*/", "#define REQ_PREV_CHOICE\t (KEY_MAX + 57)\t/* display prev field choice\t*/", "", "#define MIN_FORM_COMMAND (KEY_MAX + 1)\t/* used by form_driver\t\t*/", "#define MAX_FORM_COMMAND (KEY_MAX + 57)\t/* used by form_driver\t\t*/", "", "#if defined(MAX_COMMAND)", "#  if (MAX_FORM_COMMAND > MAX_COMMAND)", "#    error Something is wrong -- MAX_FORM_COMMAND is greater than MAX_COMMAND", "#  elif (MAX_COMMAND != (KEY_MAX + 128))", "#    error Something is wrong -- MAX_COMMAND is already inconsistently defined.", "#  endif", "#else", "#  define MAX_COMMAND (KEY_MAX + 128)", "#endif", "", "\t/*************************", "\t*  standard field types  *", "\t*************************/", "extern NCURSES_EXPORT_VAR(FIELDTYPE *) TYPE_ALPHA;", "extern NCURSES_EXPORT_VAR(FIELDTYPE *) TYPE_ALNUM;", "extern NCURSES_EXPORT_VAR(FIELDTYPE *) TYPE_ENUM;", "extern NCURSES_EXPORT_VAR(FIELDTYPE *) TYPE_INTEGER;", "extern NCURSES_EXPORT_VAR(FIELDTYPE *) TYPE_NUMERIC;", "extern NCURSES_EXPORT_VAR(FIELDTYPE *) TYPE_REGEXP;", "", "\t/************************************", "\t*  built-in additional field types  *", "\t*  They are not defined in SVr4     *", "\t************************************/", "extern NCURSES_EXPORT_VAR(FIELDTYPE *) TYPE_IPV4;      /* Internet IP Version 4 address */", "", "\t/***********************", "\t*   Default objects    *", "\t***********************/", "extern NCURSES_EXPORT_VAR(FORM *)\t_nc_Default_Form;", "extern NCURSES_EXPORT_VAR(FIELD *)\t_nc_Default_Field;", "", "", "\t/***********************", "\t*  FIELDTYPE routines  *", "\t***********************/", "extern NCURSES_EXPORT(FIELDTYPE *) new_fieldtype (", "\t\t    bool (* const field_check)(FIELD *,const void *),", "\t\t    bool (* const char_check)(int,const void *));", "extern NCURSES_EXPORT(FIELDTYPE *) link_fieldtype(", "\t\t    FIELDTYPE *, FIELDTYPE *);", "", "extern NCURSES_EXPORT(int)\tfree_fieldtype (FIELDTYPE *);", "extern NCURSES_EXPORT(int)\tset_fieldtype_arg (FIELDTYPE *,", "\t\t    void * (* const make_arg)(va_list *),", "\t\t    void * (* const copy_arg)(const void *),", "\t\t    void (* const free_arg)(void *));", "extern NCURSES_EXPORT(int)\t set_fieldtype_choice (FIELDTYPE *,", "\t\t    bool (* const next_choice)(FIELD *,const void *),", "\t      \t    bool (* const prev_choice)(FIELD *,const void *));", "", "\t/*******************", "\t*  FIELD routines  *", "\t*******************/", "extern NCURSES_EXPORT(FIELD *)\tnew_field (int,int,int,int,int,int);", "extern NCURSES_EXPORT(FIELD *)\tdup_field (FIELD *,int,int);", "extern NCURSES_EXPORT(FIELD *)\tlink_field (FIELD *,int,int);", "", "extern NCURSES_EXPORT(int)\tfree_field (FIELD *);", "extern NCURSES_EXPORT(int)\tfield_info (const FIELD *,int *,int *,int *,int *,int *,int *);", "extern NCURSES_EXPORT(int)\tdynamic_field_info (const FIELD *,int *,int *,int *);", "extern NCURSES_EXPORT(int)\tset_max_field ( FIELD *,int);", "extern NCURSES_EXPORT(int)\tmove_field (FIELD *,int,int);", "extern NCURSES_EXPORT(int)\tset_field_type (FIELD *,FIELDTYPE *,...);", "extern NCURSES_EXPORT(int)\tset_new_page (FIELD *,bool);", "extern NCURSES_EXPORT(int)\tset_field_just (FIELD *,int);", "extern NCURSES_EXPORT(int)\tfield_just (const FIELD *);", "extern NCURSES_EXPORT(int)\tset_field_fore (FIELD *,chtype);", "extern NCURSES_EXPORT(int)\tset_field_back (FIELD *,chtype);", "extern NCURSES_EXPORT(int)\tset_field_pad (FIELD *,int);", "extern NCURSES_EXPORT(int)\tfield_pad (const FIELD *);", "extern NCURSES_EXPORT(int)\tset_field_buffer (FIELD *,int,const char *);", "extern NCURSES_EXPORT(int)\tset_field_status (FIELD *,bool);", "extern NCURSES_EXPORT(int)\tset_field_userptr (FIELD *, void *);", "extern NCURSES_EXPORT(int)\tset_field_opts (FIELD *,Field_Options);", "extern NCURSES_EXPORT(int)\tfield_opts_on (FIELD *,Field_Options);", "extern NCURSES_EXPORT(int)\tfield_opts_off (FIELD *,Field_Options);", "", "extern NCURSES_EXPORT(chtype)\tfield_fore (const FIELD *);", "extern NCURSES_EXPORT(chtype)\tfield_back (const FIELD *);", "", "extern NCURSES_EXPORT(bool)\tnew_page (const FIELD *);", "extern NCURSES_EXPORT(bool)\tfield_status (const FIELD *);", "", "extern NCURSES_EXPORT(void *)\tfield_arg (const FIELD *);", "", "extern NCURSES_EXPORT(void *)\tfield_userptr (const FIELD *);", "", "extern NCURSES_EXPORT(FIELDTYPE *)\tfield_type (const FIELD *);", "", "extern NCURSES_EXPORT(char *)\tfield_buffer (const FIELD *,int);", "", "extern NCURSES_EXPORT(Field_Options)\tfield_opts (const FIELD *);", "", "\t/******************", "\t*  FORM routines  *", "\t******************/", "", "extern NCURSES_EXPORT(FORM *)\tnew_form (FIELD **);", "", "extern NCURSES_EXPORT(FIELD **)\tform_fields (const FORM *);", "extern NCURSES_EXPORT(FIELD *)\tcurrent_field (const FORM *);", "", "extern NCURSES_EXPORT(WINDOW *)\tform_win (const FORM *);", "extern NCURSES_EXPORT(WINDOW *)\tform_sub (const FORM *);", "", "extern NCURSES_EXPORT(Form_Hook)\tform_init (const FORM *);", "extern NCURSES_EXPORT(Form_Hook)\tform_term (const FORM *);", "extern NCURSES_EXPORT(Form_Hook)\tfield_init (const FORM *);", "extern NCURSES_EXPORT(Form_Hook)\tfield_term (const FORM *);", "", "extern NCURSES_EXPORT(int)\tfree_form (FORM *);", "extern NCURSES_EXPORT(int)\tset_form_fields (FORM *,FIELD **);", "extern NCURSES_EXPORT(int)\tfield_count (const FORM *);", "extern NCURSES_EXPORT(int)\tset_form_win (FORM *,WINDOW *);", "extern NCURSES_EXPORT(int)\tset_form_sub (FORM *,WINDOW *);", "extern NCURSES_EXPORT(int)\tset_current_field (FORM *,FIELD *);", "extern NCURSES_EXPORT(int)\tfield_index (const FIELD *);", "extern NCURSES_EXPORT(int)\tset_form_page (FORM *,int);", "extern NCURSES_EXPORT(int)\tform_page (const FORM *);", "extern NCURSES_EXPORT(int)\tscale_form (const FORM *,int *,int *);", "extern NCURSES_EXPORT(int)\tset_form_init (FORM *,Form_Hook);", "extern NCURSES_EXPORT(int)\tset_form_term (FORM *,Form_Hook);", "extern NCURSES_EXPORT(int)\tset_field_init (FORM *,Form_Hook);", "extern NCURSES_EXPORT(int)\tset_field_term (FORM *,Form_Hook);", "extern NCURSES_EXPORT(int)\tpost_form (FORM *);", "extern NCURSES_EXPORT(int)\tunpost_form (FORM *);", "extern NCURSES_EXPORT(int)\tpos_form_cursor (FORM *);", "extern NCURSES_EXPORT(int)\tform_driver (FORM *,int);", "extern NCURSES_EXPORT(int)\tset_form_userptr (FORM *,void *);", "extern NCURSES_EXPORT(int)\tset_form_opts (FORM *,Form_Options);", "extern NCURSES_EXPORT(int)\tform_opts_on (FORM *,Form_Options);", "extern NCURSES_EXPORT(int)\tform_opts_off (FORM *,Form_Options);", "extern NCURSES_EXPORT(int)\tform_request_by_name (const char *);", "", "extern NCURSES_EXPORT(const char *)\tform_request_name (int);", "", "extern NCURSES_EXPORT(void *)\tform_userptr (const FORM *);", "", "extern NCURSES_EXPORT(Form_Options)\tform_opts (const FORM *);", "", "extern NCURSES_EXPORT(bool)\tdata_ahead (const FORM *);", "extern NCURSES_EXPORT(bool)\tdata_behind (const FORM *);", "", "#ifdef __cplusplus", "  }", "#endif", "", "#endif\t/* FORM_H */" },
    ["fsproperties.h"] = { "/*", " * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "", "#ifndef _FSPROPERTIES_H_", "#define _FSPROPERTIES_H_", "", "/* Info plist keys */", '#define kFSMediaTypesKey             "FSMediaTypes"', '#define kFSPersonalitiesKey          "FSPersonalities"', "", "/* Sub-keys for FSMediaTypes dictionaries */", '#define kFSMediaPropertiesKey        "FSMediaProperties"', '#define kFSProbeArgumentsKey         "FSProbeArguments"', '#define kFSProbeExecutableKey        "FSProbeExecutable"', '#define kFSProbeOrderKey             "FSProbeOrder"', "", "/* Sub-keys for FSPersonalities dictionaries */", '#define kFSFormatArgumentsKey        "FSFormatArguments"', '#define kFSFormatContentMaskKey      "FSFormatContentMask"', '#define kFSFormatExecutableKey       "FSFormatExecutable"', '#define kFSFormatInteractiveKey      "FSFormatInteractive"', '#define kFSFormatMinimumSizeKey      "FSFormatMinimumSize"', '#define kFSFormatMaximumSizeKey      "FSFormatMaximumSize"', '#define kFSMountArgumentsKey         "FSMountArguments"', '#define kFSMountExecutableKey        "FSMountExecutable"', '#define kFSNameKey                   "FSName"', '#define kFSRepairArgumentsKey        "FSRepairArguments"', '#define kFSRepairExecutableKey       "FSRepairExecutable"', '#define kFSVerificationArgumentsKey  "FSVerificationArguments"', '#define kFSVerificationExecutableKey "FSVerificationExecutable"', '#define kFSSubTypeKey                "FSSubType"', '#define kFSXMLOutputArgumentKey      "FSXMLOutputArgument"', "", '#define\tkFSCoreStorageEncryptNameKey "FSCoreStorageEncryptionName"', "", "#endif /* _FSPROPERTIES_H_ */" },
    ["fstab.h"] = { "/*", " * Copyright (c) 1980, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)fstab.h\t8.1 (Berkeley) 6/2/93", " */", "", "#ifndef _FSTAB_H_", "#define _FSTAB_H_", "", "/*", " * File system table, see fstab(5).", " *", " * Used by dump, mount, umount, swapon, fsck, df, ...", " *", " * For ufs fs_spec field is the block special name.  Programs that want to", " * use the character special name must create that name by prepending a 'r'", ' * after the right most slash.  Quota files are always named "quotas", so', ' * if type is "rq", then use concatenation of fs_file and "quotas" to locate', " * quota file.", " */", '#define\t_PATH_FSTAB\t"/etc/fstab"', '#define\tFSTAB\t\t"/etc/fstab"\t/* deprecated */', "", '#define\tFSTAB_RW\t"rw"\t\t/* read/write device */', '#define\tFSTAB_RQ\t"rq"\t\t/* read/write with quotas */', '#define\tFSTAB_RO\t"ro"\t\t/* read-only device */', '#define\tFSTAB_SW\t"sw"\t\t/* swap device */', '#define\tFSTAB_XX\t"xx"\t\t/* ignore totally */', "", "struct fstab {", "\tchar\t*fs_spec;\t\t/* block special device name */", "\tchar\t*fs_file;\t\t/* file system path prefix */", "\tchar\t*fs_vfstype;\t\t/* File system type, ufs, nfs */", "\tchar\t*fs_mntops;\t\t/* Mount options ala -o */", "\tchar\t*fs_type;\t\t/* FSTAB_* from fs_mntops */", "\tint\tfs_freq;\t\t/* dump frequency, in days */", "\tint\tfs_passno;\t\t/* pass number on parallel dump */", "};", "", "#include <sys/cdefs.h>", "", "__BEGIN_DECLS", "struct fstab *getfsent(void);", "struct fstab *getfsspec(const char *);", "struct fstab *getfsfile(const char *);", "int setfsent(void);", "void endfsent(void);", "__END_DECLS", "", "#endif /* !_FSTAB_H_ */" },
    ["fts.h"] = { "/*", " * Copyright (c) 2000, 2003-2006, 2008, 2012 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/*", " * Copyright (c) 1989, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)fts.h\t8.3 (Berkeley) 8/14/94", " */", "", "#ifndef\t_FTS_H_", "#define\t_FTS_H_", "", "#include <sys/_types.h>", "#include <sys/_types/_dev_t.h>", "#include <sys/_types/_ino_t.h>", "#include <sys/_types/_nlink_t.h>", "", "typedef struct {", "\tstruct _ftsent *fts_cur;\t/* current node */", "\tstruct _ftsent *fts_child;\t/* linked list of children */", "\tstruct _ftsent **fts_array;\t/* sort array */", "\tdev_t fts_dev;\t\t\t/* starting device # */", "\tchar *fts_path;\t\t\t/* path for this descent */", "\tint fts_rfd;\t\t\t/* fd for root */", "\tint fts_pathlen;\t\t/* sizeof(path) */", "\tint fts_nitems;\t\t\t/* elements in the sort array */", "#ifdef __BLOCKS__", "\tunion {", "#endif /* __BLOCKS__ */", "\t    int (*fts_compar)();\t/* compare function */", "#ifdef __BLOCKS__", "\t    int (^fts_compar_b)();\t/* compare block */", "\t};", "#endif /* __BLOCKS__ */", "", "#define\tFTS_COMFOLLOW\t0x001\t\t/* follow command line symlinks */", "#define\tFTS_LOGICAL\t0x002\t\t/* logical walk */", "#define\tFTS_NOCHDIR\t0x004\t\t/* don't change directories */", "#define\tFTS_NOSTAT\t0x008\t\t/* don't get stat info */", "#define\tFTS_PHYSICAL\t0x010\t\t/* physical walk */", "#define\tFTS_SEEDOT\t0x020\t\t/* return dot and dot-dot */", "#define\tFTS_XDEV\t0x040\t\t/* don't cross devices */", "#define\tFTS_WHITEOUT\t0x080\t\t/* return whiteout information */", "#define\tFTS_COMFOLLOWDIR 0x400\t\t/* (non-std) follow command line symlinks for directories only */", "#if (defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1090) || (defined(__ENVIRONMENT_IPHONE_OS_VERSION_MIN_REQUIRED__) && __ENVIRONMENT_IPHONE_OS_VERSION_MIN_REQUIRED__ >= 70000)", "#define\tFTS_NOSTAT_TYPE\t0x800\t\t/* (non-std) no stat, but use d_type in struct dirent when available */", "#define\tFTS_OPTIONMASK\t0xcff\t\t/* valid user option mask */", "#else", "#define\tFTS_OPTIONMASK\t0x4ff\t\t/* valid user option mask */", "#endif", "", "#define\tFTS_NAMEONLY\t0x100\t\t/* (private) child names only */", "#define\tFTS_STOP\t0x200\t\t/* (private) unrecoverable error */", "#ifdef __BLOCKS__", "#define\tFTS_BLOCK_COMPAR 0x80000000\t/* fts_compar is a block */", "#endif /* __BLOCKS__ */", "\tint fts_options;\t\t/* fts_open options, global flags */", "} FTS;", "", "typedef struct _ftsent {", "\tstruct _ftsent *fts_cycle;\t/* cycle node */", "\tstruct _ftsent *fts_parent;\t/* parent directory */", "\tstruct _ftsent *fts_link;\t/* next file in directory */", "\tlong fts_number;\t        /* local numeric value */", "\tvoid *fts_pointer;\t        /* local address value */", "\tchar *fts_accpath;\t\t/* access path */", "\tchar *fts_path;\t\t\t/* root path */", "\tint fts_errno;\t\t\t/* errno for this node */", "\tint fts_symfd;\t\t\t/* fd for symlink */", "\tunsigned short fts_pathlen;\t/* strlen(fts_path) */", "\tunsigned short fts_namelen;\t/* strlen(fts_name) */", "", "\tino_t fts_ino;\t\t\t/* inode */", "\tdev_t fts_dev;\t\t\t/* device */", "\tnlink_t fts_nlink;\t\t/* link count */", "", "#define\tFTS_ROOTPARENTLEVEL\t-1", "#define\tFTS_ROOTLEVEL\t\t 0", "\tshort fts_level;\t\t/* depth (-1 to N) */", "", "#define\tFTS_D\t\t 1\t\t/* preorder directory */", "#define\tFTS_DC\t\t 2\t\t/* directory that causes cycles */", "#define\tFTS_DEFAULT\t 3\t\t/* none of the above */", "#define\tFTS_DNR\t\t 4\t\t/* unreadable directory */", "#define\tFTS_DOT\t\t 5\t\t/* dot or dot-dot */", "#define\tFTS_DP\t\t 6\t\t/* postorder directory */", "#define\tFTS_ERR\t\t 7\t\t/* error; errno is set */", "#define\tFTS_F\t\t 8\t\t/* regular file */", "#define\tFTS_INIT\t 9\t\t/* initialized only */", "#define\tFTS_NS\t\t10\t\t/* stat(2) failed */", "#define\tFTS_NSOK\t11\t\t/* no stat(2) requested */", "#define\tFTS_SL\t\t12\t\t/* symbolic link */", "#define\tFTS_SLNONE\t13\t\t/* symbolic link without target */", "#define\tFTS_W\t\t14\t\t/* whiteout object */", "\tunsigned short fts_info;\t/* user flags for FTSENT structure */", "", "#define\tFTS_DONTCHDIR\t 0x01\t\t/* don't chdir .. to the parent */", "#define\tFTS_SYMFOLLOW\t 0x02\t\t/* followed a symlink to get here */", "#define\tFTS_ISW\t\t 0x04\t\t/* this is a whiteout object */", "\tunsigned short fts_flags;\t/* private flags for FTSENT structure */", "", "#define\tFTS_AGAIN\t 1\t\t/* read node again */", "#define\tFTS_FOLLOW\t 2\t\t/* follow symbolic link */", "#define\tFTS_NOINSTR\t 3\t\t/* no instructions */", "#define\tFTS_SKIP\t 4\t\t/* discard node */", "\tunsigned short fts_instr;\t/* fts_set() instructions */", "", "\tstruct stat *fts_statp;\t\t/* stat(2) information */", "\tchar fts_name[1];\t\t/* file name */", "} FTSENT;", "", "#include <sys/cdefs.h>", "#include <Availability.h>", "", "__BEGIN_DECLS", "FTSENT\t*fts_children(FTS *, int) __DARWIN_INODE64(fts_children);", "int\t fts_close(FTS *) __DARWIN_INODE64(fts_close);", "FTS\t*fts_open(char * const *, int,", "\t    int (*)(const FTSENT **, const FTSENT **)) __DARWIN_INODE64(fts_open);", "#ifdef __BLOCKS__", "FTS\t*fts_open_b(char * const *, int,", "\t    int (^)(const FTSENT **, const FTSENT **)) __DARWIN_INODE64(fts_open_b) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);", "#endif /* __BLOCKS__ */", "FTSENT\t*fts_read(FTS *) __DARWIN_INODE64(fts_read);", "int\t fts_set(FTS *, FTSENT *, int) __DARWIN_INODE64(fts_set);", "__END_DECLS", "", "#endif /* !_FTS_H_ */" },
    ["ftw.h"] = { "/*\t$OpenBSD: ftw.h,v 1.1 2003/07/21 21:13:18 millert Exp $\t*/", "", "/*", " * Copyright (c) 2003 Todd C. Miller <Todd.Miller@courtesan.com>", " *", " * Permission to use, copy, modify, and distribute this software for any", " * purpose with or without fee is hereby granted, provided that the above", " * copyright notice and this permission notice appear in all copies.", " *", ' * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES', " * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF", " * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR", " * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES", " * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN", " * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF", " * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.", " *", " * Sponsored in part by the Defense Advanced Research Projects", " * Agency (DARPA) and Air Force Research Laboratory, Air Force", " * Materiel Command, USAF, under agreement number F39502-99-1-0512.", " */", "", "#ifndef\t_FTW_H", "#define\t_FTW_H", "", "#include <sys/stat.h>", "", "/*", " * Valid flags for the 3rd argument to the function that is passed as the", " * second argument to ftw(3) and nftw(3).  Say it three times fast!", " */", "#define\tFTW_F\t\t0\t/* File.  */", "#define\tFTW_D\t\t1\t/* Directory.  */", "#define\tFTW_DNR\t\t2\t/* Directory without read permission.  */", "#define\tFTW_DP\t\t3\t/* Directory with subdirectories visited.  */", "#define\tFTW_NS\t\t4\t/* Unknown type; stat() failed.  */", "#define\tFTW_SL\t\t5\t/* Symbolic link.  */", "#define\tFTW_SLN\t\t6\t/* Sym link that names a nonexistent file.  */", "", "/*", " * Flags for use as the 4th argument to nftw(3).  These may be ORed together.", " */", "#define\tFTW_PHYS\t0x01\t/* Physical walk, don't follow sym links.  */", "#define\tFTW_MOUNT\t0x02\t/* The walk does not cross a mount point.  */", "#define\tFTW_DEPTH\t0x04\t/* Subdirs visited before the dir itself. */", "#define\tFTW_CHDIR\t0x08\t/* Change to a directory before reading it. */", "", "struct FTW {", "\tint base;", "\tint level;", "};", "", "__BEGIN_DECLS", "int\tftw(const char *, int (*)(const char *, const struct stat *, int), int) ", "\t__DARWIN_ALIAS_I(ftw);", "int\tnftw(const char *, int (*)(const char *, const struct stat *, int,", "\t    struct FTW *), int, int) __DARWIN_ALIAS_I(nftw);", "__END_DECLS", "", "#endif\t/* !_FTW_H */" },
    ["get_compat.h"] = { "/*", " * Copyright (c) 2004 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "", "#include <stdbool.h>", "", "extern bool compat_mode(const char *function, const char *mode);", "", "/* this will eventually cache the result, you need to call it with a", "  static string otherwise it will cache the wrong result.  It ought", "  to be fast enough to use in things like malloc(2) without extra", "  tricks */", "#define COMPAT_MODE(func, mode) compat_mode(func, mode)" },
    ["gethostuuid.h"] = { "/*", " * Copyright (c) 2013 Apple Inc. All rights reserved.", " *", " * @APPLE_OSREFERENCE_LICENSE_HEADER_START@", " *", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. The rights granted to you under the License", " * may not be used to create, or enable the creation or redistribution of,", " * unlawful or unlicensed copies of an Apple operating system, or to", " * circumvent, violate, or enable the circumvention or violation of, any", " * terms of an Apple operating system software license agreement.", " *", " * Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this file.", " *", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " *", " * @APPLE_OSREFERENCE_LICENSE_HEADER_END@", " */", "", "#ifndef __GETHOSTUUID_H", "#define __GETHOSTUUID_H", "", "#include <sys/_types/_timespec.h>", "#include <sys/_types/_uuid_t.h>", "#include <Availability.h>", "", "#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && (__IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_7_0)", 'int gethostuuid(uuid_t, const struct timespec *) __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_NA, __MAC_NA, __IPHONE_2_0, __IPHONE_5_0, "gethostuuid() is no longer supported");', "#else", "int gethostuuid(uuid_t, const struct timespec *) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_NA);", "#endif", "", "#endif /* __GETHOSTUUID_H */" },
    ["getopt.h"] = { "/*\t$NetBSD: getopt.h,v 1.4 2000/07/07 10:43:54 ad Exp $\t*/", "/*\t$FreeBSD: src/include/getopt.h,v 1.6 2004/02/24 08:09:20 ache Exp $ */", "", "/*-", " * Copyright (c) 2000 The NetBSD Foundation, Inc.", " * All rights reserved.", " *", " * This code is derived from software contributed to The NetBSD Foundation", " * by Dieter Baron and Thomas Klausner.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *        This product includes software developed by the NetBSD", " *        Foundation, Inc. and its contributors.", " * 4. Neither the name of The NetBSD Foundation nor the names of its", " *    contributors may be used to endorse or promote products derived", " *    from this software without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS", " * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED", " * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR", " * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS", " * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR", " * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF", " * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS", " * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN", " * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)", " * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE", " * POSSIBILITY OF SUCH DAMAGE.", " */", "", "#ifndef _GETOPT_H_", "#define _GETOPT_H_", "", "#include <sys/cdefs.h>", "#include <unistd.h>", "", "/*", " * GNU-like getopt_long()/getopt_long_only() with 4.4BSD optreset extension.", " * getopt() is declared here too for GNU programs.", " */", "#define no_argument        0", "#define required_argument  1", "#define optional_argument  2", "", "struct option {", "\t/* name of long option */", "\tconst char *name;", "\t/*", "\t * one of no_argument, required_argument, and optional_argument:", "\t * whether option takes an argument", "\t */", "\tint has_arg;", "\t/* if not NULL, set *flag to val when option found */", "\tint *flag;", "\t/* if flag not NULL, value to set *flag to; else return value */", "\tint val;", "};", "", "__BEGIN_DECLS", "int\tgetopt_long(int, char * const *, const char *,", "\tconst struct option *, int *);", "int\tgetopt_long_only(int, char * const *, const char *,", "\tconst struct option *, int *);", "#ifndef _GETOPT", "#define\t_GETOPT", "int\t getopt(int, char * const [], const char *) __DARWIN_ALIAS(getopt);", "", "extern char *optarg;\t\t\t/* getopt(3) external variables */", "extern int optind, opterr, optopt;", "#endif", "#ifndef _OPTRESET", "#define\t_OPTRESET", "extern int optreset;\t\t\t/* getopt(3) external variable */", "#endif", "__END_DECLS", " ", "#endif /* !_GETOPT_H_ */" },
    ["glob.h"] = { "/*", " * Copyright (c) 1989, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * This code is derived from software contributed to Berkeley by", " * Guido van Rossum.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)glob.h\t8.1 (Berkeley) 6/2/93", " * $FreeBSD: /repoman/r/ncvs/src/include/glob.h,v 1.7 2002/07/17 04:58:09 mikeh Exp $", " */", "", "#ifndef _GLOB_H_", "#define\t_GLOB_H_", "", "#include <_types.h>", "#include <sys/cdefs.h>", "#include <Availability.h>", "#include <sys/_types/_size_t.h>", "", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "struct dirent;", "struct stat;", "#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */", "typedef struct {", "\tsize_t gl_pathc;\t/* Count of total paths so far. */", "\tint gl_matchc;\t\t/* Count of paths matching pattern. */", "\tsize_t gl_offs;\t\t/* Reserved at beginning of gl_pathv. */", "\tint gl_flags;\t\t/* Copy of flags parameter to glob. */", "\tchar **gl_pathv;\t/* List of paths matching pattern. */", "\t\t\t\t/* Copy of errfunc parameter to glob. */", "#ifdef __BLOCKS__", "\tunion {", "#endif /* __BLOCKS__ */", "\t\tint (*gl_errfunc)(const char *, int);", "#ifdef __BLOCKS__", "\t\tint (^gl_errblk)(const char *, int);", "\t};", "#endif /* __BLOCKS__ */", "", "\t/*", "\t * Alternate filesystem access methods for glob; replacement", "\t * versions of closedir(3), readdir(3), opendir(3), stat(2)", "\t * and lstat(2).", "\t */", "\tvoid (*gl_closedir)(void *);", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "\tstruct dirent *(*gl_readdir)(void *);", "#else /* (_POSIX_C_SOURCE && !_DARWIN_C_SOURCE) */", "\tvoid *(*gl_readdir)(void *);", "#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */", "\tvoid *(*gl_opendir)(const char *);", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "\tint (*gl_lstat)(const char *, struct stat *);", "\tint (*gl_stat)(const char *, struct stat *);", "#else /* (_POSIX_C_SOURCE && !_DARWIN_C_SOURCE) */", "\tint (*gl_lstat)(const char *, void *);", "\tint (*gl_stat)(const char *, void *);", "#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */", "} glob_t;", "", "/* Believed to have been introduced in 1003.2-1992 */", "#define\tGLOB_APPEND\t0x0001\t/* Append to output from previous call. */", "#define\tGLOB_DOOFFS\t0x0002\t/* Use gl_offs. */", "#define\tGLOB_ERR\t0x0004\t/* Return on error. */", "#define\tGLOB_MARK\t0x0008\t/* Append / to matching directories. */", "#define\tGLOB_NOCHECK\t0x0010\t/* Return pattern itself if nothing matches. */", "#define\tGLOB_NOSORT\t0x0020\t/* Don't sort. */", "#define\tGLOB_NOESCAPE\t0x2000\t/* Disable backslash escaping. */", "", "/* Error values returned by glob(3) */", "#define\tGLOB_NOSPACE\t(-1)\t/* Malloc call failed. */", "#define\tGLOB_ABORTED\t(-2)\t/* Unignored error. */", "#define\tGLOB_NOMATCH\t(-3)\t/* No match and GLOB_NOCHECK was not set. */", "#define\tGLOB_NOSYS\t(-4)\t/* Obsolete: source comptability only. */", "", "#define\tGLOB_ALTDIRFUNC\t0x0040\t/* Use alternately specified directory funcs. */", "#define\tGLOB_BRACE\t0x0080\t/* Expand braces ala csh. */", "#define\tGLOB_MAGCHAR\t0x0100\t/* Pattern had globbing characters. */", "#define\tGLOB_NOMAGIC\t0x0200\t/* GLOB_NOCHECK without magic chars (csh). */", "#define\tGLOB_QUOTE\t0x0400\t/* Quote special chars with \\. */", "#define\tGLOB_TILDE\t0x0800\t/* Expand tilde names from the passwd file. */", "#define\tGLOB_LIMIT\t0x1000\t/* limit number of returned paths */", "#ifdef __BLOCKS__", "#define\t_GLOB_ERR_BLOCK\t0x80000000 /* (internal) error callback is a block */", "#endif /* __BLOCKS__ */", "", "/* source compatibility, these are the old names */", "#define GLOB_MAXPATH\tGLOB_LIMIT", "#define\tGLOB_ABEND\tGLOB_ABORTED", "", "__BEGIN_DECLS", "int\tglob(const char * __restrict, int, int (*)(const char *, int), ", "\t     glob_t * __restrict) __DARWIN_INODE64(glob);", "#ifdef __BLOCKS__", "int\tglob_b(const char * __restrict, int, int (^)(const char *, int), ", "\t     glob_t * __restrict) __DARWIN_INODE64(glob_b) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);", "#endif /* __BLOCKS__ */", "void\tglobfree(glob_t *);", "__END_DECLS", "", "#endif /* !_GLOB_H_ */" },
    ["grp.h"] = { "/*-", " * Copyright (c) 1989, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " * (c) UNIX System Laboratories, Inc.", " * All or some portions of this file are derived from material licensed", " * to the University of California by American Telephone and Telegraph", " * Co. or Unix System Laboratories, Inc. and are reproduced herein with", " * the permission of UNIX System Laboratories, Inc.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)grp.h\t8.2 (Berkeley) 1/21/94", " */", "/* Portions copyright (c) 2000-2011 Apple Inc. All rights reserved. */ ", "", "#ifndef _GRP_H_", "#define\t_GRP_H_", "", "#include <_types.h>", "#include <sys/_types/_gid_t.h>\t/* [XBD] */", "#include <sys/_types/_size_t.h> /* SUSv4 */", "", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", '#define\t_PATH_GROUP\t\t"/etc/group"', "#endif", "", "struct group {", "\tchar\t*gr_name;\t\t/* [XBD] group name */", "\tchar\t*gr_passwd;\t\t/* [???] group password */", "\tgid_t\tgr_gid;\t\t\t/* [XBD] group id */", "\tchar\t**gr_mem;\t\t/* [XBD] group members */", "};", "", "#include <sys/cdefs.h>", "", "__BEGIN_DECLS", "/* [XBD] */", "struct group *getgrgid(gid_t);", "struct group *getgrnam(const char *);", "/* [TSF] */", "int getgrgid_r(gid_t, struct group *, char *, size_t, struct group **);", "int getgrnam_r(const char *, struct group *, char *, size_t, struct group **);", "/* [XSI] */", "struct group *getgrent(void);", "void setgrent(void);", "void endgrent(void);", "__END_DECLS", "", "#if (!defined(_POSIX_C_SOURCE) && !defined(_XOPEN_SOURCE)) || defined(_DARWIN_C_SOURCE)", "#include <uuid/uuid.h>", "__BEGIN_DECLS", "char *group_from_gid(gid_t, int);", "struct group *getgruuid(uuid_t);", "int getgruuid_r(uuid_t, struct group *, char *, size_t, struct group **);", "__END_DECLS", "#endif", "", "#if !defined(_XOPEN_SOURCE) || defined(_DARWIN_C_SOURCE)", "__BEGIN_DECLS", "void setgrfile(const char *);", "int setgroupent(int);", "__END_DECLS", "#endif", "", "#endif /* !_GRP_H_ */" },
    ["gssapi.h"] = { "/* ", " * Wrapper so that #include <gssapi.h> will work without special include", " * paths.", " */", "#include <gssapi/gssapi.h>" },
    ["histedit.h"] = { "/*\t$NetBSD: histedit.h,v 1.49 2012/05/31 13:16:39 christos Exp $\t*/", "", "/*-", " * Copyright (c) 1992, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * This code is derived from software contributed to Berkeley by", " * Christos Zoulas of Cornell University.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)histedit.h\t8.2 (Berkeley) 1/3/94", " */", "", "/*", " * histedit.h: Line editor and history interface.", " */", "#ifndef _HISTEDIT_H_", "#define\t_HISTEDIT_H_", "", "#define\tLIBEDIT_MAJOR 2", "#define\tLIBEDIT_MINOR 11", "", "#include <sys/types.h>", "#include <stdio.h>", "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "", "/*", " * ==== Editing ====", " */", "", "typedef struct editline EditLine;", "", "/*", " * For user-defined function interface", " */", "typedef struct lineinfo {", "\tconst char\t*buffer;", "\tconst char\t*cursor;", "\tconst char\t*lastchar;", "} LineInfo;", "", "/*", " * EditLine editor function return codes.", " * For user-defined function interface", " */", "#define\tCC_NORM\t\t0", "#define\tCC_NEWLINE\t1", "#define\tCC_EOF\t\t2", "#define\tCC_ARGHACK\t3", "#define\tCC_REFRESH\t4", "#define\tCC_CURSOR\t5", "#define\tCC_ERROR\t6", "#define\tCC_FATAL\t7", "#define\tCC_REDISPLAY\t8", "#define\tCC_REFRESH_BEEP\t9", "", "/*", " * Initialization, cleanup, and resetting", " */", "EditLine\t*el_init(const char *, FILE *, FILE *, FILE *);", "void\t\t el_end(EditLine *);", "void\t\t el_reset(EditLine *);", "", "/*", " * Get a line, a character or push a string back in the input queue", " */", "const char\t*el_gets(EditLine *, int *);", "int\t\t el_getc(EditLine *, char *);", "void\t\t el_push(EditLine *, const char *);", "", "/*", " * Beep!", " */", "void\t\t el_beep(EditLine *);", "", "/*", " * High level function internals control", " * Parses argc, argv array and executes builtin editline commands", " */", "int\t\t el_parse(EditLine *, int, const char **);", "", "/*", " * Low level editline access functions", " */", "int\t\t el_set(EditLine *, int, ...);", "int\t\t el_get(EditLine *, int, ...);", "unsigned char\t_el_fn_complete(EditLine *, int);", "", "/*", " * el_set/el_get parameters", " *", " * When using el_wset/el_wget (as opposed to el_set/el_get):", " *   Char is wchar_t, otherwise it is char.", " *   prompt_func is el_wpfunc_t, otherwise it is el_pfunc_t .", "", " * Prompt function prototypes are:", " *   typedef char    *(*el_pfunct_t)  (EditLine *);", " *   typedef wchar_t *(*el_wpfunct_t) (EditLine *);", " *", " * For operations that support set or set/get, the argument types listed are for", ' * the "set" operation. For "get", each listed type must be a pointer.', " * E.g. EL_EDITMODE takes an int when set, but an int* when get.", " * ", ' * Operations that only support "get" have the correct argument types listed.', " */", "#define\tEL_PROMPT\t0\t/* , prompt_func);\t\t      set/get */", "#define\tEL_TERMINAL\t1\t/* , const char *);\t\t      set/get */", "#define\tEL_EDITOR\t2\t/* , const Char *);\t\t      set/get */", "#define\tEL_SIGNAL\t3\t/* , int);\t\t\t      set/get */", "#define\tEL_BIND\t\t4\t/* , const Char *, ..., NULL);\t      set     */", "#define\tEL_TELLTC\t5\t/* , const Char *, ..., NULL);\t      set     */", "#define\tEL_SETTC\t6\t/* , const Char *, ..., NULL);\t      set     */", "#define\tEL_ECHOTC\t7\t/* , const Char *, ..., NULL);        set     */", "#define\tEL_SETTY\t8\t/* , const Char *, ..., NULL);        set     */", "#define\tEL_ADDFN\t9\t/* , const Char *, const Char,        set     */", "\t\t\t\t/*   el_func_t);\t\t \t      */", "#define\tEL_HIST\t\t10\t/* , hist_fun_t, const void *);\t      set     */", "#define\tEL_EDITMODE\t11\t/* , int);\t\t\t      set/get */", "#define\tEL_RPROMPT\t12\t/* , prompt_func);\t\t      set/get */", "#define\tEL_GETCFN\t13\t/* , el_rfunc_t);\t\t      set/get */", "#define\tEL_CLIENTDATA\t14\t/* , void *);\t\t\t      set/get */", "#define\tEL_UNBUFFERED\t15\t/* , int);\t\t\t      set/get */", "#define\tEL_PREP_TERM\t16\t/* , int);\t\t\t      set     */", "#define\tEL_GETTC\t17\t/* , const Char *, ..., NULL);\t\t  get */", "#define\tEL_GETFP\t18\t/* , int, FILE **);\t\t          get */", "#define\tEL_SETFP\t19\t/* , int, FILE *);\t\t      set     */", "#define\tEL_REFRESH\t20\t/* , void);\t\t\t      set     */", "#define\tEL_PROMPT_ESC\t21\t/* , prompt_func, Char);\t      set/get */", "#define\tEL_RPROMPT_ESC\t22\t/* , prompt_func, Char);\t      set/get */", "#define\tEL_RESIZE\t23\t/* , el_zfunc_t, void *);\t      set     */", "", "#define\tEL_BUILTIN_GETCFN\t(NULL)", "", "/*", " * Source named file or $PWD/.editrc or $HOME/.editrc", " */", "int\t\tel_source(EditLine *, const char *);", "", "/*", " * Must be called when the terminal changes size; If EL_SIGNAL", " * is set this is done automatically otherwise it is the responsibility", " * of the application", " */", "void\t\t el_resize(EditLine *);", "", "/*", " * User-defined function interface.", " */", "const LineInfo\t*el_line(EditLine *);", "int\t\t el_insertstr(EditLine *, const char *);", "void\t\t el_deletestr(EditLine *, int);", "", "", "/*", " * ==== History ====", " */", "", "typedef struct history History;", "", "typedef struct HistEvent {", "\tint\t\t num;", "\tconst char\t*str;", "} HistEvent;", "", "/*", " * History access functions.", " */", "History *\thistory_init(void);", "void\t\thistory_end(History *);", "", "int\t\thistory(History *, HistEvent *, int, ...);", "", "#define\tH_FUNC\t\t 0\t/* , UTSL\t\t*/", "#define\tH_SETSIZE\t 1\t/* , const int);\t*/", "#define\tH_GETSIZE\t 2\t/* , void);\t\t*/", "#define\tH_FIRST\t\t 3\t/* , void);\t\t*/", "#define\tH_LAST\t\t 4\t/* , void);\t\t*/", "#define\tH_PREV\t\t 5\t/* , void);\t\t*/", "#define\tH_NEXT\t\t 6\t/* , void);\t\t*/", "#define\tH_CURR\t\t 8\t/* , void);\t\t*/", "#define\tH_SET\t\t 7\t/* , int);\t\t*/", "#define\tH_ADD\t\t 9\t/* , const wchar_t *);\t*/", "#define\tH_ENTER\t\t10\t/* , const wchar_t *);\t*/", "#define\tH_APPEND\t11\t/* , const wchar_t *);\t*/", "#define\tH_END\t\t12\t/* , void);\t\t*/", "#define\tH_NEXT_STR\t13\t/* , const wchar_t *);\t*/", "#define\tH_PREV_STR\t14\t/* , const wchar_t *);\t*/", "#define\tH_NEXT_EVENT\t15\t/* , const int);\t*/", "#define\tH_PREV_EVENT\t16\t/* , const int);\t*/", "#define\tH_LOAD\t\t17\t/* , const char *);\t*/", "#define\tH_SAVE\t\t18\t/* , const char *);\t*/", "#define\tH_CLEAR\t\t19\t/* , void);\t\t*/", "#define\tH_SETUNIQUE\t20\t/* , int);\t\t*/", "#define\tH_GETUNIQUE\t21\t/* , void);\t\t*/", "#define\tH_DEL\t\t22\t/* , int);\t\t*/", "#define\tH_NEXT_EVDATA\t23\t/* , const int, histdata_t *);\t*/", "#define\tH_DELDATA\t24\t/* , int, histdata_t *);*/", "#define\tH_REPLACE\t25\t/* , const char *, histdata_t);\t*/", "", "", "", "/*", " * ==== Tokenization ====", " */", "", "typedef struct tokenizer Tokenizer;", "", "/*", " * String tokenization functions, using simplified sh(1) quoting rules", " */", "Tokenizer\t*tok_init(const char *);", "void\t\t tok_end(Tokenizer *);", "void\t\t tok_reset(Tokenizer *);", "int\t\t tok_line(Tokenizer *, const LineInfo *,", "\t\t    int *, const char ***, int *, int *);", "int\t\t tok_str(Tokenizer *, const char *,", "\t\t    int *, const char ***);", "", "/*", " * Begin Wide Character Support", " */", "#ifdef __linux__", "/* Apparently we need _GNU_SOURCE defined to get access to wcsdup on Linux */", "#ifndef _GNU_SOURCE", "#define _GNU_SOURCE", "#endif", "#endif", "", "#include <wchar.h>", "#include <wctype.h>", "", "/*", " * Wide character versions", " */", "", "/*", " * ==== Editing ====", " */", "typedef struct lineinfow {", "\tconst wchar_t\t*buffer;", "\tconst wchar_t\t*cursor;", "\tconst wchar_t\t*lastchar;", "} LineInfoW;", "", "const wchar_t\t*el_wgets(EditLine *, int *);", "int\t\t el_wgetc(EditLine *, wchar_t *);", "void\t\t el_wpush(EditLine *, const wchar_t *);", "", "int\t\t el_wparse(EditLine *, int, const wchar_t **);", "", "int\t\t el_wset(EditLine *, int, ...);", "int\t\t el_wget(EditLine *, int, ...);", "", "const LineInfoW\t*el_wline(EditLine *);", "int\t\t el_winsertstr(EditLine *, const wchar_t *);", "#define          el_wdeletestr  el_deletestr", "", "/*", " * ==== History ====", " */", "typedef struct histeventW {", "\tint\t\t num;", "\tconst wchar_t\t*str;", "} HistEventW;", "", "typedef struct historyW HistoryW;", "", "HistoryW *\thistory_winit(void);", "void\t\thistory_wend(HistoryW *);", "", "int\t\thistory_w(HistoryW *, HistEventW *, int, ...);", "", "/*", " * ==== Tokenization ====", " */", "typedef struct tokenizerW TokenizerW;", "", "/* Wide character tokenizer support */", "TokenizerW\t*tok_winit(const wchar_t *);", "void\t\t tok_wend(TokenizerW *);", "void\t\t tok_wreset(TokenizerW *);", "int\t\t tok_wline(TokenizerW *, const LineInfoW *,", "\t\t    int *, const wchar_t ***, int *, int *);", "int\t\t tok_wstr(TokenizerW *, const wchar_t *,", "\t\t    int *, const wchar_t ***);", "", "#ifdef __cplusplus", "}", "#endif", "", "#endif /* _HISTEDIT_H_ */" },
    ["iconv.h"] = { "/* Copyright (C) 1999-2003, 2005-2006 Free Software Foundation, Inc.", "   This file is part of the GNU LIBICONV Library.", "", "   The GNU LIBICONV Library is free software; you can redistribute it", "   and/or modify it under the terms of the GNU Library General Public", "   License as published by the Free Software Foundation; either version 2", "   of the License, or (at your option) any later version.", "", "   The GNU LIBICONV Library is distributed in the hope that it will be", "   useful, but WITHOUT ANY WARRANTY; without even the implied warranty of", "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU", "   Library General Public License for more details.", "", "   You should have received a copy of the GNU Library General Public", "   License along with the GNU LIBICONV Library; see the file COPYING.LIB.", "   If not, write to the Free Software Foundation, Inc., 51 Franklin Street,", "   Fifth Floor, Boston, MA 02110-1301, USA.  */", "", '/* When installed, this file is called "iconv.h". */', "", "#ifndef _LIBICONV_H", "#define _LIBICONV_H", "", "#include <sys/cdefs.h>", "#include <_types.h>", "#include <sys/_types/_size_t.h>", "", "#define _LIBICONV_VERSION 0x010B    /* version number: (major<<8) + minor */", "extern  int _libiconv_version; /* Likewise */", "", "/* We would like to #include any system header file which could define", "   iconv_t, 1. in order to eliminate the risk that the user gets compilation", "   errors because some other system header file includes /usr/include/iconv.h", "   which defines iconv_t or declares iconv after this file, 2. when compiling", "   for LIBICONV_PLUG, we need the proper iconv_t type in order to produce", "   binary compatible code.", "   But gcc's #include_next is not portable. Thus, once libiconv's iconv.h", "   has been installed in /usr/local/include, there is no way any more to", "   include the original /usr/include/iconv.h. We simply have to get away", "   without it.", "   Ad 1. The risk that a system header file does", '   #include "iconv.h"  or  #include_next "iconv.h"', "   is small. They all do #include <iconv.h>.", "   Ad 2. The iconv_t type is a pointer type in all cases I have seen. (It", "   has to be a scalar type because (iconv_t)(-1) is a possible return value", "   from iconv_open().) */", "", "/* Define iconv_t ourselves. */", "#ifndef _ICONV_T", "#define _ICONV_T", "typedef void* iconv_t;", "#endif", "", "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "", "", "/* Allocates descriptor for code conversion from encoding `fromcode' to", "   encoding `tocode'. */", "iconv_t iconv_open (const char* /*tocode*/, const char* /*fromcode*/);", "", "/* Converts, using conversion descriptor `cd', at most `*inbytesleft' bytes", "   starting at `*inbuf', writing at most `*outbytesleft' bytes starting at", "   `*outbuf'.", "   Decrements `*inbytesleft' and increments `*inbuf' by the same amount.", "   Decrements `*outbytesleft' and increments `*outbuf' by the same amount. */", "size_t iconv (iconv_t /*cd*/,", "\tchar ** __restrict /*inbuf*/,  size_t * __restrict /*inbytesleft*/,", "\tchar ** __restrict /*outbuf*/, size_t * __restrict /*outbytesleft*/);", "", "/* Frees resources allocated for conversion descriptor `cd'. */", "int iconv_close (iconv_t /*cd*/);", "", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "", "/* Nonstandard extensions. */", "", "#include <sys/_types/_wchar_t.h>", "", "/* Control of attributes. */", "int iconvctl (iconv_t /*cd*/, int /*request*/, void* /*argument*/);", "", "/* Hook performed after every successful conversion of a Unicode character. */", "typedef void (*iconv_unicode_char_hook) (unsigned int uc, void* data);", "/* Hook performed after every successful conversion of a wide character. */", "typedef void (*iconv_wide_char_hook) (wchar_t wc, void* data);", "/* Set of hooks. */", "struct iconv_hooks {", "  iconv_unicode_char_hook uc_hook;", "  iconv_wide_char_hook wc_hook;", "  void* data;", "};", "", "/* Fallback function.  Invoked when a small number of bytes could not be", "   converted to a Unicode character.  This function should process all", "   bytes from inbuf and may produce replacement Unicode characters by calling", "   the write_replacement callback repeatedly.  */", "typedef void (*iconv_unicode_mb_to_uc_fallback)", "             (const char* inbuf, size_t inbufsize,", "              void (*write_replacement) (const unsigned int *buf, size_t buflen,", "                                         void* callback_arg),", "              void* callback_arg,", "              void* data);", "/* Fallback function.  Invoked when a Unicode character could not be converted", "   to the target encoding.  This function should process the character and", "   may produce replacement bytes (in the target encoding) by calling the", "   write_replacement callback repeatedly.  */", "typedef void (*iconv_unicode_uc_to_mb_fallback)", "             (unsigned int code,", "              void (*write_replacement) (const char *buf, size_t buflen,", "                                         void* callback_arg),", "              void* callback_arg,", "              void* data);", "#if 1", "/* Fallback function.  Invoked when a number of bytes could not be converted to", "   a wide character.  This function should process all bytes from inbuf and may", "   produce replacement wide characters by calling the write_replacement", "   callback repeatedly.  */", "typedef void (*iconv_wchar_mb_to_wc_fallback)", "             (const char* inbuf, size_t inbufsize,", "              void (*write_replacement) (const wchar_t *buf, size_t buflen,", "                                         void* callback_arg),", "              void* callback_arg,", "              void* data);", "/* Fallback function.  Invoked when a wide character could not be converted to", "   the target encoding.  This function should process the character and may", "   produce replacement bytes (in the target encoding) by calling the", "   write_replacement callback repeatedly.  */", "typedef void (*iconv_wchar_wc_to_mb_fallback)", "             (wchar_t code,", "              void (*write_replacement) (const char *buf, size_t buflen,", "                                         void* callback_arg),", "              void* callback_arg,", "              void* data);", "#else", "/* If the wchar_t type does not exist, these two fallback functions are never", "   invoked.  Their argument list therefore does not matter.  */", "typedef void (*iconv_wchar_mb_to_wc_fallback) ();", "typedef void (*iconv_wchar_wc_to_mb_fallback) ();", "#endif", "/* Set of fallbacks. */", "struct iconv_fallbacks {", "  iconv_unicode_mb_to_uc_fallback mb_to_uc_fallback;", "  iconv_unicode_uc_to_mb_fallback uc_to_mb_fallback;", "  iconv_wchar_mb_to_wc_fallback mb_to_wc_fallback;", "  iconv_wchar_wc_to_mb_fallback wc_to_mb_fallback;", "  void* data;", "};", "", "/* Requests for iconvctl. */", "#define ICONV_TRIVIALP            0  /* int *argument */", "#define ICONV_GET_TRANSLITERATE   1  /* int *argument */", "#define ICONV_SET_TRANSLITERATE   2  /* const int *argument */", "#define ICONV_GET_DISCARD_ILSEQ   3  /* int *argument */", "#define ICONV_SET_DISCARD_ILSEQ   4  /* const int *argument */", "#define ICONV_SET_HOOKS           5  /* const struct iconv_hooks *argument */", "#define ICONV_SET_FALLBACKS       6  /* const struct iconv_fallbacks *argument */", "", "/* Listing of locale independent encodings. */", "void iconvlist (int (* /*do_one*/) (unsigned int /*namescount*/,", "                                      const char * const * /*names*/,", "                                      void* /*data*/),", "                       void* /*data*/);", "", "/* Canonicalize an encoding name.", "   The result is either a canonical encoding name, or name itself. */", "extern const char * iconv_canonicalize (const char * name);", "", "/* Support for relocatable packages.  */", "", "/* Sets the original and the current installation prefix of the package.", "   Relocation simply replaces a pathname starting with the original prefix", "   by the corresponding pathname with the current prefix instead.  Both", '   prefixes should be directory names without trailing slash (i.e. use ""', '   instead of "/").  */', "void libiconv_set_relocation_prefix (const char * /*orig_prefix*/,", "\t\t\t\t\t    const char * /*curr_prefix*/);", "", "#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */", "", "", "#ifdef __cplusplus", "}", "#endif", "", "", "#endif /* _LIBICONV_H */" },
    ["ifaddrs.h"] = { "/*\t$FreeBSD: src/include/ifaddrs.h,v 1.3.32.1.4.1 2010/06/14 02:09:06 kensmith Exp $\t*/", "", "/*", " * Copyright (c) 1995, 1999", " *\tBerkeley Software Design, Inc.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " *", " * THIS SOFTWARE IS PROVIDED BY Berkeley Software Design, Inc. ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL Berkeley Software Design, Inc. BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\tBSDI ifaddrs.h,v 2.5 2000/02/23 14:51:59 dab Exp", " */", "", "#ifndef\t_IFADDRS_H_", "#define\t_IFADDRS_H_", "", "#include <Availability.h>", "", "struct ifaddrs {", "\tstruct ifaddrs  *ifa_next;", "\tchar\t\t*ifa_name;", "\tunsigned int\t ifa_flags;", "\tstruct sockaddr\t*ifa_addr;", "\tstruct sockaddr\t*ifa_netmask;", "\tstruct sockaddr\t*ifa_dstaddr;", "\tvoid\t\t*ifa_data;", "};", "", "/*", " * This may have been defined in <net/if.h>.  Note that if <net/if.h> is", " * to be included it must be included before this header file.", " */", "#ifndef\tifa_broadaddr", "#define\tifa_broadaddr\tifa_dstaddr\t/* broadcast address interface */", "#endif", "", "struct ifmaddrs {", "\tstruct ifmaddrs\t*ifma_next;", "\tstruct sockaddr\t*ifma_name;", "\tstruct sockaddr\t*ifma_addr;", "\tstruct sockaddr\t*ifma_lladdr;", "};", "", "#include <sys/cdefs.h>", "", "__BEGIN_DECLS", "extern int getifaddrs(struct ifaddrs **);", "extern void freeifaddrs(struct ifaddrs *);", "extern int getifmaddrs(struct ifmaddrs **) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);", "extern void freeifmaddrs(struct ifmaddrs *) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);", "__END_DECLS", "", "#endif" },
    ["inttypes.h"] = { "/*", " * Copyright (c) 2000-2004, 2013 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "", "/*", " * <inttypes.h> -- Standard C header, defined in ISO/IEC 9899:1999", ' * (aka "C99"), section 7.8.   This defines format string conversion', " * specifiers suitable for use within arguments to fprintf and fscanf", " * and their ilk.", " */", "", "#if !defined(_INTTYPES_H_)", "#define _INTTYPES_H_", "", '#  define __PRI_8_LENGTH_MODIFIER__ "hh"', '#  define __PRI_64_LENGTH_MODIFIER__ "ll"', '#  define __SCN_64_LENGTH_MODIFIER__ "ll"', '#  define __PRI_MAX_LENGTH_MODIFIER__ "j"', '#  define __SCN_MAX_LENGTH_MODIFIER__ "j"', "", '#  define PRId8         __PRI_8_LENGTH_MODIFIER__ "d"', '#  define PRIi8         __PRI_8_LENGTH_MODIFIER__ "i"', '#  define PRIo8         __PRI_8_LENGTH_MODIFIER__ "o"', '#  define PRIu8         __PRI_8_LENGTH_MODIFIER__ "u"', '#  define PRIx8         __PRI_8_LENGTH_MODIFIER__ "x"', '#  define PRIX8         __PRI_8_LENGTH_MODIFIER__ "X"', "", '#  define PRId16        "hd"', '#  define PRIi16        "hi"', '#  define PRIo16        "ho"', '#  define PRIu16        "hu"', '#  define PRIx16        "hx"', '#  define PRIX16        "hX"', "", '#  define PRId32        "d"', '#  define PRIi32        "i"', '#  define PRIo32        "o"', '#  define PRIu32        "u"', '#  define PRIx32        "x"', '#  define PRIX32        "X"', "", '#  define PRId64        __PRI_64_LENGTH_MODIFIER__ "d"', '#  define PRIi64        __PRI_64_LENGTH_MODIFIER__ "i"', '#  define PRIo64        __PRI_64_LENGTH_MODIFIER__ "o"', '#  define PRIu64        __PRI_64_LENGTH_MODIFIER__ "u"', '#  define PRIx64        __PRI_64_LENGTH_MODIFIER__ "x"', '#  define PRIX64        __PRI_64_LENGTH_MODIFIER__ "X"', "", "#  define PRIdLEAST8    PRId8", "#  define PRIiLEAST8    PRIi8", "#  define PRIoLEAST8    PRIo8", "#  define PRIuLEAST8    PRIu8", "#  define PRIxLEAST8    PRIx8", "#  define PRIXLEAST8    PRIX8", "", "#  define PRIdLEAST16   PRId16", "#  define PRIiLEAST16   PRIi16", "#  define PRIoLEAST16   PRIo16", "#  define PRIuLEAST16   PRIu16", "#  define PRIxLEAST16   PRIx16", "#  define PRIXLEAST16   PRIX16", "", "#  define PRIdLEAST32   PRId32", "#  define PRIiLEAST32   PRIi32", "#  define PRIoLEAST32   PRIo32", "#  define PRIuLEAST32   PRIu32", "#  define PRIxLEAST32   PRIx32", "#  define PRIXLEAST32   PRIX32", "", "#  define PRIdLEAST64   PRId64", "#  define PRIiLEAST64   PRIi64", "#  define PRIoLEAST64   PRIo64", "#  define PRIuLEAST64   PRIu64", "#  define PRIxLEAST64   PRIx64", "#  define PRIXLEAST64   PRIX64", "", "#  define PRIdFAST8     PRId8", "#  define PRIiFAST8     PRIi8", "#  define PRIoFAST8     PRIo8", "#  define PRIuFAST8     PRIu8", "#  define PRIxFAST8     PRIx8", "#  define PRIXFAST8     PRIX8", "", "#  define PRIdFAST16    PRId16", "#  define PRIiFAST16    PRIi16", "#  define PRIoFAST16    PRIo16", "#  define PRIuFAST16    PRIu16", "#  define PRIxFAST16    PRIx16", "#  define PRIXFAST16    PRIX16", "", "#  define PRIdFAST32    PRId32", "#  define PRIiFAST32    PRIi32", "#  define PRIoFAST32    PRIo32", "#  define PRIuFAST32    PRIu32", "#  define PRIxFAST32    PRIx32", "#  define PRIXFAST32    PRIX32", "", "#  define PRIdFAST64    PRId64", "#  define PRIiFAST64    PRIi64", "#  define PRIoFAST64    PRIo64", "#  define PRIuFAST64    PRIu64", "#  define PRIxFAST64    PRIx64", "#  define PRIXFAST64    PRIX64", "", "/* int32_t is 'int', but intptr_t is 'long'.  */", '#  define PRIdPTR       "ld"', '#  define PRIiPTR       "li"', '#  define PRIoPTR       "lo"', '#  define PRIuPTR       "lu"', '#  define PRIxPTR       "lx"', '#  define PRIXPTR       "lX"', "", '#  define PRIdMAX        __PRI_MAX_LENGTH_MODIFIER__ "d"', '#  define PRIiMAX        __PRI_MAX_LENGTH_MODIFIER__ "i"', '#  define PRIoMAX        __PRI_MAX_LENGTH_MODIFIER__ "o"', '#  define PRIuMAX        __PRI_MAX_LENGTH_MODIFIER__ "u"', '#  define PRIxMAX        __PRI_MAX_LENGTH_MODIFIER__ "x"', '#  define PRIXMAX        __PRI_MAX_LENGTH_MODIFIER__ "X"', "", '#  define SCNd8         __PRI_8_LENGTH_MODIFIER__ "d"', '#  define SCNi8         __PRI_8_LENGTH_MODIFIER__ "i"', '#  define SCNo8         __PRI_8_LENGTH_MODIFIER__ "o"', '#  define SCNu8         __PRI_8_LENGTH_MODIFIER__ "u"', '#  define SCNx8         __PRI_8_LENGTH_MODIFIER__ "x"', "", '#  define SCNd16        "hd"', '#  define SCNi16        "hi"', '#  define SCNo16        "ho"', '#  define SCNu16        "hu"', '#  define SCNx16        "hx"', "", '#  define SCNd32        "d"', '#  define SCNi32        "i"', '#  define SCNo32        "o"', '#  define SCNu32        "u"', '#  define SCNx32        "x"', "", '#  define SCNd64        __SCN_64_LENGTH_MODIFIER__ "d"', '#  define SCNi64        __SCN_64_LENGTH_MODIFIER__ "i"', '#  define SCNo64        __SCN_64_LENGTH_MODIFIER__ "o"', '#  define SCNu64        __SCN_64_LENGTH_MODIFIER__ "u"', '#  define SCNx64        __SCN_64_LENGTH_MODIFIER__ "x"', "", "#  define SCNdLEAST8    SCNd8", "#  define SCNiLEAST8    SCNi8", "#  define SCNoLEAST8    SCNo8", "#  define SCNuLEAST8    SCNu8", "#  define SCNxLEAST8    SCNx8", "", "#  define SCNdLEAST16   SCNd16", "#  define SCNiLEAST16   SCNi16", "#  define SCNoLEAST16   SCNo16", "#  define SCNuLEAST16   SCNu16", "#  define SCNxLEAST16   SCNx16", "", "#  define SCNdLEAST32   SCNd32", "#  define SCNiLEAST32   SCNi32", "#  define SCNoLEAST32   SCNo32", "#  define SCNuLEAST32   SCNu32", "#  define SCNxLEAST32   SCNx32", "", "#  define SCNdLEAST64   SCNd64", "#  define SCNiLEAST64   SCNi64", "#  define SCNoLEAST64   SCNo64", "#  define SCNuLEAST64   SCNu64", "#  define SCNxLEAST64   SCNx64", "", "#  define SCNdFAST8     SCNd8", "#  define SCNiFAST8     SCNi8", "#  define SCNoFAST8     SCNo8", "#  define SCNuFAST8     SCNu8", "#  define SCNxFAST8     SCNx8", "", "#  define SCNdFAST16    SCNd16", "#  define SCNiFAST16    SCNi16", "#  define SCNoFAST16    SCNo16", "#  define SCNuFAST16    SCNu16", "#  define SCNxFAST16    SCNx16", "", "#  define SCNdFAST32    SCNd32", "#  define SCNiFAST32    SCNi32", "#  define SCNoFAST32    SCNo32", "#  define SCNuFAST32    SCNu32", "#  define SCNxFAST32    SCNx32", "", "#  define SCNdFAST64    SCNd64", "#  define SCNiFAST64    SCNi64", "#  define SCNoFAST64    SCNo64", "#  define SCNuFAST64    SCNu64", "#  define SCNxFAST64    SCNx64", "", '#  define SCNdPTR       "ld"', '#  define SCNiPTR       "li"', '#  define SCNoPTR       "lo"', '#  define SCNuPTR       "lu"', '#  define SCNxPTR       "lx"', "", '#  define SCNdMAX       __SCN_MAX_LENGTH_MODIFIER__ "d"', '#  define SCNiMAX       __SCN_MAX_LENGTH_MODIFIER__ "i"', '#  define SCNoMAX       __SCN_MAX_LENGTH_MODIFIER__ "o"', '#  define SCNuMAX       __SCN_MAX_LENGTH_MODIFIER__ "u"', '#  define SCNxMAX       __SCN_MAX_LENGTH_MODIFIER__ "x"', "", "#include <sys/cdefs.h>", "#include <Availability.h>", "", "#include <_types.h>", "#include <sys/_types/_wchar_t.h>", "", "#include <stdint.h>", "", "__BEGIN_DECLS", "", "/* 7.8.2.1 */", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "extern intmax_t", "imaxabs(intmax_t j);", "", "/* 7.8.2.2 */", "typedef struct {", "\tintmax_t quot;", "\tintmax_t rem;", "} imaxdiv_t;", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "extern imaxdiv_t", "imaxdiv(intmax_t __numer, intmax_t __denom);", "", "/* 7.8.2.3 */", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "extern intmax_t", "strtoimax(const char * __restrict __nptr,", "\t  char ** __restrict __endptr,", "\t  int __base);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "extern uintmax_t", "strtoumax(const char * __restrict __nptr,", "\t  char ** __restrict __endptr,", "\t  int __base);", "", "/* 7.8.2.4 */", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "extern intmax_t", "wcstoimax(const wchar_t * __restrict __nptr,", "\t  wchar_t ** __restrict __endptr,", "\t  int __base);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "extern uintmax_t", "wcstoumax(const wchar_t * __restrict __nptr,", "\t  wchar_t ** __restrict __endptr,", "\t  int __base);", "", "/* Poison the following routines if -fshort-wchar is set */", "#if !defined(__cplusplus) && defined(__WCHAR_MAX__) && __WCHAR_MAX__ <= 0xffffU", "#pragma GCC poison wcstoimax wcstoumax", "#endif", "", "__END_DECLS", "", "#ifdef _USE_EXTENDED_LOCALES_", "#include <xlocale/_inttypes.h>", "#endif /* _USE_EXTENDED_LOCALES_ */", "", "/*", "   No need to #undef the __*_{8,64}_LENGTH_MODIFIER__ macros;", "   in fact, you can't #undef them, because later uses of any of", "   their dependents will *not* then do the intended substitution.", "   Expansion of a #define like this one:", "", "        #define x IDENT y", "", "   uses the cpp value of IDENT at the location where x is *expanded*,", "   not where it is #defined.", "*/", "", "#endif /* !_INTTYPES_H_ */" },
    ["iso646.h"] = { "/*-", " * Copyright (c) 1998 Alex Nash", " * All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " *", " * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " * $FreeBSD: src/include/iso646.h,v 1.4 2002/09/18 22:23:59 mike Exp $", " */", "", "#ifndef _ISO646_H_", "#define\t_ISO646_H_", "", "#include <sys/cdefs.h>", "", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "", "#ifndef __cplusplus", "#define\tand\t&&", "#define\tand_eq\t&=", "#define\tbitand\t&", "#define\tbitor\t|", "#define\tcompl\t~", "#define\tnot\t!", "#define\tnot_eq\t!=", "#define\tor\t||", "#define\tor_eq\t|=", "#define\txor\t^", "#define\txor_eq\t^=", "#endif /* ! __cplusplus */", "", "#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */", "", "#endif /* !_ISO646_H_ */" },
    ["krb5.h"] = { "/* The MIT Kerberos header file krb5.h used to live here.", "", "   As of the 1.5 release, we're installing multiple Kerberos headers,", "   so they're all moving to a krb5/ subdirectory.  This file is", "   present just to keep old software still compiling.  Please update", "   your code to use the new path for the header.  */", "#include <krb5/krb5.h>" },
    ["langinfo.h"] = { "/*-", " * Copyright (c) 2001 Alexey Zelkin <phantom@FreeBSD.org>", " * All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " *", " * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " * $FreeBSD: /repoman/r/ncvs/src/include/langinfo.h,v 1.6 2002/09/18 05:54:25 mike Exp $", " */", "", "#ifndef _LANGINFO_H_", "#define\t_LANGINFO_H_", "", "#include <_types.h>", "#include <_types/_nl_item.h>", "", "#define\tCODESET\t\t0\t/* codeset name */", "#define\tD_T_FMT\t\t1\t/* string for formatting date and time */", "#define\tD_FMT\t\t2\t/* date format string */", "#define\tT_FMT\t\t3\t/* time format string */", "#define\tT_FMT_AMPM\t4\t/* a.m. or p.m. time formatting string */", "#define\tAM_STR\t\t5\t/* Ante Meridian affix */", "#define\tPM_STR\t\t6\t/* Post Meridian affix */", "", "/* week day names */", "#define\tDAY_1\t\t7", "#define\tDAY_2\t\t8", "#define\tDAY_3\t\t9", "#define\tDAY_4\t\t10", "#define\tDAY_5\t\t11", "#define\tDAY_6\t\t12", "#define\tDAY_7\t\t13", "", "/* abbreviated week day names */", "#define\tABDAY_1\t\t14", "#define\tABDAY_2\t\t15", "#define\tABDAY_3\t\t16", "#define\tABDAY_4\t\t17", "#define\tABDAY_5\t\t18", "#define\tABDAY_6\t\t19", "#define\tABDAY_7\t\t20", "", "/* month names */", "#define\tMON_1\t\t21", "#define\tMON_2\t\t22", "#define\tMON_3\t\t23", "#define\tMON_4\t\t24", "#define\tMON_5\t\t25", "#define\tMON_6\t\t26", "#define\tMON_7\t\t27", "#define\tMON_8\t\t28", "#define\tMON_9\t\t29", "#define\tMON_10\t\t30", "#define\tMON_11\t\t31", "#define\tMON_12\t\t32", "", "/* abbreviated month names */", "#define\tABMON_1\t\t33", "#define\tABMON_2\t\t34", "#define\tABMON_3\t\t35", "#define\tABMON_4\t\t36", "#define\tABMON_5\t\t37", "#define\tABMON_6\t\t38", "#define\tABMON_7\t\t39", "#define\tABMON_8\t\t40", "#define\tABMON_9\t\t41", "#define\tABMON_10\t42", "#define\tABMON_11\t43", "#define\tABMON_12\t44", "", "#define\tERA\t\t45\t/* era description segments */", "#define\tERA_D_FMT\t46\t/* era date format string */", "#define\tERA_D_T_FMT\t47\t/* era date and time format string */", "#define\tERA_T_FMT\t48\t/* era time format string */", "#define\tALT_DIGITS\t49\t/* alternative symbols for digits */", "", "#define\tRADIXCHAR\t50\t/* radix char */", "#define\tTHOUSEP\t\t51\t/* separator for thousands */", "", "#define\tYESEXPR\t\t52\t/* affirmative response expression */", "#define\tNOEXPR\t\t53\t/* negative response expression */", "", "#if (__DARWIN_C_LEVEL > __DARWIN_C_ANSI && __DARWIN_C_LEVEL < 200112L) || __DARWIN_C_LEVEL == __DARWIN_C_FULL", "#define\tYESSTR\t\t54\t/* affirmative response for yes/no queries */", "#define\tNOSTR\t\t55\t/* negative response for yes/no queries */", "#endif", "", "#define\tCRNCYSTR\t56\t/* currency symbol */", "", "#if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))", "#define\tD_MD_ORDER\t57\t/* month/day order (local extension) */", "#endif", "", "__BEGIN_DECLS", "char\t*nl_langinfo(nl_item);", "__END_DECLS", "", "#ifdef _USE_EXTENDED_LOCALES_", "#include <xlocale/_langinfo.h>", "#endif /* _USE_EXTENDED_LOCALES_ */", "", "#endif /* !_LANGINFO_H_ */" },
    ["launch.h"] = { "/*", " * Copyright (c) 2005 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_APACHE_LICENSE_HEADER_START@", " * ", ' * Licensed under the Apache License, Version 2.0 (the "License");', " * you may not use this file except in compliance with the License.", " * You may obtain a copy of the License at", " * ", " *     http://www.apache.org/licenses/LICENSE-2.0", " * ", " * Unless required by applicable law or agreed to in writing, software", ' * distributed under the License is distributed on an "AS IS" BASIS,', " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.", " * See the License for the specific language governing permissions and", " * limitations under the License.", " * ", " * @APPLE_APACHE_LICENSE_HEADER_END@", " */", "", "#ifndef __LAUNCH_H__", "#define __LAUNCH_H__", "", "#include <mach/mach.h>", "#include <sys/cdefs.h>", "#include <stddef.h>", "#include <stdbool.h>", "", "#pragma GCC visibility push(default)", "", "__BEGIN_DECLS", "", "#ifdef __GNUC__", "#define __ld_normal __attribute__((__nothrow__))", "#define __ld_setter __attribute__((__nothrow__, __nonnull__))", "#define __ld_getter __attribute__((__nothrow__, __nonnull__, __pure__, __warn_unused_result__))", "#define __ld_iterator(x, y) __attribute__((__nonnull__(x, y)))", "#define __ld_allocator __attribute__((__nothrow__, __malloc__, __nonnull__, __warn_unused_result__))", "#else", "#define __ld_normal", "#define __ld_setter", "#define __ld_getter", "#define __ld_iterator(x, y)", "#define __ld_allocator", "#endif", "", '#define LAUNCH_KEY_SUBMITJOB "SubmitJob"', '#define LAUNCH_KEY_REMOVEJOB "RemoveJob"', '#define LAUNCH_KEY_STARTJOB "StartJob"', '#define LAUNCH_KEY_STOPJOB "StopJob"', '#define LAUNCH_KEY_GETJOB "GetJob"', '#define LAUNCH_KEY_GETJOBS "GetJobs"', '#define LAUNCH_KEY_CHECKIN "CheckIn"', "", '#define LAUNCH_JOBKEY_DEFAULTS "__Defaults"', "", '#define LAUNCH_JOBKEY_LABEL "Label"', '#define LAUNCH_JOBKEY_DISABLED "Disabled"', '#define LAUNCH_JOBKEY_USERNAME "UserName"', '#define LAUNCH_JOBKEY_GROUPNAME "GroupName"', '#define LAUNCH_JOBKEY_TIMEOUT "TimeOut"', '#define LAUNCH_JOBKEY_EXITTIMEOUT "ExitTimeOut"', '#define LAUNCH_JOBKEY_INITGROUPS "InitGroups"', '#define LAUNCH_JOBKEY_SOCKETS "Sockets"', '#define LAUNCH_JOBKEY_MACHSERVICES "MachServices"', '#define LAUNCH_JOBKEY_MACHSERVICELOOKUPPOLICIES "MachServiceLookupPolicies"', '#define LAUNCH_JOBKEY_INETDCOMPATIBILITY "inetdCompatibility"', '#define LAUNCH_JOBKEY_ENABLEGLOBBING "EnableGlobbing"', '#define LAUNCH_JOBKEY_PROGRAMARGUMENTS "ProgramArguments"', '#define LAUNCH_JOBKEY_PROGRAM "Program"', '#define LAUNCH_JOBKEY_ONDEMAND "OnDemand"', '#define LAUNCH_JOBKEY_KEEPALIVE "KeepAlive"', '#define LAUNCH_JOBKEY_LIMITLOADTOHOSTS "LimitLoadToHosts"', '#define LAUNCH_JOBKEY_LIMITLOADFROMHOSTS "LimitLoadFromHosts"', '#define LAUNCH_JOBKEY_LIMITLOADTOSESSIONTYPE "LimitLoadToSessionType"', '#define LAUNCH_JOBKEY_LIMITLOADTOHARDWARE "LimitLoadToHardware"', '#define LAUNCH_JOBKEY_LIMITLOADFROMHARDWARE "LimitLoadFromHardware"', '#define LAUNCH_JOBKEY_RUNATLOAD "RunAtLoad"', '#define LAUNCH_JOBKEY_ROOTDIRECTORY "RootDirectory"', '#define LAUNCH_JOBKEY_WORKINGDIRECTORY "WorkingDirectory"', '#define LAUNCH_JOBKEY_ENVIRONMENTVARIABLES "EnvironmentVariables"', '#define LAUNCH_JOBKEY_USERENVIRONMENTVARIABLES "UserEnvironmentVariables"', '#define LAUNCH_JOBKEY_UMASK "Umask"', '#define LAUNCH_JOBKEY_NICE "Nice"', '#define LAUNCH_JOBKEY_HOPEFULLYEXITSFIRST "HopefullyExitsFirst"', '#define LAUNCH_JOBKEY_HOPEFULLYEXITSLAST "HopefullyExitsLast"', '#define LAUNCH_JOBKEY_LOWPRIORITYIO "LowPriorityIO"', '#define LAUNCH_JOBKEY_SESSIONCREATE "SessionCreate"', '#define LAUNCH_JOBKEY_STARTONMOUNT "StartOnMount"', '#define LAUNCH_JOBKEY_SOFTRESOURCELIMITS "SoftResourceLimits"', '#define LAUNCH_JOBKEY_HARDRESOURCELIMITS "HardResourceLimits"', '#define LAUNCH_JOBKEY_STANDARDINPATH "StandardInPath"', '#define LAUNCH_JOBKEY_STANDARDOUTPATH "StandardOutPath"', '#define LAUNCH_JOBKEY_STANDARDERRORPATH "StandardErrorPath"', '#define LAUNCH_JOBKEY_DEBUG "Debug"', '#define LAUNCH_JOBKEY_WAITFORDEBUGGER "WaitForDebugger"', '#define LAUNCH_JOBKEY_QUEUEDIRECTORIES "QueueDirectories"', '#define LAUNCH_JOBKEY_WATCHPATHS "WatchPaths"', '#define LAUNCH_JOBKEY_STARTINTERVAL "StartInterval"', '#define LAUNCH_JOBKEY_STARTCALENDARINTERVAL "StartCalendarInterval"', '#define LAUNCH_JOBKEY_BONJOURFDS "BonjourFDs"', '#define LAUNCH_JOBKEY_LASTEXITSTATUS "LastExitStatus"', '#define LAUNCH_JOBKEY_PID "PID"', '#define LAUNCH_JOBKEY_THROTTLEINTERVAL "ThrottleInterval"', '#define LAUNCH_JOBKEY_LAUNCHONLYONCE "LaunchOnlyOnce"', '#define LAUNCH_JOBKEY_ABANDONPROCESSGROUP "AbandonProcessGroup"', '#define LAUNCH_JOBKEY_IGNOREPROCESSGROUPATSHUTDOWN\t"IgnoreProcessGroupAtShutdown"', '#define LAUNCH_JOBKEY_POLICIES "Policies"', '#define LAUNCH_JOBKEY_ENABLETRANSACTIONS "EnableTransactions"', '#define LAUNCH_JOBKEY_CFBUNDLEIDENTIFIER "CFBundleIdentifier"', '#define LAUNCH_JOBKEY_PROCESSTYPE "ProcessType"', '#define LAUNCH_KEY_PROCESSTYPE_APP "App"', '#define LAUNCH_KEY_PROCESSTYPE_STANDARD "Standard"', '#define LAUNCH_KEY_PROCESSTYPE_BACKGROUND "Background"', '#define LAUNCH_KEY_PROCESSTYPE_INTERACTIVE "Interactive"', '#define LAUNCH_KEY_PROCESSTYPE_ADAPTIVE "Adaptive"', "", '#define LAUNCH_JOBPOLICY_DENYCREATINGOTHERJOBS "DenyCreatingOtherJobs"', "", '#define LAUNCH_JOBINETDCOMPATIBILITY_WAIT "Wait"', "", '#define LAUNCH_JOBKEY_MACH_RESETATCLOSE "ResetAtClose"', '#define LAUNCH_JOBKEY_MACH_HIDEUNTILCHECKIN "HideUntilCheckIn"', '#define LAUNCH_JOBKEY_MACH_DRAINMESSAGESONCRASH "DrainMessagesOnCrash"', '#define LAUNCH_JOBKEY_MACH_PINGEVENTUPDATES "PingEventUpdates"', "", '#define LAUNCH_JOBKEY_KEEPALIVE_SUCCESSFULEXIT "SuccessfulExit"', '#define LAUNCH_JOBKEY_KEEPALIVE_NETWORKSTATE "NetworkState"', '#define LAUNCH_JOBKEY_KEEPALIVE_PATHSTATE "PathState"', '#define LAUNCH_JOBKEY_KEEPALIVE_OTHERJOBACTIVE "OtherJobActive"', '#define LAUNCH_JOBKEY_KEEPALIVE_OTHERJOBENABLED "OtherJobEnabled"', '#define LAUNCH_JOBKEY_KEEPALIVE_AFTERINITIALDEMAND\t"AfterInitialDemand"', '#define LAUNCH_JOBKEY_KEEPALIVE_CRASHED "Crashed"', "", '#define LAUNCH_JOBKEY_LAUNCHEVENTS "LaunchEvents"', "", '#define LAUNCH_JOBKEY_CAL_MINUTE "Minute"', '#define LAUNCH_JOBKEY_CAL_HOUR "Hour"', '#define LAUNCH_JOBKEY_CAL_DAY "Day"', '#define LAUNCH_JOBKEY_CAL_WEEKDAY "Weekday"', '#define LAUNCH_JOBKEY_CAL_MONTH "Month"', "", '#define LAUNCH_JOBKEY_RESOURCELIMIT_CORE "Core"', '#define LAUNCH_JOBKEY_RESOURCELIMIT_CPU "CPU"', '#define LAUNCH_JOBKEY_RESOURCELIMIT_DATA "Data"', '#define LAUNCH_JOBKEY_RESOURCELIMIT_FSIZE "FileSize"', '#define LAUNCH_JOBKEY_RESOURCELIMIT_MEMLOCK "MemoryLock"', '#define LAUNCH_JOBKEY_RESOURCELIMIT_NOFILE "NumberOfFiles"', '#define LAUNCH_JOBKEY_RESOURCELIMIT_NPROC "NumberOfProcesses"', '#define LAUNCH_JOBKEY_RESOURCELIMIT_RSS "ResidentSetSize"', '#define LAUNCH_JOBKEY_RESOURCELIMIT_STACK "Stack"', "", '#define LAUNCH_JOBKEY_DISABLED_MACHINETYPE "MachineType"', '#define LAUNCH_JOBKEY_DISABLED_MODELNAME "ModelName"', "", '#define LAUNCH_JOBSOCKETKEY_TYPE "SockType"', '#define LAUNCH_JOBSOCKETKEY_PASSIVE "SockPassive"', '#define LAUNCH_JOBSOCKETKEY_BONJOUR "Bonjour"', '#define LAUNCH_JOBSOCKETKEY_SECUREWITHKEY "SecureSocketWithKey"', '#define LAUNCH_JOBSOCKETKEY_PATHNAME "SockPathName"', '#define LAUNCH_JOBSOCKETKEY_PATHMODE "SockPathMode"', '#define LAUNCH_JOBSOCKETKEY_NODENAME "SockNodeName"', '#define LAUNCH_JOBSOCKETKEY_SERVICENAME "SockServiceName"', '#define LAUNCH_JOBSOCKETKEY_FAMILY "SockFamily"', '#define LAUNCH_JOBSOCKETKEY_PROTOCOL "SockProtocol"', '#define LAUNCH_JOBSOCKETKEY_MULTICASTGROUP "MulticastGroup"', "", "/* These APIs are NOT suitable for general use. Their use should be constrained", " * to checking into launchd to obtain socket file descriptors using the", " * LAUNCH_CHECK_IN message type.", " */", "typedef struct _launch_data *launch_data_t;", "", "typedef enum {", "\tLAUNCH_DATA_DICTIONARY = 1,", "\tLAUNCH_DATA_ARRAY,", "\tLAUNCH_DATA_FD,", "\tLAUNCH_DATA_INTEGER,", "\tLAUNCH_DATA_REAL,", "\tLAUNCH_DATA_BOOL,", "\tLAUNCH_DATA_STRING,", "\tLAUNCH_DATA_OPAQUE,", "\tLAUNCH_DATA_ERRNO,", "\tLAUNCH_DATA_MACHPORT,", "} launch_data_type_t;", "", "__ld_allocator", "launch_data_t", "launch_data_alloc(launch_data_type_t);", "", "__ld_allocator", "launch_data_t", "launch_data_copy(launch_data_t);", "", "__ld_getter", "launch_data_type_t", "launch_data_get_type(const launch_data_t);", "", "__ld_setter", "void", "launch_data_free(launch_data_t);", "", "__ld_setter", "bool", "launch_data_dict_insert(launch_data_t, const launch_data_t, const char *);", "", "__ld_getter", "launch_data_t", "launch_data_dict_lookup(const launch_data_t, const char *);", "", "__ld_setter", "bool", "launch_data_dict_remove(launch_data_t, const char *);", "", "__ld_iterator(1, 2)", "void", "launch_data_dict_iterate(const launch_data_t,", "\tvoid (*)(const launch_data_t, const char *, void *), void *);", "", "__ld_getter", "size_t", "launch_data_dict_get_count(const launch_data_t);", "", "__ld_setter", "bool", "launch_data_array_set_index(launch_data_t, const launch_data_t, size_t);", "", "__ld_getter", "launch_data_t", "launch_data_array_get_index(const launch_data_t, size_t);", "", "__ld_getter", "size_t", "launch_data_array_get_count(const launch_data_t);", "", "__ld_allocator", "launch_data_t", "launch_data_new_fd(int);", "", "__ld_allocator", "launch_data_t", "launch_data_new_machport(mach_port_t);", "", "__ld_allocator", "launch_data_t", "launch_data_new_integer(long long);", "", "__ld_allocator", "launch_data_t", "launch_data_new_bool(bool);", "", "__ld_allocator", "launch_data_t", "launch_data_new_real(double);", "", "__ld_allocator", "launch_data_t", "launch_data_new_string(const char *);", "", "__ld_allocator", "launch_data_t", "launch_data_new_opaque(const void *, size_t);", "", " __ld_setter", "bool", "launch_data_set_fd(launch_data_t, int);", "", " __ld_setter", "bool", "launch_data_set_machport(launch_data_t, mach_port_t);", "", " __ld_setter", "bool", "launch_data_set_integer(launch_data_t, long long);", "", " __ld_setter", "bool", "launch_data_set_bool(launch_data_t, bool);", "", " __ld_setter", "bool", "launch_data_set_real(launch_data_t, double);", "", " __ld_setter", "bool", "launch_data_set_string(launch_data_t, const char *);", "", " __ld_setter", "bool", "launch_data_set_opaque(launch_data_t, const void *, size_t);", "", "__ld_getter", "int\t", "launch_data_get_fd(const launch_data_t);", "", "__ld_getter", "mach_port_t", "launch_data_get_machport(const launch_data_t);", "", "__ld_getter", "long long", "launch_data_get_integer(const launch_data_t);", "", "__ld_getter", "bool", "launch_data_get_bool(const launch_data_t);", "", "__ld_getter", "double", "launch_data_get_real(const launch_data_t);", "", "__ld_getter", "const char *", "launch_data_get_string(const launch_data_t);", "", "__ld_getter", "void *", "launch_data_get_opaque(const launch_data_t);", "", "__ld_getter", "size_t", "launch_data_get_opaque_size(const launch_data_t);", "", "__ld_getter", "int", "launch_data_get_errno(const launch_data_t);", "", "", "/* launch_get_fd()", " *", " * Use this to get the FD if you're doing asynchronous I/O with select(),", " * poll() or kevent().", " */", "__ld_normal", "int", "launch_get_fd(void);", "", "/* launch_msg()", " *", " * Use this API to check in. Nothing else.", " */", "__ld_normal", "launch_data_t", "launch_msg(const launch_data_t);", "", "__END_DECLS", "", "#pragma GCC visibility pop", "", "#endif /* __LAUNCH_H__ */" },
    ["lber.h"] = { "/* $OpenLDAP$ */", "/* This work is part of OpenLDAP Software <http://www.openldap.org/>.", " *", " * Copyright 1998-2011 The OpenLDAP Foundation.", " * All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted only as authorized by the OpenLDAP", " * Public License.", " *", " * A copy of this license is available in file LICENSE in the", " * top-level directory of the distribution or, alternatively, at", " * <http://www.OpenLDAP.org/license.html>.", " */", "/* Portions Copyright (c) 1990 Regents of the University of Michigan.", " * All rights reserved.", " *", " * Redistribution and use in source and binary forms are permitted", " * provided that this notice is preserved and that due credit is given", " * to the University of Michigan at Ann Arbor. The name of the University", " * may not be used to endorse or promote products derived from this", " * software without specific prior written permission. This software", " * is provided ``as is'' without express or implied warranty.", " */", "", "#ifndef _LBER_H", "#define _LBER_H", "", "#include <lber_types.h>", "#include <string.h>", "", "LDAP_BEGIN_DECL", "", "/*", " * ber_tag_t represents the identifier octets at the beginning of BER", " * elements.  OpenLDAP treats them as mere big-endian unsigned integers.", " *", " * Actually the BER identifier octets look like this:", " *", " *\tBits of 1st octet:", " *\t______", " *\t8 7 | CLASS", " *\t0 0 = UNIVERSAL", " *\t0 1 = APPLICATION", " *\t1 0 = CONTEXT-SPECIFIC", " *\t1 1 = PRIVATE", " *\t\t_____", " *\t\t| 6 | DATA-TYPE", " *\t\t  0 = PRIMITIVE", " *\t\t  1 = CONSTRUCTED", " *\t\t\t___________", " *\t\t\t| 5 ... 1 | TAG-NUMBER", " *", " *  For ASN.1 tag numbers >= 0x1F, TAG-NUMBER above is 0x1F and the next", " *  BER octets contain the actual ASN.1 tag number:  Big-endian, base", " *  128, 8.bit = 1 in all but the last octet, minimum number of octets.", " */", "", "/* BER classes and mask (in 1st identifier octet) */", "#define LBER_CLASS_UNIVERSAL\t((ber_tag_t) 0x00U)", "#define LBER_CLASS_APPLICATION\t((ber_tag_t) 0x40U)", "#define LBER_CLASS_CONTEXT\t\t((ber_tag_t) 0x80U)", "#define LBER_CLASS_PRIVATE\t\t((ber_tag_t) 0xc0U)", "#define LBER_CLASS_MASK\t\t\t((ber_tag_t) 0xc0U)", "", "/* BER encoding type and mask (in 1st identifier octet) */", "#define LBER_PRIMITIVE\t\t\t((ber_tag_t) 0x00U)", "#define LBER_CONSTRUCTED\t\t((ber_tag_t) 0x20U)", "#define LBER_ENCODING_MASK\t\t((ber_tag_t) 0x20U)", "", "#define LBER_BIG_TAG_MASK\t\t((ber_tag_t) 0x1fU)", "#define LBER_MORE_TAG_MASK\t\t((ber_tag_t) 0x80U)", "", "/*", " * LBER_ERROR and LBER_DEFAULT are values that can never appear", " * as valid BER tags, so it is safe to use them to report errors.", " * Valid tags have (tag & (ber_tag_t) 0xFF) != 0xFF.", " */", "#define LBER_ERROR\t\t\t((ber_tag_t) -1)", "#define LBER_DEFAULT\t\t((ber_tag_t) -1)", "", "/* general BER types we know about */", "#define LBER_BOOLEAN\t\t((ber_tag_t) 0x01UL)", "#define LBER_INTEGER\t\t((ber_tag_t) 0x02UL)", "#define LBER_BITSTRING\t\t((ber_tag_t) 0x03UL)", "#define LBER_OCTETSTRING\t((ber_tag_t) 0x04UL)", "#define LBER_NULL\t\t\t((ber_tag_t) 0x05UL)", "#define LBER_ENUMERATED\t\t((ber_tag_t) 0x0aUL)", "#define LBER_SEQUENCE\t\t((ber_tag_t) 0x30UL)\t/* constructed */", "#define LBER_SET\t\t\t((ber_tag_t) 0x31UL)\t/* constructed */", "", "/* LBER BerElement options */", "#define LBER_USE_DER\t\t0x01", "", "/* get/set options for BerElement */", "#define LBER_OPT_BER_OPTIONS\t\t\t0x01", "#define LBER_OPT_BER_DEBUG\t\t\t\t0x02", "#define LBER_OPT_BER_REMAINING_BYTES\t0x03", "#define LBER_OPT_BER_TOTAL_BYTES\t\t0x04", "#define LBER_OPT_BER_BYTES_TO_WRITE\t\t0x05", "#define LBER_OPT_BER_MEMCTX\t\t\t\t0x06", "", "#define LBER_OPT_DEBUG_LEVEL\tLBER_OPT_BER_DEBUG", "#define LBER_OPT_REMAINING_BYTES\tLBER_OPT_BER_REMAINING_BYTES", "#define LBER_OPT_TOTAL_BYTES\t\tLBER_OPT_BER_TOTAL_BYTES", "#define LBER_OPT_BYTES_TO_WRITE\t\tLBER_OPT_BER_BYTES_TO_WRITE", "", "#define LBER_OPT_LOG_PRINT_FN\t0x8001", "#define LBER_OPT_MEMORY_FNS\t\t0x8002", "#define LBER_OPT_ERROR_FN\t\t0x8003", "#define LBER_OPT_LOG_PRINT_FILE\t\t0x8004", "", "/* get/set Memory Debug options */", "#define LBER_OPT_MEMORY_INUSE\t\t0x8005\t/* for memory debugging */", "#define LBER_OPT_LOG_PROC           0x8006  /* for external logging function */", "", "typedef int* (*BER_ERRNO_FN) LDAP_P(( void ));", "", "typedef void (*BER_LOG_PRINT_FN) LDAP_P(( LDAP_CONST char *buf ));", "", "typedef void* (BER_MEMALLOC_FN)\tLDAP_P(( ber_len_t size, void *ctx ));", "typedef void* (BER_MEMCALLOC_FN)\tLDAP_P(( ber_len_t n, ber_len_t size, void *ctx ));", "typedef void* (BER_MEMREALLOC_FN)\tLDAP_P(( void *p, ber_len_t size, void *ctx ));", "typedef void  (BER_MEMFREE_FN)\t\tLDAP_P(( void *p, void *ctx ));", "", "typedef struct lber_memory_fns {", "\tBER_MEMALLOC_FN\t*bmf_malloc;", "\tBER_MEMCALLOC_FN *bmf_calloc;", "\tBER_MEMREALLOC_FN *bmf_realloc;", "\tBER_MEMFREE_FN *bmf_free;", "} BerMemoryFunctions;", "", "/* LBER Sockbuf_IO options */", "#define LBER_SB_OPT_GET_FD\t\t1", "#define LBER_SB_OPT_SET_FD\t\t2", "#define LBER_SB_OPT_HAS_IO\t\t3", "#define LBER_SB_OPT_SET_NONBLOCK\t4", "#define LBER_SB_OPT_GET_SSL\t\t7", "#define LBER_SB_OPT_DATA_READY\t\t8", "#define LBER_SB_OPT_SET_READAHEAD\t9", "#define LBER_SB_OPT_DRAIN\t\t10", "#define LBER_SB_OPT_NEEDS_READ\t\t11", "#define LBER_SB_OPT_NEEDS_WRITE\t\t12", "#define LBER_SB_OPT_GET_MAX_INCOMING\t13", "#define LBER_SB_OPT_SET_MAX_INCOMING\t14", "", "/* Only meaningful ifdef LDAP_PF_LOCAL_SENDMSG */", "#define LBER_SB_OPT_UNGET_BUF\t15", "", "/* Largest option used by the library */", "#define LBER_SB_OPT_OPT_MAX\t\t15", "", "/* LBER IO operations stacking levels */", "#define LBER_SBIOD_LEVEL_PROVIDER\t10", "#define LBER_SBIOD_LEVEL_TRANSPORT\t20", "#define LBER_SBIOD_LEVEL_APPLICATION\t30", "", "/* get/set options for Sockbuf */", "#define LBER_OPT_SOCKBUF_DESC\t\t0x1000", "#define LBER_OPT_SOCKBUF_OPTIONS\t0x1001", "#define LBER_OPT_SOCKBUF_DEBUG\t\t0x1002", "", "/* on/off values */", "LBER_V( char ) ber_pvt_opt_on;", "#define LBER_OPT_ON\t\t((void *) &ber_pvt_opt_on)", "#define LBER_OPT_OFF\t((void *) 0)", "", "#define LBER_OPT_SUCCESS\t(0)", "#define LBER_OPT_ERROR\t\t(-1)", "", "typedef struct berelement BerElement;", "typedef struct sockbuf Sockbuf;", "", "typedef struct sockbuf_io Sockbuf_IO;", "", "/* Structure for LBER IO operarion descriptor */", "typedef struct sockbuf_io_desc {", "\tint\t\t\tsbiod_level;", "\tSockbuf\t\t\t*sbiod_sb;", "\tSockbuf_IO\t\t*sbiod_io;", "\tvoid \t\t\t*sbiod_pvt;", "\tstruct sockbuf_io_desc\t*sbiod_next;", "} Sockbuf_IO_Desc;", "", "/* Structure for LBER IO operation functions */", "struct sockbuf_io {", "\tint (*sbi_setup)( Sockbuf_IO_Desc *sbiod, void *arg );", "\tint (*sbi_remove)( Sockbuf_IO_Desc *sbiod );", "\tint (*sbi_ctrl)( Sockbuf_IO_Desc *sbiod, int opt, void *arg);", "", "\tber_slen_t (*sbi_read)( Sockbuf_IO_Desc *sbiod, void *buf,", "\t\tber_len_t len );", "\tber_slen_t (*sbi_write)( Sockbuf_IO_Desc *sbiod, void *buf,", "\t\tber_len_t len );", "", "\tint (*sbi_close)( Sockbuf_IO_Desc *sbiod );", "};", "", "/* Helper macros for LBER IO functions */", "#define LBER_SBIOD_READ_NEXT( sbiod, buf, len ) \\", "\t( (sbiod)->sbiod_next->sbiod_io->sbi_read( (sbiod)->sbiod_next, \\", "\t\tbuf, len ) )", "#define LBER_SBIOD_WRITE_NEXT( sbiod, buf, len ) \\", "\t( (sbiod)->sbiod_next->sbiod_io->sbi_write( (sbiod)->sbiod_next, \\", "\t\tbuf, len ) )", "#define LBER_SBIOD_CTRL_NEXT( sbiod, opt, arg ) \\", "\t( (sbiod)->sbiod_next ? \\", "\t\t( (sbiod)->sbiod_next->sbiod_io->sbi_ctrl( \\", "\t\t(sbiod)->sbiod_next, opt, arg ) ) : 0 )", "", "/* structure for returning a sequence of octet strings + length */", "typedef struct berval {", "\tber_len_t\tbv_len;", "\tchar\t\t*bv_val;", "} BerValue;", "", "typedef BerValue *BerVarray;\t/* To distinguish from a single bv */", "", "/* this should be moved to lber-int.h */", "", "/*", " * in bprint.c:", " */", "LBER_F( void )", "ber_error_print LDAP_P((", "\tLDAP_CONST char *data ));", "", "LBER_F( void )", "ber_bprint LDAP_P((", "\tLDAP_CONST char *data, ber_len_t len ));", "", "LBER_F( void )", "ber_dump LDAP_P((", "\tBerElement *ber, int inout ));", "", "/*", " * in decode.c:", " */", "typedef int (*BERDecodeCallback) LDAP_P((", "\tBerElement *ber,", "\tvoid *data,", "\tint mode ));", "", "LBER_F( ber_tag_t )", "ber_get_tag LDAP_P((", "\tBerElement *ber ));", "", "LBER_F( ber_tag_t )", "ber_skip_tag LDAP_P((", "\tBerElement *ber,", "\tber_len_t *len ));", "", "LBER_F( ber_tag_t )", "ber_peek_tag LDAP_P((", "\tBerElement *ber,", "\tber_len_t *len ));", "", "LBER_F( ber_tag_t )", "ber_skip_element LDAP_P((", "\tBerElement *ber,", "\tstruct berval *bv ));", "", "LBER_F( ber_tag_t )", "ber_peek_element LDAP_P((", "\tLDAP_CONST BerElement *ber,", "\tstruct berval *bv ));", "", "LBER_F( ber_tag_t )", "ber_get_int LDAP_P((", "\tBerElement *ber,", "\tber_int_t *num ));", "", "LBER_F( ber_tag_t )", "ber_get_enum LDAP_P((", "\tBerElement *ber,", "\tber_int_t *num ));", "", "LBER_F( ber_tag_t )", "ber_get_stringb LDAP_P((", "\tBerElement *ber,", "\tchar *buf,", "\tber_len_t *len ));", "", "#define\tLBER_BV_ALLOC\t0x01\t/* allocate/copy result, otherwise in-place */", "#define\tLBER_BV_NOTERM\t0x02\t/* omit NUL-terminator if parsing in-place */", "#define\tLBER_BV_STRING\t0x04\t/* fail if berval contains embedded \\0 */", "/* LBER_BV_STRING currently accepts a terminating \\0 in the berval, because", " * Active Directory sends that in at least the diagonsticMessage field.", " */", "", "LBER_F( ber_tag_t )", "ber_get_stringbv LDAP_P((", "\tBerElement *ber,", "\tstruct berval *bv,", "\tint options ));", "", "LBER_F( ber_tag_t )", "ber_get_stringa LDAP_P((", "\tBerElement *ber,", "\tchar **buf ));", "", "LBER_F( ber_tag_t )", "ber_get_stringal LDAP_P((", "\tBerElement *ber,", "\tstruct berval **bv ));", "", "LBER_F( ber_tag_t )", "ber_get_bitstringa LDAP_P((", "\tBerElement *ber,", "\tchar **buf,", "\tber_len_t *len ));", "", "LBER_F( ber_tag_t )", "ber_get_null LDAP_P((", "\tBerElement *ber ));", "", "LBER_F( ber_tag_t )", "ber_get_boolean LDAP_P((", "\tBerElement *ber,", "\tber_int_t *boolval ));", "", "LBER_F( ber_tag_t )", "ber_first_element LDAP_P((", "\tBerElement *ber,", "\tber_len_t *len,", "\tchar **last ));", "", "LBER_F( ber_tag_t )", "ber_next_element LDAP_P((", "\tBerElement *ber,", "\tber_len_t *len,", "\tLDAP_CONST char *last ));", "", "LBER_F( ber_tag_t )", "ber_scanf LDAP_P((", "\tBerElement *ber,", "\tLDAP_CONST char *fmt,", "\t... ));", "", "LBER_F( int )", "ber_decode_oid LDAP_P((", "\tstruct berval *in,", "\tstruct berval *out ));", "", "/*", " * in encode.c", " */", "LBER_F( int )", "ber_encode_oid LDAP_P((", "\tstruct berval *in,", "\tstruct berval *out ));", "", "typedef int (*BEREncodeCallback) LDAP_P((", "\tBerElement *ber,", "\tvoid *data ));", "", "LBER_F( int )", "ber_put_enum LDAP_P((", "\tBerElement *ber,", "\tber_int_t num,", "\tber_tag_t tag ));", "", "LBER_F( int )", "ber_put_int LDAP_P((", "\tBerElement *ber,", "\tber_int_t num,", "\tber_tag_t tag ));", "", "LBER_F( int )", "ber_put_ostring LDAP_P((", "\tBerElement *ber,", "\tLDAP_CONST char *str,", "\tber_len_t len,", "\tber_tag_t tag ));", "", "LBER_F( int )", "ber_put_berval LDAP_P((", "\tBerElement *ber,", "\tstruct berval *bv,", "\tber_tag_t tag ));", "", "LBER_F( int )", "ber_put_string LDAP_P((", "\tBerElement *ber,", "\tLDAP_CONST char *str,", "\tber_tag_t tag ));", "", "LBER_F( int )", "ber_put_bitstring LDAP_P((", "\tBerElement *ber,", "\tLDAP_CONST char *str,", "\tber_len_t bitlen,", "\tber_tag_t tag ));", "", "LBER_F( int )", "ber_put_null LDAP_P((", "\tBerElement *ber,", "\tber_tag_t tag ));", "", "LBER_F( int )", "ber_put_boolean LDAP_P((", "\tBerElement *ber,", "\tber_int_t boolval,", "\tber_tag_t tag ));", "", "LBER_F( int )", "ber_start_seq LDAP_P((", "\tBerElement *ber,", "\tber_tag_t tag ));", "", "LBER_F( int )", "ber_start_set LDAP_P((", "\tBerElement *ber,", "\tber_tag_t tag ));", "", "LBER_F( int )", "ber_put_seq LDAP_P((", "\tBerElement *ber ));", "", "LBER_F( int )", "ber_put_set LDAP_P((", "\tBerElement *ber ));", "", "LBER_F( int )", "ber_printf LDAP_P((", "\tBerElement *ber,", "\tLDAP_CONST char *fmt,", "\t... ));", "", "", "/*", " * in io.c:", " */", "", "LBER_F( ber_slen_t )", "ber_skip_data LDAP_P((", "\tBerElement *ber,", "\tber_len_t len ));", "", "LBER_F( ber_slen_t )", "ber_read LDAP_P((", "\tBerElement *ber,", "\tchar *buf,", "\tber_len_t len ));", "", "LBER_F( ber_slen_t )", "ber_write LDAP_P((", "\tBerElement *ber,", "\tLDAP_CONST char *buf,", "\tber_len_t len,", "\tint zero ));\t/* nonzero is unsupported from OpenLDAP 2.4.18 */", "", "LBER_F( void )", "ber_free LDAP_P((", "\tBerElement *ber,", "\tint freebuf ));", "", "LBER_F( void )", "ber_free_buf LDAP_P(( BerElement *ber ));", "", "LBER_F( int )", "ber_flush2 LDAP_P((", "\tSockbuf *sb,", "\tBerElement *ber,", "\tint freeit ));", "#define LBER_FLUSH_FREE_NEVER\t\t(0x0)\t/* traditional behavior */", "#define LBER_FLUSH_FREE_ON_SUCCESS\t(0x1)\t/* traditional behavior */", "#define LBER_FLUSH_FREE_ON_ERROR\t(0x2)", "#define LBER_FLUSH_FREE_ALWAYS\t\t(LBER_FLUSH_FREE_ON_SUCCESS|LBER_FLUSH_FREE_ON_ERROR)", "", "LBER_F( int )", "ber_flush LDAP_P((", "\tSockbuf *sb,", "\tBerElement *ber,", "\tint freeit )); /* DEPRECATED */", "", "LBER_F( BerElement * )", "ber_alloc LDAP_P(( void )); /* DEPRECATED */", "", "LBER_F( BerElement * )", "der_alloc LDAP_P(( void )); /* DEPRECATED */", "", "LBER_F( BerElement * )", "ber_alloc_t LDAP_P((", "\tint beroptions ));", "", "LBER_F( BerElement * )", "ber_dup LDAP_P((", "\tBerElement *ber ));", "", "LBER_F( ber_tag_t )", "ber_get_next LDAP_P((", "\tSockbuf *sb,", "\tber_len_t *len,", "\tBerElement *ber ));", "", "LBER_F( void )", "ber_init2 LDAP_P((", "\tBerElement *ber,", "\tstruct berval *bv,", "\tint options ));", "", "LBER_F( void )", "ber_init_w_nullc LDAP_P((\t/* DEPRECATED */", "\tBerElement *ber,", "\tint options ));", "", "LBER_F( void )", "ber_reset LDAP_P((", "\tBerElement *ber,", "\tint was_writing ));", "", "LBER_F( BerElement * )", "ber_init LDAP_P((", "\tstruct berval *bv ));", "", "LBER_F( int )", "ber_flatten LDAP_P((", "\tBerElement *ber,", "\tstruct berval **bvPtr ));", "", "LBER_F( int )", "ber_flatten2 LDAP_P((", "\tBerElement *ber,", "\tstruct berval *bv,", "\tint alloc ));", "", "LBER_F( int )", "ber_remaining LDAP_P((", "\tBerElement *ber ));", "", "/*", " * LBER ber accessor functions", " */", "", "LBER_F( int )", "ber_get_option LDAP_P((", "\tvoid *item,", "\tint option,", "\tvoid *outvalue));", "", "LBER_F( int )", "ber_set_option LDAP_P((", "\tvoid *item,", "\tint option,", "\tLDAP_CONST void *invalue));", "", "/*", " * LBER sockbuf.c", " */", "", "LBER_F( Sockbuf *  )", "ber_sockbuf_alloc LDAP_P((", "\tvoid ));", "", "LBER_F( void )", "ber_sockbuf_free LDAP_P((", "\tSockbuf *sb ));", "", "LBER_F( int )", "ber_sockbuf_add_io LDAP_P((", "\tSockbuf *sb,", "\tSockbuf_IO *sbio,", "\tint layer,", "\tvoid *arg ));", "", "LBER_F( int )", "ber_sockbuf_remove_io LDAP_P((", "\tSockbuf *sb,", "\tSockbuf_IO *sbio,", "\tint layer ));", "", "LBER_F( int )", "ber_sockbuf_ctrl LDAP_P((", "\tSockbuf *sb,", "\tint opt,", "\tvoid *arg ));", "", "LBER_V( Sockbuf_IO ) ber_sockbuf_io_tcp;", "LBER_V( Sockbuf_IO ) ber_sockbuf_io_readahead;", "LBER_V( Sockbuf_IO ) ber_sockbuf_io_fd;", "LBER_V( Sockbuf_IO ) ber_sockbuf_io_debug;", "LBER_V( Sockbuf_IO ) ber_sockbuf_io_udp;", "", "/*", " * LBER memory.c", " */", "LBER_F( void * )", "ber_memalloc LDAP_P((", "\tber_len_t s ));", "", "LBER_F( void * )", "ber_memrealloc LDAP_P((", "\tvoid* p,", "\tber_len_t s ));", "", "LBER_F( void * )", "ber_memcalloc LDAP_P((", "\tber_len_t n,", "\tber_len_t s ));", "", "LBER_F( void )", "ber_memfree LDAP_P((", "\tvoid* p ));", "", "LBER_F( void )", "ber_memvfree LDAP_P((", "\tvoid** vector ));", "", "LBER_F( void )", "ber_bvfree LDAP_P((", "\tstruct berval *bv ));", "", "LBER_F( void )", "ber_bvecfree LDAP_P((", "\tstruct berval **bv ));", "", "LBER_F( int )", "ber_bvecadd LDAP_P((", "\tstruct berval ***bvec,", "\tstruct berval *bv ));", "", "LBER_F( struct berval * )", "ber_dupbv LDAP_P((", "\tstruct berval *dst, struct berval *src ));", "", "LBER_F( struct berval * )", "ber_bvdup LDAP_P((", "\tstruct berval *src ));", "", "LBER_F( struct berval * )", "ber_mem2bv LDAP_P((", "\tLDAP_CONST char *, ber_len_t len, int duplicate, struct berval *bv));", "", "LBER_F( struct berval * )", "ber_str2bv LDAP_P((", "\tLDAP_CONST char *, ber_len_t len, int duplicate, struct berval *bv));", "", "#define\tber_bvstr(a)\t((ber_str2bv)((a), 0, 0, NULL))", "#define\tber_bvstrdup(a)\t((ber_str2bv)((a), 0, 1, NULL))", "", "LBER_F( char * )", "ber_strdup LDAP_P((", "\tLDAP_CONST char * ));", "", "LBER_F( ber_len_t )", "ber_strnlen LDAP_P((", "\tLDAP_CONST char *s, ber_len_t len ));", "", "LBER_F( char * )", "ber_strndup LDAP_P((", "\tLDAP_CONST char *s, ber_len_t l ));", "", "LBER_F( struct berval * )", "ber_bvreplace LDAP_P((", "\tstruct berval *dst, LDAP_CONST struct berval *src ));", "", "LBER_F( void )", "ber_bvarray_free LDAP_P(( BerVarray p ));", "", "LBER_F( int )", "ber_bvarray_add LDAP_P(( BerVarray *p, BerValue *bv ));", "", "#define ber_bvcmp(v1,v2) \\", "\t((v1)->bv_len < (v2)->bv_len \\", "\t\t? -1 : ((v1)->bv_len > (v2)->bv_len \\", "\t\t\t? 1 : memcmp((v1)->bv_val, (v2)->bv_val, (v1)->bv_len) ))", "", "/*", " * error.c", " */", "LBER_F( int * ) ber_errno_addr LDAP_P((void));", "#define ber_errno (*(ber_errno_addr)())", "", "#define LBER_ERROR_NONE\t\t0", "#define LBER_ERROR_PARAM\t0x1", "#define LBER_ERROR_MEMORY\t0x2", "", "LDAP_END_DECL", "", "#endif /* _LBER_H */" },
    ["lber_types.h"] = { "/* include/lber_types.h.  Generated from lber_types.hin by configure.  */", "/* $OpenLDAP$ */", "/* This work is part of OpenLDAP Software <http://www.openldap.org/>.", " *", " * Copyright 1998-2011 The OpenLDAP Foundation.", " * All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted only as authorized by the OpenLDAP", " * Public License.", " *", " * A copy of this license is available in file LICENSE in the", " * top-level directory of the distribution or, alternatively, at", " * <http://www.OpenLDAP.org/license.html>.", " */", "", "/*", " * LBER types", " */", "", "#ifndef _LBER_TYPES_H", "#define _LBER_TYPES_H", "", "#include <ldap_cdefs.h>", "", "LDAP_BEGIN_DECL", "", "/* LBER boolean, enum, integers (32 bits or larger) */", "#define LBER_INT_T int", "", "/* LBER tags (32 bits or larger) */", "#define LBER_TAG_T long", "", "/* LBER socket descriptor */", "#define LBER_SOCKET_T int", "", "/* LBER lengths (32 bits or larger) */", "#define LBER_LEN_T long", "", "/* ------------------------------------------------------------ */", "", "/* booleans, enumerations, and integers */", "typedef LBER_INT_T ber_int_t;", "", "/* signed and unsigned versions */", "typedef signed LBER_INT_T ber_sint_t;", "typedef unsigned LBER_INT_T ber_uint_t;", "", "/* tags */", "typedef unsigned LBER_TAG_T ber_tag_t;", "", '/* "socket" descriptors */', "typedef LBER_SOCKET_T ber_socket_t;", "", "/* lengths */", "typedef unsigned LBER_LEN_T ber_len_t;", "", "/* signed lengths */", "typedef signed LBER_LEN_T ber_slen_t;", "", "LDAP_END_DECL", "", "#endif /* _LBER_TYPES_H */" },
    ["ldap.h"] = { "/* $OpenLDAP$ */", "/* This work is part of OpenLDAP Software <http://www.openldap.org/>.", " * ", " * Copyright 1998-2011 The OpenLDAP Foundation.", " * All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted only as authorized by the OpenLDAP", " * Public License.", " *", " * A copy of this license is available in file LICENSE in the", " * top-level directory of the distribution or, alternatively, at", " * <http://www.OpenLDAP.org/license.html>.", " */", "/* Portions Copyright (c) 1990 Regents of the University of Michigan.", " * All rights reserved.", " *", " * Redistribution and use in source and binary forms are permitted", " * provided that this notice is preserved and that due credit is given", " * to the University of Michigan at Ann Arbor. The name of the University", " * may not be used to endorse or promote products derived from this", " * software without specific prior written permission. This software", " * is provided ``as is'' without express or implied warranty.", " */", "", "#ifndef _LDAP_H", "#define _LDAP_H", "", "/* pull in lber */", "#include <lber.h>", "", "/* include version and API feature defines */", "#include <ldap_features.h>", "", "LDAP_BEGIN_DECL", "", "#define LDAP_VERSION1\t1", "#define LDAP_VERSION2\t2", "#define LDAP_VERSION3\t3", "", "#define LDAP_VERSION_MIN\tLDAP_VERSION2", "#define\tLDAP_VERSION\t\tLDAP_VERSION2", "#define LDAP_VERSION_MAX\tLDAP_VERSION3", "", "/* Use -DLDAP_DEPRECATED=0 to hide deprecated interfaces */", "#ifndef LDAP_DEPRECATED", "#define LDAP_DEPRECATED 1", "#endif", "", "/*", " * We use 3000+n here because it is above 1823 (for RFC 1823),", " * above 2000+rev of IETF LDAPEXT draft (now quite dated),", " * yet below allocations for new RFCs (just in case there is", " * someday an RFC produced).", " */", "#define LDAP_API_VERSION\t3001", '#define LDAP_VENDOR_NAME\t"OpenLDAP"', "", "/* OpenLDAP API Features */", "#define LDAP_API_FEATURE_X_OPENLDAP LDAP_VENDOR_VERSION", "", "#if defined( LDAP_API_FEATURE_X_OPENLDAP_REENTRANT ) || \\", "\t( defined( LDAP_THREAD_SAFE ) && \\", "\t\tdefined( LDAP_API_FEATURE_X_OPENLDAP_THREAD_SAFE ) )", "\t/* -lldap may or may not be thread safe */", "\t/* -lldap_r, if available, is always thread safe */", "#\tdefine\tLDAP_API_FEATURE_THREAD_SAFE \t\t1", "#\tdefine  LDAP_API_FEATURE_SESSION_THREAD_SAFE\t1", "#\tdefine  LDAP_API_FEATURE_OPERATION_THREAD_SAFE\t1", "#endif", "#if defined( LDAP_THREAD_SAFE ) && \\", "\tdefined( LDAP_API_FEATURE_X_OPENLDAP_THREAD_SAFE )", "/* #define LDAP_API_FEATURE_SESSION_SAFE\t1\t*/", "/* #define LDAP_API_OPERATION_SESSION_SAFE\t1\t*/", "#endif", "", "", "#define LDAP_PORT\t\t389\t\t/* ldap:///\t\tdefault LDAP port */", "#define LDAPS_PORT\t\t636\t\t/* ldaps:///\tdefault LDAP over TLS port */", "", '#define LDAP_ROOT_DSE\t\t\t\t""', '#define LDAP_NO_ATTRS\t\t\t\t"1.1"', '#define LDAP_ALL_USER_ATTRIBUTES\t"*"', '#define LDAP_ALL_OPERATIONAL_ATTRIBUTES\t"+" /* RFC 3673 */', "", "/* RFC 4511:  maxInt INTEGER ::= 2147483647 -- (2^^31 - 1) -- */", "#define LDAP_MAXINT (2147483647)", "", "/*", " * LDAP_OPTions", " *\t0x0000 - 0x0fff reserved for api options", " *\t0x1000 - 0x3fff reserved for api extended options", " *\t0x4000 - 0x7fff reserved for private and experimental options", " */", "", "#define LDAP_OPT_API_INFO\t\t\t0x0000", "#define LDAP_OPT_DESC\t\t\t\t0x0001 /* historic */", "#define LDAP_OPT_DEREF\t\t\t\t0x0002", "#define LDAP_OPT_SIZELIMIT\t\t\t0x0003", "#define LDAP_OPT_TIMELIMIT\t\t\t0x0004", "/* 0x05 - 0x07 not defined */", "#define LDAP_OPT_REFERRALS\t\t\t0x0008", "#define LDAP_OPT_RESTART\t\t\t0x0009", "/* 0x0a - 0x10 not defined */", "#define LDAP_OPT_PROTOCOL_VERSION\t\t0x0011", "#define LDAP_OPT_SERVER_CONTROLS\t\t0x0012", "#define LDAP_OPT_CLIENT_CONTROLS\t\t0x0013", "/* 0x14 not defined */", "#define LDAP_OPT_API_FEATURE_INFO\t\t0x0015", "/* 0x16 - 0x2f not defined */", "#define LDAP_OPT_HOST_NAME\t\t\t0x0030", "#define LDAP_OPT_RESULT_CODE\t\t\t0x0031", "#define LDAP_OPT_ERROR_NUMBER\t\t\tLDAP_OPT_RESULT_CODE", "#define LDAP_OPT_DIAGNOSTIC_MESSAGE\t\t0x0032", "#define LDAP_OPT_ERROR_STRING\t\t\tLDAP_OPT_DIAGNOSTIC_MESSAGE", "#define LDAP_OPT_MATCHED_DN\t\t\t0x0033", "/* 0x0034 - 0x3fff not defined */", "/* 0x0091 used by Microsoft for LDAP_OPT_AUTO_RECONNECT */", "#define LDAP_OPT_SSPI_FLAGS\t\t\t0x0092", "/* 0x0093 used by Microsoft for LDAP_OPT_SSL_INFO */", "/* 0x0094 used by Microsoft for LDAP_OPT_REF_DEREF_CONN_PER_MSG */", "#define LDAP_OPT_SIGN\t\t\t\t0x0095", "#define LDAP_OPT_ENCRYPT\t\t\t0x0096", "#define LDAP_OPT_SASL_METHOD\t\t\t0x0097", "/* 0x0098 used by Microsoft for LDAP_OPT_AREC_EXCLUSIVE */", "#define LDAP_OPT_SECURITY_CONTEXT\t\t0x0099", "/* 0x009A used by Microsoft for LDAP_OPT_ROOTDSE_CACHE */", "/* 0x009B - 0x3fff not defined */", "", "/* API Extensions */", "#define LDAP_OPT_API_EXTENSION_BASE 0x4000  /* API extensions */", "", "/* private and experimental options */", "/* OpenLDAP specific options */", "#define LDAP_OPT_DEBUG_LEVEL\t\t0x5001\t/* debug level */", "#define LDAP_OPT_TIMEOUT\t\t\t0x5002\t/* default timeout */", "#define LDAP_OPT_REFHOPLIMIT\t\t0x5003\t/* ref hop limit */", "#define LDAP_OPT_NETWORK_TIMEOUT\t0x5005\t/* socket level timeout */", "#define LDAP_OPT_URI\t\t\t\t0x5006", "#define LDAP_OPT_REFERRAL_URLS      0x5007  /* Referral URLs */", "#define LDAP_OPT_SOCKBUF            0x5008  /* sockbuf */", "#define LDAP_OPT_DEFBASE\t\t0x5009\t/* searchbase */", "#define\tLDAP_OPT_CONNECT_ASYNC\t\t0x5010\t/* create connections asynchronously */", "#define\tLDAP_OPT_CONNECT_CB\t\t\t0x5011\t/* connection callbacks */", "#define\tLDAP_OPT_SESSION_REFCNT\t\t0x5012\t/* session reference count */", "", "/* OpenLDAP TLS options */", "#define LDAP_OPT_X_TLS\t\t\t\t0x6000", "#define LDAP_OPT_X_TLS_CTX\t\t\t0x6001\t/* OpenSSL CTX* */", "#define LDAP_OPT_X_TLS_CACERTFILE\t0x6002", "#define LDAP_OPT_X_TLS_CACERTDIR\t0x6003", "#define LDAP_OPT_X_TLS_CERTFILE\t\t0x6004", "#define LDAP_OPT_X_TLS_KEYFILE\t\t0x6005", "#define LDAP_OPT_X_TLS_REQUIRE_CERT\t0x6006", "#define LDAP_OPT_X_TLS_PROTOCOL_MIN\t0x6007", "#define LDAP_OPT_X_TLS_CIPHER_SUITE\t0x6008", "#define LDAP_OPT_X_TLS_RANDOM_FILE\t0x6009", "#define LDAP_OPT_X_TLS_SSL_CTX\t\t0x600a\t/* OpenSSL SSL* */", "#define LDAP_OPT_X_TLS_CRLCHECK\t\t0x600b", "#define LDAP_OPT_X_TLS_CONNECT_CB\t0x600c", "#define LDAP_OPT_X_TLS_CONNECT_ARG\t0x600d", "#define LDAP_OPT_X_TLS_DHFILE\t\t0x600e", "#define LDAP_OPT_X_TLS_NEWCTX\t\t0x600f", "#define LDAP_OPT_X_TLS_CRLFILE\t\t0x6010\t/* GNUtls only */", "#define LDAP_OPT_X_TLS_PACKAGE\t\t0x6011", "#define LDAP_OPT_X_TLS_CERT_IDENTITY 0x60fe /*Apple Specific code*/", "#define LDAP_OPT_X_TLS_PASSPHRASE\t0x60ff  /*Apple Specific code*/", "", "#define LDAP_OPT_X_TLS_NEVER\t0", "#define LDAP_OPT_X_TLS_HARD\t\t1", "#define LDAP_OPT_X_TLS_DEMAND\t2", "#define LDAP_OPT_X_TLS_ALLOW\t3", "#define LDAP_OPT_X_TLS_TRY\t\t4", "", "#define LDAP_OPT_X_TLS_CRL_NONE\t0", "#define LDAP_OPT_X_TLS_CRL_PEER\t1", "#define LDAP_OPT_X_TLS_CRL_ALL\t2", "", "/* for LDAP_OPT_X_TLS_PROTOCOL_MIN */", "#define LDAP_OPT_X_TLS_PROTOCOL(maj,min)\t(((maj) << 8) + (min))", "#define LDAP_OPT_X_TLS_PROTOCOL_SSL2\t\t(2 << 8)", "#define LDAP_OPT_X_TLS_PROTOCOL_SSL3\t\t(3 << 8)", "#define LDAP_OPT_X_TLS_PROTOCOL_TLS1_0\t\t((3 << 8) + 1)", "#define LDAP_OPT_X_TLS_PROTOCOL_TLS1_1\t\t((3 << 8) + 2)", "#define LDAP_OPT_X_TLS_PROTOCOL_TLS1_2\t\t((3 << 8) + 3)", "", "/* OpenLDAP SASL options */", "#define LDAP_OPT_X_SASL_MECH\t\t\t0x6100", "#define LDAP_OPT_X_SASL_REALM\t\t\t0x6101", "#define LDAP_OPT_X_SASL_AUTHCID\t\t\t0x6102", "#define LDAP_OPT_X_SASL_AUTHZID\t\t\t0x6103", "#define LDAP_OPT_X_SASL_SSF\t\t\t\t0x6104 /* read-only */", "#define LDAP_OPT_X_SASL_SSF_EXTERNAL\t0x6105 /* write-only */", "#define LDAP_OPT_X_SASL_SECPROPS\t\t0x6106 /* write-only */", "#define LDAP_OPT_X_SASL_SSF_MIN\t\t\t0x6107", "#define LDAP_OPT_X_SASL_SSF_MAX\t\t\t0x6108", "#define LDAP_OPT_X_SASL_MAXBUFSIZE\t\t0x6109", "#define LDAP_OPT_X_SASL_MECHLIST\t\t0x610a /* read-only */", "#define LDAP_OPT_X_SASL_NOCANON\t\t\t0x610b", "#define LDAP_OPT_X_SASL_USERNAME\t\t0x610c /* read-only */", "#define LDAP_OPT_X_SASL_GSS_CREDS\t\t0x610d", "", "/* OpenLDAP GSSAPI options */", "#define LDAP_OPT_X_GSSAPI_DO_NOT_FREE_CONTEXT      0x6200", "#define LDAP_OPT_X_GSSAPI_ALLOW_REMOTE_PRINCIPAL   0x6201", "", "/*", " * OpenLDAP per connection tcp-keepalive settings", " * (Linux only, ignored where unsupported)", " */", "#define LDAP_OPT_X_KEEPALIVE_IDLE\t\t0x6300", "#define LDAP_OPT_X_KEEPALIVE_PROBES\t\t0x6301", "#define LDAP_OPT_X_KEEPALIVE_INTERVAL\t0x6302", "", "/* Private API Extensions -- reserved for application use */", "#define LDAP_OPT_PRIVATE_EXTENSION_BASE 0x7000  /* Private API inclusive */", "", "/* This option disables reverse lookups for hostnames provided during ldap_init.", " * If the hostname was an IP, then a reverse lookup is still done.", " */", "#define LDAP_OPT_NOREVERSE_LOOKUP\t\tLDAP_OPT_X_SASL_NOCANON", "", "/*", " * ldap_get_option() and ldap_set_option() return values.", " * As later versions may return other values indicating", " * failure, current applications should only compare returned", " * value against LDAP_OPT_SUCCESS.", " */", "#define LDAP_OPT_SUCCESS\t0", "#define\tLDAP_OPT_ERROR\t\t(-1)", "", "/* option on/off values */", "#define LDAP_OPT_ON\t\t((void *) &ber_pvt_opt_on)", "#define LDAP_OPT_OFF\t((void *) 0)", "", "typedef struct ldapapiinfo {", "\tint\t\tldapai_info_version;\t\t/* version of LDAPAPIInfo */", "#define LDAP_API_INFO_VERSION\t(1)", "\tint\t\tldapai_api_version;\t\t\t/* revision of API supported */", "\tint\t\tldapai_protocol_version;\t/* highest LDAP version supported */", "\tchar\t**ldapai_extensions;\t\t/* names of API extensions */", "\tchar\t*ldapai_vendor_name;\t\t/* name of supplier */", "\tint\t\tldapai_vendor_version;\t\t/* supplier-specific version * 100 */", "} LDAPAPIInfo;", "", "typedef struct ldap_apifeature_info {", "\tint\t\tldapaif_info_version;\t\t/* version of LDAPAPIFeatureInfo */", "#define LDAP_FEATURE_INFO_VERSION (1)\t/* apifeature_info struct version */", "\tchar*\tldapaif_name;\t\t\t\t/* LDAP_API_FEATURE_* (less prefix) */", "\tint\t\tldapaif_version;\t\t\t/* value of LDAP_API_FEATURE_... */", "} LDAPAPIFeatureInfo;", "", "/*", " * LDAP Control structure", " */", "typedef struct ldapcontrol {", "\tchar *\t\t\tldctl_oid;\t\t\t/* numericoid of control */", "\tstruct berval\tldctl_value;\t\t/* encoded value of control */", "\tchar\t\t\tldctl_iscritical;\t/* criticality */", "} LDAPControl;", "", "/* LDAP Controls */", "/*\tstandard track controls */", '#define LDAP_CONTROL_MANAGEDSAIT\t"2.16.840.1.113730.3.4.2"  /* RFC 3296 */', '#define LDAP_CONTROL_PROXY_AUTHZ\t"2.16.840.1.113730.3.4.18" /* RFC 4370 */', '#define LDAP_CONTROL_SUBENTRIES\t\t"1.3.6.1.4.1.4203.1.10.1"  /* RFC 3672 */', "", '#define LDAP_CONTROL_VALUESRETURNFILTER "1.2.826.0.1.3344810.2.3"/* RFC 3876 */', "", '#define LDAP_CONTROL_ASSERT\t\t\t\t"1.3.6.1.1.12"\t\t\t/* RFC 4528 */', '#define LDAP_CONTROL_PRE_READ\t\t\t"1.3.6.1.1.13.1"\t\t/* RFC 4527 */', '#define LDAP_CONTROL_POST_READ\t\t\t"1.3.6.1.1.13.2"\t\t/* RFC 4527 */', "", '#define LDAP_CONTROL_SORTREQUEST    "1.2.840.113556.1.4.473" /* RFC 2891 */', '#define LDAP_CONTROL_SORTRESPONSE\t"1.2.840.113556.1.4.474" /* RFC 2891 */', "", "/*\tnon-standard track controls */", '#define LDAP_CONTROL_PAGEDRESULTS\t"1.2.840.113556.1.4.319"   /* RFC 2696 */', "", "/* LDAP Content Synchronization Operation -- RFC 4533 */", '#define LDAP_SYNC_OID\t\t\t"1.3.6.1.4.1.4203.1.9.1"', '#define LDAP_CONTROL_SYNC\t\tLDAP_SYNC_OID ".1"', '#define LDAP_CONTROL_SYNC_STATE\tLDAP_SYNC_OID ".2"', '#define LDAP_CONTROL_SYNC_DONE\tLDAP_SYNC_OID ".3"', '#define LDAP_SYNC_INFO\t\t\tLDAP_SYNC_OID ".4"', "", "#define LDAP_SYNC_NONE\t\t\t\t\t0x00", "#define LDAP_SYNC_REFRESH_ONLY\t\t\t0x01", "#define LDAP_SYNC_RESERVED\t\t\t\t0x02", "#define LDAP_SYNC_REFRESH_AND_PERSIST\t0x03", "", "#define LDAP_SYNC_REFRESH_PRESENTS\t\t0", "#define LDAP_SYNC_REFRESH_DELETES\t\t1", "", "#define LDAP_TAG_SYNC_NEW_COOKIE\t\t((ber_tag_t) 0x80U)", "#define LDAP_TAG_SYNC_REFRESH_DELETE\t((ber_tag_t) 0xa1U)", "#define LDAP_TAG_SYNC_REFRESH_PRESENT\t((ber_tag_t) 0xa2U)", "#define\tLDAP_TAG_SYNC_ID_SET\t\t\t((ber_tag_t) 0xa3U)", "", "#define LDAP_TAG_SYNC_COOKIE\t\t\t((ber_tag_t) 0x04U)", "#define LDAP_TAG_REFRESHDELETES\t\t\t((ber_tag_t) 0x01U)", "#define LDAP_TAG_REFRESHDONE\t\t\t((ber_tag_t) 0x01U)", "#define LDAP_TAG_RELOAD_HINT\t\t\t((ber_tag_t) 0x01U)", "", "#define LDAP_SYNC_PRESENT\t\t\t\t0", "#define LDAP_SYNC_ADD\t\t\t\t\t1", "#define LDAP_SYNC_MODIFY\t\t\t\t2", "#define LDAP_SYNC_DELETE\t\t\t\t3", "#define LDAP_SYNC_NEW_COOKIE\t\t\t4", "", "", "/* Password policy Controls *//* work in progress */", "/* ITS#3458: released; disabled by default */", '#define LDAP_CONTROL_PASSWORDPOLICYREQUEST\t"1.3.6.1.4.1.42.2.27.8.5.1"', '#define LDAP_CONTROL_PASSWORDPOLICYRESPONSE\t"1.3.6.1.4.1.42.2.27.8.5.1"', "", "/* various works in progress */", '#define LDAP_CONTROL_NOOP\t\t\t\t"1.3.6.1.4.1.4203.666.5.2"', '#define LDAP_CONTROL_NO_SUBORDINATES\t"1.3.6.1.4.1.4203.666.5.11"', '#define LDAP_CONTROL_RELAX\t\t\t\t"1.3.6.1.4.1.4203.666.5.12"', "#define LDAP_CONTROL_MANAGEDIT\t\t\tLDAP_CONTROL_RELAX", '#define LDAP_CONTROL_SLURP\t\t\t\t"1.3.6.1.4.1.4203.666.5.13"', '#define LDAP_CONTROL_VALSORT\t\t\t"1.3.6.1.4.1.4203.666.5.14"', '#define LDAP_CONTROL_DONTUSECOPY\t\t"1.3.6.1.4.1.4203.666.5.15"', '#define\tLDAP_CONTROL_X_DEREF\t\t\t"1.3.6.1.4.1.4203.666.5.16"', '#define\tLDAP_CONTROL_X_WHATFAILED\t\t"1.3.6.1.4.1.4203.666.5.17"', "", "/* LDAP Chaining Behavior Control *//* work in progress */", "/* <draft-sermersheim-ldap-chaining>;", " * see also LDAP_NO_REFERRALS_FOUND, LDAP_CANNOT_CHAIN */", '#define LDAP_CONTROL_X_CHAINING_BEHAVIOR\t"1.3.6.1.4.1.4203.666.11.3"', "", "#define\tLDAP_CHAINING_PREFERRED\t\t\t\t0", "#define\tLDAP_CHAINING_REQUIRED\t\t\t\t1", "#define LDAP_REFERRALS_PREFERRED\t\t\t2", "#define LDAP_REFERRALS_REQUIRED\t\t\t\t3", "", "/* MS Active Directory controls (for compatibility) */", '#define LDAP_CONTROL_X_INCREMENTAL_VALUES\t"1.2.840.113556.1.4.802"', '#define LDAP_CONTROL_X_DOMAIN_SCOPE\t\t\t"1.2.840.113556.1.4.1339"', '#define LDAP_CONTROL_X_PERMISSIVE_MODIFY\t"1.2.840.113556.1.4.1413"', '#define LDAP_CONTROL_X_SEARCH_OPTIONS\t\t"1.2.840.113556.1.4.1340"', "#define LDAP_SEARCH_FLAG_DOMAIN_SCOPE 1 /* do not generate referrals */", "#define LDAP_SEARCH_FLAG_PHANTOM_ROOT 2 /* search all subordinate NCs */", '#define LDAP_CONTROL_X_TREE_DELETE\t\t"1.2.840.113556.1.4.805"', "", "/* MS Active Directory controls - not implemented in slapd(8) */", '#define LDAP_CONTROL_X_EXTENDED_DN\t\t"1.2.840.113556.1.4.529"', "", "/* <draft-wahl-ldap-session> */", '#define LDAP_CONTROL_X_SESSION_TRACKING\t\t"1.3.6.1.4.1.21008.108.63.1"', "#define LDAP_CONTROL_X_SESSION_TRACKING_RADIUS_ACCT_SESSION_ID \\", '\t\t\t\t\t\tLDAP_CONTROL_X_SESSION_TRACKING ".1"', "#define LDAP_CONTROL_X_SESSION_TRACKING_RADIUS_ACCT_MULTI_SESSION_ID \\", '\t\t\t\t\t\tLDAP_CONTROL_X_SESSION_TRACKING ".2"', "#define LDAP_CONTROL_X_SESSION_TRACKING_USERNAME \\", '\t\t\t\t\t\tLDAP_CONTROL_X_SESSION_TRACKING ".3"', "/* various expired works */", "", "/* various expired works */", "/* LDAP Duplicated Entry Control Extension *//* not implemented in slapd(8) */", '#define LDAP_CONTROL_DUPENT_REQUEST\t\t"2.16.840.1.113719.1.27.101.1"', '#define LDAP_CONTROL_DUPENT_RESPONSE\t"2.16.840.1.113719.1.27.101.2"', '#define LDAP_CONTROL_DUPENT_ENTRY\t\t"2.16.840.1.113719.1.27.101.3"', "#define LDAP_CONTROL_DUPENT\tLDAP_CONTROL_DUPENT_REQUEST", "", "/* LDAP Persistent Search Control *//* not implemented in slapd(8) */", '#define LDAP_CONTROL_PERSIST_REQUEST\t\t\t\t"2.16.840.1.113730.3.4.3"', '#define LDAP_CONTROL_PERSIST_ENTRY_CHANGE_NOTICE\t"2.16.840.1.113730.3.4.7"', "#define LDAP_CONTROL_PERSIST_ENTRY_CHANGE_ADD\t\t0x1", "#define LDAP_CONTROL_PERSIST_ENTRY_CHANGE_DELETE\t0x2", "#define LDAP_CONTROL_PERSIST_ENTRY_CHANGE_MODIFY\t0x4", "#define LDAP_CONTROL_PERSIST_ENTRY_CHANGE_RENAME\t0x8", "", "/* LDAP VLV */", '#define LDAP_CONTROL_VLVREQUEST    \t"2.16.840.1.113730.3.4.9"', '#define LDAP_CONTROL_VLVRESPONSE    "2.16.840.1.113730.3.4.10"', "", "/* LDAP Unsolicited Notifications */", '#define\tLDAP_NOTICE_OF_DISCONNECTION\t"1.3.6.1.4.1.1466.20036" /* RFC 4511 */', "#define LDAP_NOTICE_DISCONNECT LDAP_NOTICE_OF_DISCONNECTION", "", "/* LDAP Extended Operations */", '#define LDAP_EXOP_START_TLS\t\t"1.3.6.1.4.1.1466.20037"\t/* RFC 4511 */', "", '#define LDAP_EXOP_MODIFY_PASSWD\t"1.3.6.1.4.1.4203.1.11.1"\t/* RFC 3062 */', "#define LDAP_TAG_EXOP_MODIFY_PASSWD_ID\t((ber_tag_t) 0x80U)", "#define LDAP_TAG_EXOP_MODIFY_PASSWD_OLD\t((ber_tag_t) 0x81U)", "#define LDAP_TAG_EXOP_MODIFY_PASSWD_NEW\t((ber_tag_t) 0x82U)", "#define LDAP_TAG_EXOP_MODIFY_PASSWD_GEN\t((ber_tag_t) 0x80U)", "", '#define LDAP_EXOP_CANCEL\t\t"1.3.6.1.1.8"\t\t\t\t\t/* RFC 3909 */', "#define LDAP_EXOP_X_CANCEL\t\tLDAP_EXOP_CANCEL", "", '#define\tLDAP_EXOP_REFRESH\t\t"1.3.6.1.4.1.1466.101.119.1"\t/* RFC 2589 */', "#define\tLDAP_TAG_EXOP_REFRESH_REQ_DN\t((ber_tag_t) 0x80U)", "#define\tLDAP_TAG_EXOP_REFRESH_REQ_TTL\t((ber_tag_t) 0x81U)", "#define\tLDAP_TAG_EXOP_REFRESH_RES_TTL\t((ber_tag_t) 0x81U)", "", '#define LDAP_EXOP_WHO_AM_I\t\t"1.3.6.1.4.1.4203.1.11.3"\t\t/* RFC 4532 */', "#define LDAP_EXOP_X_WHO_AM_I\tLDAP_EXOP_WHO_AM_I", "", "/* various works in progress */", '#define LDAP_EXOP_TURN\t\t"1.3.6.1.1.19"\t\t\t\t/* RFC 4531 */', "#define LDAP_EXOP_X_TURN\tLDAP_EXOP_TURN", "", "/* LDAP Distributed Procedures <draft-sermersheim-ldap-distproc> */", "/* a work in progress */", '#define LDAP_X_DISTPROC_BASE\t\t"1.3.6.1.4.1.4203.666.11.6"', '#define LDAP_EXOP_X_CHAINEDREQUEST\tLDAP_X_DISTPROC_BASE ".1"', '#define LDAP_FEATURE_X_CANCHAINOPS\tLDAP_X_DISTPROC_BASE ".2"', '#define LDAP_CONTROL_X_RETURNCONTREF\tLDAP_X_DISTPROC_BASE ".3"', '#define LDAP_URLEXT_X_LOCALREFOID\tLDAP_X_DISTPROC_BASE ".4"', '#define LDAP_URLEXT_X_REFTYPEOID\tLDAP_X_DISTPROC_BASE ".5"', "#define LDAP_URLEXT_X_SEARCHEDSUBTREEOID \\", '\t\t\t\t\tLDAP_X_DISTPROC_BASE ".6"', '#define LDAP_URLEXT_X_FAILEDNAMEOID\tLDAP_X_DISTPROC_BASE ".7"', '#define LDAP_URLEXT_X_LOCALREF\t\t"x-localReference"', '#define LDAP_URLEXT_X_REFTYPE\t\t"x-referenceType"', '#define LDAP_URLEXT_X_SEARCHEDSUBTREE\t"x-searchedSubtree"', '#define LDAP_URLEXT_X_FAILEDNAME\t"x-failedName"', "", "#ifdef LDAP_DEVEL", '#define LDAP_X_TXN\t\t\t\t\t\t"1.3.6.1.4.1.4203.666.11.7" /* tmp */', '#define LDAP_EXOP_X_TXN_START\t\t\tLDAP_X_TXN ".1"', '#define LDAP_CONTROL_X_TXN_SPEC\t\t\tLDAP_X_TXN ".2"', '#define LDAP_EXOP_X_TXN_END\t\t\t\tLDAP_X_TXN ".3"', '#define LDAP_EXOP_X_TXN_ABORTED_NOTICE\tLDAP_X_TXN ".4"', "#endif", "", "/* LDAP Features */", '#define LDAP_FEATURE_ALL_OP_ATTRS\t"1.3.6.1.4.1.4203.1.5.1"\t/* RFC 3673 */', "#define LDAP_FEATURE_OBJECTCLASS_ATTRS \\", '\t"1.3.6.1.4.1.4203.1.5.2" /*  @objectClass - new number to be assigned */', '#define LDAP_FEATURE_ABSOLUTE_FILTERS "1.3.6.1.4.1.4203.1.5.3"  /* (&) (|) */', '#define LDAP_FEATURE_LANGUAGE_TAG_OPTIONS "1.3.6.1.4.1.4203.1.5.4"', '#define LDAP_FEATURE_LANGUAGE_RANGE_OPTIONS "1.3.6.1.4.1.4203.1.5.5"', '#define LDAP_FEATURE_MODIFY_INCREMENT "1.3.6.1.1.14"', "", "/* LDAP Experimental (works in progress) Features */", "#define LDAP_FEATURE_SUBORDINATE_SCOPE \\", '\t"1.3.6.1.4.1.4203.666.8.1" /* "children" */', "#define LDAP_FEATURE_CHILDREN_SCOPE LDAP_FEATURE_SUBORDINATE_SCOPE", "", "/*", " * specific LDAP instantiations of BER types we know about", " */", "", "/* Overview of LBER tag construction", " *", " *\tBits", " *\t______", " *\t8 7 | CLASS", " *\t0 0 = UNIVERSAL", " *\t0 1 = APPLICATION", " *\t1 0 = CONTEXT-SPECIFIC", " *\t1 1 = PRIVATE", " *\t\t_____", " *\t\t| 6 | DATA-TYPE", " *\t\t  0 = PRIMITIVE", " *\t\t  1 = CONSTRUCTED", " *\t\t\t___________", " *\t\t\t| 5 ... 1 | TAG-NUMBER", " */", "", "/* general stuff */", "#define LDAP_TAG_MESSAGE\t((ber_tag_t) 0x30U)\t/* constructed + 16 */", "#define LDAP_TAG_MSGID\t\t((ber_tag_t) 0x02U)\t/* integer */", "", "#define LDAP_TAG_LDAPDN\t\t((ber_tag_t) 0x04U)\t/* octet string */", "#define LDAP_TAG_LDAPCRED\t((ber_tag_t) 0x04U)\t/* octet string */", "", "#define LDAP_TAG_CONTROLS\t((ber_tag_t) 0xa0U)\t/* context specific + constructed + 0 */", "#define LDAP_TAG_REFERRAL\t((ber_tag_t) 0xa3U)\t/* context specific + constructed + 3 */", "", "#define LDAP_TAG_NEWSUPERIOR\t((ber_tag_t) 0x80U)\t/* context-specific + primitive + 0 */", "", "#define LDAP_TAG_EXOP_REQ_OID   ((ber_tag_t) 0x80U)\t/* context specific + primitive */", "#define LDAP_TAG_EXOP_REQ_VALUE ((ber_tag_t) 0x81U)\t/* context specific + primitive */", "#define LDAP_TAG_EXOP_RES_OID   ((ber_tag_t) 0x8aU)\t/* context specific + primitive */", "#define LDAP_TAG_EXOP_RES_VALUE ((ber_tag_t) 0x8bU)\t/* context specific + primitive */", "", "#define LDAP_TAG_IM_RES_OID   ((ber_tag_t) 0x80U)\t/* context specific + primitive */", "#define LDAP_TAG_IM_RES_VALUE ((ber_tag_t) 0x81U)\t/* context specific + primitive */", "", "#define LDAP_TAG_SASL_RES_CREDS\t((ber_tag_t) 0x87U)\t/* context specific + primitive */", "", "/* LDAP Request Messages */", "#define LDAP_REQ_BIND\t\t((ber_tag_t) 0x60U)\t/* application + constructed */", "#define LDAP_REQ_UNBIND\t\t((ber_tag_t) 0x42U)\t/* application + primitive   */", "#define LDAP_REQ_SEARCH\t\t((ber_tag_t) 0x63U)\t/* application + constructed */", "#define LDAP_REQ_MODIFY\t\t((ber_tag_t) 0x66U)\t/* application + constructed */", "#define LDAP_REQ_ADD\t\t((ber_tag_t) 0x68U)\t/* application + constructed */", "#define LDAP_REQ_DELETE\t\t((ber_tag_t) 0x4aU)\t/* application + primitive   */", "#define LDAP_REQ_MODDN\t\t((ber_tag_t) 0x6cU)\t/* application + constructed */", "#define LDAP_REQ_MODRDN\t\tLDAP_REQ_MODDN", "#define LDAP_REQ_RENAME\t\tLDAP_REQ_MODDN", "#define LDAP_REQ_COMPARE\t((ber_tag_t) 0x6eU)\t/* application + constructed */", "#define LDAP_REQ_ABANDON\t((ber_tag_t) 0x50U)\t/* application + primitive   */", "#define LDAP_REQ_EXTENDED\t((ber_tag_t) 0x77U)\t/* application + constructed */", "", "/* LDAP Response Messages */", "#define LDAP_RES_BIND\t\t((ber_tag_t) 0x61U)\t/* application + constructed */", "#define LDAP_RES_SEARCH_ENTRY\t((ber_tag_t) 0x64U)\t/* application + constructed */", "#define LDAP_RES_SEARCH_REFERENCE\t((ber_tag_t) 0x73U)\t/* V3: application + constructed */", "#define LDAP_RES_SEARCH_RESULT\t((ber_tag_t) 0x65U)\t/* application + constructed */", "#define LDAP_RES_MODIFY\t\t((ber_tag_t) 0x67U)\t/* application + constructed */", "#define LDAP_RES_ADD\t\t((ber_tag_t) 0x69U)\t/* application + constructed */", "#define LDAP_RES_DELETE\t\t((ber_tag_t) 0x6bU)\t/* application + constructed */", "#define LDAP_RES_MODDN\t\t((ber_tag_t) 0x6dU)\t/* application + constructed */", "#define LDAP_RES_MODRDN\t\tLDAP_RES_MODDN\t/* application + constructed */", "#define LDAP_RES_RENAME\t\tLDAP_RES_MODDN\t/* application + constructed */", "#define LDAP_RES_COMPARE\t((ber_tag_t) 0x6fU)\t/* application + constructed */", "#define LDAP_RES_EXTENDED\t((ber_tag_t) 0x78U)\t/* V3: application + constructed */", "#define LDAP_RES_INTERMEDIATE\t((ber_tag_t) 0x79U) /* V3+: application + constructed */", "", "#define LDAP_RES_ANY\t\t\t(-1)", "#define LDAP_RES_UNSOLICITED\t(0)", "", "", "/* sasl methods */", "#define LDAP_SASL_SIMPLE\t((char*)0)", '#define LDAP_SASL_NULL\t\t("")', "", "", "/* authentication methods available */", "#define LDAP_AUTH_NONE   ((ber_tag_t) 0x00U) /* no authentication */", "#define LDAP_AUTH_SIMPLE ((ber_tag_t) 0x80U) /* context specific + primitive */", "#define LDAP_AUTH_SASL   ((ber_tag_t) 0xa3U) /* context specific + constructed */", "#define LDAP_AUTH_KRBV4  ((ber_tag_t) 0xffU) /* means do both of the following */", "#define LDAP_AUTH_KRBV41 ((ber_tag_t) 0x81U) /* context specific + primitive */", "#define LDAP_AUTH_KRBV42 ((ber_tag_t) 0x82U) /* context specific + primitive */", "", "/* used by the Windows API but not used on the wire */", "#define LDAP_AUTH_NEGOTIATE ((ber_tag_t) 0x04FFU)", "", "/* filter types */", "#define LDAP_FILTER_AND\t((ber_tag_t) 0xa0U)\t/* context specific + constructed */", "#define LDAP_FILTER_OR\t((ber_tag_t) 0xa1U)\t/* context specific + constructed */", "#define LDAP_FILTER_NOT\t((ber_tag_t) 0xa2U)\t/* context specific + constructed */", "#define LDAP_FILTER_EQUALITY ((ber_tag_t) 0xa3U) /* context specific + constructed */", "#define LDAP_FILTER_SUBSTRINGS ((ber_tag_t) 0xa4U) /* context specific + constructed */", "#define LDAP_FILTER_GE ((ber_tag_t) 0xa5U) /* context specific + constructed */", "#define LDAP_FILTER_LE ((ber_tag_t) 0xa6U) /* context specific + constructed */", "#define LDAP_FILTER_PRESENT ((ber_tag_t) 0x87U) /* context specific + primitive   */", "#define LDAP_FILTER_APPROX ((ber_tag_t) 0xa8U)\t/* context specific + constructed */", "#define LDAP_FILTER_EXT\t((ber_tag_t) 0xa9U)\t/* context specific + constructed */", "", "/* extended filter component types */", "#define LDAP_FILTER_EXT_OID\t\t((ber_tag_t) 0x81U)\t/* context specific */", "#define LDAP_FILTER_EXT_TYPE\t((ber_tag_t) 0x82U)\t/* context specific */", "#define LDAP_FILTER_EXT_VALUE\t((ber_tag_t) 0x83U)\t/* context specific */", "#define LDAP_FILTER_EXT_DNATTRS\t((ber_tag_t) 0x84U)\t/* context specific */", "", "/* substring filter component types */", "#define LDAP_SUBSTRING_INITIAL\t((ber_tag_t) 0x80U)\t/* context specific */", "#define LDAP_SUBSTRING_ANY\t\t((ber_tag_t) 0x81U)\t/* context specific */", "#define LDAP_SUBSTRING_FINAL\t((ber_tag_t) 0x82U)\t/* context specific */", "", "/* search scopes */", "#define LDAP_SCOPE_BASE\t\t\t((ber_int_t) 0x0000)", "#define LDAP_SCOPE_BASEOBJECT\tLDAP_SCOPE_BASE", "#define LDAP_SCOPE_ONELEVEL\t\t((ber_int_t) 0x0001)", "#define LDAP_SCOPE_ONE\t\t\tLDAP_SCOPE_ONELEVEL", "#define LDAP_SCOPE_SUBTREE\t\t((ber_int_t) 0x0002)", "#define LDAP_SCOPE_SUB\t\t\tLDAP_SCOPE_SUBTREE", "#define LDAP_SCOPE_SUBORDINATE\t((ber_int_t) 0x0003) /* OpenLDAP extension */", "#define LDAP_SCOPE_CHILDREN\t\tLDAP_SCOPE_SUBORDINATE", "#define LDAP_SCOPE_DEFAULT\t\t((ber_int_t) -1)\t /* OpenLDAP extension */", "", "/* substring filter component types */", "#define LDAP_SUBSTRING_INITIAL\t((ber_tag_t) 0x80U)\t/* context specific */", "#define LDAP_SUBSTRING_ANY\t\t((ber_tag_t) 0x81U)\t/* context specific */", "#define LDAP_SUBSTRING_FINAL\t((ber_tag_t) 0x82U)\t/* context specific */", "", "/*", " * LDAP Result Codes", " */", "#define LDAP_SUCCESS\t\t\t\t0x00", "", "#define LDAP_RANGE(n,x,y)\t(((x) <= (n)) && ((n) <= (y)))", "", "#define LDAP_OPERATIONS_ERROR\t\t0x01", "#define LDAP_PROTOCOL_ERROR\t\t\t0x02", "#define LDAP_TIMELIMIT_EXCEEDED\t\t0x03", "#define LDAP_SIZELIMIT_EXCEEDED\t\t0x04", "#define LDAP_COMPARE_FALSE\t\t\t0x05", "#define LDAP_COMPARE_TRUE\t\t\t0x06", "#define LDAP_AUTH_METHOD_NOT_SUPPORTED\t0x07", "#define LDAP_STRONG_AUTH_NOT_SUPPORTED\tLDAP_AUTH_METHOD_NOT_SUPPORTED", "#define LDAP_STRONG_AUTH_REQUIRED\t0x08", "#define LDAP_STRONGER_AUTH_REQUIRED\tLDAP_STRONG_AUTH_REQUIRED", "#define LDAP_PARTIAL_RESULTS\t\t0x09\t/* LDAPv2+ (not LDAPv3) */", "", "#define\tLDAP_REFERRAL\t\t\t\t0x0a /* LDAPv3 */", "#define LDAP_ADMINLIMIT_EXCEEDED\t0x0b /* LDAPv3 */", "#define\tLDAP_UNAVAILABLE_CRITICAL_EXTENSION\t0x0c /* LDAPv3 */", "#define LDAP_CONFIDENTIALITY_REQUIRED\t0x0d /* LDAPv3 */", "#define\tLDAP_SASL_BIND_IN_PROGRESS\t0x0e /* LDAPv3 */", "", "#define LDAP_ATTR_ERROR(n)\tLDAP_RANGE((n),0x10,0x15) /* 16-21 */", "", "#define LDAP_NO_SUCH_ATTRIBUTE\t\t0x10", "#define LDAP_UNDEFINED_TYPE\t\t\t0x11", "#define LDAP_INAPPROPRIATE_MATCHING\t0x12", "#define LDAP_CONSTRAINT_VIOLATION\t0x13", "#define LDAP_TYPE_OR_VALUE_EXISTS\t0x14", "#define LDAP_INVALID_SYNTAX\t\t\t0x15", "", "#define LDAP_NAME_ERROR(n)\tLDAP_RANGE((n),0x20,0x24) /* 32-34,36 */", "", "#define LDAP_NO_SUCH_OBJECT\t\t\t0x20", "#define LDAP_ALIAS_PROBLEM\t\t\t0x21", "#define LDAP_INVALID_DN_SYNTAX\t\t0x22", "#define LDAP_IS_LEAF\t\t\t\t0x23 /* not LDAPv3 */", "#define LDAP_ALIAS_DEREF_PROBLEM\t0x24", "", "#define LDAP_SECURITY_ERROR(n)\tLDAP_RANGE((n),0x2F,0x32) /* 47-50 */", "", "#define LDAP_X_PROXY_AUTHZ_FAILURE\t0x2F /* LDAPv3 proxy authorization */", "#define LDAP_INAPPROPRIATE_AUTH\t\t0x30", "#define LDAP_INVALID_CREDENTIALS\t0x31", "#define LDAP_INSUFFICIENT_ACCESS\t0x32", "", "#define LDAP_SERVICE_ERROR(n)\tLDAP_RANGE((n),0x33,0x36) /* 51-54 */", "", "#define LDAP_BUSY\t\t\t\t\t0x33", "#define LDAP_UNAVAILABLE\t\t\t0x34", "#define LDAP_UNWILLING_TO_PERFORM\t0x35", "#define LDAP_LOOP_DETECT\t\t\t0x36", "", "#define LDAP_UPDATE_ERROR(n)\tLDAP_RANGE((n),0x40,0x47) /* 64-69,71 */", "", "#define LDAP_NAMING_VIOLATION\t\t0x40", "#define LDAP_OBJECT_CLASS_VIOLATION\t0x41", "#define LDAP_NOT_ALLOWED_ON_NONLEAF\t0x42", "#define LDAP_NOT_ALLOWED_ON_RDN\t\t0x43", "#define LDAP_ALREADY_EXISTS\t\t\t0x44", "#define LDAP_NO_OBJECT_CLASS_MODS\t0x45", "#define LDAP_RESULTS_TOO_LARGE\t\t0x46 /* CLDAP */", "#define LDAP_AFFECTS_MULTIPLE_DSAS\t0x47", "", "#define LDAP_VLV_ERROR\t\t\t\t0x4C", "", "#define LDAP_OTHER\t\t\t\t\t0x50", "", "/* LCUP operation codes (113-117) - not implemented */", "#define LDAP_CUP_RESOURCES_EXHAUSTED\t0x71", "#define LDAP_CUP_SECURITY_VIOLATION\t\t0x72", "#define LDAP_CUP_INVALID_DATA\t\t\t0x73", "#define LDAP_CUP_UNSUPPORTED_SCHEME\t\t0x74", "#define LDAP_CUP_RELOAD_REQUIRED\t\t0x75", "", "/* Cancel operation codes (118-121) */", "#define LDAP_CANCELLED\t\t\t\t0x76", "#define LDAP_NO_SUCH_OPERATION\t\t0x77", "#define LDAP_TOO_LATE\t\t\t\t0x78", "#define LDAP_CANNOT_CANCEL\t\t\t0x79", "", "/* Assertion control (122) */ ", "#define LDAP_ASSERTION_FAILED\t\t0x7A", "", "/* Proxied Authorization Denied (123) */ ", "#define LDAP_PROXIED_AUTHORIZATION_DENIED\t\t0x7B", "", "/* Experimental result codes */", "#define LDAP_E_ERROR(n)\tLDAP_RANGE((n),0x1000,0x3FFF)", "", "/* LDAP Sync (4096) */", "#define LDAP_SYNC_REFRESH_REQUIRED\t\t0x1000", "", "", "/* Private Use result codes */", "#define LDAP_X_ERROR(n)\tLDAP_RANGE((n),0x4000,0xFFFF)", "", "#define LDAP_X_SYNC_REFRESH_REQUIRED\t0x4100 /* defunct */", "#define LDAP_X_ASSERTION_FAILED\t\t\t0x410f /* defunct */", "", "/* for the LDAP No-Op control */", "#define LDAP_X_NO_OPERATION\t\t\t\t0x410e", "", "/* for the Chaining Behavior control (consecutive result codes requested;", " * see <draft-sermersheim-ldap-chaining> ) */", "#ifdef LDAP_CONTROL_X_CHAINING_BEHAVIOR", "#define\tLDAP_X_NO_REFERRALS_FOUND\t\t0x4110", "#define LDAP_X_CANNOT_CHAIN\t\t\t0x4111", "#endif", "", "/* for Distributed Procedures (see <draft-sermersheim-ldap-distproc>) */", "#ifdef LDAP_X_DISTPROC_BASE", "#define LDAP_X_INVALIDREFERENCE\t\t\t0x4112", "#endif", "", "#ifdef LDAP_X_TXN", "#define LDAP_X_TXN_SPECIFY_OKAY\t\t0x4120", "#define LDAP_X_TXN_ID_INVALID\t\t0x4121", "#endif", "", "/* API Error Codes", " *", " * Based on draft-ietf-ldap-c-api-xx", " * but with new negative code values", " */", "#define LDAP_API_ERROR(n)\t\t((n)<0)", "#define LDAP_API_RESULT(n)\t\t((n)<=0)", "", "#define LDAP_SERVER_DOWN\t\t\t\t(-1)", "#define LDAP_LOCAL_ERROR\t\t\t\t(-2)", "#define LDAP_ENCODING_ERROR\t\t\t\t(-3)", "#define LDAP_DECODING_ERROR\t\t\t\t(-4)", "#define LDAP_TIMEOUT\t\t\t\t\t(-5)", "#define LDAP_AUTH_UNKNOWN\t\t\t\t(-6)", "#define LDAP_FILTER_ERROR\t\t\t\t(-7)", "#define LDAP_USER_CANCELLED\t\t\t\t(-8)", "#define LDAP_PARAM_ERROR\t\t\t\t(-9)", "#define LDAP_NO_MEMORY\t\t\t\t\t(-10)", "#define LDAP_CONNECT_ERROR\t\t\t\t(-11)", "#define LDAP_NOT_SUPPORTED\t\t\t\t(-12)", "#define LDAP_CONTROL_NOT_FOUND\t\t\t(-13)", "#define LDAP_NO_RESULTS_RETURNED\t\t(-14)", "#define LDAP_MORE_RESULTS_TO_RETURN\t\t(-15)\t/* Obsolete */", "#define LDAP_CLIENT_LOOP\t\t\t\t(-16)", "#define LDAP_REFERRAL_LIMIT_EXCEEDED\t(-17)", "#define\tLDAP_X_CONNECTING\t\t\t(-18)", "", "", "/*", " * This structure represents both ldap messages and ldap responses.", " * These are really the same, except in the case of search responses,", " * where a response has multiple messages.", " */", "", "typedef struct ldapmsg LDAPMessage;", "", "/* for modifications */", "typedef struct ldapmod {", "\tint\t\tmod_op;", "", "#define LDAP_MOD_OP\t\t\t(0x0007)", "#define LDAP_MOD_ADD\t\t(0x0000)", "#define LDAP_MOD_DELETE\t\t(0x0001)", "#define LDAP_MOD_REPLACE\t(0x0002)", "#define LDAP_MOD_INCREMENT\t(0x0003) /* OpenLDAP extension */", "#define LDAP_MOD_BVALUES\t(0x0080)", "/* IMPORTANT: do not use code 0x1000 (or above),", " * it is used internally by the backends!", " * (see ldap/servers/slapd/slap.h)", " */", "", "\tchar\t\t*mod_type;", "\tunion mod_vals_u {", "\t\tchar\t\t**modv_strvals;", "\t\tstruct berval\t**modv_bvals;", "\t} mod_vals;", "#define mod_values\tmod_vals.modv_strvals", "#define mod_bvalues\tmod_vals.modv_bvals", "} LDAPMod;", "", "/*", " * structure representing an ldap session which can", " * encompass connections to multiple servers (in the", " * face of referrals).", " */", "typedef struct ldap LDAP;", "", "#define LDAP_DEREF_NEVER\t\t0x00", "#define LDAP_DEREF_SEARCHING\t0x01", "#define LDAP_DEREF_FINDING\t\t0x02", "#define LDAP_DEREF_ALWAYS\t\t0x03", "", "#define LDAP_NO_LIMIT\t\t\t0", "", "/* how many messages to retrieve results for */", "#define LDAP_MSG_ONE\t\t\t0x00", "#define LDAP_MSG_ALL\t\t\t0x01", "#define LDAP_MSG_RECEIVED\t\t0x02", "", "/*", " * types for ldap URL handling", " */", "typedef struct ldap_url_desc {", "\tstruct ldap_url_desc *lud_next;", "\tchar\t*lud_scheme;", "\tchar\t*lud_host;", "\tint\t\tlud_port;", "\tchar\t*lud_dn;", "\tchar\t**lud_attrs;", "\tint\t\tlud_scope;", "\tchar\t*lud_filter;", "\tchar\t**lud_exts;", "\tint\t\tlud_crit_exts;", "} LDAPURLDesc;", "", "#define LDAP_URL_SUCCESS\t\t0x00\t/* Success */", "#define LDAP_URL_ERR_MEM\t\t0x01\t/* can't allocate memory space */", "#define LDAP_URL_ERR_PARAM\t\t0x02\t/* parameter is bad */", "", "#define LDAP_URL_ERR_BADSCHEME\t0x03\t/* URL doesn't begin with \"ldap[si]://\" */", '#define LDAP_URL_ERR_BADENCLOSURE 0x04\t/* URL is missing trailing ">" */', "#define LDAP_URL_ERR_BADURL\t\t0x05\t/* URL is bad */", "#define LDAP_URL_ERR_BADHOST\t0x06\t/* host port is bad */", "#define LDAP_URL_ERR_BADATTRS\t0x07\t/* bad (or missing) attributes */", "#define LDAP_URL_ERR_BADSCOPE\t0x08\t/* scope string is invalid (or missing) */", "#define LDAP_URL_ERR_BADFILTER\t0x09\t/* bad or missing filter */", "#define LDAP_URL_ERR_BADEXTS\t0x0a\t/* bad or missing extensions */", "", "/*", " * LDAP sync (RFC4533) API", " */", "", "typedef struct ldap_sync_t ldap_sync_t;", "", "typedef enum {", "\t/* these are private - the client should never see them */", "\tLDAP_SYNC_CAPI_NONE\t\t= -1,", "", "\tLDAP_SYNC_CAPI_PHASE_FLAG\t= 0x10U,", "\tLDAP_SYNC_CAPI_IDSET_FLAG\t= 0x20U,", "\tLDAP_SYNC_CAPI_DONE_FLAG\t= 0x40U,", "", "\t/* these are passed to ls_search_entry() */", "\tLDAP_SYNC_CAPI_PRESENT\t\t= LDAP_SYNC_PRESENT,", "\tLDAP_SYNC_CAPI_ADD\t\t= LDAP_SYNC_ADD,", "\tLDAP_SYNC_CAPI_MODIFY\t\t= LDAP_SYNC_MODIFY,", "\tLDAP_SYNC_CAPI_DELETE\t\t= LDAP_SYNC_DELETE,", "", "\t/* these are passed to ls_intermediate() */", "\tLDAP_SYNC_CAPI_PRESENTS\t\t= ( LDAP_SYNC_CAPI_PHASE_FLAG | LDAP_SYNC_CAPI_PRESENT ),", "\tLDAP_SYNC_CAPI_DELETES\t\t= ( LDAP_SYNC_CAPI_PHASE_FLAG | LDAP_SYNC_CAPI_DELETE ),", "", "\tLDAP_SYNC_CAPI_PRESENTS_IDSET\t= ( LDAP_SYNC_CAPI_PRESENTS | LDAP_SYNC_CAPI_IDSET_FLAG ),", "\tLDAP_SYNC_CAPI_DELETES_IDSET\t= ( LDAP_SYNC_CAPI_DELETES | LDAP_SYNC_CAPI_IDSET_FLAG ),", "", "\tLDAP_SYNC_CAPI_DONE\t\t= ( LDAP_SYNC_CAPI_DONE_FLAG | LDAP_SYNC_CAPI_PRESENTS )", "} ldap_sync_refresh_t;", "", "/*", " * Called when an entry is returned by ldap_result().", " * If phase is LDAP_SYNC_CAPI_ADD or LDAP_SYNC_CAPI_MODIFY,", " * the entry has been either added or modified, and thus", " * the complete view of the entry should be in the LDAPMessage.", " * If phase is LDAP_SYNC_CAPI_PRESENT or LDAP_SYNC_CAPI_DELETE,", " * only the DN should be in the LDAPMessage.", " */", "typedef int (*ldap_sync_search_entry_f) LDAP_P((", "\tldap_sync_t\t\t\t*ls,", "\tLDAPMessage\t\t\t*msg,", "\tstruct berval\t\t\t*entryUUID,", "\tldap_sync_refresh_t\t\tphase ));", "", "/*", " * Called when a reference is returned; the client should know ", " * what to do with it.", " */", "typedef int (*ldap_sync_search_reference_f) LDAP_P((", "\tldap_sync_t\t\t\t*ls,", "\tLDAPMessage\t\t\t*msg ));", "", "/*", " * Called when specific intermediate/final messages are returned.", " * If phase is LDAP_SYNC_CAPI_PRESENTS or LDAP_SYNC_CAPI_DELETES,", ' * a "presents" or "deletes" phase begins.', ' * If phase is LDAP_SYNC_CAPI_DONE, a special "presents" phase', ' * with refreshDone set to "TRUE" has been returned, to indicate', " * that the refresh phase of a refreshAndPersist is complete.", " * In the above cases, syncUUIDs is NULL.", " *", " * If phase is LDAP_SYNC_CAPI_PRESENTS_IDSET or ", " * LDAP_SYNC_CAPI_DELETES_IDSET, syncUUIDs is an array of UUIDs", " * that are either present or have been deleted.", " */", "typedef int (*ldap_sync_intermediate_f) LDAP_P((", "\tldap_sync_t\t\t\t*ls,", "\tLDAPMessage\t\t\t*msg,", "\tBerVarray\t\t\tsyncUUIDs,", "\tldap_sync_refresh_t\t\tphase ));", "", "/*", " * Called when a searchResultDone is returned.  In refreshAndPersist,", " * this can only occur if the search for any reason is being terminated", " * by the server.", " */", "typedef int (*ldap_sync_search_result_f) LDAP_P((", "\tldap_sync_t\t\t\t*ls,", "\tLDAPMessage\t\t\t*msg,", "\tint\t\t\t\trefreshDeletes ));", "", "/*", " * This structure contains all information about the persistent search;", " * the caller is responsible for connecting, setting version, binding, tls...", " */", "struct ldap_sync_t {", "\t/* conf search params */", "\tchar\t\t\t\t*ls_base;", "\tint\t\t\t\tls_scope;", "\tchar\t\t\t\t*ls_filter;", "\tchar\t\t\t\t**ls_attrs;", "\tint\t\t\t\tls_timelimit;", "\tint\t\t\t\tls_sizelimit;", "", "\t/* poll timeout */", "\tint\t\t\t\tls_timeout;", "", "\t/* helpers - add as appropriate */", "\tldap_sync_search_entry_f\tls_search_entry;", "\tldap_sync_search_reference_f\tls_search_reference;", "\tldap_sync_intermediate_f\tls_intermediate;", "\tldap_sync_search_result_f\tls_search_result;", "", "\t/* set by the caller as appropriate */", "\tvoid\t\t\t\t*ls_private;", "", "\t/* conn stuff */", "\tLDAP\t\t\t\t*ls_ld;", "", "\t/* --- the parameters below are private - do not modify --- */", "", "\t/* FIXME: make the structure opaque, and provide an interface", "\t * to modify the public values? */", "", "\t/* result stuff */", "\tint\t\t\t\tls_msgid;", "", "\t/* sync stuff */", "\t/* needed by refreshOnly */", "\tint\t\t\t\tls_reloadHint;", "", "\t/* opaque - need to pass between sessions, updated by the API */", "\tstruct berval\t\t\tls_cookie;", "", "\t/* state variable - do not modify */", "\tldap_sync_refresh_t\t\tls_refreshPhase;", "};", "", "/*", " * End of LDAP sync (RFC4533) API", " */", "", "/*", " * Connection callbacks...", " */", "struct ldap_conncb;", "struct sockaddr;", "", "/* Called after a connection is established */", "typedef int (ldap_conn_add_f) LDAP_P(( LDAP *ld, Sockbuf *sb, LDAPURLDesc *srv, struct sockaddr *addr,", "\tstruct ldap_conncb *ctx ));", "/* Called before a connection is closed */", "typedef void (ldap_conn_del_f) LDAP_P(( LDAP *ld, Sockbuf *sb, struct ldap_conncb *ctx ));", "", "/* Callbacks are pushed on a stack. Last one pushed is first one executed. The", " * delete callback is called with a NULL Sockbuf just before freeing the LDAP handle.", " */", "typedef struct ldap_conncb {", "\tldap_conn_add_f *lc_add;", "\tldap_conn_del_f *lc_del;", "\tvoid *lc_arg;", "} ldap_conncb;", "", "/*", " * The API draft spec says we should declare (or cause to be declared)", " * 'struct timeval'.   We don't.  See IETF LDAPext discussions.", " */", "struct timeval;", "", "/*", " * in options.c:", " */", "LDAP_F( int )", "ldap_get_option LDAP_P((", "\tLDAP *ld,", "\tint option,", "\tvoid *outvalue));", "", "LDAP_F( int )", "ldap_set_option LDAP_P((", "\tLDAP *ld,", "\tint option,", "\tLDAP_CONST void *invalue));", "", "/* V3 REBIND Function Callback Prototype */", "typedef int (LDAP_REBIND_PROC) LDAP_P((", "\tLDAP *ld, LDAP_CONST char *url,", "\tber_tag_t request, ber_int_t msgid,", "\tvoid *params ));", "", "LDAP_F( int )", "ldap_set_rebind_proc LDAP_P((", "\tLDAP *ld,", "\tLDAP_REBIND_PROC *rebind_proc,", "\tvoid *params ));", "", "/* V3 referral selection Function Callback Prototype */", "typedef int (LDAP_NEXTREF_PROC) LDAP_P((", "\tLDAP *ld, char ***refsp, int *cntp,", "\tvoid *params ));", "", "LDAP_F( int )", "ldap_set_nextref_proc LDAP_P((", "\tLDAP *ld,", "\tLDAP_NEXTREF_PROC *nextref_proc,", "\tvoid *params ));", "", "/* V3 URLLIST Function Callback Prototype */", "typedef int (LDAP_URLLIST_PROC) LDAP_P((", "\tLDAP *ld, ", "\tLDAPURLDesc **urllist,", "\tLDAPURLDesc **url,", "\tvoid *params ));", "", "LDAP_F( int )", "ldap_set_urllist_proc LDAP_P((", "\tLDAP *ld,", "\tLDAP_URLLIST_PROC *urllist_proc,", "\tvoid *params ));", "", "/*", " * in controls.c:", " */", "#if LDAP_DEPRECATED\t", "LDAP_F( int )", "ldap_create_control LDAP_P((\t/* deprecated, use ldap_control_create */", "\tLDAP_CONST char *requestOID,", "\tBerElement *ber,", "\tint iscritical,", "\tLDAPControl **ctrlp ));", "", "LDAP_F( LDAPControl * )", "ldap_find_control LDAP_P((\t/* deprecated, use ldap_control_find */", "\tLDAP_CONST char *oid,", "\tLDAPControl **ctrls ));", "#endif", "", "LDAP_F( int )", "ldap_control_create LDAP_P((", "\tLDAP_CONST char *requestOID,", "\tint iscritical,", "\tstruct berval *value,", "\tint dupval,", "\tLDAPControl **ctrlp ));", "", "LDAP_F( LDAPControl * )", "ldap_control_find LDAP_P((", "\tLDAP_CONST char *oid,", "\tLDAPControl **ctrls,", "\tLDAPControl ***nextctrlp ));", "", "LDAP_F( void )", "ldap_control_free LDAP_P((", "\tLDAPControl *ctrl ));", "", "LDAP_F( void )", "ldap_controls_free LDAP_P((", "\tLDAPControl **ctrls ));", "", "LDAP_F( LDAPControl ** )", "ldap_controls_dup LDAP_P((", "\tLDAPControl *LDAP_CONST *controls ));", "", "LDAP_F( LDAPControl * )", "ldap_control_dup LDAP_P((", "\tLDAP_CONST LDAPControl *c ));", "", "/*", " * in dnssrv.c:", " */", "LDAP_F( int )", "ldap_domain2dn LDAP_P((", "\tLDAP_CONST char* domain,", "\tchar** dn ));", "", "LDAP_F( int )", "ldap_dn2domain LDAP_P((", "\tLDAP_CONST char* dn,", "\tchar** domain ));", "", "LDAP_F( int )", "ldap_domain2hostlist LDAP_P((", "\tLDAP_CONST char *domain,", "\tchar** hostlist ));", "", "/*", " * in extended.c:", " */", "LDAP_F( int )", "ldap_extended_operation LDAP_P((", "\tLDAP\t\t\t*ld,", "\tLDAP_CONST char\t*reqoid,", "\tstruct berval\t*reqdata,", "\tLDAPControl\t\t**serverctrls,", "\tLDAPControl\t\t**clientctrls,", "\tint\t\t\t\t*msgidp ));", "", "LDAP_F( int )", "ldap_extended_operation_s LDAP_P((", "\tLDAP\t\t\t*ld,", "\tLDAP_CONST char\t*reqoid,", "\tstruct berval\t*reqdata,", "\tLDAPControl\t\t**serverctrls,", "\tLDAPControl\t\t**clientctrls,", "\tchar\t\t\t**retoidp,", "\tstruct berval\t**retdatap ));", "", "LDAP_F( int )", "ldap_parse_extended_result LDAP_P((", "\tLDAP\t\t\t*ld,", "\tLDAPMessage\t\t*res,", "\tchar\t\t\t**retoidp,", "\tstruct berval\t**retdatap,", "\tint\t\t\t\tfreeit ));", "", "LDAP_F( int )", "ldap_parse_intermediate LDAP_P((", "\tLDAP\t\t\t*ld,", "\tLDAPMessage\t\t*res,", "\tchar\t\t\t**retoidp,", "\tstruct berval\t**retdatap,", "\tLDAPControl\t\t***serverctrls,", "\tint\t\t\t\tfreeit ));", "", "", "/*", " * in abandon.c:", " */", "LDAP_F( int )", "ldap_abandon_ext LDAP_P((", "\tLDAP\t\t\t*ld,", "\tint\t\t\t\tmsgid,", "\tLDAPControl\t\t**serverctrls,", "\tLDAPControl\t\t**clientctrls ));", "", "#if LDAP_DEPRECATED\t", "LDAP_F( int )", "ldap_abandon LDAP_P((\t/* deprecated, use ldap_abandon_ext */", "\tLDAP *ld,", "\tint msgid ));", "#endif", "", "/*", " * in add.c:", " */", "LDAP_F( int )", "ldap_add_ext LDAP_P((", "\tLDAP\t\t\t*ld,", "\tLDAP_CONST char\t*dn,", "\tLDAPMod\t\t\t**attrs,", "\tLDAPControl\t\t**serverctrls,", "\tLDAPControl\t\t**clientctrls,", "\tint \t\t\t*msgidp ));", "", "LDAP_F( int )", "ldap_add_ext_s LDAP_P((", "\tLDAP\t\t\t*ld,", "\tLDAP_CONST char\t*dn,", "\tLDAPMod\t\t\t**attrs,", "\tLDAPControl\t\t**serverctrls,", "\tLDAPControl\t\t**clientctrls ));", "", "#if LDAP_DEPRECATED", "LDAP_F( int )", "ldap_add LDAP_P((\t/* deprecated, use ldap_add_ext */", "\tLDAP *ld,", "\tLDAP_CONST char *dn,", "\tLDAPMod **attrs ));", "", "LDAP_F( int )", "ldap_add_s LDAP_P((\t/* deprecated, use ldap_add_ext_s */", "\tLDAP *ld,", "\tLDAP_CONST char *dn,", "\tLDAPMod **attrs ));", "#endif", "", "", "/*", " * in sasl.c:", " */", "LDAP_F( int )", "ldap_sasl_bind LDAP_P((", "\tLDAP\t\t\t*ld,", "\tLDAP_CONST char\t*dn,", "\tLDAP_CONST char\t*mechanism,", "\tstruct berval\t*cred,", "\tLDAPControl\t\t**serverctrls,", "\tLDAPControl\t\t**clientctrls,", "\tint\t\t\t\t*msgidp ));", "", "/* Interaction flags (should be passed about in a control)", " *  Automatic (default): use defaults, prompt otherwise", " *  Interactive: prompt always", " *  Quiet: never prompt", " */", "#define LDAP_SASL_AUTOMATIC\t\t0U", "#define LDAP_SASL_INTERACTIVE\t1U", "#define LDAP_SASL_QUIET\t\t\t2U", "", "/*", " * V3 SASL Interaction Function Callback Prototype", " *\twhen using Cyrus SASL, interact is pointer to sasl_interact_t", " *  should likely passed in a control (and provided controls)", " */", "typedef int (LDAP_SASL_INTERACT_PROC) LDAP_P((", "\tLDAP *ld, unsigned flags, void* defaults, void *interact ));", "", "LDAP_F( int )", "ldap_sasl_interactive_bind LDAP_P((", "\tLDAP *ld,", "\tLDAP_CONST char *dn, /* usually NULL */", "\tLDAP_CONST char *saslMechanism,", "\tLDAPControl **serverControls,", "\tLDAPControl **clientControls,", "", "\t/* should be client controls */", "\tunsigned flags,", "\tLDAP_SASL_INTERACT_PROC *proc,", "\tvoid *defaults,", "\t", "\t/* as obtained from ldap_result() */", "\tLDAPMessage *result,", "", "\t/* returned during bind processing */", "\tconst char **rmech,", "\tint *msgid ));", "", "LDAP_F( int )", "ldap_sasl_interactive_bind_s LDAP_P((", "\tLDAP *ld,", "\tLDAP_CONST char *dn, /* usually NULL */", "\tLDAP_CONST char *saslMechanism,", "\tLDAPControl **serverControls,", "\tLDAPControl **clientControls,", "", "\t/* should be client controls */", "\tunsigned flags,", "\tLDAP_SASL_INTERACT_PROC *proc,", "\tvoid *defaults ));", "", "LDAP_F( int )", "ldap_sasl_bind_s LDAP_P((", "\tLDAP\t\t\t*ld,", "\tLDAP_CONST char\t*dn,", "\tLDAP_CONST char\t*mechanism,", "\tstruct berval\t*cred,", "\tLDAPControl\t\t**serverctrls,", "\tLDAPControl\t\t**clientctrls,", "\tstruct berval\t**servercredp ));", "", "LDAP_F( int )", "ldap_parse_sasl_bind_result LDAP_P((", "\tLDAP\t\t\t*ld,", "\tLDAPMessage\t\t*res,", "\tstruct berval\t**servercredp,", "\tint\t\t\t\tfreeit ));", "", "#if LDAP_DEPRECATED", "/*", " * in bind.c:", " *\t(deprecated)", " */", "LDAP_F( int )", "ldap_bind LDAP_P((\t/* deprecated, use ldap_sasl_bind */", "\tLDAP *ld,", "\tLDAP_CONST char *who,", "\tLDAP_CONST char *passwd,", "\tint authmethod ));", "", "LDAP_F( int )", "ldap_bind_s LDAP_P((\t/* deprecated, use ldap_sasl_bind_s */", "\tLDAP *ld,", "\tLDAP_CONST char *who,", "\tLDAP_CONST char *cred,", "\tint authmethod ));", "", "/*", " * in sbind.c:", " */", "LDAP_F( int )", "ldap_simple_bind LDAP_P(( /* deprecated, use ldap_sasl_bind */", "\tLDAP *ld,", "\tLDAP_CONST char *who,", "\tLDAP_CONST char *passwd ));", "", "LDAP_F( int )", "ldap_simple_bind_s LDAP_P(( /* deprecated, use ldap_sasl_bind_s */", "\tLDAP *ld,", "\tLDAP_CONST char *who,", "\tLDAP_CONST char *passwd ));", "", "#endif", "", "", "/*", " * in compare.c:", " */", "LDAP_F( int )", "ldap_compare_ext LDAP_P((", "\tLDAP\t\t\t*ld,", "\tLDAP_CONST char\t*dn,", "\tLDAP_CONST char\t*attr,", "\tstruct berval\t*bvalue,", "\tLDAPControl\t\t**serverctrls,", "\tLDAPControl\t\t**clientctrls,", "\tint \t\t\t*msgidp ));", "", "LDAP_F( int )", "ldap_compare_ext_s LDAP_P((", "\tLDAP\t\t\t*ld,", "\tLDAP_CONST char\t*dn,", "\tLDAP_CONST char\t*attr,", "\tstruct berval\t*bvalue,", "\tLDAPControl\t\t**serverctrls,", "\tLDAPControl\t\t**clientctrls ));", "", "#if LDAP_DEPRECATED", "LDAP_F( int )", "ldap_compare LDAP_P((\t/* deprecated, use ldap_compare_ext */", "\tLDAP *ld,", "\tLDAP_CONST char *dn,", "\tLDAP_CONST char *attr,", "\tLDAP_CONST char *value ));", "", "LDAP_F( int )", "ldap_compare_s LDAP_P((\t/* deprecated, use ldap_compare_ext_s */", "\tLDAP *ld,", "\tLDAP_CONST char *dn,", "\tLDAP_CONST char *attr,", "\tLDAP_CONST char *value ));", "#endif", "", "", "/*", " * in delete.c:", " */", "LDAP_F( int )", "ldap_delete_ext LDAP_P((", "\tLDAP\t\t\t*ld,", "\tLDAP_CONST char\t*dn,", "\tLDAPControl\t\t**serverctrls,", "\tLDAPControl\t\t**clientctrls,", "\tint \t\t\t*msgidp ));", "", "LDAP_F( int )", "ldap_delete_ext_s LDAP_P((", "\tLDAP\t\t\t*ld,", "\tLDAP_CONST char\t*dn,", "\tLDAPControl\t\t**serverctrls,", "\tLDAPControl\t\t**clientctrls ));", "", "#if LDAP_DEPRECATED", "LDAP_F( int )", "ldap_delete LDAP_P((\t/* deprecated, use ldap_delete_ext */", "\tLDAP *ld,", "\tLDAP_CONST char *dn ));", "", "LDAP_F( int )", "ldap_delete_s LDAP_P((\t/* deprecated, use ldap_delete_ext_s */", "\tLDAP *ld,", "\tLDAP_CONST char *dn ));", "#endif", "", "", "/*", " * in error.c:", " */", "LDAP_F( int )", "ldap_parse_result LDAP_P((", "\tLDAP\t\t\t*ld,", "\tLDAPMessage\t\t*res,", "\tint\t\t\t\t*errcodep,", "\tchar\t\t\t**matcheddnp,", "\tchar\t\t\t**errmsgp,", "\tchar\t\t\t***referralsp,", "\tLDAPControl\t\t***serverctrls,", "\tint\t\t\t\tfreeit ));", "", "LDAP_F( char * )", "ldap_err2string LDAP_P((", "\tint err ));", "", "#if LDAP_DEPRECATED", "LDAP_F( int )", "ldap_result2error LDAP_P((\t/* deprecated, use ldap_parse_result */", "\tLDAP *ld,", "\tLDAPMessage *r,", "\tint freeit ));", "", "LDAP_F( void )", "ldap_perror LDAP_P((\t/* deprecated, use ldap_err2string */", "\tLDAP *ld,", "\tLDAP_CONST char *s ));", "#endif", "", "", "/*", " * gssapi.c:", " */", "LDAP_F( int )", "ldap_gssapi_bind LDAP_P((", "\tLDAP *ld,", "\tLDAP_CONST char *dn,", "\tLDAP_CONST char *creds ));", "", "LDAP_F( int )", "ldap_gssapi_bind_s LDAP_P((", "\tLDAP *ld,", "\tLDAP_CONST char *dn,", "\tLDAP_CONST char *creds ));", "", "", "/*", " * in modify.c:", " */", "LDAP_F( int )", "ldap_modify_ext LDAP_P((", "\tLDAP\t\t\t*ld,", "\tLDAP_CONST char\t*dn,", "\tLDAPMod\t\t\t**mods,", "\tLDAPControl\t\t**serverctrls,", "\tLDAPControl\t\t**clientctrls,", "\tint \t\t\t*msgidp ));", "", "LDAP_F( int )", "ldap_modify_ext_s LDAP_P((", "\tLDAP\t\t\t*ld,", "\tLDAP_CONST char\t*dn,", "\tLDAPMod\t\t\t**mods,", "\tLDAPControl\t\t**serverctrls,", "\tLDAPControl\t\t**clientctrls ));", "", "#if LDAP_DEPRECATED", "LDAP_F( int )", "ldap_modify LDAP_P((\t/* deprecated, use ldap_modify_ext */", "\tLDAP *ld,", "\tLDAP_CONST char *dn,", "\tLDAPMod **mods ));", "", "LDAP_F( int )", "ldap_modify_s LDAP_P((\t/* deprecated, use ldap_modify_ext_s */", "\tLDAP *ld,", "\tLDAP_CONST char *dn,", "\tLDAPMod **mods ));", "#endif", "", "", "/*", " * in modrdn.c:", " */", "LDAP_F( int )", "ldap_rename LDAP_P((", "\tLDAP *ld,", "\tLDAP_CONST char *dn,", "\tLDAP_CONST char *newrdn,", "\tLDAP_CONST char *newSuperior,", "\tint deleteoldrdn,", "\tLDAPControl **sctrls,", "\tLDAPControl **cctrls,", "\tint *msgidp ));", "", "LDAP_F( int )", "ldap_rename_s LDAP_P((", "\tLDAP *ld,", "\tLDAP_CONST char *dn,", "\tLDAP_CONST char *newrdn,", "\tLDAP_CONST char *newSuperior,", "\tint deleteoldrdn,", "\tLDAPControl **sctrls,", "\tLDAPControl **cctrls ));", "", "#if LDAP_DEPRECATED", "LDAP_F( int )", "ldap_rename2 LDAP_P((\t/* deprecated, use ldap_rename */", "\tLDAP *ld,", "\tLDAP_CONST char *dn,", "\tLDAP_CONST char *newrdn,", "\tLDAP_CONST char *newSuperior,", "\tint deleteoldrdn ));", "", "LDAP_F( int )", "ldap_rename2_s LDAP_P((\t/* deprecated, use ldap_rename_s */", "\tLDAP *ld,", "\tLDAP_CONST char *dn,", "\tLDAP_CONST char *newrdn,", "\tLDAP_CONST char *newSuperior,", "\tint deleteoldrdn ));", "", "LDAP_F( int )", "ldap_modrdn LDAP_P((\t/* deprecated, use ldap_rename */", "\tLDAP *ld,", "\tLDAP_CONST char *dn,", "\tLDAP_CONST char *newrdn ));", "", "LDAP_F( int )", "ldap_modrdn_s LDAP_P((\t/* deprecated, use ldap_rename_s */", "\tLDAP *ld,", "\tLDAP_CONST char *dn,", "\tLDAP_CONST char *newrdn ));", "", "LDAP_F( int )", "ldap_modrdn2 LDAP_P((\t/* deprecated, use ldap_rename */", "\tLDAP *ld,", "\tLDAP_CONST char *dn,", "\tLDAP_CONST char *newrdn,", "\tint deleteoldrdn ));", "", "LDAP_F( int )", "ldap_modrdn2_s LDAP_P((\t/* deprecated, use ldap_rename_s */", "\tLDAP *ld,", "\tLDAP_CONST char *dn,", "\tLDAP_CONST char *newrdn,", "\tint deleteoldrdn));", "#endif", "", "", "/*", " * in open.c:", " */", "#if LDAP_DEPRECATED", "LDAP_F( LDAP * )", "ldap_init LDAP_P(( /* deprecated, use ldap_create or ldap_initialize */", "\tLDAP_CONST char *host,", "\tint port ));", "", "LDAP_F( LDAP * )", "ldap_open LDAP_P((\t/* deprecated, use ldap_create or ldap_initialize */", "\tLDAP_CONST char *host,", "\tint port ));", "#endif", "", "LDAP_F( int )", "ldap_create LDAP_P((", "\tLDAP **ldp ));", "", "LDAP_F( int )", "ldap_initialize LDAP_P((", "\tLDAP **ldp,", "\tLDAP_CONST char *url ));", "", "LDAP_F( LDAP * )", "ldap_dup LDAP_P((", "\tLDAP *old ));", "", "/*", " * in tls.c", " */", "", "LDAP_F( int )", "ldap_tls_inplace LDAP_P((", "\tLDAP *ld ));", "", "LDAP_F( int )", "ldap_start_tls LDAP_P((", "\tLDAP *ld,", "\tLDAPControl **serverctrls,", "\tLDAPControl **clientctrls,", "\tint *msgidp ));", "", "LDAP_F( int )", "ldap_install_tls LDAP_P((", "\tLDAP *ld ));", "", "LDAP_F( int )", "ldap_start_tls_s LDAP_P((", "\tLDAP *ld,", "\tLDAPControl **serverctrls,", "\tLDAPControl **clientctrls ));", "", "/*", " * in messages.c:", " */", "LDAP_F( LDAPMessage * )", "ldap_first_message LDAP_P((", "\tLDAP *ld,", "\tLDAPMessage *chain ));", "", "LDAP_F( LDAPMessage * )", "ldap_next_message LDAP_P((", "\tLDAP *ld,", "\tLDAPMessage *msg ));", "", "LDAP_F( int )", "ldap_count_messages LDAP_P((", "\tLDAP *ld,", "\tLDAPMessage *chain ));", "", "/*", " * in references.c:", " */", "LDAP_F( LDAPMessage * )", "ldap_first_reference LDAP_P((", "\tLDAP *ld,", "\tLDAPMessage *chain ));", "", "LDAP_F( LDAPMessage * )", "ldap_next_reference LDAP_P((", "\tLDAP *ld,", "\tLDAPMessage *ref ));", "", "LDAP_F( int )", "ldap_count_references LDAP_P((", "\tLDAP *ld,", "\tLDAPMessage *chain ));", "", "LDAP_F( int )", "ldap_parse_reference LDAP_P((", "\tLDAP\t\t\t*ld,", "\tLDAPMessage\t\t*ref,", "\tchar\t\t\t***referralsp,", "\tLDAPControl\t\t***serverctrls,", "\tint\t\t\t\tfreeit));", "", "", "/*", " * in getentry.c:", " */", "LDAP_F( LDAPMessage * )", "ldap_first_entry LDAP_P((", "\tLDAP *ld,", "\tLDAPMessage *chain ));", "", "LDAP_F( LDAPMessage * )", "ldap_next_entry LDAP_P((", "\tLDAP *ld,", "\tLDAPMessage *entry ));", "", "LDAP_F( int )", "ldap_count_entries LDAP_P((", "\tLDAP *ld,", "\tLDAPMessage *chain ));", "", "LDAP_F( int )", "ldap_get_entry_controls LDAP_P((", "\tLDAP\t\t\t*ld,", "\tLDAPMessage\t\t*entry,", "\tLDAPControl\t\t***serverctrls));", "", "", "/*", " * in addentry.c", " */", "LDAP_F( LDAPMessage * )", "ldap_delete_result_entry LDAP_P((", "\tLDAPMessage **list,", "\tLDAPMessage *e ));", "", "LDAP_F( void )", "ldap_add_result_entry LDAP_P((", "\tLDAPMessage **list,", "\tLDAPMessage *e ));", "", "", "/*", " * in getdn.c", " */", "LDAP_F( char * )", "ldap_get_dn LDAP_P((", "\tLDAP *ld,", "\tLDAPMessage *entry ));", "", "typedef struct ldap_ava {", "\tstruct berval la_attr;", "\tstruct berval la_value;", "\tunsigned la_flags;", "#define LDAP_AVA_NULL\t\t\t\t0x0000U", "#define LDAP_AVA_STRING\t\t\t\t0x0001U", "#define LDAP_AVA_BINARY\t\t\t\t0x0002U", "#define LDAP_AVA_NONPRINTABLE\t\t0x0004U", "#define LDAP_AVA_FREE_ATTR\t\t\t0x0010U", "#define LDAP_AVA_FREE_VALUE\t\t\t0x0020U", "", "\tvoid *la_private;", "} LDAPAVA;", "", "typedef LDAPAVA** LDAPRDN;", "typedef LDAPRDN* LDAPDN;", "", "/* DN formats */", "#define LDAP_DN_FORMAT_LDAP\t\t\t0x0000U", "#define LDAP_DN_FORMAT_LDAPV3\t\t0x0010U", "#define LDAP_DN_FORMAT_LDAPV2\t\t0x0020U", "#define LDAP_DN_FORMAT_DCE\t\t\t0x0030U", "#define LDAP_DN_FORMAT_UFN\t\t\t0x0040U\t/* dn2str only */", "#define LDAP_DN_FORMAT_AD_CANONICAL\t0x0050U\t/* dn2str only */", "#define LDAP_DN_FORMAT_LBER\t\t\t0x00F0U /* for testing only */", "#define LDAP_DN_FORMAT_MASK\t\t\t0x00F0U", "", "/* DN flags */", "#define LDAP_DN_PRETTY\t\t\t\t0x0100U", "#define LDAP_DN_SKIP\t\t\t\t0x0200U", "#define LDAP_DN_P_NOLEADTRAILSPACES\t0x1000U", "#define LDAP_DN_P_NOSPACEAFTERRDN\t0x2000U", "#define LDAP_DN_PEDANTIC\t\t\t0xF000U", "", "LDAP_F( void ) ldap_rdnfree LDAP_P(( LDAPRDN rdn ));", "LDAP_F( void ) ldap_dnfree LDAP_P(( LDAPDN dn ));", "", "LDAP_F( int )", "ldap_bv2dn LDAP_P(( ", "\tstruct berval *bv, ", "\tLDAPDN *dn, ", "\tunsigned flags ));", "", "LDAP_F( int )", "ldap_str2dn LDAP_P((", "\tLDAP_CONST char *str,", "\tLDAPDN *dn,", "\tunsigned flags ));", "", "LDAP_F( int )", "ldap_dn2bv LDAP_P((", "\tLDAPDN dn,", "\tstruct berval *bv,", "\tunsigned flags ));", "", "LDAP_F( int )", "ldap_dn2str LDAP_P((", "\tLDAPDN dn,", "\tchar **str,", "\tunsigned flags ));", "", "LDAP_F( int )", "ldap_bv2rdn LDAP_P((", "\tstruct berval *bv,", "\tLDAPRDN *rdn,", "\tchar **next,", "\tunsigned flags ));", "", "LDAP_F( int )", "ldap_str2rdn LDAP_P((", "\tLDAP_CONST char *str,", "\tLDAPRDN *rdn,", "\tchar **next,", "\tunsigned flags ));", "", "LDAP_F( int )", "ldap_rdn2bv LDAP_P((", "\tLDAPRDN rdn,", "\tstruct berval *bv,", "\tunsigned flags ));", "", "LDAP_F( int )", "ldap_rdn2str LDAP_P((", "\tLDAPRDN rdn,", "\tchar **str,", "\tunsigned flags ));", "", "LDAP_F( int )", "ldap_dn_normalize LDAP_P((", "\tLDAP_CONST char *in, unsigned iflags,", "\tchar **out, unsigned oflags ));", "", "LDAP_F( char * )", "ldap_dn2ufn LDAP_P(( /* deprecated, use ldap_str2dn/dn2str */", "\tLDAP_CONST char *dn ));", "", "LDAP_F( char ** )", "ldap_explode_dn LDAP_P(( /* deprecated, ldap_str2dn */", "\tLDAP_CONST char *dn,", "\tint notypes ));", "", "LDAP_F( char ** )", "ldap_explode_rdn LDAP_P(( /* deprecated, ldap_str2rdn */", "\tLDAP_CONST char *rdn,", "\tint notypes ));", "", "typedef int LDAPDN_rewrite_func", "\tLDAP_P(( LDAPDN dn, unsigned flags, void *ctx ));", "", "LDAP_F( int )", "ldap_X509dn2bv LDAP_P(( void *x509_name, struct berval *dn,", "\tLDAPDN_rewrite_func *func, unsigned flags ));", "", "LDAP_F( char * )", "ldap_dn2dcedn LDAP_P(( /* deprecated, ldap_str2dn/dn2str */", "\tLDAP_CONST char *dn ));", "", "LDAP_F( char * )", "ldap_dcedn2dn LDAP_P(( /* deprecated, ldap_str2dn/dn2str */", "\tLDAP_CONST char *dce ));", "", "LDAP_F( char * )", "ldap_dn2ad_canonical LDAP_P(( /* deprecated, ldap_str2dn/dn2str */", "\tLDAP_CONST char *dn ));", "", "LDAP_F( int )", "ldap_get_dn_ber LDAP_P((", "\tLDAP *ld, LDAPMessage *e, BerElement **berout, struct berval *dn ));", "", "LDAP_F( int )", "ldap_get_attribute_ber LDAP_P((", "\tLDAP *ld, LDAPMessage *e, BerElement *ber, struct berval *attr,", "\tstruct berval **vals ));", "", "/*", " * in getattr.c", " */", "LDAP_F( char * )", "ldap_first_attribute LDAP_P((", "\tLDAP *ld,", "\tLDAPMessage *entry,", "\tBerElement **ber ));", "", "LDAP_F( char * )", "ldap_next_attribute LDAP_P((", "\tLDAP *ld,", "\tLDAPMessage *entry,", "\tBerElement *ber ));", "", "", "/*", " * in getvalues.c", " */", "LDAP_F( struct berval ** )", "ldap_get_values_len LDAP_P((", "\tLDAP *ld,", "\tLDAPMessage *entry,", "\tLDAP_CONST char *target ));", "", "LDAP_F( int )", "ldap_count_values_len LDAP_P((", "\tstruct berval **vals ));", "", "LDAP_F( void )", "ldap_value_free_len LDAP_P((", "\tstruct berval **vals ));", "", "#if LDAP_DEPRECATED", "LDAP_F( char ** )", "ldap_get_values LDAP_P((\t/* deprecated, use ldap_get_values_len */", "\tLDAP *ld,", "\tLDAPMessage *entry,", "\tLDAP_CONST char *target ));", "", "LDAP_F( int )", "ldap_count_values LDAP_P((\t/* deprecated, use ldap_count_values_len */", "\tchar **vals ));", "", "LDAP_F( void )", "ldap_value_free LDAP_P((\t/* deprecated, use ldap_value_free_len */", "\tchar **vals ));", "#endif", "", "/*", " * in result.c:", " */", "LDAP_F( int )", "ldap_result LDAP_P((", "\tLDAP *ld,", "\tint msgid,", "\tint all,", "\tstruct timeval *timeout,", "\tLDAPMessage **result ));", "", "LDAP_F( int )", "ldap_msgtype LDAP_P((", "\tLDAPMessage *lm ));", "", "LDAP_F( int )", "ldap_msgid   LDAP_P((", "\tLDAPMessage *lm ));", "", "LDAP_F( int )", "ldap_msgfree LDAP_P((", "\tLDAPMessage *lm ));", "", "LDAP_F( int )", "ldap_msgdelete LDAP_P((", "\tLDAP *ld,", "\tint msgid ));", "", "", "/*", " * in search.c:", " */", "LDAP_F( int )", "ldap_bv2escaped_filter_value LDAP_P(( ", "\tstruct berval *in, ", "\tstruct berval *out ));", "", "LDAP_F( int )", "ldap_search_ext LDAP_P((", "\tLDAP\t\t\t*ld,", "\tLDAP_CONST char\t*base,", "\tint\t\t\t\tscope,", "\tLDAP_CONST char\t*filter,", "\tchar\t\t\t**attrs,", "\tint\t\t\t\tattrsonly,", "\tLDAPControl\t\t**serverctrls,", "\tLDAPControl\t\t**clientctrls,", "\tstruct timeval\t*timeout,", "\tint\t\t\t\tsizelimit,", "\tint\t\t\t\t*msgidp ));", "", "LDAP_F( int )", "ldap_search_ext_s LDAP_P((", "\tLDAP\t\t\t*ld,", "\tLDAP_CONST char\t*base,", "\tint\t\t\t\tscope,", "\tLDAP_CONST char\t*filter,", "\tchar\t\t\t**attrs,", "\tint\t\t\t\tattrsonly,", "\tLDAPControl\t\t**serverctrls,", "\tLDAPControl\t\t**clientctrls,", "\tstruct timeval\t*timeout,", "\tint\t\t\t\tsizelimit,", "\tLDAPMessage\t\t**res ));", "", "#if LDAP_DEPRECATED", "LDAP_F( int )", "ldap_search LDAP_P((\t/* deprecated, use ldap_search_ext */", "\tLDAP *ld,", "\tLDAP_CONST char *base,", "\tint scope,", "\tLDAP_CONST char *filter,", "\tchar **attrs,", "\tint attrsonly ));", "", "LDAP_F( int )", "ldap_search_s LDAP_P((\t/* deprecated, use ldap_search_ext_s */", "\tLDAP *ld,", "\tLDAP_CONST char *base,", "\tint scope,", "\tLDAP_CONST char *filter,", "\tchar **attrs,", "\tint attrsonly,", "\tLDAPMessage **res ));", "", "LDAP_F( int )", "ldap_search_st LDAP_P((\t/* deprecated, use ldap_search_ext_s */", "\tLDAP *ld,", "\tLDAP_CONST char *base,", "\tint scope,", "\tLDAP_CONST char *filter,", "    char **attrs,", "\tint attrsonly,", "\tstruct timeval *timeout,", "\tLDAPMessage **res ));", "#endif", "", "/*", " * in unbind.c", " */", "LDAP_F( int )", "ldap_unbind_ext LDAP_P((", "\tLDAP\t\t\t*ld,", "\tLDAPControl\t\t**serverctrls,", "\tLDAPControl\t\t**clientctrls));", "", "LDAP_F( int )", "ldap_unbind_ext_s LDAP_P((", "\tLDAP\t\t\t*ld,", "\tLDAPControl\t\t**serverctrls,", "\tLDAPControl\t\t**clientctrls));", "", "LDAP_F( int )", "ldap_destroy LDAP_P((", "\tLDAP\t\t\t*ld));", "", "#if LDAP_DEPRECATED", "LDAP_F( int )", "ldap_unbind LDAP_P(( /* deprecated, use ldap_unbind_ext */", "\tLDAP *ld ));", "", "LDAP_F( int )", "ldap_unbind_s LDAP_P(( /* deprecated, use ldap_unbind_ext_s */", "\tLDAP *ld ));", "#endif", "", "/*", " * in filter.c", " */", "LDAP_F( int )", "ldap_put_vrFilter LDAP_P((", "\tBerElement *ber,", "\tconst char *vrf ));", "", "/*", " * in free.c", " */", "", "LDAP_F( void * )", "ldap_memalloc LDAP_P((", "\tber_len_t s ));", "", "LDAP_F( void * )", "ldap_memrealloc LDAP_P((", "\tvoid* p,", "\tber_len_t s ));", "", "LDAP_F( void * )", "ldap_memcalloc LDAP_P((", "\tber_len_t n,", "\tber_len_t s ));", "", "LDAP_F( void )", "ldap_memfree LDAP_P((", "\tvoid* p ));", "", "LDAP_F( void )", "ldap_memvfree LDAP_P((", "\tvoid** v ));", "", "LDAP_F( char * )", "ldap_strdup LDAP_P((", "\tLDAP_CONST char * ));", "", "LDAP_F( void )", "ldap_mods_free LDAP_P((", "\tLDAPMod **mods,", "\tint freemods ));", "", "", "#if LDAP_DEPRECATED", "/*", " * in sort.c (deprecated, use custom code instead)", " */", "typedef int (LDAP_SORT_AD_CMP_PROC) LDAP_P(( /* deprecated */", "\tLDAP_CONST char *left,", "\tLDAP_CONST char *right ));", "", "typedef int (LDAP_SORT_AV_CMP_PROC) LDAP_P(( /* deprecated */", "\tLDAP_CONST void *left,", "\tLDAP_CONST void *right ));", "", "LDAP_F( int )\t/* deprecated */", "ldap_sort_entries LDAP_P(( LDAP *ld,", "\tLDAPMessage **chain,", "\tLDAP_CONST char *attr,", "\tLDAP_SORT_AD_CMP_PROC *cmp ));", "", "LDAP_F( int )\t/* deprecated */", "ldap_sort_values LDAP_P((", "\tLDAP *ld,", "\tchar **vals,", "\tLDAP_SORT_AV_CMP_PROC *cmp ));", "", "LDAP_F( int ) /* deprecated */", "ldap_sort_strcasecmp LDAP_P((", "\tLDAP_CONST void *a,", "\tLDAP_CONST void *b ));", "#endif", "", "/*", " * in url.c", " */", "LDAP_F( int )", "ldap_is_ldap_url LDAP_P((", "\tLDAP_CONST char *url ));", "", "LDAP_F( int )", "ldap_is_ldaps_url LDAP_P((", "\tLDAP_CONST char *url ));", "", "LDAP_F( int )", "ldap_is_ldapi_url LDAP_P((", "\tLDAP_CONST char *url ));", "", "LDAP_F( int )", "ldap_url_parse LDAP_P((", "\tLDAP_CONST char *url,", "\tLDAPURLDesc **ludpp ));", "", "LDAP_F( char * )", "ldap_url_desc2str LDAP_P((", "\tLDAPURLDesc *ludp ));", "", "LDAP_F( void )", "ldap_free_urldesc LDAP_P((", "\tLDAPURLDesc *ludp ));", "", "", "/*", " * LDAP Cancel Extended Operation <draft-zeilenga-ldap-cancel-xx.txt>", " *  in cancel.c", " */", "#define LDAP_API_FEATURE_CANCEL 1000", "", "LDAP_F( int )", "ldap_cancel LDAP_P(( LDAP *ld,", "\tint cancelid,", "\tLDAPControl\t\t**sctrls,", "\tLDAPControl\t\t**cctrls,", "\tint\t\t\t\t*msgidp ));", "", "LDAP_F( int )", "ldap_cancel_s LDAP_P(( LDAP *ld,", "\tint cancelid,", "\tLDAPControl **sctrl,", "\tLDAPControl **cctrl ));", "", "/*", " * LDAP Turn Extended Operation <draft-zeilenga-ldap-turn-xx.txt>", " *  in turn.c", " */", "#define LDAP_API_FEATURE_TURN 1000", "", "LDAP_F( int )", "ldap_turn LDAP_P(( LDAP *ld,", "\tint mutual,", "\tLDAP_CONST char* identifier,", "\tLDAPControl\t\t**sctrls,", "\tLDAPControl\t\t**cctrls,", "\tint\t\t\t\t*msgidp ));", "", "LDAP_F( int )", "ldap_turn_s LDAP_P(( LDAP *ld,", "\tint mutual,", "\tLDAP_CONST char* identifier,", "\tLDAPControl **sctrl,", "\tLDAPControl **cctrl ));", "", "/*", " * LDAP Paged Results", " *\tin pagectrl.c", " */", "#define LDAP_API_FEATURE_PAGED_RESULTS 2000", "", "LDAP_F( int )", "ldap_create_page_control_value LDAP_P((", "\tLDAP *ld,", "\tber_int_t pagesize,", "\tstruct berval *cookie,", "\tstruct berval *value ));", "", "LDAP_F( int )", "ldap_create_page_control LDAP_P((", "\tLDAP *ld,", "\tber_int_t pagesize,", "\tstruct berval *cookie,", "\tint iscritical,", "\tLDAPControl **ctrlp ));", "", "#if LDAP_DEPRECATED", "LDAP_F( int )", "ldap_parse_page_control LDAP_P((", "\t/* deprecated, use ldap_parse_pageresponse_control */", "\tLDAP *ld,", "\tLDAPControl **ctrls,", "\tber_int_t *count,", "\tstruct berval **cookie ));", "#endif", "", "LDAP_F( int )", "ldap_parse_pageresponse_control LDAP_P((", "\tLDAP *ld,", "\tLDAPControl *ctrl,", "\tber_int_t *count,", "\tstruct berval *cookie ));", "", "/*", " * LDAP Server Side Sort", " *\tin sortctrl.c", " */", "#define LDAP_API_FEATURE_SERVER_SIDE_SORT 2000", "", "/* structure for a sort-key */", "typedef struct ldapsortkey {", "\tchar *attributeType;", "\tchar *orderingRule;", "\tint reverseOrder;", "} LDAPSortKey;", "", "LDAP_F( int )", "ldap_create_sort_keylist LDAP_P((", "\tLDAPSortKey ***sortKeyList,", "\tchar *keyString ));", "", "LDAP_F( void )", "ldap_free_sort_keylist LDAP_P((", "\tLDAPSortKey **sortkeylist ));", "", "LDAP_F( int )", "ldap_create_sort_control_value LDAP_P((", "\tLDAP *ld,", "\tLDAPSortKey **keyList,", "\tstruct berval *value ));", "", "LDAP_F( int )", "ldap_create_sort_control LDAP_P((", "\tLDAP *ld,", "\tLDAPSortKey **keyList,", "\tint iscritical,", "\tLDAPControl **ctrlp ));", "", "LDAP_F( int )", "ldap_parse_sort_control LDAP_P((", "\tLDAP           *ld,", "\tLDAPControl    **ctrlp,", "\tunsigned long  *result,", "\tchar           **attribute ));", "", "LDAP_F( int )", "ldap_parse_sortresponse_control LDAP_P((", "\tLDAP *ld,", "\tLDAPControl *ctrl,", "\tber_int_t *result,", "\tchar **attribute ));", "", "/*", " * LDAP Virtual List View", " *\tin vlvctrl.c", " */", "#define LDAP_API_FEATURE_VIRTUAL_LIST_VIEW 2000", "", "/* structure for virtual list */", "typedef struct ldapvlvinfo {", "\tber_int_t ldvlv_version;", "    ber_int_t ldvlv_before_count;", "    ber_int_t ldvlv_after_count;", "    ber_int_t ldvlv_offset;", "    ber_int_t ldvlv_count;", "    struct berval *\tldvlv_attrvalue;", "    struct berval *\tldvlv_context;", "    void *\t\t\tldvlv_extradata;", "} LDAPVLVInfo;", "", "LDAP_F( int )", "ldap_create_vlv_control_value LDAP_P((", "\tLDAP *ld,", "\tLDAPVLVInfo *ldvlistp,", "\tstruct berval *value));", "", "LDAP_F( int )", "ldap_create_vlv_control LDAP_P((", "\tLDAP *ld,", "\tLDAPVLVInfo *ldvlistp,", "\tLDAPControl **ctrlp ));", "", "LDAP_F( int )", "ldap_parse_vlv_control LDAP_P(( ", "\tLDAP          *ld,", "\tLDAPControl   **ctrls,", "\tunsigned long *target_posp,", "\tunsigned long *list_countp,", "\tstruct berval **contextp,", "\tint           *errcodep ));", "", "LDAP_F( int )", "ldap_parse_vlvresponse_control LDAP_P((", "\tLDAP          *ld,", "\tLDAPControl   *ctrls,", "\tber_int_t *target_posp,", "\tber_int_t *list_countp,", "\tstruct berval **contextp,", "\tint           *errcodep ));", "", "/*", " * LDAP Who Am I?", " *\tin whoami.c", " */", "#define LDAP_API_FEATURE_WHOAMI 1000", "", "LDAP_F( int )", "ldap_parse_whoami LDAP_P((", "\tLDAP *ld,", "\tLDAPMessage *res,", "\tstruct berval **authzid ));", "", "LDAP_F( int )", "ldap_whoami LDAP_P(( LDAP *ld,", "\tLDAPControl\t\t**sctrls,", "\tLDAPControl\t\t**cctrls,", "\tint\t\t\t\t*msgidp ));", "", "LDAP_F( int )", "ldap_whoami_s LDAP_P((", "\tLDAP *ld,", "\tstruct berval **authzid,", "\tLDAPControl **sctrls,", "\tLDAPControl **cctrls ));", "", "/*", " * LDAP Password Modify", " *\tin passwd.c", " */", "#define LDAP_API_FEATURE_PASSWD_MODIFY 1000", "", "LDAP_F( int )", "ldap_parse_passwd LDAP_P((", "\tLDAP *ld,", "\tLDAPMessage *res,", "\tstruct berval *newpasswd ));", "", "LDAP_F( int )", "ldap_passwd LDAP_P(( LDAP *ld,", "\tstruct berval\t*user,", "\tstruct berval\t*oldpw,", "\tstruct berval\t*newpw,", "\tLDAPControl\t\t**sctrls,", "\tLDAPControl\t\t**cctrls,", "\tint\t\t\t\t*msgidp ));", "", "LDAP_F( int )", "ldap_passwd_s LDAP_P((", "\tLDAP *ld,", "\tstruct berval\t*user,", "\tstruct berval\t*oldpw,", "\tstruct berval\t*newpw,", "\tstruct berval *newpasswd,", "\tLDAPControl **sctrls,", "\tLDAPControl **cctrls ));", "", "#ifdef LDAP_CONTROL_PASSWORDPOLICYREQUEST", "/*", " * LDAP Password Policy controls", " *\tin ppolicy.c", " */", "#define LDAP_API_FEATURE_PASSWORD_POLICY 1000", "", "typedef enum passpolicyerror_enum {", "       PP_passwordExpired = 0,", "       PP_accountLocked = 1,", "       PP_changeAfterReset = 2,", "       PP_passwordModNotAllowed = 3,", "       PP_mustSupplyOldPassword = 4,", "       PP_insufficientPasswordQuality = 5,", "       PP_passwordTooShort = 6,", "       PP_passwordTooYoung = 7,", "       PP_passwordInHistory = 8,", "       PP_noError = 65535", "} LDAPPasswordPolicyError;", "", "LDAP_F( int )", "ldap_create_passwordpolicy_control LDAP_P((", "        LDAP *ld,", "        LDAPControl **ctrlp ));", "", "LDAP_F( int )", "ldap_parse_passwordpolicy_control LDAP_P((", "        LDAP *ld,", "        LDAPControl *ctrl,", "        ber_int_t *expirep,", "        ber_int_t *gracep,", "        LDAPPasswordPolicyError *errorp ));", "", "LDAP_F( const char * )", "ldap_passwordpolicy_err2txt LDAP_P(( LDAPPasswordPolicyError ));", "#endif /* LDAP_CONTROL_PASSWORDPOLICYREQUEST */", "", "/*", " * LDAP Dynamic Directory Services Refresh -- RFC 2589", " *\tin dds.c", " */", "#define LDAP_API_FEATURE_REFRESH 1000", "", "LDAP_F( int )", "ldap_parse_refresh LDAP_P((", "\tLDAP *ld,", "\tLDAPMessage *res,", "\tber_int_t *newttl ));", "", "LDAP_F( int )", "ldap_refresh LDAP_P(( LDAP *ld,", "\tstruct berval\t*dn,", "\tber_int_t ttl,", "\tLDAPControl\t\t**sctrls,", "\tLDAPControl\t\t**cctrls,", "\tint\t\t\t\t*msgidp ));", "", "LDAP_F( int )", "ldap_refresh_s LDAP_P((", "\tLDAP *ld,", "\tstruct berval\t*dn,", "\tber_int_t ttl,", "\tber_int_t *newttl,", "\tLDAPControl **sctrls,", "\tLDAPControl **cctrls ));", "", "/*", " * LDAP Transactions", " */", "#ifdef LDAP_X_TXN", "LDAP_F( int )", "ldap_txn_start LDAP_P(( LDAP *ld,", "\tLDAPControl\t\t**sctrls,", "\tLDAPControl\t\t**cctrls,", "\tint\t\t\t\t*msgidp ));", "", "LDAP_F( int )", "ldap_txn_start_s LDAP_P(( LDAP *ld,", "\tLDAPControl **sctrl,", "\tLDAPControl **cctrl,", "\tstruct berval **rettxnid ));", "", "LDAP_F( int )", "ldap_txn_end LDAP_P(( LDAP *ld,", "\tint\tcommit,", "\tstruct berval\t*txnid,", "\tLDAPControl\t\t**sctrls,", "\tLDAPControl\t\t**cctrls,", "\tint\t\t\t\t*msgidp ));", "", "LDAP_F( int )", "ldap_txn_end_s LDAP_P(( LDAP *ld,", "\tint\tcommit,", "\tstruct berval *txnid,", "\tLDAPControl **sctrl,", "\tLDAPControl **cctrl,", "\tint *retidp ));", "#endif", "", "/*", " * in ldap_sync.c", " */", "", "/*", " * initialize the persistent search structure", " */", "LDAP_F( ldap_sync_t * )", "ldap_sync_initialize LDAP_P((", "\tldap_sync_t\t*ls ));", "", "/*", " * destroy the persistent search structure", " */", "LDAP_F( void )", "ldap_sync_destroy LDAP_P((", "\tldap_sync_t\t*ls,", "\tint\t\tfreeit ));", "", "/*", " * initialize a refreshOnly sync", " */", "LDAP_F( int )", "ldap_sync_init LDAP_P((", "\tldap_sync_t\t*ls,", "\tint\t\tmode ));", "", "/*", " * initialize a refreshOnly sync", " */", "LDAP_F( int )", "ldap_sync_init_refresh_only LDAP_P((", "\tldap_sync_t\t*ls ));", "", "/*", " * initialize a refreshAndPersist sync", " */", "LDAP_F( int )", "ldap_sync_init_refresh_and_persist LDAP_P((", "\tldap_sync_t\t*ls ));", "", "/*", " * poll for new responses", " */", "LDAP_F( int )", "ldap_sync_poll LDAP_P((", "\tldap_sync_t\t*ls ));", "", "#ifdef LDAP_CONTROL_X_SESSION_TRACKING", "", "/*", " * in stctrl.c", " */", "LDAP_F( int )", "ldap_create_session_tracking_value LDAP_P((", "\tLDAP\t\t*ld,", "\tchar\t\t*sessionSourceIp,", "\tchar\t\t*sessionSourceName,", "\tchar\t\t*formatOID,", "\tstruct berval\t*sessionTrackingIdentifier,", "\tstruct berval\t*value ));", "", "LDAP_F( int )", "ldap_create_session_tracking LDAP_P((", "\tLDAP\t\t*ld,", "\tchar\t\t*sessionSourceIp,", "\tchar\t\t*sessionSourceName,", "\tchar\t\t*formatOID,", "\tstruct berval\t*sessionTrackingIdentifier,", "\tLDAPControl\t**ctrlp ));", "", "LDAP_F( int )", "ldap_parse_session_tracking_control LDAP_P((", "\tLDAP *ld,", "\tLDAPControl *ctrl,", "\tstruct berval *ip,", "\tstruct berval *name,", "\tstruct berval *oid,", "\tstruct berval *id ));", "", "#endif /* LDAP_CONTROL_X_SESSION_TRACKING */", "", "/*", " * in assertion.c", " */", "LDAP_F (int)", "ldap_create_assertion_control_value LDAP_P((", "\tLDAP\t\t*ld,", "\tchar\t\t*assertion,", "\tstruct berval\t*value ));", "", "LDAP_F( int )", "ldap_create_assertion_control LDAP_P((", "\tLDAP\t\t*ld,", "\tchar\t\t*filter,", "\tint\t\tiscritical,", "\tLDAPControl\t**ctrlp ));", "", "/*", " * in deref.c", " */", "", "typedef struct LDAPDerefSpec {", "\tchar *derefAttr;", "\tchar **attributes;", "} LDAPDerefSpec;", "", "typedef struct LDAPDerefVal {", "\tchar *type;", "\tBerVarray vals;", "\tstruct LDAPDerefVal *next;", "} LDAPDerefVal;", "", "typedef struct LDAPDerefRes {", "\tchar *derefAttr;", "\tstruct berval derefVal;", "\tLDAPDerefVal *attrVals;", "\tstruct LDAPDerefRes *next;", "} LDAPDerefRes;", "", "LDAP_F( int )", "ldap_create_deref_control_value LDAP_P((", "\tLDAP *ld,", "\tLDAPDerefSpec *ds,", "\tstruct berval *value ));", "", "LDAP_F( int )", "ldap_create_deref_control LDAP_P((", "\tLDAP\t\t*ld,", "\tLDAPDerefSpec\t*ds,", "\tint\t\tiscritical,", "\tLDAPControl\t**ctrlp ));", "", "LDAP_F( void )", "ldap_derefresponse_free LDAP_P((", "\tLDAPDerefRes *dr ));", "", "LDAP_F( int )", "ldap_parse_derefresponse_control LDAP_P((", "\tLDAP *ld,", "\tLDAPControl *ctrl,", "\tLDAPDerefRes **drp ));", "", "LDAP_F( int )", "ldap_parse_deref_control LDAP_P((", "\tLDAP\t\t*ld,", "\tLDAPControl\t**ctrls,", "\tLDAPDerefRes\t**drp ));", "", "LDAP_END_DECL", "#endif /* _LDAP_H */" },
    ["ldap_cdefs.h"] = { "/* $OpenLDAP$ */", "/* This work is part of OpenLDAP Software <http://www.openldap.org/>.", " * ", " * Copyright 1998-2011 The OpenLDAP Foundation.", " * All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted only as authorized by the OpenLDAP", " * Public License.", " *", " * A copy of this license is available in file LICENSE in the", " * top-level directory of the distribution or, alternatively, at", " * <http://www.OpenLDAP.org/license.html>.", " */", "/* LDAP C Defines */", "", "#ifndef _LDAP_CDEFS_H", "#define _LDAP_CDEFS_H", "", "#if defined(__cplusplus) || defined(c_plusplus)", '#\tdefine LDAP_BEGIN_DECL\textern "C" {', "#\tdefine LDAP_END_DECL\t}", "#else", "#\tdefine LDAP_BEGIN_DECL\t/* begin declarations */", "#\tdefine LDAP_END_DECL\t/* end declarations */", "#endif", "", "#if !defined(LDAP_NO_PROTOTYPES) && ( defined(LDAP_NEEDS_PROTOTYPES) || \\", "\tdefined(__STDC__) || defined(__cplusplus) || defined(c_plusplus) )", "", "\t/* ANSI C or C++ */", "#\tdefine LDAP_P(protos)\tprotos", "#\tdefine LDAP_CONCAT1(x,y)\tx ## y", "#\tdefine LDAP_CONCAT(x,y)\tLDAP_CONCAT1(x,y)", "#\tdefine LDAP_STRING(x)\t#x /* stringify without expanding x */", "#\tdefine LDAP_XSTRING(x)\tLDAP_STRING(x) /* expand x, then stringify */", "", "#ifndef LDAP_CONST", "#\tdefine LDAP_CONST\tconst", "#endif", "", "#else /* no prototypes */", "", "\t/* traditional C */", "#\tdefine LDAP_P(protos)\t()", "#\tdefine LDAP_CONCAT(x,y)\tx/**/y", '#\tdefine LDAP_STRING(x)\t"x"', "", "#ifndef LDAP_CONST", "#\tdefine LDAP_CONST\t/* no const */", "#endif", "", "#endif /* no prototypes */", "", "#if (__GNUC__) * 1000 + (__GNUC_MINOR__) >= 2006", "#\tdefine LDAP_GCCATTR(attrs)\t__attribute__(attrs)", "#else", "#\tdefine LDAP_GCCATTR(attrs)", "#endif", "", "/*", " * Support for Windows DLLs.", " *", " * When external source code includes header files for dynamic libraries,", ' * the external source code is "importing" DLL symbols into its resulting', " * object code. On Windows, symbols imported from DLLs must be explicitly", " * indicated in header files with the __declspec(dllimport) directive.", " * This is not totally necessary for functions because the compiler", " * (gcc or MSVC) will generate stubs when this directive is absent.", " * However, this is required for imported variables.", " *", " * The LDAP libraries, i.e. liblber and libldap, can be built as", " * static or shared, based on configuration. Just about all other source", " * code in OpenLDAP use these libraries. If the LDAP libraries", " * are configured as shared, 'configure' defines the LDAP_LIBS_DYNAMIC", " * macro. When other source files include LDAP library headers, the", " * LDAP library symbols will automatically be marked as imported. When", " * the actual LDAP libraries are being built, the symbols will not", " * be marked as imported because the LBER_LIBRARY or LDAP_LIBRARY macros", " * will be respectively defined.", " *", " * Any project outside of OpenLDAP with source code wanting to use", " * LDAP dynamic libraries should explicitly define LDAP_LIBS_DYNAMIC.", " * This will ensure that external source code appropriately marks symbols", " * that will be imported.", " *", " * The slapd executable, itself, can be used as a dynamic library.", " * For example, if a backend module is compiled as shared, it will", " * import symbols from slapd. When this happens, the slapd symbols", " * must be marked as imported in header files that the backend module", " * includes. Remember that slapd links with various static libraries.", " * If the LDAP libraries were configured as static, their object", " * code is also part of the monolithic slapd executable. Thus, when", " * a backend module imports symbols from slapd, it imports symbols from", " * all of the static libraries in slapd as well. Thus, the SLAP_IMPORT", " * macro, when defined, will appropriately mark symbols as imported.", " * This macro should be used by shared backend modules as well as any", " * other external source code that imports symbols from the slapd", " * executable as if it were a DLL.", " *", " * Note that we don't actually have to worry about using the", " * __declspec(dllexport) directive anywhere. This is because both", " * MSVC and Mingw provide alternate (more effective) methods for exporting", " * symbols out of binaries, i.e. the use of a DEF file.", " *", " * NOTE ABOUT BACKENDS: Backends can be configured as static or dynamic.", " * When a backend is configured as dynamic, slapd will load the backend", " * explicitly and populate function pointer structures by calling", " * the backend's well-known initialization function. Because of this", " * procedure, slapd never implicitly imports symbols from dynamic backends.", " * This makes it unnecessary to tag various backend functions with the", " * __declspec(dllimport) directive. This is because neither slapd nor", " * any other external binary should ever be implicitly loading a backend", " * dynamic module.", " *", " * Backends are supposed to be self-contained. However, it appears that", " * back-meta DOES implicitly import symbols from back-ldap. This means", " * that the __declspec(dllimport) directive should be marked on back-ldap", " * functions (in its header files) if and only if we're compiling for", " * windows AND back-ldap has been configured as dynamic AND back-meta", " * is the client of back-ldap. When client is slapd, there is no effect", " * since slapd does not implicitly import symbols.", " *", " * TODO(?): Currently, back-meta nor back-ldap is supported for Mingw32.", " * Thus, there's no need to worry about this right now. This is something that", " * may or may not have to be addressed in the future.", " */", "", "/* LBER library */", "#if defined(_WIN32) && \\", "    ((defined(LDAP_LIBS_DYNAMIC) && !defined(LBER_LIBRARY)) || \\", "     (!defined(LDAP_LIBS_DYNAMIC) && defined(SLAPD_IMPORT)))", "#\tdefine LBER_F(type)\t\textern __declspec(dllimport) type", "#\tdefine LBER_V(type)\t\textern __declspec(dllimport) type", "#else", "#\tdefine LBER_F(type)\t\textern type", "#\tdefine LBER_V(type)\t\textern type", "#endif", "", "/* LDAP library */", "#if defined(_WIN32) && \\", "    ((defined(LDAP_LIBS_DYNAMIC) && !defined(LDAP_LIBRARY)) || \\", "     (!defined(LDAP_LIBS_DYNAMIC) && defined(SLAPD_IMPORT)))", "#\tdefine LDAP_F(type)\t\textern __declspec(dllimport) type", "#\tdefine LDAP_V(type)\t\textern __declspec(dllimport) type", "#else", "#\tdefine LDAP_F(type)\t\textern type", "#\tdefine LDAP_V(type)\t\textern type", "#endif", "", "/* AVL library */", "#if defined(_WIN32) && defined(SLAPD_IMPORT)", "#\tdefine LDAP_AVL_F(type)\t\textern __declspec(dllimport) type", "#\tdefine LDAP_AVL_V(type)\t\textern __declspec(dllimport) type", "#else", "#\tdefine LDAP_AVL_F(type)\t\textern type", "#\tdefine LDAP_AVL_V(type)\t\textern type", "#endif", "", "/* LDIF library */", "#if defined(_WIN32) && defined(SLAPD_IMPORT)", "#\tdefine LDAP_LDIF_F(type)\textern __declspec(dllimport) type", "#\tdefine LDAP_LDIF_V(type)\textern __declspec(dllimport) type", "#else", "#\tdefine LDAP_LDIF_F(type)\textern type", "#\tdefine LDAP_LDIF_V(type)\textern type", "#endif", "", "/* LUNICODE library */", "#if defined(_WIN32) && defined(SLAPD_IMPORT)", "#\tdefine LDAP_LUNICODE_F(type)\textern __declspec(dllimport) type", "#\tdefine LDAP_LUNICODE_V(type)\textern __declspec(dllimport) type", "#else", "#\tdefine LDAP_LUNICODE_F(type)\textern type", "#\tdefine LDAP_LUNICODE_V(type)\textern type", "#endif", "", "/* LUTIL library */", "#if defined(_WIN32) && defined(SLAPD_IMPORT)", "#\tdefine LDAP_LUTIL_F(type)\textern __declspec(dllimport) type", "#\tdefine LDAP_LUTIL_V(type)\textern __declspec(dllimport) type", "#else", "#\tdefine LDAP_LUTIL_F(type)\textern type", "#\tdefine LDAP_LUTIL_V(type)\textern type", "#endif", "", "/* REWRITE library */", "#if defined(_WIN32) && defined(SLAPD_IMPORT)", "#\tdefine LDAP_REWRITE_F(type)\textern __declspec(dllimport) type", "#\tdefine LDAP_REWRITE_V(type)\textern __declspec(dllimport) type", "#else", "#\tdefine LDAP_REWRITE_F(type)\textern type", "#\tdefine LDAP_REWRITE_V(type)\textern type", "#endif", "", "/* SLAPD (as a dynamic library exporting symbols) */", "#if defined(_WIN32) && defined(SLAPD_IMPORT)", "#\tdefine LDAP_SLAPD_F(type)\textern __declspec(dllimport) type", "#\tdefine LDAP_SLAPD_V(type)\textern __declspec(dllimport) type", "#else", "#\tdefine LDAP_SLAPD_F(type)\textern type", "#\tdefine LDAP_SLAPD_V(type)\textern type", "#endif", "", "/* SLAPD (as a dynamic library exporting symbols) */", "#if defined(_WIN32) && defined(SLAPD_IMPORT)", "#\tdefine LDAP_SLAPI_F(type)\textern __declspec(dllimport) type", "#\tdefine LDAP_SLAPI_V(type)\textern __declspec(dllimport) type", "#else", "#\tdefine LDAP_SLAPI_F(type)\textern type", "#\tdefine LDAP_SLAPI_V(type)\textern type", "#endif", "", "/* SLAPD (as a dynamic library exporting symbols) */", "#if defined(_WIN32) && defined(SLAPD_IMPORT)", "#\tdefine SLAPI_F(type)\t\textern __declspec(dllimport) type", "#\tdefine SLAPI_V(type)\t\textern __declspec(dllimport) type", "#else", "#\tdefine SLAPI_F(type)\t\textern type", "#\tdefine SLAPI_V(type)\t\textern type", "#endif", "", "/*", " * C library. Mingw32 links with the dynamic C run-time library by default,", " * so the explicit definition of CSTATIC will keep dllimport from", " * being defined, if desired.", " *", " * MSVC defines the _DLL macro when the compiler is invoked with /MD or /MDd,", " * which means the resulting object code will be linked with the dynamic", " * C run-time library.", " *", " * Technically, it shouldn't be necessary to redefine any functions that", " * the headers for the C library should already contain. Nevertheless, this", " * is here as a safe-guard.", " *", " * TODO: Determine if these macros ever get expanded for Windows. If not,", " * the declspec expansion can probably be removed.", " */", "#if (defined(__MINGW32__) && !defined(CSTATIC)) || \\", "    (defined(_MSC_VER) && defined(_DLL))", "#\tdefine LDAP_LIBC_F(type)\textern __declspec(dllimport) type", "#\tdefine LDAP_LIBC_V(type)\textern __declspec(dllimport) type", "#else", "#\tdefine LDAP_LIBC_F(type)\textern type", "#\tdefine LDAP_LIBC_V(type)\textern type", "#endif", "", "#endif /* _LDAP_CDEFS_H */" },
    ["ldap_features.h"] = { "/* include/ldap_features.h.  Generated from ldap_features.hin by configure.  */", "/* $OpenLDAP$ */", "/* This work is part of OpenLDAP Software <http://www.openldap.org/>.", " *", " * Copyright 1998-2011 The OpenLDAP Foundation.", " * All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted only as authorized by the OpenLDAP", " * Public License.", " *", " * A copy of this license is available in file LICENSE in the", " * top-level directory of the distribution or, alternatively, at", " * <http://www.OpenLDAP.org/license.html>.", " */", "", "/* ", " * LDAP Features", " */", "", "#ifndef _LDAP_FEATURES_H", "#define _LDAP_FEATURES_H 1", "", "/* OpenLDAP API version macros */", "#define LDAP_VENDOR_VERSION 20428", "#define LDAP_VENDOR_VERSION_MAJOR 2", "#define LDAP_VENDOR_VERSION_MINOR 4", "#define LDAP_VENDOR_VERSION_PATCH 28", "", "/*", "** WORK IN PROGRESS!", "**", "** OpenLDAP reentrancy/thread-safeness should be dynamically", "** checked using ldap_get_option().", "**", "** The -lldap implementation is not thread-safe.", "**", "** The -lldap_r implementation is:", "**\t\tLDAP_API_FEATURE_THREAD_SAFE (basic thread safety)", "** but also be:", "**\t\tLDAP_API_FEATURE_SESSION_THREAD_SAFE", "**\t\tLDAP_API_FEATURE_OPERATION_THREAD_SAFE", "**", "** The preprocessor flag LDAP_API_FEATURE_X_OPENLDAP_THREAD_SAFE", "** can be used to determine if -lldap_r is available at compile", "** time.  You must define LDAP_THREAD_SAFE if and only if you", "** link with -lldap_r.", "**", "** If you fail to define LDAP_THREAD_SAFE when linking with", "** -lldap_r or define LDAP_THREAD_SAFE when linking with -lldap,", "** provided header definations and declarations may be incorrect.", "**", "*/", "", "/* is -lldap_r available or not */", "#define LDAP_API_FEATURE_X_OPENLDAP_THREAD_SAFE 1", "", "/* LDAP v2 Referrals */", "/* #undef LDAP_API_FEATURE_X_OPENLDAP_V2_REFERRALS */", "", "#endif /* LDAP_FEATURES */" },
    ["ldap_schema.h"] = { "/* $OpenLDAP$ */", "/* This work is part of OpenLDAP Software <http://www.openldap.org/>.", " *", " * Copyright 1998-2011 The OpenLDAP Foundation.", " * All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted only as authorized by the OpenLDAP", " * Public License.", " *", " * A copy of this license is available in file LICENSE in the", " * top-level directory of the distribution or, alternatively, at", " * <http://www.OpenLDAP.org/license.html>.", " */", "", "/* ldap-schema.h - Header for basic schema handling functions that can be", " *\t\tused by both clients and servers.", " * these routines should be renamed ldap_x_...", " */", "", "#ifndef _LDAP_SCHEMA_H", "#define _LDAP_SCHEMA_H 1", "", "#include <ldap_cdefs.h>", "", "LDAP_BEGIN_DECL", "", "/* Codes for parsing errors */", "", "#define LDAP_SCHERR_OUTOFMEM\t\t1", "#define LDAP_SCHERR_UNEXPTOKEN\t\t2", "#define LDAP_SCHERR_NOLEFTPAREN\t\t3", "#define LDAP_SCHERR_NORIGHTPAREN\t4", "#define LDAP_SCHERR_NODIGIT\t\t\t5", "#define LDAP_SCHERR_BADNAME\t\t\t6", "#define LDAP_SCHERR_BADDESC\t\t\t7", "#define LDAP_SCHERR_BADSUP\t\t\t8", "#define LDAP_SCHERR_DUPOPT\t\t\t9", "#define LDAP_SCHERR_EMPTY\t\t\t10", "#define LDAP_SCHERR_MISSING\t\t\t11", "#define LDAP_SCHERR_OUT_OF_ORDER\t12", "", "typedef struct ldap_schema_extension_item {", "\tchar *lsei_name;", "\tchar **lsei_values;", "} LDAPSchemaExtensionItem;", "", "typedef struct ldap_syntax {", "\tchar *syn_oid;\t\t/* REQUIRED */", "\tchar **syn_names;\t/* OPTIONAL */", "\tchar *syn_desc;\t\t/* OPTIONAL */", "\tLDAPSchemaExtensionItem **syn_extensions; /* OPTIONAL */", "} LDAPSyntax;", "", "typedef struct ldap_matchingrule {", "\tchar *mr_oid;\t\t/* REQUIRED */", "\tchar **mr_names;\t/* OPTIONAL */", "\tchar *mr_desc;\t\t/* OPTIONAL */", "\tint  mr_obsolete;\t/* OPTIONAL */", "\tchar *mr_syntax_oid;\t/* REQUIRED */", "\tLDAPSchemaExtensionItem **mr_extensions; /* OPTIONAL */", "} LDAPMatchingRule;", "", "typedef struct ldap_matchingruleuse {", "\tchar *mru_oid;\t\t/* REQUIRED */", "\tchar **mru_names;\t/* OPTIONAL */", "\tchar *mru_desc;\t\t/* OPTIONAL */", "\tint  mru_obsolete;\t/* OPTIONAL */", "\tchar **mru_applies_oids;\t/* REQUIRED */", "\tLDAPSchemaExtensionItem **mru_extensions; /* OPTIONAL */", "} LDAPMatchingRuleUse;", "", "typedef struct ldap_attributetype {", "\tchar *at_oid;\t\t/* REQUIRED */", "\tchar **at_names;\t/* OPTIONAL */", "\tchar *at_desc;\t\t/* OPTIONAL */", "\tint  at_obsolete;\t/* 0=no, 1=yes */", "\tchar *at_sup_oid;\t/* OPTIONAL */", "\tchar *at_equality_oid;\t/* OPTIONAL */", "\tchar *at_ordering_oid;\t/* OPTIONAL */", "\tchar *at_substr_oid;\t/* OPTIONAL */", "\tchar *at_syntax_oid;\t/* OPTIONAL */", "\tint  at_syntax_len;\t/* OPTIONAL */", "\tint  at_single_value;\t/* 0=no, 1=yes */", "\tint  at_collective;\t/* 0=no, 1=yes */", "\tint  at_no_user_mod;\t/* 0=no, 1=yes */", "\tint  at_usage;\t\t/* 0=userApplications, 1=directoryOperation,", "\t\t\t\t   2=distributedOperation, 3=dSAOperation */", "\tLDAPSchemaExtensionItem **at_extensions; /* OPTIONAL */", "} LDAPAttributeType;", "", "typedef struct ldap_objectclass {", "\tchar *oc_oid;\t\t/* REQUIRED */", "\tchar **oc_names;\t/* OPTIONAL */", "\tchar *oc_desc;\t\t/* OPTIONAL */", "\tint  oc_obsolete;\t/* 0=no, 1=yes */", "\tchar **oc_sup_oids;\t/* OPTIONAL */", "\tint  oc_kind;\t\t/* 0=ABSTRACT, 1=STRUCTURAL, 2=AUXILIARY */", "\tchar **oc_at_oids_must;\t/* OPTIONAL */", "\tchar **oc_at_oids_may;\t/* OPTIONAL */", "\tLDAPSchemaExtensionItem **oc_extensions; /* OPTIONAL */", "} LDAPObjectClass;", "", "typedef struct ldap_contentrule {", "\tchar *cr_oid;\t\t/* REQUIRED */", "\tchar **cr_names;\t/* OPTIONAL */", "\tchar *cr_desc;\t\t/* OPTIONAL */", "\tchar **cr_sup_oids;\t/* OPTIONAL */", "\tint  cr_obsolete;\t/* 0=no, 1=yes */", "\tchar **cr_oc_oids_aux;\t/* OPTIONAL */", "\tchar **cr_at_oids_must;\t/* OPTIONAL */", "\tchar **cr_at_oids_may;\t/* OPTIONAL */", "\tchar **cr_at_oids_not;\t/* OPTIONAL */", "\tLDAPSchemaExtensionItem **cr_extensions; /* OPTIONAL */", "} LDAPContentRule;", "", "typedef struct ldap_nameform {", "\tchar *nf_oid;\t\t/* REQUIRED */", "\tchar **nf_names;\t/* OPTIONAL */", "\tchar *nf_desc;\t\t/* OPTIONAL */", "\tint  nf_obsolete;\t/* 0=no, 1=yes */", "\tchar *nf_objectclass;\t/* REQUIRED */", "\tchar **nf_at_oids_must;\t/* REQUIRED */", "\tchar **nf_at_oids_may;\t/* OPTIONAL */", "\tLDAPSchemaExtensionItem **nf_extensions; /* OPTIONAL */", "} LDAPNameForm;", "", "typedef struct ldap_structurerule {", "\tint sr_ruleid;\t\t/* REQUIRED */", "\tchar **sr_names;\t/* OPTIONAL */", "\tchar *sr_desc;\t\t/* OPTIONAL */", "\tint  sr_obsolete;\t/* 0=no, 1=yes */", "\tchar *sr_nameform;\t/* REQUIRED */", "\tint sr_nsup_ruleids;/* number of sr_sup_ruleids */", "\tint *sr_sup_ruleids;/* OPTIONAL */", "\tLDAPSchemaExtensionItem **sr_extensions; /* OPTIONAL */", "} LDAPStructureRule;", "", "/*", " * Misc macros", " */", "#define LDAP_SCHEMA_NO\t\t\t\t0", "#define LDAP_SCHEMA_YES\t\t\t\t1", "", "#define LDAP_SCHEMA_USER_APPLICATIONS\t\t0", "#define LDAP_SCHEMA_DIRECTORY_OPERATION\t\t1", "#define LDAP_SCHEMA_DISTRIBUTED_OPERATION\t2", "#define LDAP_SCHEMA_DSA_OPERATION\t\t3", "", "#define LDAP_SCHEMA_ABSTRACT\t\t\t0", "#define LDAP_SCHEMA_STRUCTURAL\t\t\t1", "#define LDAP_SCHEMA_AUXILIARY\t\t\t2", "", "", "/*", " * Flags that control how liberal the parsing routines are.", " */", "#define LDAP_SCHEMA_ALLOW_NONE\t\t0x00U /* Strict parsing               */", "#define LDAP_SCHEMA_ALLOW_NO_OID\t0x01U /* Allow missing oid            */", "#define LDAP_SCHEMA_ALLOW_QUOTED\t0x02U /* Allow bogus extra quotes     */", "#define LDAP_SCHEMA_ALLOW_DESCR\t\t0x04U /* Allow descr instead of OID   */", "#define LDAP_SCHEMA_ALLOW_DESCR_PREFIX\t0x08U /* Allow descr as OID prefix    */", "#define LDAP_SCHEMA_ALLOW_OID_MACRO\t0x10U /* Allow OID macros in slapd    */", "#define LDAP_SCHEMA_ALLOW_OUT_OF_ORDER_FIELDS 0x20U /* Allow fields in most any order */", "#define LDAP_SCHEMA_ALLOW_ALL\t\t0x3fU /* Be very liberal in parsing   */", "#define\tLDAP_SCHEMA_SKIP\t\t\t0x80U /* Don't malloc any result      */", "", "", "LDAP_F( LDAP_CONST char * )", "ldap_syntax2name LDAP_P((", "\tLDAPSyntax * syn ));", "", "LDAP_F( LDAP_CONST char * )", "ldap_matchingrule2name LDAP_P((", "\tLDAPMatchingRule * mr ));", "", "LDAP_F( LDAP_CONST char * )", "ldap_matchingruleuse2name LDAP_P((", "\tLDAPMatchingRuleUse * mru ));", "", "LDAP_F( LDAP_CONST char * )", "ldap_attributetype2name LDAP_P((", "\tLDAPAttributeType * at ));", "", "LDAP_F( LDAP_CONST char * )", "ldap_objectclass2name LDAP_P((", "\tLDAPObjectClass * oc ));", "", "LDAP_F( LDAP_CONST char * )", "ldap_contentrule2name LDAP_P((", "\tLDAPContentRule * cr ));", "", "LDAP_F( LDAP_CONST char * )", "ldap_nameform2name LDAP_P((", "\tLDAPNameForm * nf ));", "", "LDAP_F( LDAP_CONST char * )", "ldap_structurerule2name LDAP_P((", "\tLDAPStructureRule * sr ));", "", "LDAP_F( void )", "ldap_syntax_free LDAP_P((", "\tLDAPSyntax * syn ));", "", "LDAP_F( void )", "ldap_matchingrule_free LDAP_P((", "\tLDAPMatchingRule * mr ));", "", "LDAP_F( void )", "ldap_matchingruleuse_free LDAP_P((", "\tLDAPMatchingRuleUse * mr ));", "", "LDAP_F( void )", "ldap_attributetype_free LDAP_P((", "\tLDAPAttributeType * at ));", "", "LDAP_F( void )", "ldap_objectclass_free LDAP_P((", "\tLDAPObjectClass * oc ));", "", "LDAP_F( void )", "ldap_contentrule_free LDAP_P((", "\tLDAPContentRule * cr ));", "", "LDAP_F( void )", "ldap_nameform_free LDAP_P((", "\tLDAPNameForm * nf ));", "", "LDAP_F( void )", "ldap_structurerule_free LDAP_P((", "\tLDAPStructureRule * sr ));", "", "LDAP_F( LDAPStructureRule * )", "ldap_str2structurerule LDAP_P((", "\tLDAP_CONST char * s,", "\tint * code,", "\tLDAP_CONST char ** errp,", "\tLDAP_CONST unsigned flags ));", "", "LDAP_F( LDAPNameForm * )", "ldap_str2nameform LDAP_P((", "\tLDAP_CONST char * s,", "\tint * code,", "\tLDAP_CONST char ** errp,", "\tLDAP_CONST unsigned flags ));", "", "LDAP_F( LDAPContentRule * )", "ldap_str2contentrule LDAP_P((", "\tLDAP_CONST char * s,", "\tint * code,", "\tLDAP_CONST char ** errp,", "\tLDAP_CONST unsigned flags ));", "", "LDAP_F( LDAPObjectClass * )", "ldap_str2objectclass LDAP_P((", "\tLDAP_CONST char * s,", "\tint * code,", "\tLDAP_CONST char ** errp,", "\tLDAP_CONST unsigned flags ));", "", "LDAP_F( LDAPAttributeType * )", "ldap_str2attributetype LDAP_P((", "\tLDAP_CONST char * s,", "\tint * code,", "\tLDAP_CONST char ** errp,", "\tLDAP_CONST unsigned flags ));", "", "LDAP_F( LDAPSyntax * )", "ldap_str2syntax LDAP_P((", "\tLDAP_CONST char * s,", "\tint * code,", "\tLDAP_CONST char ** errp,", "\tLDAP_CONST unsigned flags ));", "", "LDAP_F( LDAPMatchingRule * )", "ldap_str2matchingrule LDAP_P((", "\tLDAP_CONST char * s,", "\tint * code,", "\tLDAP_CONST char ** errp,", "\tLDAP_CONST unsigned flags ));", "", "LDAP_F( LDAPMatchingRuleUse * )", "ldap_str2matchingruleuse LDAP_P((", "\tLDAP_CONST char * s,", "\tint * code,", "\tLDAP_CONST char ** errp,", "\tLDAP_CONST unsigned flags ));", "", "LDAP_F( char * )", "ldap_structurerule2str LDAP_P((", "\tLDAPStructureRule * sr ));", "", "LDAP_F( struct berval * )", "ldap_structurerule2bv LDAP_P((", "\tLDAPStructureRule * sr, struct berval *bv ));", "", "LDAP_F( char * )", "ldap_nameform2str LDAP_P((", "\tLDAPNameForm * nf ));", "", "LDAP_F( struct berval * )", "ldap_nameform2bv LDAP_P((", "\tLDAPNameForm * nf, struct berval *bv ));", "", "LDAP_F( char * )", "ldap_contentrule2str LDAP_P((", "\tLDAPContentRule * cr ));", "", "LDAP_F( struct berval * )", "ldap_contentrule2bv LDAP_P((", "\tLDAPContentRule * cr, struct berval *bv ));", "", "LDAP_F( char * )", "ldap_objectclass2str LDAP_P((", "\tLDAPObjectClass * oc ));", "", "LDAP_F( struct berval * )", "ldap_objectclass2bv LDAP_P((", "\tLDAPObjectClass * oc, struct berval *bv ));", "", "LDAP_F( char * )", "ldap_attributetype2str LDAP_P((", "\tLDAPAttributeType * at ));", "", "LDAP_F( struct berval * )", "ldap_attributetype2bv LDAP_P((", "\tLDAPAttributeType * at, struct berval *bv ));", "", "LDAP_F( char * )", "ldap_syntax2str LDAP_P((", "\tLDAPSyntax * syn ));", "", "LDAP_F( struct berval * )", "ldap_syntax2bv LDAP_P((", "\tLDAPSyntax * syn, struct berval *bv ));", "", "LDAP_F( char * )", "ldap_matchingrule2str LDAP_P((", "\tLDAPMatchingRule * mr ));", "", "LDAP_F( struct berval * )", "ldap_matchingrule2bv LDAP_P((", "\tLDAPMatchingRule * mr, struct berval *bv ));", "", "LDAP_F( char * )", "ldap_matchingruleuse2str LDAP_P((", "\tLDAPMatchingRuleUse * mru ));", "", "LDAP_F( struct berval * )", "ldap_matchingruleuse2bv LDAP_P((", "\tLDAPMatchingRuleUse * mru, struct berval *bv ));", "", "LDAP_F( char * )", "ldap_scherr2str LDAP_P((", "\tint code )) LDAP_GCCATTR((const));", "", "LDAP_END_DECL", "", "#endif", "" },
    ["ldap_utf8.h"] = { "/* $OpenLDAP$ */", "/* This work is part of OpenLDAP Software <http://www.openldap.org/>.", " *", " * Copyright 1998-2011 The OpenLDAP Foundation.", " * All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted only as authorized by the OpenLDAP", " * Public License.", " *", " * A copy of this license is available in file LICENSE in the", " * top-level directory of the distribution or, alternatively, at", " * <http://www.OpenLDAP.org/license.html>.", " */", "/* This notice applies to changes, created by or for Novell, Inc.,", " * to preexisting works for which notices appear elsewhere in this file.", " *", " * Copyright (C) 2000 Novell, Inc. All Rights Reserved.", " *", " * THIS WORK IS SUBJECT TO U.S. AND INTERNATIONAL COPYRIGHT LAWS AND TREATIES.", " * USE, MODIFICATION, AND REDISTRIBUTION OF THIS WORK IS SUBJECT TO VERSION", " * 2.0.1 OF THE OPENLDAP PUBLIC LICENSE, A COPY OF WHICH IS AVAILABLE AT", ' * HTTP://WWW.OPENLDAP.ORG/LICENSE.HTML OR IN THE FILE "LICENSE" IN THE', " * TOP-LEVEL DIRECTORY OF THE DISTRIBUTION. ANY USE OR EXPLOITATION OF THIS", " * WORK OTHER THAN AS AUTHORIZED IN VERSION 2.0.1 OF THE OPENLDAP PUBLIC", " * LICENSE, OR OTHER PRIOR WRITTEN CONSENT FROM NOVELL, COULD SUBJECT THE", " * PERPETRATOR TO CRIMINAL AND CIVIL LIABILITY.", " */", "/* Note: A verbatim copy of version 2.0.1 of the OpenLDAP Public License", ' * can be found in the file "build/LICENSE-2.0.1" in this distribution', " * of OpenLDAP Software.", " */", "", "#ifndef _LDAP_UTF8_H", "#define _LDAP_UTF8_H", "", "#include <lber_types.h>\t/* get ber_*_t */", "", "/*", " * UTF-8 Utility Routines", " */", "", "LDAP_BEGIN_DECL", "", "#define LDAP_UCS4_INVALID (0x80000000U)", "typedef ber_int_t ldap_ucs4_t;", "", "", "/* LDAP_MAX_UTF8_LEN is 3 or 6 depending on size of wchar_t */", "#define LDAP_MAX_UTF8_LEN  ( sizeof(wchar_t) * 3/2 )", "", "/* Unicode conversion routines  */", "LDAP_F( ldap_ucs4_t ) ldap_x_utf8_to_ucs4( LDAP_CONST char * p );", "LDAP_F( int ) ldap_x_ucs4_to_utf8( ldap_ucs4_t c, char *buf );", "", "", "/*", " * Wide Char / UTF-8 Conversion Routines", " */", "", "/* UTF-8 character to Wide Char */", "LDAP_F(int) ldap_x_utf8_to_wc LDAP_P((", "\twchar_t *wchar, LDAP_CONST char *utf8char ));", "", "/* UTF-8 string to Wide Char string */", "LDAP_F(int) ldap_x_utf8s_to_wcs LDAP_P((", "\twchar_t *wcstr, LDAP_CONST char *utf8str, size_t count ));", "", "/* Wide Char to UTF-8 character */", "LDAP_F(int) ldap_x_wc_to_utf8 LDAP_P((", "\tchar *utf8char, wchar_t wchar, size_t count ));", "", "/* Wide Char string to UTF-8 string */", "LDAP_F(int) ldap_x_wcs_to_utf8s LDAP_P((", "\tchar *utf8str, LDAP_CONST wchar_t *wcstr, size_t count ));", "", "/*", " * MultiByte Char / UTF-8 Conversion Routines", " */", "", "/* UTF-8 character to MultiByte character */", "LDAP_F(int) ldap_x_utf8_to_mb LDAP_P((", "\tchar *mbchar, LDAP_CONST char *utf8char,", "\tint (*ldap_f_wctomb)( char *mbchar, wchar_t wchar )));", "", "/* UTF-8 string to MultiByte string */", "LDAP_F(int) ldap_x_utf8s_to_mbs LDAP_P((", "\tchar *mbstr, LDAP_CONST char *utf8str, size_t count,", "\tsize_t (*ldap_f_wcstombs)( char *mbstr,", "\t\tLDAP_CONST wchar_t *wcstr, size_t count) ));", "", "/* MultiByte character to UTF-8 character */", "LDAP_F(int) ldap_x_mb_to_utf8 LDAP_P((", "\tchar *utf8char, LDAP_CONST char *mbchar, size_t mbsize,", "\tint (*ldap_f_mbtowc)( wchar_t *wchar,", "\t\tLDAP_CONST char *mbchar, size_t count) ));", "", "/* MultiByte string to UTF-8 string */", "LDAP_F(int) ldap_x_mbs_to_utf8s LDAP_P((", "\tchar *utf8str, LDAP_CONST char *mbstr, size_t count,", "\tsize_t (*ldap_f_mbstowcs)( wchar_t *wcstr,", "\t\tLDAP_CONST char *mbstr, size_t count) ));", "", "LDAP_END_DECL", "", "#endif /* _LDAP_UTF8_H */" },
    ["ldif.h"] = { "/* $OpenLDAP$ */", "/* This work is part of OpenLDAP Software <http://www.openldap.org/>.", " *", " * Copyright 1998-2011 The OpenLDAP Foundation.", " * All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted only as authorized by the OpenLDAP", " * Public License.", " *", " * A copy of this license is available in file LICENSE in the", " * top-level directory of the distribution or, alternatively, at", " * <http://www.OpenLDAP.org/license.html>.", " */", "/* Portions Copyright (c) 1996 Regents of the University of Michigan.", " * All rights reserved.", " *", " * Redistribution and use in source and binary forms are permitted", " * provided that this notice is preserved and that due credit is given", " * to the University of Michigan at Ann Arbor. The name of the University", " * may not be used to endorse or promote products derived from this", " * software without specific prior written permission. This software", " * is provided ``as is'' without express or implied warranty.", " */", "", "#ifndef _LDIF_H", "#define _LDIF_H", "", "#include <ldap_cdefs.h>", "", "LDAP_BEGIN_DECL", "", "/* This is NOT a bogus extern declaration (unlike ldap_debug) */", "LDAP_LDIF_V (int) ldif_debug;", "", "#define LDIF_LINE_WIDTH      76      /* default maximum length of LDIF lines */", "#define LDIF_LINE_WIDTH_MAX  ((ber_len_t)-1) /* maximum length of LDIF lines */", "#define LDIF_LINE_WIDTH_WRAP(wrap) ((wrap) == 0 ? LDIF_LINE_WIDTH : (wrap))", "", "/*", " * Macro to calculate maximum number of bytes that the base64 equivalent", ' * of an item that is "len" bytes long will take up.  Base64 encoding', " * uses one byte for every six bits in the value plus up to two pad bytes.", " */", "#define LDIF_BASE64_LEN(len)\t(((len) * 4 / 3 ) + 3)", "", "/*", " * Macro to calculate maximum size that an LDIF-encoded type (length", ' * tlen) and value (length vlen) will take up:  room for type + ":: " +', " * first newline + base64 value + continued lines.  Each continued line", " * needs room for a newline and a leading space character.", " */", "#define LDIF_SIZE_NEEDED(nlen,vlen) \\", "    ((nlen) + 4 + LDIF_BASE64_LEN(vlen) \\", "    + ((LDIF_BASE64_LEN(vlen) + (nlen) + 3) / LDIF_LINE_WIDTH * 2 ))", "", "#define LDIF_SIZE_NEEDED_WRAP(nlen,vlen,wrap) \\", "    ((nlen) + 4 + LDIF_BASE64_LEN(vlen) \\", "    + ((wrap) == 0 ? ((LDIF_BASE64_LEN(vlen) + (nlen) + 3) / ( LDIF_LINE_WIDTH ) * 2 ) : \\", "\t((wrap) == LDIF_LINE_WIDTH_MAX ? 0 : ((LDIF_BASE64_LEN(vlen) + (nlen) + 3) / (wrap) * 2 ))))", "", "LDAP_LDIF_F( int )", "ldif_parse_line LDAP_P((", "\tLDAP_CONST char *line,", "\tchar **name,", "\tchar **value,", "\tber_len_t *vlen ));", "", "LDAP_LDIF_F( int )", "ldif_parse_line2 LDAP_P((", "\tchar *line,", "\tstruct berval *type,", "\tstruct berval *value,", "\tint *freeval ));", "", "LDAP_LDIF_F( FILE * )", "ldif_open_url LDAP_P(( LDAP_CONST char *urlstr ));", "", "LDAP_LDIF_F( int )", "ldif_fetch_url LDAP_P((", "\tLDAP_CONST char *line,", "\tchar **value,", "\tber_len_t *vlen ));", "", "LDAP_LDIF_F( char * )", "ldif_getline LDAP_P(( char **next ));", "", "LDAP_LDIF_F( int )", "ldif_countlines LDAP_P(( LDAP_CONST char *line ));", "", "/* ldif_ropen, rclose, read_record - just for reading LDIF files,", " * no special open/close needed to write LDIF files.", " */", "typedef struct LDIFFP {", "\tFILE *fp;", "\tstruct LDIFFP *prev;", "} LDIFFP;", "", "LDAP_LDIF_F( LDIFFP * )", "ldif_open LDAP_P(( LDAP_CONST char *file, LDAP_CONST char *mode ));", "", "LDAP_LDIF_F( void )", "ldif_close LDAP_P(( LDIFFP * ));", "", "LDAP_LDIF_F( int )", "ldif_read_record LDAP_P((", "\tLDIFFP *fp,", "\tint *lineno,", "\tchar **bufp,", "\tint *buflen ));", "", "LDAP_LDIF_F( int )", "ldif_must_b64_encode_register LDAP_P((", "\tLDAP_CONST char *name,", "\tLDAP_CONST char *oid ));", "", "LDAP_LDIF_F( void )", "ldif_must_b64_encode_release LDAP_P(( void ));", "", "#define LDIF_PUT_NOVALUE\t0x0000\t/* no value */", "#define LDIF_PUT_VALUE\t\t0x0001\t/* value w/ auto detection */", "#define LDIF_PUT_TEXT\t\t0x0002\t/* assume text */", "#define\tLDIF_PUT_BINARY\t\t0x0004\t/* assume binary (convert to base64) */", "#define LDIF_PUT_B64\t\t0x0008\t/* pre-converted base64 value */", "", "#define LDIF_PUT_COMMENT\t0x0010\t/* comment */", "#define LDIF_PUT_URL\t\t0x0020\t/* url */", "#define LDIF_PUT_SEP\t\t0x0040\t/* separator */", "", "LDAP_LDIF_F( void )", "ldif_sput LDAP_P((", "\tchar **out,", "\tint type,", "\tLDAP_CONST char *name,", "\tLDAP_CONST char *val,", "\tber_len_t vlen ));", "", "LDAP_LDIF_F( void )", "ldif_sput_wrap LDAP_P((", "\tchar **out,", "\tint type,", "\tLDAP_CONST char *name,", "\tLDAP_CONST char *val,", "\tber_len_t vlen,", "        ber_len_t wrap ));", "", "LDAP_LDIF_F( char * )", "ldif_put LDAP_P((", "\tint type,", "\tLDAP_CONST char *name,", "\tLDAP_CONST char *val,", "\tber_len_t vlen ));", "", "LDAP_LDIF_F( char * )", "ldif_put_wrap LDAP_P((", "\tint type,", "\tLDAP_CONST char *name,", "\tLDAP_CONST char *val,", "\tber_len_t vlen,", "\tber_len_t wrap ));", "", "LDAP_LDIF_F( int )", "ldif_is_not_printable LDAP_P((", "\tLDAP_CONST char *val,", "\tber_len_t vlen ));", "", "LDAP_END_DECL", "", "#endif /* _LDIF_H */" },
    ["libc.h"] = { "/*", " * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/*", " * Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved", " */", "", "#ifndef _LIBC_H", "#define _LIBC_H", "", "#include <stdio.h>", "#include <unistd.h>", "", "#ifdef\t__STRICT_BSD__", "#include <strings.h>", "#include <varargs.h>", "#else", "#include <string.h>", "#include <stdlib.h>", "#include <time.h>", "#include <stdarg.h>", "#endif", "", "#include <sys/param.h>", "#include <sys/mount.h>", "#include <sys/types.h>", "#include <sys/wait.h>", "#include <sys/time.h>", "#include <sys/times.h>", "#include <sys/resource.h>", "#include <signal.h>", "#include <sys/time.h>", "#include <sys/stat.h>", "#include <sys/file.h>", "#include <sys/socket.h>", "#include <sys/ioctl.h>", "#include <netinet/in.h>", "#include <arpa/inet.h>", "#include <mach/machine/vm_types.h>", "#include <mach/boolean.h>", "#include <mach/kern_return.h>", "", "struct qelem {", "        struct qelem *q_forw;", "        struct qelem *q_back;", "        char *q_data;", "};", "", "#include <sys/cdefs.h>", "", "__BEGIN_DECLS", "extern kern_return_t map_fd(int fd, vm_offset_t offset,", "        vm_offset_t *addr, boolean_t find_space, vm_size_t numbytes);", "__END_DECLS", "", "#endif  /* _LIBC_H */" },
    ["libcharset.h"] = { "/* Copyright (C) 2003 Free Software Foundation, Inc.", "   This file is part of the GNU CHARSET Library.", "", "   The GNU CHARSET Library is free software; you can redistribute it and/or", "   modify it under the terms of the GNU Library General Public License as", "   published by the Free Software Foundation; either version 2 of the", "   License, or (at your option) any later version.", "", "   The GNU CHARSET Library is distributed in the hope that it will be useful,", "   but WITHOUT ANY WARRANTY; without even the implied warranty of", "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU", "   Library General Public License for more details.", "", "   You should have received a copy of the GNU Library General Public License", "   along with the GNU CHARSET Library; see the file COPYING.LIB.  If not,", "   write to the Free Software Foundation, Inc., 51 Franklin Street,", "   Fifth Floor, Boston, MA 02110-1301, USA.  */", "", "#ifndef _LIBCHARSET_H", "#define _LIBCHARSET_H", "", "#include <localcharset.h>", "", "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "", "", "/* Support for relocatable packages.  */", "", "/* Sets the original and the current installation prefix of the package.", "   Relocation simply replaces a pathname starting with the original prefix", "   by the corresponding pathname with the current prefix instead.  Both", '   prefixes should be directory names without trailing slash (i.e. use ""', '   instead of "/").  */', "extern void libcharset_set_relocation_prefix (const char *orig_prefix,", "\t\t\t\t\t      const char *curr_prefix);", "", "", "#ifdef __cplusplus", "}", "#endif", "", "", "#endif /* _LIBCHARSET_H */" },
    ["libgen.h"] = { "/*\t$OpenBSD: libgen.h,v 1.4 1999/05/28 22:00:22 espie Exp $\t*/", "/*\t$FreeBSD: src/include/libgen.h,v 1.1.2.1 2000/11/12 18:01:51 adrian Exp $\t*/", "", "/*", " * Copyright (c) 1997 Todd C. Miller <Todd.Miller@courtesan.com>", " * All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. The name of the author may not be used to endorse or promote products", " *    derived from this software without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,", " * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY", " * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL", " * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,", " * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,", " * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;", " * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,", " * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR", " * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF", " * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.", " */", "", "#ifndef _LIBGEN_H_", "#define _LIBGEN_H_", "", "#include <sys/cdefs.h>", "", "__BEGIN_DECLS", "", "#if __DARWIN_UNIX03", "", "char\t*basename(char *);", "char\t*dirname(char *);", "", "#else  /* !__DARWIN_UNIX03 */", "", "char\t*basename(const char *);", "char\t*dirname(const char *);", "", "#endif /* __DARWIN_UNIX_03 */", "", "__END_DECLS", "", "#endif /* _LIBGEN_H_ */" },
    ["libproc.h"] = { "/*", " * Copyright (c) 2006, 2007, 2010 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "#ifndef _LIBPROC_H_", "#define _LIBPROC_H_", "", "#include <sys/cdefs.h>", "#include <sys/param.h>", "#include <sys/types.h>", "#include <sys/stat.h>", "#include <sys/mount.h>", "#include <sys/resource.h>", "#include <stdint.h>", "#include <stdbool.h>", "", "#include <sys/proc_info.h>", "", "#include <Availability.h>", "", "/*", " * This header file contains private interfaces to obtain process information.  ", " * These interfaces are subject to change in future releases.", " */", "", "/*!", "\t@define PROC_LISTPIDSPATH_PATH_IS_VOLUME", "\t@discussion This flag indicates that all processes that hold open", "\t\tfile references on the volume associated with the specified", "\t\tpath should be returned.", " */", "#define PROC_LISTPIDSPATH_PATH_IS_VOLUME\t1", "", "", "/*!", "\t@define PROC_LISTPIDSPATH_EXCLUDE_EVTONLY", "\t@discussion This flag indicates that file references that were opened", "\t\twith the O_EVTONLY flag should be excluded from the matching", "\t\tcriteria.", " */", "#define PROC_LISTPIDSPATH_EXCLUDE_EVTONLY\t2", "", "__BEGIN_DECLS", "", "", "/*!", "\t@function proc_listpidspath", "\t@discussion A function which will search through the current", "\t\tprocesses looking for open file references which match", "\t\ta specified path or volume.", "\t@param type types of processes to be searched (see proc_listpids)", "\t@param typeinfo adjunct information for type", "\t@param path file or volume path", "\t@param pathflags flags to control which files should be considered", "\t\tduring the process search.", "\t@param buffer a C array of int-sized values to be filled with", "\t\tprocess identifiers that hold an open file reference", "\t\tmatching the specified path or volume.  Pass NULL to", "\t\tobtain the minimum buffer size needed to hold the", "\t\tcurrently active processes.", "\t@param buffersize the size (in bytes) of the provided buffer.", "\t@result the number of bytes of data returned in the provided buffer;", "\t\t-1 if an error was encountered;", " */", "int\tproc_listpidspath(uint32_t\ttype,", "\t\t\t  uint32_t\ttypeinfo,", "\t\t\t  const char\t*path,", "\t\t\t  uint32_t\tpathflags,", "\t\t\t  void\t\t*buffer,", "\t\t\t  int\t\tbuffersize) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "", "int proc_listpids(uint32_t type, uint32_t typeinfo, void *buffer, int buffersize) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int proc_listallpids(void * buffer, int buffersize) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_1);", "int proc_listpgrppids(pid_t pgrpid, void * buffer, int buffersize) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_1);", "int proc_listchildpids(pid_t ppid, void * buffer, int buffersize) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_1);", "int proc_pidinfo(int pid, int flavor, uint64_t arg,  void *buffer, int buffersize) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int proc_pidfdinfo(int pid, int fd, int flavor, void * buffer, int buffersize) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int proc_pidfileportinfo(int pid, uint32_t fileport, int flavor, void *buffer, int buffersize) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);", "int proc_name(int pid, void * buffer, uint32_t buffersize) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int proc_regionfilename(int pid, uint64_t address, void * buffer, uint32_t buffersize) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int proc_kmsgbuf(void * buffer, uint32_t buffersize) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int proc_pidpath(int pid, void * buffer, uint32_t  buffersize) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int proc_libversion(int *major, int * minor) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "", "/*", " * Return resource usage information for the given pid, which can be a live process or a zombie.", " *", " * Returns 0 on success; or -1 on failure, with errno set to indicate the specific error.", " */", "int proc_pid_rusage(int pid, int flavor, rusage_info_t *buffer) __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0);", "", "/* ", " * A process can use the following api to set its own process control ", " * state on resoure starvation. The argument can have one of the PROC_SETPC_XX values", " */", "#define PROC_SETPC_NONE\t\t0", "#define PROC_SETPC_THROTTLEMEM\t1", "#define PROC_SETPC_SUSPEND\t2", "#define PROC_SETPC_TERMINATE\t3", "", "int proc_setpcontrol(const int control) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);", "int proc_setpcontrol(const int control);", "", "int proc_track_dirty(pid_t pid, uint32_t flags);", "int proc_set_dirty(pid_t pid, bool dirty);", "int proc_get_dirty(pid_t pid, uint32_t *flags);", "", "int proc_terminate(pid_t pid, int *sig);", "", "__END_DECLS", "", "#endif /*_LIBPROC_H_ */" },
    ["libunwind.h"] = { "/* -*- mode: C; c-basic-offset: 4; -*- ", " *", " * Copyright (c) 2008-2011 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " * ", " * ", " *            C interface to libuwind ", " *", " * Source compatible with libuwind API documented at:", " *    http://www.nongnu.org/libunwind/man/libunwind(3).html", " * ", " */", "", "", "#ifndef __LIBUNWIND__", "#define __LIBUNWIND__", "", "#include <stdint.h>", "#include <stddef.h>", "#include <mach/mach_types.h>", "#include <Availability.h>", "", "/* error codes */", "enum {", "    UNW_ESUCCESS           = 0,            /* no error */", "    UNW_EUNSPEC            = -6540,        /* unspecified (general) error */", "    UNW_ENOMEM             = -6541,        /* out of memory */", "    UNW_EBADREG            = -6542,        /* bad register number */", "    UNW_EREADONLYREG       = -6543,        /* attempt to write read-only register */", "    UNW_ESTOPUNWIND        = -6544,        /* stop unwinding */", "    UNW_EINVALIDIP         = -6545,        /* invalid IP */", "    UNW_EBADFRAME          = -6546,        /* bad frame */", "    UNW_EINVAL             = -6547,        /* unsupported operation or bad value */", "    UNW_EBADVERSION        = -6548,        /* unwind info has unsupported version */", "    UNW_ENOINFO            = -6549         /* no unwind info found */", "};", "", "", "struct unw_context_t { uint64_t data[128]; };", "typedef struct unw_context_t     unw_context_t;", "", "struct unw_cursor_t { uint64_t data[140]; };", "typedef struct unw_cursor_t      unw_cursor_t;", "", "typedef struct unw_addr_space*   unw_addr_space_t;", "", "typedef int                      unw_regnum_t;", "typedef uint64_t                 unw_word_t;", "typedef double                   unw_fpreg_t;", "", "struct unw_proc_info_t", "{", "    unw_word_t    start_ip;         /* start address of function */", "    unw_word_t    end_ip;           /* address after end of function */", "    unw_word_t    lsda;             /* address of language specific data area, or zero if not used */", "    unw_word_t    handler;          /* personality routine, or zero if not used */", "    unw_word_t    gp;               /* not used */", "    unw_word_t    flags;            /* not used */", "    uint32_t      format;           /* compact unwind encoding, or zero if none */", "    uint32_t      unwind_info_size; /* size of dwarf unwind info, or zero if none */", "    unw_word_t    unwind_info;      /* address of dwarf unwind info, or zero if none */", "    unw_word_t    extra;            /* mach_header of mach-o image containing function */", "};", "typedef struct unw_proc_info_t unw_proc_info_t;", "", "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "", "#if !__arm__", "extern int         unw_getcontext(unw_context_t*)                               __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_5_0);", "extern int         unw_init_local(unw_cursor_t*, unw_context_t*)                __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_5_0);", "extern int         unw_step(unw_cursor_t*)                                      __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_5_0);", "extern int         unw_get_reg(unw_cursor_t*, unw_regnum_t, unw_word_t*)        __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_5_0);", "extern int         unw_get_fpreg(unw_cursor_t*, unw_regnum_t, unw_fpreg_t*)     __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_5_0);", "extern int         unw_set_reg(unw_cursor_t*, unw_regnum_t, unw_word_t)         __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_5_0);", "extern int         unw_set_fpreg(unw_cursor_t*, unw_regnum_t, unw_fpreg_t)      __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_5_0);", "extern int         unw_resume(unw_cursor_t*)                                    __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_5_0);", "", "extern const char* unw_regname(unw_cursor_t*, unw_regnum_t)                     __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_5_0);", "extern int         unw_get_proc_info(unw_cursor_t*, unw_proc_info_t*)           __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_5_0);", "extern int         unw_is_fpreg(unw_cursor_t*, unw_regnum_t)                    __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_5_0);", "extern int         unw_is_signal_frame(unw_cursor_t*)                           __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_5_0);", "extern int         unw_get_proc_name(unw_cursor_t*, char*, size_t, unw_word_t*) __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_5_0);", "//extern int       unw_get_save_loc(unw_cursor_t*, int, unw_save_loc_t*);", "#endif", "", "", "#if UNW_REMOTE", "/* ", ' * Mac OS X "remote" API for unwinding other processes on same machine', " *", " */", "extern unw_addr_space_t    unw_local_addr_space;", "extern unw_addr_space_t    unw_create_addr_space_for_task(task_t);", "extern void                unw_destroy_addr_space(unw_addr_space_t);", "extern int                 unw_init_remote_thread(unw_cursor_t*, unw_addr_space_t, thread_t*);", "#endif", "", "", "/* ", ' * traditional libuwind "remote" API ', " *   NOT IMPLEMENTED on Mac OS X", " *", " * extern int               unw_init_remote(unw_cursor_t*, unw_addr_space_t, thread_t*);", " * extern unw_accessors_t   unw_get_accessors(unw_addr_space_t);", " * extern unw_addr_space_t  unw_create_addr_space(unw_accessors_t, int);", " * extern void              unw_flush_cache(unw_addr_space_t, unw_word_t, unw_word_t);", " * extern int               unw_set_caching_policy(unw_addr_space_t, unw_caching_policy_t);", " * extern void              _U_dyn_register(unw_dyn_info_t*);", " * extern void              _U_dyn_cancel(unw_dyn_info_t*);", " */", "", "", "#ifdef __cplusplus", "}", "#endif", "", "", "// architecture independent register numbers ", "enum {", "    UNW_REG_IP = -1,        // instruction pointer", "    UNW_REG_SP = -2,        // stack pointer", "};", "", "", "// 32-bit x86 registers", "enum {", "    UNW_X86_EAX = 0,", "    UNW_X86_ECX = 1,", "    UNW_X86_EDX = 2,", "    UNW_X86_EBX = 3,", "    UNW_X86_EBP = 4,", "    UNW_X86_ESP = 5,", "    UNW_X86_ESI = 6,", "    UNW_X86_EDI = 7", "};", "", "", "// 64-bit x86_64 registers", "enum {", "    UNW_X86_64_RAX =  0,", "    UNW_X86_64_RDX =  1,", "    UNW_X86_64_RCX =  2,", "    UNW_X86_64_RBX =  3,", "    UNW_X86_64_RSI =  4,", "    UNW_X86_64_RDI =  5,", "    UNW_X86_64_RBP =  6,", "    UNW_X86_64_RSP =  7,", "    UNW_X86_64_R8  =  8,", "    UNW_X86_64_R9  =  9,", "    UNW_X86_64_R10 = 10,", "    UNW_X86_64_R11 = 11,", "    UNW_X86_64_R12 = 12,", "    UNW_X86_64_R13 = 13,", "    UNW_X86_64_R14 = 14,", "    UNW_X86_64_R15 = 15", "};", "", "", "// 32-bit ppc register numbers", "enum {", "    UNW_PPC_R0  =  0,", "    UNW_PPC_R1  =  1,", "    UNW_PPC_R2  =  2,", "    UNW_PPC_R3  =  3,", "    UNW_PPC_R4  =  4,", "    UNW_PPC_R5  =  5,", "    UNW_PPC_R6  =  6,", "    UNW_PPC_R7  =  7,", "    UNW_PPC_R8  =  8,", "    UNW_PPC_R9  =  9,", "    UNW_PPC_R10 = 10,", "    UNW_PPC_R11 = 11,", "    UNW_PPC_R12 = 12,", "    UNW_PPC_R13 = 13,", "    UNW_PPC_R14 = 14,", "    UNW_PPC_R15 = 15,", "    UNW_PPC_R16 = 16,", "    UNW_PPC_R17 = 17,", "    UNW_PPC_R18 = 18,", "    UNW_PPC_R19 = 19,", "    UNW_PPC_R20 = 20,", "    UNW_PPC_R21 = 21,", "    UNW_PPC_R22 = 22,", "    UNW_PPC_R23 = 23,", "    UNW_PPC_R24 = 24,", "    UNW_PPC_R25 = 25,", "    UNW_PPC_R26 = 26,", "    UNW_PPC_R27 = 27,", "    UNW_PPC_R28 = 28,", "    UNW_PPC_R29 = 29,", "    UNW_PPC_R30 = 30,", "    UNW_PPC_R31 = 31,", "    UNW_PPC_F0  = 32,", "    UNW_PPC_F1  = 33,", "    UNW_PPC_F2  = 34,", "    UNW_PPC_F3  = 35,", "    UNW_PPC_F4  = 36,", "    UNW_PPC_F5  = 37,", "    UNW_PPC_F6  = 38,", "    UNW_PPC_F7  = 39,", "    UNW_PPC_F8  = 40,", "    UNW_PPC_F9  = 41,", "    UNW_PPC_F10 = 42,", "    UNW_PPC_F11 = 43,", "    UNW_PPC_F12 = 44,", "    UNW_PPC_F13 = 45,", "    UNW_PPC_F14 = 46,", "    UNW_PPC_F15 = 47,", "    UNW_PPC_F16 = 48,", "    UNW_PPC_F17 = 49,", "    UNW_PPC_F18 = 50,", "    UNW_PPC_F19 = 51,", "    UNW_PPC_F20 = 52,", "    UNW_PPC_F21 = 53,", "    UNW_PPC_F22 = 54,", "    UNW_PPC_F23 = 55,", "    UNW_PPC_F24 = 56,", "    UNW_PPC_F25 = 57,", "    UNW_PPC_F26 = 58,", "    UNW_PPC_F27 = 59,", "    UNW_PPC_F28 = 60,", "    UNW_PPC_F29 = 61,", "    UNW_PPC_F30 = 62,", "    UNW_PPC_F31 = 63,", "    UNW_PPC_MQ  = 64,", "    UNW_PPC_LR  = 65,", "    UNW_PPC_CTR = 66,", "    UNW_PPC_AP  = 67,", "\tUNW_PPC_CR0 = 68,", "    UNW_PPC_CR1 = 69,", "\tUNW_PPC_CR2 = 70,", "\tUNW_PPC_CR3 = 71,", "\tUNW_PPC_CR4 = 72,", "\tUNW_PPC_CR5 = 73,", "\tUNW_PPC_CR6 = 74,", "\tUNW_PPC_CR7 = 75,", "\tUNW_PPC_XER = 76,", "\tUNW_PPC_V0  = 77,", "    UNW_PPC_V1  = 78,", "    UNW_PPC_V2  = 79,", "    UNW_PPC_V3  = 80,", "    UNW_PPC_V4  = 81,", "    UNW_PPC_V5  = 82,", "    UNW_PPC_V6  = 83,", "    UNW_PPC_V7  = 84,", "    UNW_PPC_V8  = 85,", "    UNW_PPC_V9  = 86,", "    UNW_PPC_V10 = 87,", "    UNW_PPC_V11 = 88,", "    UNW_PPC_V12 = 89,", "    UNW_PPC_V13 = 90,", "    UNW_PPC_V14 = 91,", "    UNW_PPC_V15 = 92,", "    UNW_PPC_V16 = 93,", "    UNW_PPC_V17 = 94,", "    UNW_PPC_V18 = 95,", "    UNW_PPC_V19 = 96,", "    UNW_PPC_V20 = 97,", "    UNW_PPC_V21 = 98,", "    UNW_PPC_V22 = 99,", "    UNW_PPC_V23 = 100,", "    UNW_PPC_V24 = 101,", "    UNW_PPC_V25 = 102,", "    UNW_PPC_V26 = 103,", "    UNW_PPC_V27 = 104,", "    UNW_PPC_V28 = 105,", "    UNW_PPC_V29 = 106,", "    UNW_PPC_V30 = 107,", "    UNW_PPC_V31 = 108,", "    UNW_PPC_VRSAVE  = 109,", "    UNW_PPC_VSCR    = 110,", "    UNW_PPC_SPE_ACC = 111,", "    UNW_PPC_SPEFSCR = 112", "\t", "};", "", "", "", "", "#endif", "" },
    ["limits.h"] = { "/*", " * Copyright (c) 2000, 2004-2007, 2009 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/*\t$NetBSD: limits.h,v 1.8 1996/10/21 05:10:50 jtc Exp $\t*/", "", "/*", " * Copyright (c) 1988, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)limits.h\t8.2 (Berkeley) 1/4/94", " */", "", "#ifndef _LIMITS_H_", "#define\t_LIMITS_H_", "", "#include <sys/cdefs.h>", "#include <machine/limits.h>", "#include <sys/syslimits.h>", "", "#if __DARWIN_C_LEVEL > __DARWIN_C_ANSI", "#define\t_POSIX_ARG_MAX\t\t4096", "#define\t_POSIX_CHILD_MAX\t25", "#define\t_POSIX_LINK_MAX\t\t8", "#define\t_POSIX_MAX_CANON\t255", "#define\t_POSIX_MAX_INPUT\t255", "#define\t_POSIX_NAME_MAX\t\t14", "#define\t_POSIX_NGROUPS_MAX\t8", "#define\t_POSIX_OPEN_MAX\t\t20", "#define\t_POSIX_PATH_MAX\t\t256", "#define\t_POSIX_PIPE_BUF\t\t512", "#define\t_POSIX_SSIZE_MAX\t32767", "#define\t_POSIX_STREAM_MAX\t8", "#define\t_POSIX_TZNAME_MAX\t6", "", "#define\t_POSIX2_BC_BASE_MAX\t\t99", "#define\t_POSIX2_BC_DIM_MAX\t\t2048", "#define\t_POSIX2_BC_SCALE_MAX\t\t99", "#define\t_POSIX2_BC_STRING_MAX\t\t1000", "#define\t_POSIX2_EQUIV_CLASS_MAX\t\t2", "#define\t_POSIX2_EXPR_NEST_MAX\t\t32", "#define\t_POSIX2_LINE_MAX\t\t2048", "#define\t_POSIX2_RE_DUP_MAX\t\t255", "#endif /* __DARWIN_C_LEVEL > __DARWIN_C_ANSI */", "", "#if __DARWIN_C_LEVEL >= 199309L", "#define _POSIX_AIO_LISTIO_MAX   2", "#define _POSIX_AIO_MAX          1", "#define _POSIX_DELAYTIMER_MAX   32", "#define _POSIX_MQ_OPEN_MAX      8", "#define _POSIX_MQ_PRIO_MAX\t32", "#define _POSIX_RTSIG_MAX \t\t\t8", "#define _POSIX_SEM_NSEMS_MAX \t\t\t256", "#define _POSIX_SEM_VALUE_MAX \t\t\t32767", "#define _POSIX_SIGQUEUE_MAX \t\t\t32", "#define _POSIX_TIMER_MAX \t\t\t32", "#endif /* __DARWIN_C_LEVEL >= 199309L */", "", "#if __DARWIN_C_LEVEL >= 199506L", "#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS \t4", "#define _POSIX_THREAD_KEYS_MAX \t\t\t128", "#define _POSIX_THREAD_THREADS_MAX \t\t64", "", "#define PTHREAD_DESTRUCTOR_ITERATIONS \t4", "#define PTHREAD_KEYS_MAX \t\t512", "#define PTHREAD_STACK_MIN \t\t8192", "#endif /* __DARWIN_C_LEVEL >= 199506L */", "", "#if __DARWIN_C_LEVEL >= 200112", "#define _POSIX_HOST_NAME_MAX    255", "#define _POSIX_LOGIN_NAME_MAX   9", "#define _POSIX_SS_REPL_MAX \t\t\t4", "#define _POSIX_SYMLINK_MAX \t\t\t255", "#define _POSIX_SYMLOOP_MAX \t\t\t8", "#define _POSIX_TRACE_EVENT_NAME_MAX \t\t30", "#define _POSIX_TRACE_NAME_MAX \t\t\t8", "#define _POSIX_TRACE_SYS_MAX \t\t\t8", "#define _POSIX_TRACE_USER_EVENT_MAX \t\t32", "#define _POSIX_TTY_NAME_MAX \t\t\t9", "#define _POSIX2_CHARCLASS_NAME_MAX\t14", "#define\t_POSIX2_COLL_WEIGHTS_MAX\t2", "", "#define _POSIX_RE_DUP_MAX \t\t_POSIX2_RE_DUP_MAX", "#endif /* __DARWIN_C_LEVEL >= 200112 */", "", "#if __DARWIN_C_LEVEL >= __DARWIN_C_FULL", "#define OFF_MIN\t\tLLONG_MIN\t/* min value for an off_t */", "#define OFF_MAX\t\tLLONG_MAX\t/* max value for an off_t */", "#endif /* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */", "", "/* Actually for XSI Visible */", "#if __DARWIN_C_LEVEL > __DARWIN_C_ANSI", "", "/* Removed in Issue 6 */", "#if !defined(_POSIX_C_SOURCE) || _POSIX_C_SOURCE < 200112L", "#define PASS_MAX\t128", "#endif", "", "#define NL_ARGMAX\t9", "#define NL_LANGMAX\t14", "#define NL_MSGMAX\t32767", "#define NL_NMAX\t\t1", "#define NL_SETMAX\t255", "#define NL_TEXTMAX\t2048", "", "#define _XOPEN_IOV_MAX\t16", "#define IOV_MAX\t\t1024", "#define _XOPEN_NAME_MAX 255", "#define _XOPEN_PATH_MAX 1024", "", "#endif /* __DARWIN_C_LEVEL > __DARWIN_C_ANSI */", "", "/* NZERO to be defined here. TBD. See also sys/param.h  */", "", "#endif /* !_LIMITS_H_ */" },
    ["localcharset.h"] = { "/* Determine a canonical name for the current locale's character encoding.", "   Copyright (C) 2000-2003 Free Software Foundation, Inc.", "   This file is part of the GNU CHARSET Library.", "", "   This program is free software; you can redistribute it and/or modify it", "   under the terms of the GNU Library General Public License as published", "   by the Free Software Foundation; either version 2, or (at your option)", "   any later version.", "", "   This program is distributed in the hope that it will be useful,", "   but WITHOUT ANY WARRANTY; without even the implied warranty of", "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU", "   Library General Public License for more details.", "", "   You should have received a copy of the GNU Library General Public", "   License along with this program; if not, write to the Free Software", "   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,", "   USA.  */", "", "#ifndef _LOCALCHARSET_H", "#define _LOCALCHARSET_H", "", "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "", "", "/* Determine the current locale's character encoding, and canonicalize it", "   into one of the canonical names listed in config.charset.", "   The result must not be freed; it is statically allocated.", "   If the canonical name cannot be determined, the result is a non-canonical", "   name.  */", "extern const char * locale_charset (void);", "", "", "#ifdef __cplusplus", "}", "#endif", "", "", "#endif /* _LOCALCHARSET_H */" },
    ["locale.h"] = { "/*", " * Copyright (c) 1991, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)locale.h\t8.1 (Berkeley) 6/2/93", " * $FreeBSD: /repoman/r/ncvs/src/include/locale.h,v 1.7 2002/10/09 09:19:27 tjr Exp $", " */", "", "#ifndef _LOCALE_H_", "#define _LOCALE_H_", "", "#include <_locale.h>", "", "#define\tLC_ALL\t\t0", "#define\tLC_COLLATE\t1", "#define\tLC_CTYPE\t2", "#define\tLC_MONETARY\t3", "#define\tLC_NUMERIC\t4", "#define\tLC_TIME\t\t5", "#define\tLC_MESSAGES\t6", "", "#define\t_LC_LAST\t7\t\t/* marks end */", "", "__BEGIN_DECLS", "char\t\t*setlocale(int, const char *);", "__END_DECLS", "", "#endif /* _LOCALE_H_ */" },
    ["math.h"] = { "/*", " * Copyright (c) 2002 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * The contents of this file constitute Original Code as defined in and", " * are subject to the Apple Public Source License Version 1.1 (the", ' * "License").  You may not use this file except in compliance with the', " * License.  Please obtain a copy of the License at", " * http://www.apple.com/publicsource and read it before using this file.", " * ", " * This Original Code and all software distributed under the License are", ' * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER', " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the", " * License for the specific language governing rights and limitations", " * under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "", "#ifndef __MATH_H__", "#define __MATH_H__", "", "#ifndef __MATH__", "#define __MATH__", "#endif", "", "#include <sys/cdefs.h>", "#include <Availability.h>", "", "__BEGIN_DECLS", "", "/******************************************************************************", " * Floating point data types                                                  *", " ******************************************************************************/", "", "/*  Define float_t and double_t per C standard, ISO/IEC 9899:2011 7.12 2,", "    taking advantage of GCC's __FLT_EVAL_METHOD__ (which a compiler may", "    define anytime and GCC does) that shadows FLT_EVAL_METHOD (which a", "    compiler must define only in float.h).                                    */", "#if __FLT_EVAL_METHOD__ == 0", "    typedef float float_t;", "    typedef double double_t;", "#elif __FLT_EVAL_METHOD__ == 1", "    typedef double float_t;", "    typedef double double_t;", "#elif __FLT_EVAL_METHOD__ == 2 || __FLT_EVAL_METHOD__ == -1", "    typedef long double float_t;", "    typedef long double double_t;", "#else /* __FLT_EVAL_METHOD__ */", '#   error "Unsupported value of __FLT_EVAL_METHOD__."', "#endif /* __FLT_EVAL_METHOD__ */", "", "#if defined(__GNUC__)", "#   define    HUGE_VAL     __builtin_huge_val()", "#   define    HUGE_VALF    __builtin_huge_valf()", "#   define    HUGE_VALL    __builtin_huge_vall()", '#   define    NAN          __builtin_nanf("0x7fc00000")', "#else", "#   define    HUGE_VAL     1e500", "#   define    HUGE_VALF    1e50f", "#   define    HUGE_VALL    1e5000L", "#   define    NAN          __nan()", "#endif", "", "#define INFINITY    HUGE_VALF", "", "/******************************************************************************", " *      Taxonomy of floating point data types                                 *", " ******************************************************************************/", "", "#define FP_NAN          1", "#define FP_INFINITE     2", "#define FP_ZERO         3", "#define FP_NORMAL       4", "#define FP_SUBNORMAL    5", "#define FP_SUPERNORMAL  6 /* legacy PowerPC support; this is otherwise unused */", "", "#if defined __ARM_VFPV4__", "/*  On these architectures, fma(), fmaf( ), and fmal( ) are generally about as", "    fast as (or faster than) separate multiply and add of the same operands.  */", "#   define FP_FAST_FMA     1", "#   define FP_FAST_FMAF    1", "#   define FP_FAST_FMAL    1", "#elif (defined __i386__ || defined __x86_64__) && defined __FMA__", "/*  When targeting the FMA ISA extension, fma() and fmaf( ) are generally", "    about as fast as (or faster than) separate multiply and add of the same", "    operands, but fmal( ) may be more costly.                                 */", "#   define FP_FAST_FMA     1", "#   define FP_FAST_FMAF    1", "#   undef  FP_FAST_FMAL", "#else", "/*  On these architectures, fma( ), fmaf( ), and fmal( ) function calls are", "    significantly more costly than separate multiply and add operations.      */", "#   undef  FP_FAST_FMA", "#   undef  FP_FAST_FMAF", "#   undef  FP_FAST_FMAL", "#endif", "", "/* The values returned by `ilogb' for 0 and NaN respectively. */", "#define FP_ILOGB0      (-2147483647 - 1)", "#define FP_ILOGBNAN    (-2147483647 - 1)", "", "/* Bitmasks for the math_errhandling macro.  */", "#define MATH_ERRNO        1    /* errno set by math functions.  */", "#define MATH_ERREXCEPT    2    /* Exceptions raised by math functions.  */", "", "#define math_errhandling (__math_errhandling())", "extern int __math_errhandling(void);", "", "/******************************************************************************", " *                                                                            *", " *                              Inquiry macros                                *", " *                                                                            *", " *  fpclassify      Returns one of the FP_* values.                           *", " *  isnormal        Non-zero if and only if the argument x is normalized.     *", " *  isfinite        Non-zero if and only if the argument x is finite.         *", " *  isnan           Non-zero if and only if the argument x is a NaN.          *", " *  signbit         Non-zero if and only if the sign of the argument x is     *", " *                  negative.  This includes, NaNs, infinities and zeros.     *", " *                                                                            *", " ******************************************************************************/", "", "#if (defined __MAC_OS_X_VERSION_MIN_REQUIRED && __MAC_OS_X_VERSION_MIN_REQUIRED < 1080) || \\", "    (defined __IPHONE_OS_VERSION_MIN_REQUIRED && __IPHONE_OS_VERSION_MIN_REQUIRED < 60000)", "#   if defined __i386__ || defined __x86_64__", "#       define __fpclassifyl __fpclassify", "#       define __isnormall   __isnormal", "#       define __isfinitel   __isfinite", "#       define __isinfl      __isinf", "#       define __isnanl      __isnan", "#   elif defined __arm__", "#       define __fpclassifyd __fpclassify", "#   endif", "#endif", "", "#define fpclassify(x)                                                    \\", "    ( sizeof(x) == sizeof(float)  ? __fpclassifyf((float)(x))            \\", "    : sizeof(x) == sizeof(double) ? __fpclassifyd((double)(x))           \\", "                                  : __fpclassifyl((long double)(x)))", "", "extern int __fpclassifyf(float);", "extern int __fpclassifyd(double);", "extern int __fpclassifyl(long double);", "", "#if (defined(__GNUC__) && 0 == __FINITE_MATH_ONLY__) || \\", "    (defined __IPHONE_OS_VERSION_MIN_REQUIRED && __IPHONE_OS_VERSION_MIN_REQUIRED < 60000 && defined __arm__)", "/*  These inline functions may fail to return expected results if unsafe", "    math optimizations like those enabled by -ffast-math are turned on.", "    Thus, (somewhat surprisingly) you only get the fast inline", "    implementations if such compiler options are NOT enabled.  This is", "    because the inline functions require the compiler to be adhering to", "    the standard in order to work properly; -ffast-math, among other", "    things, implies that NaNs don't happen, which allows the compiler to", "    optimize away checks like x != x, which might lead to things like", "    isnan(NaN) returning false.                                               ", " ", "    Thus, if you compile with -ffast-math, actual function calls are", "    generated for these utilities.                                            */", "    ", "#define isnormal(x)                                                      \\", "    ( sizeof(x) == sizeof(float)  ? __inline_isnormalf((float)(x))       \\", "    : sizeof(x) == sizeof(double) ? __inline_isnormald((double)(x))      \\", "                                  : __inline_isnormall((long double)(x)))", "", "#define isfinite(x)                                                      \\", "    ( sizeof(x) == sizeof(float)  ? __inline_isfinitef((float)(x))       \\", "    : sizeof(x) == sizeof(double) ? __inline_isfinited((double)(x))      \\", "                                  : __inline_isfinitel((long double)(x)))", "", "#define isinf(x)                                                         \\", "    ( sizeof(x) == sizeof(float)  ? __inline_isinff((float)(x))          \\", "    : sizeof(x) == sizeof(double) ? __inline_isinfd((double)(x))         \\", "                                  : __inline_isinfl((long double)(x)))", "", "#define isnan(x)                                                         \\", "    ( sizeof(x) == sizeof(float)  ? __inline_isnanf((float)(x))          \\", "    : sizeof(x) == sizeof(double) ? __inline_isnand((double)(x))         \\", "                                  : __inline_isnanl((long double)(x)))", "", "#define signbit(x)                                                       \\", "    ( sizeof(x) == sizeof(float)  ? __inline_signbitf((float)(x))        \\", "    : sizeof(x) == sizeof(double) ? __inline_signbitd((double)(x))       \\", "                                  : __inline_signbitl((long double)(x)))", "", "__header_always_inline int __inline_isfinitef(float);", "__header_always_inline int __inline_isfinited(double);", "__header_always_inline int __inline_isfinitel(long double);", "__header_always_inline int __inline_isinff(float);", "__header_always_inline int __inline_isinfd(double);", "__header_always_inline int __inline_isinfl(long double);", "__header_always_inline int __inline_isnanf(float);", "__header_always_inline int __inline_isnand(double);", "__header_always_inline int __inline_isnanl(long double);", "__header_always_inline int __inline_isnormalf(float);", "__header_always_inline int __inline_isnormald(double);", "__header_always_inline int __inline_isnormall(long double);", "__header_always_inline int __inline_signbitf(float);", "__header_always_inline int __inline_signbitd(double);", "__header_always_inline int __inline_signbitl(long double);", "    ", "__header_always_inline int __inline_isfinitef(float __x) {", "    return __x == __x && __builtin_fabsf(__x) != __builtin_inff();", "}", "__header_always_inline int __inline_isfinited(double __x) {", "    return __x == __x && __builtin_fabs(__x) != __builtin_inf();", "}", "__header_always_inline int __inline_isfinitel(long double __x) {", "    return __x == __x && __builtin_fabsl(__x) != __builtin_infl();", "}", "__header_always_inline int __inline_isinff(float __x) {", "    return __builtin_fabsf(__x) == __builtin_inff();", "}", "__header_always_inline int __inline_isinfd(double __x) {", "    return __builtin_fabs(__x) == __builtin_inf();", "}", "__header_always_inline int __inline_isinfl(long double __x) {", "    return __builtin_fabsl(__x) == __builtin_infl();", "}", "__header_always_inline int __inline_isnanf(float __x) {", "    return __x != __x;", "}", "__header_always_inline int __inline_isnand(double __x) {", "    return __x != __x;", "}", "__header_always_inline int __inline_isnanl(long double __x) {", "    return __x != __x;", "}", "__header_always_inline int __inline_signbitf(float __x) {", "    union { float __f; unsigned int __u; } __u;", "    __u.__f = __x;", "    return (int)(__u.__u >> 31);", "}", "__header_always_inline int __inline_signbitd(double __x) {", "    union { double __f; unsigned long long __u; } __u;", "    __u.__f = __x;", "    return (int)(__u.__u >> 63);", "}", "#if defined __i386__ || defined __x86_64__", "__header_always_inline int __inline_signbitl(long double __x) {", "    union {", "        long double __ld;", "        struct{ unsigned long long __m; unsigned short __sexp; } __p;", "    } __u;", "    __u.__ld = __x;", "    return (int)(__u.__p.__sexp >> 15);", "}", "#else", "__header_always_inline int __inline_signbitl(long double __x) {", "    union { long double __f; unsigned long long __u;} __u;", "    __u.__f = __x;", "    return (int)(__u.__u >> 63);", "}", "#endif", "__header_always_inline int __inline_isnormalf(float __x) {", "    return __inline_isfinitef(__x) && __builtin_fabsf(__x) >= __FLT_MIN__;", "}", "__header_always_inline int __inline_isnormald(double __x) {", "    return __inline_isfinited(__x) && __builtin_fabs(__x) >= __DBL_MIN__;", "}", "__header_always_inline int __inline_isnormall(long double __x) {", "    return __inline_isfinitel(__x) && __builtin_fabsl(__x) >= __LDBL_MIN__;", "}", "    ", "#else /* defined(__GNUC__) && 0 == __FINITE_MATH_ONLY__ */", "", "/*  Implementations making function calls to fall back on when -ffast-math", "    or similar is specified.  These are not available in iOS versions prior", "    to 6.0.  If you need them, you must target that version or later.         */", "    ", "#define isnormal(x)                                               \\", "    ( sizeof(x) == sizeof(float)  ? __isnormalf((float)(x))       \\", "    : sizeof(x) == sizeof(double) ? __isnormald((double)(x))      \\", "                                  : __isnormall((long double)(x)))", "    ", "#define isfinite(x)                                               \\", "    ( sizeof(x) == sizeof(float)  ? __isfinitef((float)(x))       \\", "    : sizeof(x) == sizeof(double) ? __isfinited((double)(x))      \\", "                                  : __isfinitel((long double)(x)))", "    ", "#define isinf(x)                                                  \\", "    ( sizeof(x) == sizeof(float)  ? __isinff((float)(x))          \\", "    : sizeof(x) == sizeof(double) ? __isinfd((double)(x))         \\", "                                  : __isinfl((long double)(x)))", "    ", "#define isnan(x)                                                  \\", "    ( sizeof(x) == sizeof(float)  ? __isnanf((float)(x))          \\", "    : sizeof(x) == sizeof(double) ? __isnand((double)(x))         \\", "                                  : __isnanl((long double)(x)))", "    ", "#define signbit(x)                                                \\", "    ( sizeof(x) == sizeof(float)  ? __signbitf((float)(x))        \\", "    : sizeof(x) == sizeof(double) ? __signbitd((double)(x))       \\", "                                  : __signbitl((long double)(x)))", "    ", "extern int __isnormalf(float);", "extern int __isnormald(double);", "extern int __isnormall(long double);", "extern int __isfinitef(float);", "extern int __isfinited(double);", "extern int __isfinitel(long double);", "extern int __isinff(float);", "extern int __isinfd(double);", "extern int __isinfl(long double);", "extern int __isnanf(float);", "extern int __isnand(double);", "extern int __isnanl(long double);", "extern int __signbitf(float);", "extern int __signbitd(double);", "extern int __signbitl(long double);", "", "#endif /* defined(__GNUC__) && 0 == __FINITE_MATH_ONLY__ */", "", "/******************************************************************************", " *                                                                            *", " *                              Math Functions                                *", " *                                                                            *", " ******************************************************************************/", "    ", "extern float acosf(float);", "extern double acos(double);", "extern long double acosl(long double);", "    ", "extern float asinf(float);", "extern double asin(double);", "extern long double asinl(long double);", "    ", "extern float atanf(float);", "extern double atan(double);", "extern long double atanl(long double);", "    ", "extern float atan2f(float, float);", "extern double atan2(double, double);", "extern long double atan2l(long double, long double);", "    ", "extern float cosf(float);", "extern double cos(double);", "extern long double cosl(long double);", "    ", "extern float sinf(float);", "extern double sin(double);", "extern long double sinl(long double);", "    ", "extern float tanf(float);", "extern double tan(double);", "extern long double tanl(long double);", "    ", "extern float acoshf(float);", "extern double acosh(double);", "extern long double acoshl(long double);", "    ", "extern float asinhf(float);", "extern double asinh(double);", "extern long double asinhl(long double);", "    ", "extern float atanhf(float);", "extern double atanh(double);", "extern long double atanhl(long double);", "    ", "extern float coshf(float);", "extern double cosh(double);", "extern long double coshl(long double);", "    ", "extern float sinhf(float);", "extern double sinh(double);", "extern long double sinhl(long double);", "    ", "extern float tanhf(float);", "extern double tanh(double);", "extern long double tanhl(long double);", "    ", "extern float expf(float);", "extern double exp(double);", "extern long double expl(long double);", "", "extern float exp2f(float);", "extern double exp2(double); ", "extern long double exp2l(long double); ", "", "extern float expm1f(float);", "extern double expm1(double); ", "extern long double expm1l(long double); ", "", "extern float logf(float);", "extern double log(double);", "extern long double logl(long double);", "", "extern float log10f(float);", "extern double log10(double);", "extern long double log10l(long double);", "", "extern float log2f(float);", "extern double log2(double);", "extern long double log2l(long double);", "", "extern float log1pf(float);", "extern double log1p(double);", "extern long double log1pl(long double);", "", "extern float logbf(float);", "extern double logb(double);", "extern long double logbl(long double);", "", "extern float modff(float, float *);", "extern double modf(double, double *);", "extern long double modfl(long double, long double *);", "", "extern float ldexpf(float, int);", "extern double ldexp(double, int);", "extern long double ldexpl(long double, int);", "", "extern float frexpf(float, int *);", "extern double frexp(double, int *);", "extern long double frexpl(long double, int *);", "", "extern int ilogbf(float);", "extern int ilogb(double);", "extern int ilogbl(long double);", "", "extern float scalbnf(float, int);", "extern double scalbn(double, int);", "extern long double scalbnl(long double, int);", "", "extern float scalblnf(float, long int);", "extern double scalbln(double, long int);", "extern long double scalblnl(long double, long int);", "", "extern float fabsf(float);", "extern double fabs(double);", "extern long double fabsl(long double);", "", "extern float cbrtf(float);", "extern double cbrt(double);", "extern long double cbrtl(long double);", "", "extern float hypotf(float, float);", "extern double hypot(double, double);", "extern long double hypotl(long double, long double);", "", "extern float powf(float, float);", "extern double pow(double, double);", "extern long double powl(long double, long double);", "", "extern float sqrtf(float);", "extern double sqrt(double);", "extern long double sqrtl(long double);", "", "extern float erff(float);", "extern double erf(double);", "extern long double erfl(long double);", "", "extern float erfcf(float);", "extern double erfc(double);", "extern long double erfcl(long double);", "", "/*\tlgammaf, lgamma, and lgammal are not thread-safe. The thread-safe", "    variants lgammaf_r, lgamma_r, and lgammal_r are made available if", "    you define the _REENTRANT symbol before including <math.h>                */", "extern float lgammaf(float);", "extern double lgamma(double);", "extern long double lgammal(long double);", "", "extern float tgammaf(float);", "extern double tgamma(double);", "extern long double tgammal(long double);", "", "extern float ceilf(float);", "extern double ceil(double);", "extern long double ceill(long double);", "", "extern float floorf(float);", "extern double floor(double);", "extern long double floorl(long double);", "", "extern float nearbyintf(float);", "extern double nearbyint(double);", "extern long double nearbyintl(long double);", "", "extern float rintf(float);", "extern double rint(double);", "extern long double rintl(long double);", "", "extern long int lrintf(float);", "extern long int lrint(double);", "extern long int lrintl(long double);", "", "extern float roundf(float);", "extern double round(double);", "extern long double roundl(long double);", "", "extern long int lroundf(float);", "extern long int lround(double);", "extern long int lroundl(long double);", "    ", "/*  long long is not part of C90. Make sure you are passing -std=c99 or", "    -std=gnu99 or higher if you need these functions returning long longs     */", "#if !(__DARWIN_NO_LONG_LONG)", "extern long long int llrintf(float);", "extern long long int llrint(double);", "extern long long int llrintl(long double);", "", "extern long long int llroundf(float);", "extern long long int llround(double);", "extern long long int llroundl(long double);", "#endif /* !(__DARWIN_NO_LONG_LONG) */", "", "extern float truncf(float);", "extern double trunc(double);", "extern long double truncl(long double);", "", "extern float fmodf(float, float);", "extern double fmod(double, double);", "extern long double fmodl(long double, long double);", "", "extern float remainderf(float, float);", "extern double remainder(double, double);", "extern long double remainderl(long double, long double);", "", "extern float remquof(float, float, int *);", "extern double remquo(double, double, int *);", "extern long double remquol(long double, long double, int *);", "", "extern float copysignf(float, float);", "extern double copysign(double, double);", "extern long double copysignl(long double, long double);", "", "extern float nanf(const char *);", "extern double nan(const char *);", "extern long double nanl(const char *);", "", "extern float nextafterf(float, float);", "extern double nextafter(double, double);", "extern long double nextafterl(long double, long double);", "", "extern double nexttoward(double, long double);", "extern float nexttowardf(float, long double);", "extern long double nexttowardl(long double, long double);", "", "extern float fdimf(float, float);", "extern double fdim(double, double);", "extern long double fdiml(long double, long double);", "", "extern float fmaxf(float, float);", "extern double fmax(double, double);", "extern long double fmaxl(long double, long double);", "", "extern float fminf(float, float);", "extern double fmin(double, double);", "extern long double fminl(long double, long double);", "", "extern float fmaf(float, float, float);", "extern double fma(double, double, double);", "extern long double fmal(long double, long double, long double);", "", "#define isgreater(x, y) __builtin_isgreater((x),(y))", "#define isgreaterequal(x, y) __builtin_isgreaterequal((x),(y))", "#define isless(x, y) __builtin_isless((x),(y))", "#define islessequal(x, y) __builtin_islessequal((x),(y))", "#define islessgreater(x, y) __builtin_islessgreater((x),(y))", "#define isunordered(x, y) __builtin_isunordered((x),(y))", "", "/* Legacy BSD API: please use C99 INFINITY macro instead.                     */", "extern float __inff(void) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_9, __IPHONE_NA, __IPHONE_NA);", "extern double __inf(void) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_9, __IPHONE_NA, __IPHONE_NA);", "extern long double __infl(void) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_9, __IPHONE_NA, __IPHONE_NA);", "/* Implementation detail; please use the standard C NAN macro instead.        */", "extern float __nan(void) __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_NA);", "", "/******************************************************************************", " *  Reentrant variants of lgamma[fl]                                          *", " ******************************************************************************/", "", "#ifdef _REENTRANT", "/*  Reentrant variants of the lgamma[fl] functions.                           */", "extern float lgammaf_r(float, int *) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);", "extern double lgamma_r(double, int *) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);", "extern long double lgammal_r(long double, int *) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);", "#endif /* _REENTRANT */", "", "/******************************************************************************", " *  Apple extensions to the C standard                                        *", " ******************************************************************************/", "", "/*  Because these functions are not specified by any relevant standard, they", "    are prefixed with __, which places them in the implementor's namespace, so", "    they should not conflict with any developer or third-party code.  If they", "    are added to a relevant standard in the future, un-prefixed names may be", "    added to the library and they may be moved out of this section of the", "    header.                                                                   ", " ", "    Because these functions are non-standard, they may not be available on non-", "    Apple platforms.                                                          */", "", "/*  __exp10(x) returns 10**x.  Edge cases match those of exp( ) and exp2( ).  */", "extern float __exp10f(float) __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);", "extern double __exp10(double) __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);", "", "/*  __sincos(x,sinp,cosp) computes the sine and cosine of x with a single", "    function call, storing the sine in the memory pointed to by sinp, and", "    the cosine in the memory pointed to by cosp. Edge cases match those of", "    separate calls to sin( ) and cos( ).                                      */", "__header_always_inline void __sincosf(float __x, float *__sinp, float *__cosp) __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);", "__header_always_inline void __sincos(double __x, double *__sinp, double *__cosp) __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);", "", "/*  __sinpi(x) returns the sine of pi times x; __cospi(x) and __tanpi(x) return", "    the cosine and tangent, respectively.  These functions can produce a more", "    accurate answer than expressions of the form sin(M_PI * x) because they", "    avoid any loss of precision that results from rounding the result of the", "    multiplication M_PI * x.  They may also be significantly more efficient in", "    some cases because the argument reduction for these functions is easier", "    to compute.  Consult the man pages for edge case details.                 */", "extern float __cospif(float) __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);", "extern double __cospi(double) __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);", "extern float __sinpif(float) __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);", "extern double __sinpi(double) __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);", "extern float __tanpif(float) __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);", "extern double __tanpi(double) __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);", "", "/*  __sincospi(x,sinp,cosp) computes the sine and cosine of pi times x with a", "    single function call, storing the sine in the memory pointed to by sinp,", "    and the cosine in the memory pointed to by cosp.  Edge cases match those", "    of separate calls to __sinpi( ) and __cospi( ), and are documented in the", "    man pages.                                                                */", "__header_always_inline void __sincospif(float __x, float *__sinp, float *__cosp) __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);", "__header_always_inline void __sincospi(double __x, double *__sinp, double *__cosp) __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);", "", "/*  Implementation details of __sincos and __sincospi allowing them to return", "    two results while allowing the compiler to optimize away unnecessary load-", "    store traffic.  Although these interfaces are exposed in the math.h header", "    to allow compilers to generate better code, users should call __sincos[f]", "    and __sincospi[f] instead and allow the compiler to emit these calls.     */", "struct __float2 { float __sinval; float __cosval; };", "struct __double2 { double __sinval; double __cosval; };", "", "extern struct __float2 __sincosf_stret(float);", "extern struct __double2 __sincos_stret(double);", "extern struct __float2 __sincospif_stret(float);", "extern struct __double2 __sincospi_stret(double);", "", "__header_always_inline void __sincosf(float __x, float *__sinp, float *__cosp) {", "    const struct __float2 __stret = __sincosf_stret(__x);", "    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;", "}", "", "__header_always_inline void __sincos(double __x, double *__sinp, double *__cosp) {", "    const struct __double2 __stret = __sincos_stret(__x);", "    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;", "}", "", "__header_always_inline void __sincospif(float __x, float *__sinp, float *__cosp) {", "    const struct __float2 __stret = __sincospif_stret(__x);", "    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;", "}", "", "__header_always_inline void __sincospi(double __x, double *__sinp, double *__cosp) {", "    const struct __double2 __stret = __sincospi_stret(__x);", "    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;", "}", "", "/******************************************************************************", " *  POSIX/UNIX extensions to the C standard                                   *", " ******************************************************************************/", "", "#if __DARWIN_C_LEVEL >= 199506L", "extern double j0(double) __OSX_AVAILABLE_STARTING(__MAC_10_0,__IPHONE_3_2); ", "extern double j1(double) __OSX_AVAILABLE_STARTING(__MAC_10_0,__IPHONE_3_2); ", "extern double jn(int, double) __OSX_AVAILABLE_STARTING(__MAC_10_0,__IPHONE_3_2); ", "extern double y0(double) __OSX_AVAILABLE_STARTING(__MAC_10_0,__IPHONE_3_2); ", "extern double y1(double) __OSX_AVAILABLE_STARTING(__MAC_10_0,__IPHONE_3_2); ", "extern double yn(int, double) __OSX_AVAILABLE_STARTING(__MAC_10_0,__IPHONE_3_2); ", "extern double scalb(double, double); ", "extern int signgam;", "", "/*  Even though these might be more useful as long doubles, POSIX requires", "    that they be double-precision literals.                                   */", "#define M_E         2.71828182845904523536028747135266250   /* e              */", "#define M_LOG2E     1.44269504088896340735992468100189214   /* log2(e)        */", "#define M_LOG10E    0.434294481903251827651128918916605082  /* log10(e)       */", "#define M_LN2       0.693147180559945309417232121458176568  /* loge(2)        */", "#define M_LN10      2.30258509299404568401799145468436421   /* loge(10)       */", "#define M_PI        3.14159265358979323846264338327950288   /* pi             */", "#define M_PI_2      1.57079632679489661923132169163975144   /* pi/2           */", "#define M_PI_4      0.785398163397448309615660845819875721  /* pi/4           */", "#define M_1_PI      0.318309886183790671537767526745028724  /* 1/pi           */", "#define M_2_PI      0.636619772367581343075535053490057448  /* 2/pi           */", "#define M_2_SQRTPI  1.12837916709551257389615890312154517   /* 2/sqrt(pi)     */", "#define M_SQRT2     1.41421356237309504880168872420969808   /* sqrt(2)        */", "#define M_SQRT1_2   0.707106781186547524400844362104849039  /* 1/sqrt(2)      */", "", "#define MAXFLOAT    0x1.fffffep+127f", "#endif /* __DARWIN_C_LEVEL >= 199506L */", "", "/******************************************************************************", " *  Legacy BSD extensions to the C standard                                   *", " ******************************************************************************/", "", "#if __DARWIN_C_LEVEL >= __DARWIN_C_FULL", "#define FP_SNAN\t\tFP_NAN", "#define FP_QNAN\t\tFP_NAN", "#define\tHUGE\t\tMAXFLOAT", "#define X_TLOSS\t\t1.41484755040568800000e+16 ", "#define\tDOMAIN\t\t1", "#define\tSING\t\t2", "#define\tOVERFLOW\t3", "#define\tUNDERFLOW\t4", "#define\tTLOSS\t\t5", "#define\tPLOSS\t\t6", "", "/* Legacy BSD API: please use C99 lrint( ) instead.                           */", "extern long int rinttol(double) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_9, __IPHONE_NA, __IPHONE_NA);", "/* Legacy BSD API: please use C99 lround( ) instead.                          */", "extern long int roundtol(double) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_9, __IPHONE_NA, __IPHONE_NA);", "/* Legacy BSD API: please use C99 remainder( ) instead.                       */", "extern double drem(double, double) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_9, __IPHONE_NA, __IPHONE_NA);", "/* Legacy BSD API: please use C99 isfinite( ) instead.                        */", "extern int finite(double) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_9, __IPHONE_NA, __IPHONE_NA);", "/* Legacy BSD API: please use C99 tgamma( ) instead.                          */", "extern double gamma(double) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_9, __IPHONE_NA, __IPHONE_NA);", "/* Legacy BSD API: please use C99 frexp( ) instead.                           */", "extern double significand(double) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_9, __IPHONE_NA, __IPHONE_NA);", "", "#if !defined __cplusplus", "struct exception {", "    int type;", "    char *name;", "    double arg1;", "    double arg2;", "    double retval;", "};", "/* Legacy API: does not do anything useful.                                   */", "extern int matherr(struct exception *) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_9, __IPHONE_NA, __IPHONE_NA);", "#endif /* !defined __cplusplus */", "#endif /* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */", "", "__END_DECLS", "#endif /* __MATH_H__ */" },
    ["membership.h"] = { "/*", " * Copyright (c) 2004 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " *", " * The contents of this file constitute Original Code as defined in and", " * are subject to the Apple Public Source License Version 1.1 (the", ' * "License").  You may not use this file except in compliance with the', " * License.  Please obtain a copy of the License at", " * http://www.apple.com/publicsource and read it before using this file.", " *", " * This Original Code and all software distributed under the License are", ' * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER', " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the", " * License for the specific language governing rights and limitations", " * under the License.", " *", " * @APPLE_LICENSE_HEADER_END@", " */", "", "#ifndef _MEMBERSHIP_H_", "#define _MEMBERSHIP_H_", "", "#include <uuid/uuid.h>", "#include <ntsid.h>", "", "/*!", "\t@defined    ID_TYPE_UID", "\t@abstract   is of type uid_t", "\t@discussion is of type uid_t", "*/", "#define ID_TYPE_UID\t\t\t\t0", "", "/*!", "\t@defined    ID_TYPE_GID", "\t@abstract   is of type gid_t", "\t@discussion is of type gid_t", "*/", "#define ID_TYPE_GID\t\t\t\t1", "", "/*!", "    @defined    ID_TYPE_SID", "    @abstract   is of type ntsid_t", "    @discussion is of type ntsid_t", "*/", "#define ID_TYPE_SID\t\t\t\t3", "", "/*!", "    @defined    ID_TYPE_USERNAME", "    @abstract   is a NULL terminated UTF8 string", "    @discussion is a NULL terminated UTF8 string", "*/", "#define ID_TYPE_USERNAME\t\t4", "", "/*!", "    @defined    ID_TYPE_GROUPNAME", "    @abstract   is a NULL terminated UTF8 string", "    @discussion is a NULL terminated UTF8 string", "*/", "#define ID_TYPE_GROUPNAME\t\t5", "", "/*!", "\t@defined\tID_TYPE_UUID", "\t@abstract\tis of type uuid_t", "\t@discussion\tis of type uuid_t", "*/", "#define ID_TYPE_UUID\t\t\t6", "", "/*!", "    @defined    ID_TYPE_GROUP_NFS", "    @abstract   is a NULL terminated UTF8 string", "    @discussion is a NULL terminated UTF8 string", "*/", "#define ID_TYPE_GROUP_NFS\t7", "", "/*!", "    @defined    ID_TYPE_USER_NFS", "    @abstract   is a NULL terminated UTF8 string", "    @discussion is a NULL terminated UTF8 string", "*/", "#define ID_TYPE_USER_NFS\t\t8", "", "/*!", "\t@defined    ID_TYPE_GSS_EXPORT_NAME", "\t@abstract\tis a gss exported name", "\t@discussion\tis the data in gss_buffer_t as returned from gss_export_name.", "*/", "#define ID_TYPE_GSS_EXPORT_NAME\t10", "", "/*!", "\t@defined    ID_TYPE_X509_DN", "\t@abstract\tis a NULL terminated string representation of the X.509 certificate identity", "\t@discussion\tis a NULL terminated string with the format of:", " ", "\t\t\t\t<I>DN of the Certificate authority<S>DN of the holder", " ", "\t\t\t\tExample:", " ", "\t\t\t\t<I>DC=com,DC=example,CN=CertificatAuthority<S>DC=com,DC=example,CN=username", "*/", "#define ID_TYPE_X509_DN\t\t\t11", "", "/*!", "\t@defined    ID_TYPE_KERBEROS", "\t@abstract\tis a NULL terminated string representation of a Kerberos principal", "\t@discussion\tis a NULL terminated string in the form of user\\@REALM representing a typical ", "\t\t\t\tKerberos principal.", "*/", "#define ID_TYPE_KERBEROS\t\t12", "", "__BEGIN_DECLS", "", "/*!", "\t@function   mbr_uid_to_uuid", "\t@abstract\tconvert a UID to a corresponding UUID", "\t@discussion\twill convert a UID of a user to a corresponding UUID value.", "\t\t\t\tThis call will always succeed and may return a synthesized", "\t\t\t\tUUID with the prefix FFFFEEEE-DDDD-CCCC-BBBB-AAAAxxxxxxxx,", "\t\t\t\twhere 'xxxxxxxx' is a hex conversion of the UID. The returned", "\t\t\t\tUUID can be used for any operation including ACL and SACL", "\t\t\t\tmemberships, even if a UUID is later assigned to the user", "\t\t\t\trecord.", "\t@param\t\tuid the uid_t to be converted", "\t@param\t\tuu is the UUID found for the provided UID", "\t@result\t\treturns 0 on success or appropriate errno code.", "*/", "int mbr_uid_to_uuid(uid_t uid, uuid_t uu);", "", "/*!", "\t@function   mbr_gid_to_uuid", "\t@abstract   convert a GID to a corresponding UUID", "\t@discussion will convert a GID of a group to a corresponding UUID value.", "\t\t\t\tThis call will always succeed and may return a synthesized", "\t\t\t\tUUID with the prefix AAAABBBB-CCCC-DDDD-EEEE-FFFFxxxxxxxx,", "\t\t\t\twhere 'xxxxxxxx' is a hex conversion of the UID. The returned", "\t\t\t\tUUID can be used for any operation including ACL and SACL", "\t\t\t\tmemberships, even if a UUID is later assigned to the group", "\t\t\t\trecord.", "\t@param\t\tgid the gid_t to be converted", "\t@param\t\tuu is the UUID found for the provided GID", "\t@result\t\treturns 0 on success or appropriate errno code.", "*/", "int mbr_gid_to_uuid(gid_t gid, uuid_t uu);", "", "/*!", "\t@function   mbr_sid_to_uuid", "\t@abstract\tconvert a SID to a corresponding UUID", "\t@discussion will convert a SID to a corresponding UUID value. This call", "\t\t\t\tcan fail for records that do not have a valid SID or RID.", "\t@param\t\tsid the nt_sid_t to be converted", "\t@param\t\tuu is the UUID found for the provided GID", "\t@result\t\treturns 0 on success or appropriate errno code.", "*/", "int mbr_sid_to_uuid(const nt_sid_t* sid, uuid_t uu);", "", "/*!", "\t@function\tmbr_identifier_to_uuid", "\t@abstract\tresolves various identifiers to corresponding UUID", "\t@discussion\twill resolve various identifiers such as X.509 Distinguished ", "\t\t\t\tNames, Kerberos ID or other forms of security identifiers to a", "\t\t\t\tcorresponding UUID.", "\t@param\t\tid_type is one of the defined types", "\t@param\t\tidentifier is a generic pointer as defined by the type", "\t@param\t\tidentifier_size is the size of the data pointed to in identifier", "\t@param\t\tuu is the UUID found for the identifier", "\t@result\t\treturns 0 on success or appropriate errno code.", "*/", "int mbr_identifier_to_uuid(int id_type, const void *identifier, size_t identifier_size,", "\t\t\t\t\t\t   uuid_t uu);", "", "/*!", "\t@function\tmbr_uuid_to_id", "\t@abstract\tresolves a UUID to a corresponding ID and type", "\t@discussion\twill resolve a UUID to a corresponding GID or UID and return", "\t\t\t\tthe type of ID (ID_TYPE_UID or ID_TYPE_GID).  Synthesized", "\t\t\t\tUUID values will be directly translated to corresponding ID.", "\t\t\t\tA UID will always be returned even if the UUID is not found.  ", "\t\t\t\tThe returned ID is not persistant, but can be used to map back", "\t\t\t\tto the UUID during runtime.", "\t@param\t\tuu is the UUID to be resolved", "\t@param\t\tuid_or_gid is the UID or GID found for the UUID", "\t@param\t\tid_type is the type of ID", "\t@result\t\treturns 0 on success or appropriate errno code.", "*/", "int mbr_uuid_to_id(const uuid_t uu, id_t* uid_or_gid, int* id_type);", "", "/*!", "\t@function\tmbr_uuid_to_sid", "\t@abstract\tresolves a UUID to a corresponding SID", "\t@discussion will resolve a UUID to a corresponding SID.", "\t@param\t\tuu is the UUID to be resolved", "\t@param\t\tsid is the SID found for the UUID", "\t@result\t\treturns 0 on success or appropriate errno code.", "*/", "int mbr_uuid_to_sid(const uuid_t uu, nt_sid_t* sid);", "", "/*!", "\t@function\tmbr_sid_to_string", "\t@abstract\tconvert a SID to a corresponding character string representation", "\t@discussion for use in situations where an external representation of a SID is required.", "\t@param\t\tsid is the SID to be converted", "\t@param\t\tstring is a buffer that will be filled in with a nul-terminated string", "\t\t\t\trepresentation of the SID.  The buffer must be at least 194 characters in length.", "\t@result    returns 0 on success or appropriate errno code.", " */", "int mbr_sid_to_string(const nt_sid_t *sid, char *string);", "", "/*!", "\t@function\tmbr_string_to_sid", "\t@abstract\tconvert a character string representation of a sid to an nt_sid_t value", "\t@discussion for converting an external representation of a sid.", "\t@param\t\tstring is a buffer containing a nul-terminated string representation of a SID", "\t@param\t\tsid is the target of the conversion", "\t@result    returns 0 on success or appropriate errno code.", " */", "int mbr_string_to_sid(const char *string, nt_sid_t *sid);", "", "/*!", "\t@function\tmbr_check_membership", "\t@abstract\tchecks if a user is a member of a group", "\t@discussion\twill check if a user is a member of a group either through", "\t\t\t\tdirect membership or via nested group membership.", "\t@param\t\tuser is the UUID of the user in question", "\t@param\t\tgroup is the UUID of the group to be checked", "\t@param\t\tismember is set to 1 if user is a member of the group,", "\t\t\t\totherwise 0 is returned", "\t@result\t\treturns 0 on success or appropriate errno code.", "*/", "int mbr_check_membership(const uuid_t user, const uuid_t group, int* ismember);", "", "/*!", "\t@function\tmbr_check_service_membership", "\t@abstract   checks if a user is part of a service group", "\t@discussion will check if a user is a member of a service access group.", "\t\t\t\tThe servicename provided will be automatically prefixed with", '\t\t\t\t"com.apple.access_" (e.g., "afp" becomes "com.apple.access_afp").', '\t\t\t\tIn addition a special service group "com.apple.access_all_services"', "\t\t\t\twill be checked in addition to the specific service.", "\t@param\t\tuser is the UUID of the user in question", '\t@param\t\tservicename is the service type (e.g., "afp", "ftp", etc.)', "\t@param\t\tismember is set to 1 if user is a member of the group,", "\t\t\t\totherwise 0 is returned", "\t@result\t\treturns 0 on success or appropriate errno code.", "*/", "int mbr_check_service_membership(const uuid_t user, const char *servicename, ", "\t\t\t\t\t\t\t\t int *ismember);", "", "__END_DECLS", "", "#endif /* !_MEMBERSHIP_H_ */" },
    ["memory.h"] = { "/*", " * Copyright (c) 1988, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)memory.h\t8.1 (Berkeley) 6/2/93", " */", "", "#include <string.h>" },
    ["menu.h"] = { "/****************************************************************************", " * Copyright (c) 1998-2003,2007 Free Software Foundation, Inc.              *", " *                                                                          *", " * Permission is hereby granted, free of charge, to any person obtaining a  *", " * copy of this software and associated documentation files (the            *", ' * "Software"), to deal in the Software without restriction, including      *', " * without limitation the rights to use, copy, modify, merge, publish,      *", " * distribute, distribute with modifications, sublicense, and/or sell       *", " * copies of the Software, and to permit persons to whom the Software is    *", " * furnished to do so, subject to the following conditions:                 *", " *                                                                          *", " * The above copyright notice and this permission notice shall be included  *", " * in all copies or substantial portions of the Software.                   *", " *                                                                          *", ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *', " * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *", " * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *", " * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *", " * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *", " * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *", " * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *", " *                                                                          *", " * Except as contained in this notice, the name(s) of the above copyright   *", " * holders shall not be used in advertising or otherwise to promote the     *", " * sale, use or other dealings in this Software without prior written       *", " * authorization.                                                           *", " ****************************************************************************/", "", "/****************************************************************************", " *   Author:  Juergen Pfeifer, 1995,1997                                    *", " ****************************************************************************/", "", "/* $Id: menu.h,v 1.19 2007/02/24 17:32:13 tom Exp $ */", "", "#ifndef ETI_MENU", "#define ETI_MENU", "", "#ifdef AMIGA", "#define TEXT TEXT_ncurses", "#endif", "", "#include <curses.h>", "#include <eti.h>", "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "", "typedef int Menu_Options;", "typedef int Item_Options;", "", "/* Menu options: */", "#define O_ONEVALUE      (0x01)", "#define O_SHOWDESC      (0x02)", "#define O_ROWMAJOR      (0x04)", "#define O_IGNORECASE    (0x08)", "#define O_SHOWMATCH     (0x10)", "#define O_NONCYCLIC     (0x20)", "", "/* Item options: */", "#define O_SELECTABLE    (0x01)", "", "typedef struct", "{", "  const char* str;", "  unsigned short length;", "} TEXT;", "", "typedef struct tagITEM ", "{", "  TEXT           name;        /* name of menu item                         */", "  TEXT           description; /* description of item, optional in display  */ ", "  struct tagMENU *imenu;      /* Pointer to parent menu                    */", "  void           *userptr;    /* Pointer to user defined per item data     */ ", "  Item_Options   opt;         /* Item options                              */ ", "  short          index;       /* Item number if connected to a menu        */", "  short          y;           /* y and x location of item in menu          */", "  short          x;", "  bool           value;       /* Selection value                           */", "                             ", "  struct tagITEM *left;       /* neighbor items                            */", "  struct tagITEM *right;", "  struct tagITEM *up;", "  struct tagITEM *down;", "", "} ITEM;", "", "typedef void (*Menu_Hook)(struct tagMENU *);", "", "typedef struct tagMENU ", "{", "  short          height;                /* Nr. of chars high               */", "  short          width;                 /* Nr. of chars wide               */", "  short          rows;                  /* Nr. of items high               */", "  short          cols;                  /* Nr. of items wide               */", "  short          frows;                 /* Nr. of formatted items high     */", "  short          fcols;                 /* Nr. of formatted items wide     */", "  short          arows;                 /* Nr. of items high (actual)      */", "  short          namelen;               /* Max. name length                */", "  short          desclen;               /* Max. description length         */", "  short          marklen;               /* Length of mark, if any          */", "  short          itemlen;               /* Length of one item              */", "  short          spc_desc;              /* Spacing for descriptor          */", "  short          spc_cols;              /* Spacing for columns             */", "  short          spc_rows;              /* Spacing for rows                */ ", "  char          *pattern;               /* Buffer to store match chars     */", "  short          pindex;                /* Index into pattern buffer       */", "  WINDOW        *win;                   /* Window containing menu          */", "  WINDOW        *sub;                   /* Subwindow for menu display      */", "  WINDOW        *userwin;               /* User's window                   */", "  WINDOW        *usersub;               /* User's subwindow                */", "  ITEM          **items;                /* array of items                  */ ", "  short          nitems;                /* Nr. of items in menu            */", "  ITEM          *curitem;               /* Current item                    */", "  short          toprow;                /* Top row of menu                 */", "  chtype         fore;                  /* Selection attribute             */", "  chtype         back;                  /* Nonselection attribute          */", "  chtype         grey;                  /* Inactive attribute              */", "  unsigned char  pad;                   /* Pad character                   */", "", "  Menu_Hook      menuinit;              /* User hooks                      */", "  Menu_Hook      menuterm;", "  Menu_Hook      iteminit;", "  Menu_Hook      itemterm;", "", "  void          *userptr;               /* Pointer to menus user data      */", "  char          *mark;                  /* Pointer to marker string        */", "", "  Menu_Options   opt;                   /* Menu options                    */", "  unsigned short status;                /* Internal state of menu          */", "", "} MENU;", "", "", "/* Define keys */", "", "#define REQ_LEFT_ITEM           (KEY_MAX + 1)", "#define REQ_RIGHT_ITEM          (KEY_MAX + 2)", "#define REQ_UP_ITEM             (KEY_MAX + 3)", "#define REQ_DOWN_ITEM           (KEY_MAX + 4)", "#define REQ_SCR_ULINE           (KEY_MAX + 5)", "#define REQ_SCR_DLINE           (KEY_MAX + 6)", "#define REQ_SCR_DPAGE           (KEY_MAX + 7)", "#define REQ_SCR_UPAGE           (KEY_MAX + 8)", "#define REQ_FIRST_ITEM          (KEY_MAX + 9)", "#define REQ_LAST_ITEM           (KEY_MAX + 10)", "#define REQ_NEXT_ITEM           (KEY_MAX + 11)", "#define REQ_PREV_ITEM           (KEY_MAX + 12)", "#define REQ_TOGGLE_ITEM         (KEY_MAX + 13)", "#define REQ_CLEAR_PATTERN       (KEY_MAX + 14)", "#define REQ_BACK_PATTERN        (KEY_MAX + 15)", "#define REQ_NEXT_MATCH          (KEY_MAX + 16)", "#define REQ_PREV_MATCH          (KEY_MAX + 17)", "", "#define MIN_MENU_COMMAND        (KEY_MAX + 1)", "#define MAX_MENU_COMMAND        (KEY_MAX + 17)", "", "/*", " * Some AT&T code expects MAX_COMMAND to be out-of-band not", " * just for menu commands but for forms ones as well.", " */", "#if defined(MAX_COMMAND)", "#  if (MAX_MENU_COMMAND > MAX_COMMAND)", "#    error Something is wrong -- MAX_MENU_COMMAND is greater than MAX_COMMAND", "#  elif (MAX_COMMAND != (KEY_MAX + 128))", "#    error Something is wrong -- MAX_COMMAND is already inconsistently defined.", "#  endif", "#else", "#  define MAX_COMMAND (KEY_MAX + 128)", "#endif", "", "", "/* --------- prototypes for libmenu functions ----------------------------- */", "", "extern NCURSES_EXPORT(ITEM **)\tmenu_items (const MENU *);", "extern NCURSES_EXPORT(ITEM *)\tcurrent_item (const MENU *);", "extern NCURSES_EXPORT(ITEM *)\tnew_item (const char *,const char *);", "", "extern NCURSES_EXPORT(MENU *)\tnew_menu (ITEM **);", "", "extern NCURSES_EXPORT(Item_Options)\titem_opts (const ITEM *);", "extern NCURSES_EXPORT(Menu_Options)\tmenu_opts (const MENU *);", "", "extern NCURSES_EXPORT(Menu_Hook)\titem_init (const MENU *);", "extern NCURSES_EXPORT(Menu_Hook)\titem_term (const MENU *);", "extern NCURSES_EXPORT(Menu_Hook)\tmenu_init (const MENU *);", "extern NCURSES_EXPORT(Menu_Hook)\tmenu_term (const MENU *);", "", "extern NCURSES_EXPORT(WINDOW *)\tmenu_sub (const MENU *);", "extern NCURSES_EXPORT(WINDOW *)\tmenu_win (const MENU *);", "", "extern NCURSES_EXPORT(const char *)\titem_description (const ITEM *);", "extern NCURSES_EXPORT(const char *)\titem_name (const ITEM *);", "extern NCURSES_EXPORT(const char *)\tmenu_mark (const MENU *);", "extern NCURSES_EXPORT(const char *)\tmenu_request_name (int);", "", "extern NCURSES_EXPORT(char *)\tmenu_pattern (const MENU *);", "", "extern NCURSES_EXPORT(void *)\tmenu_userptr (const MENU *);", "extern NCURSES_EXPORT(void *)\titem_userptr (const ITEM *);", "", "extern NCURSES_EXPORT(chtype)\tmenu_back (const MENU *);", "extern NCURSES_EXPORT(chtype)\tmenu_fore (const MENU *);", "extern NCURSES_EXPORT(chtype)\tmenu_grey (const MENU *);", "", "extern NCURSES_EXPORT(int)\tfree_item (ITEM *);", "extern NCURSES_EXPORT(int)\tfree_menu (MENU *);", "extern NCURSES_EXPORT(int)\titem_count (const MENU *);", "extern NCURSES_EXPORT(int)\titem_index (const ITEM *);", "extern NCURSES_EXPORT(int)\titem_opts_off (ITEM *,Item_Options);", "extern NCURSES_EXPORT(int)\titem_opts_on (ITEM *,Item_Options);", "extern NCURSES_EXPORT(int)\tmenu_driver (MENU *,int);", "extern NCURSES_EXPORT(int)\tmenu_opts_off (MENU *,Menu_Options);", "extern NCURSES_EXPORT(int)\tmenu_opts_on (MENU *,Menu_Options);", "extern NCURSES_EXPORT(int)\tmenu_pad (const MENU *);", "extern NCURSES_EXPORT(int)\tpos_menu_cursor (const MENU *);", "extern NCURSES_EXPORT(int)\tpost_menu (MENU *);", "extern NCURSES_EXPORT(int)\tscale_menu (const MENU *,int *,int *);", "extern NCURSES_EXPORT(int)\tset_current_item (MENU *menu,ITEM *item);", "extern NCURSES_EXPORT(int)\tset_item_init (MENU *, Menu_Hook);", "extern NCURSES_EXPORT(int)\tset_item_opts (ITEM *,Item_Options);", "extern NCURSES_EXPORT(int)\tset_item_term (MENU *, Menu_Hook);", "extern NCURSES_EXPORT(int)\tset_item_userptr (ITEM *, void *);", "extern NCURSES_EXPORT(int)\tset_item_value (ITEM *,bool);", "extern NCURSES_EXPORT(int)\tset_menu_back (MENU *,chtype);", "extern NCURSES_EXPORT(int)\tset_menu_fore (MENU *,chtype);", "extern NCURSES_EXPORT(int)\tset_menu_format (MENU *,int,int);", "extern NCURSES_EXPORT(int)\tset_menu_grey (MENU *,chtype);", "extern NCURSES_EXPORT(int)\tset_menu_init (MENU *, Menu_Hook);", "extern NCURSES_EXPORT(int)\tset_menu_items (MENU *,ITEM **);", "extern NCURSES_EXPORT(int)\tset_menu_mark (MENU *, const char *);", "extern NCURSES_EXPORT(int)\tset_menu_opts (MENU *,Menu_Options);", "extern NCURSES_EXPORT(int)\tset_menu_pad (MENU *,int);", "extern NCURSES_EXPORT(int)\tset_menu_pattern (MENU *,const char *);", "extern NCURSES_EXPORT(int)\tset_menu_sub (MENU *,WINDOW *);", "extern NCURSES_EXPORT(int)\tset_menu_term (MENU *, Menu_Hook);", "extern NCURSES_EXPORT(int)\tset_menu_userptr (MENU *,void *);", "extern NCURSES_EXPORT(int)\tset_menu_win (MENU *,WINDOW *);", "extern NCURSES_EXPORT(int)\tset_top_row (MENU *,int);", "extern NCURSES_EXPORT(int)\ttop_row (const MENU *);", "extern NCURSES_EXPORT(int)\tunpost_menu (MENU *);", "extern NCURSES_EXPORT(int)\tmenu_request_by_name (const char *);", "extern NCURSES_EXPORT(int)\tset_menu_spacing (MENU *,int,int,int);", "extern NCURSES_EXPORT(int)\tmenu_spacing (const MENU *,int *,int *,int *);", "", "", "extern NCURSES_EXPORT(bool)\titem_value (const ITEM *);", "extern NCURSES_EXPORT(bool)\titem_visible (const ITEM *);", "", "extern NCURSES_EXPORT(void)\tmenu_format (const MENU *,int *,int *);", "", "#ifdef __cplusplus", "  }", "#endif", "", "#endif /* ETI_MENU */" },
    ["module.map"] = { "module Darwin [system] {", "  // Headers that are repeatedly included, and therefore should not be ", "  // assigned to any given module.", '  exclude header "_structs.h"', '  exclude header "sys/_structs.h"', "", "  module cdefs {", '    header "sys/cdefs.h"', "    export *", "  }", "", "  // C standard library", "  module C {", "    module complex {", '      header "complex.h"', "      export *", "    }", "", "    module ctype {", '      header "ctype.h"', "      export *", "    }", "", "    module errno {", '      header "errno.h"', '      header "sys/errno.h"', "      export *", "    }", "", "    module fenv {", '      header "fenv.h"', "      export *", "    }", "", "    module float {", '      header "float.h" // note: supplied by compiler', "      export *", "    }", "", "    module stdint {", '      header "stdint.h" // note: supplied by compiler', "      export *", "    }", "", "    module inttypes {", '      header "inttypes.h"', "      export *", "    }", "", "    module iso646 {", '      header "iso646.h" // note: potentially supplied by compiler', "      export *", "    }", "", "    module limits {", '      header "limits.h" // note: supplied/augmented by compiler', "      export *", "    }", "", "    module locale {", '      header "locale.h"', "      export *", "    }", "", "    module math {", '      header "math.h"', "      export *", "    }", "", "    module setjmp {", '      header "setjmp.h"', "      export *", "    }", "", "    module signal {", '      header "signal.h"', "      export *", "    }", "", "    module stdarg {", '      header "stdarg.h" // note: supplied by the compiler', "      export *", "    }", "", "    module stdbool {", '      header "stdbool.h" // note: supplied by the compiler', "      export *", "    }", "", "    module stddef {", '      header "stddef.h" // note: supplied by the compiler', "      export *", "    }", "", "    module stdio {", '      header "stdio.h"', "      export *", "    }", "", "    module stdlib {", '      header "stdlib.h"', "      export *", "      export stddef", "    }", "", "    module string {", '      header "string.h"', "      export *", "      export Darwin.POSIX.strings", "    }", "", "    module tgmath {", '      header "tgmath.h" // note: supplied by the compiler', "      export *", "    }", "", "    module time {", '      header "time.h"', "      export *", "    }", "", "    module wchar {", '      header "wchar.h"', "      export *", "    }", "", "    module wctype {", '      header "wctype.h"', "      export *", "    }", "", "    module excluded {", "      requires excluded", '      header "assert.h"', "    }", "  }", "", "  // POSIX", "  module POSIX {", "    module basic {", '      header "sys/_endian.h"', '      header "sys/_posix_availability.h"', '      header "sys/_symbol_aliasing.h"', "", "      export *", "    }", "", "    module aio {", '      header "aio.h"', '      header "sys/aio.h"', "      export *", "    }", "", "    module arpa {", "      module inet {", '        header "arpa/inet.h"', "        export *", "      }", "      export *", "    }", "", "    module cpio {", '      header "cpio.h"', "      export *", "    }", "", "    module dirent {", '      header "dirent.h"', "", '      header "sys/dir.h"', "", '      header "sys/dirent.h"', "      export *", "    }", "", "    module dlfcn {", '      header "dlfcn.h"', "      export *", "    }", "", "    module fcntl {", '      header "fcntl.h"', '      header "sys/fcntl.h"', "      export *", "    }", "", "    module fmtmsg {", '      header "fmtmsg.h"', "      export *", "    }", "", "    module fnmatch {", '      header "fnmatch.h"', "      export *", "    }", "", "    module ftw {", '      header "ftw.h"', "      export *", "    }", "", "    module glob {", '      header "glob.h"', "      export *", "    }", "", "    module grp {", '      header "grp.h"', "      export *", "    }", "", "    module iconv {", '      header "iconv.h"', "      export *", "    }", "", "    module ioctl {", '      header "sys/ioctl.h"', "      export *", "    }", "", "    module langinfo {", '      header "langinfo.h"', "      export *", "    }", "", "    module libgen {", '      header "libgen.h"', "      export *", "    }", "", "    module monetary {", '      header "monetary.h"', "      export *", "    }", "", "    module ndbm {", '      header "ndbm.h"', "      export *", "    }", "", "    module netdb {", '      header "netdb.h"', "      export *", "    }", "", "    module net {", "      module if {", '        header "net/if.h"', "        export *", "      }", "    }", "", "    module netinet {", "      module in {", '        header "netinet/in.h"', "        export *", "", '        exclude header "netinet6/in6.h"', "      }", "", "      module tcp {", '        header "netinet/tcp.h"', "        export *", "      }", "    }", "", "    module nl_types {", '      header "nl_types.h"', "      export *", "    }", "", "    module poll {", '      header "poll.h"', '      header "sys/poll.h"', "      export *", "    }", "", "    module pthread {", '      header "pthread.h"', '      header "pthread_impl.h"', "      export *", "    }", "", "    module pwd {", '      header "pwd.h"', "      export *", "    }", "", "    module regex {", '      header "regex.h"', "      export *", "    }", "", "    module sched {", '      header "sched.h"', "      export *", "    }", "", "    module search {", '      header "search.h"', "      export *", "    }", "", "    module semaphore {", '      header "semaphore.h"', "", '      header "sys/posix_sem.h"', "", "      export *", "    }", "", "    module spawn {", '      header "spawn.h"', '      header "sys/spawn.h"', "      export *", "    }", "", "    module strings {", '      header "strings.h"', "      export *", "    }", "", "    module _types {", '      umbrella "_types"', "", "      module * {", "        export *", "      }", "", "      export *", "    }", "", "    module sys {", "      export *", "", "      module ipc {", '        header "sys/ipc.h"', "        export *", "      }", "", "      module mman {", '        header "sys/mman.h"', "        export *", "      }", "", "      module msg {", '        header "sys/msg.h"', "        export *", "      }", "", "      module resource {", '        header "sys/resource.h"', "        export *", "      }", "", "      module select_proto {", '        header "sys/_select.h"', "        export *", "      }", "", "      module select {", '        header "sys/select.h"', "        export *", "      }", "", "      module sem {", '        header "sys/sem.h"', "        export *", "      }", "", "      module shm {", '        header "sys/shm.h"', "", '        header "sys/posix_shm.h"', "", "        export *", "      }", "", "      module socket {", '        header "sys/socket.h"', "        export *", "      }", "", "      module stat {", '        header "sys/stat.h"', "        export *", "      }", "", "      module statvfs {", '        header "sys/statvfs.h"', "        export *", "      }", "", "      module time {", '        header "sys/time.h"', "        export *", "      }", "", "      module times {", '        header "sys/times.h"', "        export *", "      }", "", "      module types {", '        header "sys/types.h"', '        header "sys/_types.h"', "", '        umbrella "sys/_types"', "", "        module * {", "          export *", "        }", "", "        export *", "", "", "", "", "      }", "", "      module uio {", '        header "sys/uio.h"', "        export *", "      }", "", "      module un {", '        header "sys/un.h"', "        export *", "      }", "", "      module utsname {", '        header "sys/utsname.h"', "        export *", "      }", "", "      module wait {", '        header "sys/wait.h"', "        export *", "      }", "    }", "", "    module syslog {", '      header "syslog.h"', '      header "sys/syslog.h"', "      export *", "    }", "", "    module tar {", '      header "tar.h"', "      export *", "    }", "", "    module termios {", '      header "termios.h"', '      header "sys/termios.h"', "      export *", "    }", "", "    module ulimit {", '      header "ulimit.h"', "      export *", "    }", "", "    module unistd {", '      header "unistd.h"', '      header "sys/unistd.h"', "      export *", "    }", "", "    module utime {", '      header "utime.h"', "      export *", "    }", "", "    module utmpx {", '      header "utmpx.h"', "      export *", "    }", "", "    module wordexp {", '      header "wordexp.h"', "      export *", "    }", "", "    // Re-exported C headers.", "    module complex {", "      export cstd.complex", "    }", "", "    module ctype {", "      export cstd.ctype", "    }", "", "    module errno {", "      export cstd.errno", "    }", "", "    module fenv {", "      export cstd.fenv", "    }", "", "    module inttypes {", "      export cstd.inttypes", "    }", "", "    module iso646 {", "      export cstd.iso646", "    }", "", "    module limits {", "      export cstd.limits", "    }", "", "    module locale {", "      export cstd.locale", "    }", "", "    module math {", "      export cstd.math", "    }", "", "    module setjmp {", "      export cstd.setjmp", "    }", "", "    module signal {", "      export cstd.signal", "    }", "", "    module stdbool {", "      export cstd.stdbool", "    }", "", "    module stddef {", "      export cstd.stddef", "    }", "", "    module stdint {", "      export cstd.stdint", "    }", "", "    module stdio {", "      export cstd.stdio", "    }", "", "    module stdlib {", "      export cstd.stdlib", "    }", "", "    module string {", "      export cstd.string", "    }", "", "    module time {", "      export cstd.time", "    }", "", "    module wchar {", "      export cstd.wchar", "    }", "", "    module wctype {", "      export cstd.wctype", "    }", "  }", "", "  module Availability { ", '    header "Availability.h"', '    header "AvailabilityMacros.h"', '    header "AvailabilityInternal.h"', "    export *", "  }", "", "  module ConditionalMacros {", '    header "ConditionalMacros.h"', "    export *", "  }", "", "  module getopt {", '    header "getopt.h"', "    export *", "  }", "", "  module TargetConditionals {", '    header "TargetConditionals.h"', "    export *", "  }", "", "  module AssertMacros {", '    header "AssertMacros.h"', "    export *", "  }", "", "  module MacTypes { ", '    header "MacTypes.h"', "    export *", "  } ", "", "  module Mach {", '    header "mach/mach.h"', "    export *", "", "    module boolean {", '      header "mach/boolean.h"', "      export *", "    }", "", "    module bootstrap {", '      header "mach/bootstrap.h"', "      export *", "    }", "", "    module clock {", '      header "mach/clock.h"', "      export *", "    }", "", "    module clock_priv {", '      header "mach/clock_priv.h"', "      export *", "    }", "", "    module clock_reply {", '      header "mach/clock_reply.h"', "      export *", "    }", "", "    module clock_types {", '      header "mach/clock_types.h"', "      export *", "    }", "", "    module error {", '      header "mach/error.h"', "      export *", "    }", "", "    module exc {", '      header "mach/exc.h"', "      export *", "    }", "", "    module exception {", '      header "mach/exception.h"', "      export *", "    }", "", "    module exception_types {", '      header "mach/exception_types.h"', "      export *", "    }", "", "    module host_info {", '      header "mach/host_info.h"', "      export *", "    }", "", "    module host_notify {", '      header "mach/host_notify.h"', "      export *", "    }", "", "    module host_priv {", '      header "mach/host_priv.h"', "      export *", "    }", "", "    module host_reboot {", '      header "mach/host_reboot.h"', "      export *", "    }", "", "    module host_security {", '      header "mach/host_security.h"', "      export *", "    }", "", "    module host_special_ports {", '      header "mach/host_special_ports.h"', "      export *", "    }", "", "    module kern_return {", '      header "mach/kern_return.h"', "      export *", "    }", "", "    module kmod {", '      header "mach/kmod.h"', "      export *", "    }", "", "    module lock_set {", '      header "mach/lock_set.h"', "      export *", "    }", "", "    module mach_error {", '      header "mach/mach_error.h"', "      export *", "    }", "", "    module mach_host {", '      header "mach/mach_host.h"', "      export *", "    }", "", "    module mach_init {", '      header "mach/mach_init.h"', "      export *", "    }", "", "    module mach_interface {", '      header "mach/mach_interface.h"', "      export *", "    }", "", "    module mach_param {", '      header "mach/mach_param.h"', "      export *", "    }", "", "    module mach_port {", '      header "mach/mach_port.h"', "      export *", "    }", "", "    module mach_syscalls {", '      header "mach/mach_syscalls.h"', "      export *", "    }", "", "    module mach_time {", '      header "mach/mach_time.h"', "      export *", "    }", "", "    module mach_traps {", '      header "mach/mach_traps.h"', "      export *", "    }", "", "    module mach_types {", '      header "mach/mach_types.h"', "      export *", "    }", "", "", "    module mach_vm {", '      header "mach/mach_vm.h"', "      export *", "    }", "", "", "    module memory_object_types {", '      header "mach/memory_object_types.h"', "      export *", "    }", "", "    module message {", '      header "mach/message.h"', "      export *", "    }", "", "    module mig {", '      header "mach/mig.h"', "      export *", "    }", "", "    module mig_errors {", '      header "mach/mig_errors.h"', "      export *", "    }", "", "    module ndr {", '      header "mach/ndr.h"', "      export *", "    }", "", "    module notify {", '      header "mach/notify.h"', "      export *", "    }", "", "    module policy {", '      header "mach/policy.h"', "      export *", "    }", "", "    module port {", '      header "mach/port.h"', "      export *", "    }", "", "    module port_obj {", '      header "mach/port_obj.h"', "      export *", "    }", "", "    module processor {", '      header "mach/processor.h"', "      export *", "    }", "", "    module processor_info {", '      header "mach/processor_info.h"', "      export *", "    }", "", "    module processor_set {", '      header "mach/processor_set.h"', "      export *", "    }", "", "    module rpc {", '      header "mach/rpc.h"', "      export *", "    }", "", "", "    module sdt {", '      header "mach/sdt.h"', '      header "sys/sdt.h"', "      export *", "    }", "", "", "    module semaphore {", '      header "mach/semaphore.h"', "      export *", "    }", "", "", "    module shared_region {", '      header "mach/shared_region.h"', "      export *", "    }", "", "", "    module std_types {", '      header "mach/std_types.h"', "      export *", "    }", "", "    module sync {", '      header "mach/sync.h"', "      export *", "    }", "", "    module sync_policy {", '      header "mach/sync_policy.h"', "      export *", "    }", "", "    module task {", '      header "mach/task.h"', "      export *", "    }", "", "    module task_info {", '      header "mach/task_info.h"', "      export *", "    }", "", "    module task_policy {", '      header "mach/task_policy.h"', "      export *", "    }", "", "    module task_special_ports {", '      header "mach/task_special_ports.h"', "      export *", "    }", "", "    module thread_act {", '      header "mach/thread_act.h"', "      export *", "    }", "", "    module thread_info {", '      header "mach/thread_info.h"', "      export *", "    }", "", "    module thread_policy {", '      header "mach/thread_policy.h"', "      export *", "    }", "", "    module thread_special_ports {", '      header "mach/thread_special_ports.h"', "      export *", "    }", "", "    module thread_status {", '      header "mach/thread_status.h"', "      export *", "    }", "", "    module thread_switch {", '      header "mach/thread_switch.h"', "      export *", "    }", "", "    module time_value {", '      header "mach/time_value.h"', "      export *", "    }", "", "    module vm_attributes {", '      header "mach/vm_attributes.h"', "      export *", "    }", "", "    module vm_behavior {", '      header "mach/vm_behavior.h"', "      export *", "    }", "", "    module vm_inherit {", '      header "mach/vm_inherit.h"', "      export *", "    }", "", "    module vm_map {", '      header "mach/vm_map.h"', "      export *", "    }", "", "    module vm_param {", '      header "mach/vm_param.h"', "      export *", "    }", "", "    module vm_prot {", '      header "mach/vm_prot.h"', "      export *", "    }", "", "    module vm_purgable {", '      header "mach/vm_purgable.h"', "      export *", "    }", "", "    module vm_region {", '      header "mach/vm_region.h"', "      export *", "    }", "", "    module vm_statistics {", '      header "mach/vm_statistics.h"', "      export *", "    }", "", "    module vm_sync {", '      header "mach/vm_sync.h"', "      export *", "    }", "", "    module vm_task {", '      header "mach/vm_task.h"', "      export *", "    }", "", "    module vm_types {", '      header "mach/vm_types.h"', "      export *", "    }", "", "", '    exclude header "mach/shared_memory_server.h" // deprecated', "", "", "    module machine {", '      header "mach/machine.h"', "      export *", "", "      module boolean {", '        header "mach/machine/boolean.h"', "        export *", "      }", "", "      module exception {", '        header "mach/machine/exception.h"', "        export *", "      }", "", "      module kern_return {", '        header "mach/machine/kern_return.h"', "        export *", "      }", "", "      module processor_info {", '        header "mach/machine/processor_info.h"', "        export *", "      }", "", "      module rpc {", '        header "mach/machine/rpc.h"', "        export *", "      }", "", "", "      module sdt {", '        header "mach/machine/sdt.h"', "        export *", "      }", "", "      module sdt_isa {", '        header "mach/machine/sdt_isa.h"', "        export *", "      }", "", "", "      module thread_state {", '        header "mach/machine/thread_state.h"', "        export *", "      }", "", "      module thread_status {", '        header "mach/machine/thread_status.h"', "        export *", "      }", "", "      module vm_param {", '        header "mach/machine/vm_param.h"', "        export *", "      }", "", "      module vm_types {", '        header "mach/machine/vm_types.h"', "        export *", "      }", "    }", "", "    module debug {", '      umbrella  "mach_debug"', "      module * { export * }", "      export *", "    }", "  }", "", "  module libkern {", "    export *", "", "    module OSAtomic {", '      header "libkern/OSAtomic.h"', "      export *", "    }", "", "    module OSByteOrder {", '      header "libkern/OSByteOrder.h"', '      header "libkern/_OSByteOrder.h"', "      export *", "", "", "", "", '      header "libkern/i386/_OSByteOrder.h"', "", "    }", "", "    // note: header OSKextLib.h depends on CoreFoundation and is", "    // therefore not part of this module.", "  }", "", "  module malloc {", '    header "malloc/malloc.h"', "", '    header "sys/malloc.h"', "", "    export *", "  }", "", "  module machine {", '    umbrella "machine"', "    export *", "    module * { export * }", "  }", "", "  module secure {", '    umbrella "secure"', "    export *", "    module * { export * }", "  }", "", "  module _locale {", '    header "_locale.h"', "    export *", "  }", "", "  module _types {", '    header "_types.h"', "    export *", "  }", "", "  module _wctype {", '    header "_wctype.h"', "    export *", "  }", "", "  module alloca {", '    header "alloca.h"', "    export *", "  }", "", "  module block {", "    requires blocks", '    header "Block.h"', "    export *", "  }", "", "  module bsm {", "", '    umbrella header "bsm/libbsm.h"', "    export *", "    module * { export * }", "", "  }", "", "", "  module hfs {", '    umbrella "hfs"', "    module * { export * }", "    export *", "  }", "", "", "", "  module ncurses {", '    header "ncurses.h" // note: same as curses.h', "    export *", "", "    explicit module dll {", '      header "ncurses_dll.h"', "      export *", "    }", "", "    explicit module unctrl {", '      header "unctrl.h"', "      export *", "    }", "  }", "", "", "  module net {", "", "    module if_media {", '      header "net/if_media.h"', "      export *", "    }", "", "", "    module if_var {", '      header "net/if_var.h"', "      export *", "    }", "", "", "    module route {", '      header "net/route.h"', "      export *", "    }", "", "  }", "", "  module runetype {", '    header "runetype.h"', "    export *", "  }", "", "  module sys {", "", "    module acct {", '      header "sys/acct.h"', "      export *", "    }", "", "", "    module acl {", '      header "sys/acl.h"', "      export *", "    }", "", "    module appleapiopts {", '      header "sys/appleapiopts.h"', "      export *", "    }", "", "    module attr {", '      header "sys/attr.h"', "      export *", "    }", "", "", "    module buf {", '      header "sys/buf.h"', "      export *", "    }", "", "    module conf {", '      header "sys/conf.h"', "      export *", "    }", "", "", "", "", "    module disk {", '      header "sys/disk.h"', "      export *", "    }", "", "    module dkstat {", '      header "sys/dkstat.h"', "      export *", "    }", "", "    module domain {", '      header "sys/domain.h"', "      export *", "    }", "", "    module ev {", '      header "sys/ev.h"', "      export *", "    }", "", "", "    module event {", '      header "sys/event.h"', "      export *", "    }", "", "    module file {", '      header "sys/file.h"', "      export *", "    }", "", "", "    module filedesc {", '      header "sys/filedesc.h"', "      export *", "    }", "", "", "    module filio {", '      header "sys/filio.h"', "      export *", "    }", "", "", "    module gmon {", '      header "sys/gmon.h"', "      export *", "    }", "", "", "    module ioccom {", '      header "sys/ioccom.h"', "      export *", "    }", "", "    module kauth {", '      header "sys/kauth.h"', "      export *", "    }", "", "    module lctx {", '      header "sys/lctx.h"', "      export *", "    }", "", "    module lock {", '      header "sys/lock.h"', "      export *", "    }", "", "", "    module kernel_types {", '      header "sys/kernel_types.h"', "      export *", "    }", "", "    module kern_control {", '      header "sys/kern_control.h"', "      export *", "    }", "", "    module mbuf {", '      header "sys/mbuf.h"', "      export *", "    }", "", "", "    module mount {", '      header "sys/mount.h"', "      export *", "    }", "", "", "    module msgbuf {", '      header "sys/msgbuf.h"', "      export *", "    }", "", "    module netport {", '      header "sys/netport.h"', "      export *", "    }", "", "", "    module param {", '      header "sys/param.h"', "      export *", "    }", "", "    module paths {", '      header "sys/paths.h"', "      export *", "    }", "", "", "    module pipe {", '      header "sys/pipe.h"', "      export *", "    }", "", "", "    module proc {", '      header "sys/proc.h"', "      export *", "    }", "", "", "    module proc_info {", '      header "sys/proc_info.h"', "      export *", "    }", "", "", "    module queue {", '      header "sys/queue.h"', "      export *", "    }", "", "    module quota {", '      header "sys/quota.h"', "      export *", "    }", "", "", "    module random {", '      header "sys/random.h"', "      export *", "    }", "", "", "    module rbtree {", '      header "sys/rbtree.h"', "      export *", "    }", "", "", "    module reboot {", '      header "sys/reboot.h"', "      export *", "    }", "", "    module resourcevar {", '      header "sys/resourcevar.h"', "      export *", "    }", "", "    module sbuf {", '      header "sys/sbuf.h"', "      export *", "    }", "", "", "    module semaphore {", '      header "sys/semaphore.h"', "      export *", "    }", "", "    module signal {", '      header "sys/signal.h"', "      export *", "    }", "", "", "    module signalvar {", '      header "sys/signalvar.h"', "      export *", "    }", "", "    module socketvar {", '      header "sys/socketvar.h"', "      export *", "    }", "", "", "    module sockio {", '      header "sys/sockio.h"', "      export *", "    }", "", "    module syscall {", '      header "sys/syscall.h"', "      export *", "    }", "", "    module sysctl {", '      header "sys/sysctl.h"', "      export *", "    }", "", "    module syslimits {", '      header "sys/syslimits.h"', "      export *", "    }", "", "", "    module sys_domain {", '      header "sys/sys_domain.h"', "      export *", "    }", "", "", "    module timeb {", '      header "sys/timeb.h"', "      export *", "    }", "", "", "    module trace {", '      header "sys/trace.h"', "      export *", "    }", "", "    module tty {", '      header "sys/tty.h"', "      export *", "    }", "", "", "    module ttycom {", '      header "sys/ttycom.h"', "      export *", "    }", "", "    module ttydefaults {", '      header "sys/ttydefaults.h"', "      export *", "    }", "", "    module ucontext {", '      header "sys/ucontext.h"', "      export *", "    }", "", "    module ucred {", '      header "sys/ucred.h"', "      export *", "    }", "", "", "    module unpcb {", '      header "sys/unpcb.h"', "      export *", "    }", "", "    module user {", '      header "sys/user.h"', "      export *", "    }", "", "    module utfconv {", '      header "sys/utfconv.h"', "      export *", "    }", "", "    module vcmd {", '      header "sys/vcmd.h"', "      export *", "    }", "", "", "    module vm {", '      header "sys/vm.h"', "      export *", "    }", "  }", "", "  module uuid {", '    header "uuid/uuid.h"', "    export *", "  }", "", "  module architecture {", '    header "architecture/byte_order.h"', "    export *", "  }", "", "", "  module libc {", '    header "libc.h"', "    export *", "  }", "", "", "  module sysexits {", '    header "sysexits.h"', "    export *", "  }", "}", "", "module os [system] {", "  module object {", '    header "os/object.h"', "    export *", "  }", "}", "", "module libkern [system] {", "  module OSCacheControl {", '    header "libkern/OSCacheControl.h"', "    export *", "  }", "", "", "  module OSDebug {", '    header "libkern/OSDebug.h"', "    export *", "  }", "", "  module OSReturn {", '    header "libkern/OSReturn.h"', "    export *", "  }", "", "  module OSTypes {", '    header "libkern/OSTypes.h"', "    export *", "  }", "", "}", "" },
    ["monetary.h"] = { "/*-", " * Copyright (c) 2001 Alexey Zelkin <phantom@FreeBSD.org>", " * All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " *", " * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " * $FreeBSD: /repoman/r/ncvs/src/include/monetary.h,v 1.7 2002/09/20 08:22:48 mike Exp $", " */", "", "#ifndef _MONETARY_H_", "#define\t_MONETARY_H_", "", "#include <sys/cdefs.h>", "#include <_types.h>", "#include <sys/_types/_size_t.h>", "#include <sys/_types/_ssize_t.h>", "", "__BEGIN_DECLS", "ssize_t\tstrfmon(char *, size_t, const char *, ...);", "__END_DECLS", "", "#ifdef _USE_EXTENDED_LOCALES_", "#include <xlocale/_monetary.h>", "#endif /* _USE_EXTENDED_LOCALES_ */", "", "#endif /* !_MONETARY_H_ */" },
    ["monitor.h"] = { "/*", " * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/* ", " * Copyright (c) 1988 NeXT, Inc.", " *", " * HISTORY", " *  04-May-90 Created", " */", "", "#ifndef __MONITOR_HEADER__", "#define __MONITOR_HEADER__", "", "#include <sys/cdefs.h>", "", "__BEGIN_DECLS", "extern void monstartup (char *lowpc, char *highpc);", "", "extern void monitor (char *lowpc, char *highpc, char *buf, int bufsiz, int cntsiz);", "", "extern void moncontrol (int mode);", "", "extern void monoutput (const char *filename);", "", "extern void moninit (void);", "", "extern void monreset (void);", "__END_DECLS", "", "#endif\t/* __MONITOR_HEADER__ */" },
    ["mpool.h"] = { "/*-", " * Copyright (c) 1991, 1993, 1994", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)mpool.h\t8.2 (Berkeley) 7/14/94", " * $FreeBSD: src/include/mpool.h,v 1.9 2002/03/23 17:24:53 imp Exp $", " */", "", "#ifndef _MPOOL_H_", "#define _MPOOL_H_", "", "#include <sys/queue.h>", "", "/*", " * The memory pool scheme is a simple one.  Each in-memory page is referenced", " * by a bucket which is threaded in up to two of three ways.  All active pages", " * are threaded on a hash chain (hashed by page number) and an lru chain.", " * Inactive pages are threaded on a free chain.  Each reference to a memory", " * pool is handed an opaque MPOOL cookie which stores all of this information.", " */", "#define\tHASHSIZE\t128", "#define\tHASHKEY(pgno)\t((pgno - 1) % HASHSIZE)", "", "/* The BKT structures are the elements of the queues. */", "typedef struct _bkt {", "\tTAILQ_ENTRY(_bkt) hq;\t\t/* hash queue */", "\tTAILQ_ENTRY(_bkt) q;\t\t/* lru queue */", "\tvoid    *page;\t\t\t/* page */", "\tpgno_t   pgno;\t\t\t/* page number */", "", "#define\tMPOOL_DIRTY\t0x01\t\t/* page needs to be written */", "#define\tMPOOL_PINNED\t0x02\t\t/* page is pinned into memory */", "\tu_int8_t flags;\t\t\t/* flags */", "} BKT;", "", "typedef struct MPOOL {", "\tTAILQ_HEAD(_lqh, _bkt) lqh;\t/* lru queue head */", "\t\t\t\t\t/* hash queue array */", "\tTAILQ_HEAD(_hqh, _bkt) hqh[HASHSIZE];", "\tpgno_t\tcurcache;\t\t/* current number of cached pages */", "\tpgno_t\tmaxcache;\t\t/* max number of cached pages */", "\tpgno_t\tnpages;\t\t\t/* number of pages in the file */", "\tunsigned long\tpagesize;\t/* file page size */", "\tint\tfd;\t\t\t/* file descriptor */", "\t\t\t\t\t/* page in conversion routine */", "\tvoid    (*pgin)(void *, pgno_t, void *);", "\t\t\t\t\t/* page out conversion routine */", "\tvoid    (*pgout)(void *, pgno_t, void *);", "\tvoid\t*pgcookie;\t\t/* cookie for page in/out routines */", "#ifdef STATISTICS", "\tunsigned long\tcachehit;", "\tunsigned long\tcachemiss;", "\tunsigned long\tpagealloc;", "\tunsigned long\tpageflush;", "\tunsigned long\tpageget;", "\tunsigned long\tpagenew;", "\tunsigned long\tpageput;", "\tunsigned long\tpageread;", "\tunsigned long\tpagewrite;", "#endif", "} MPOOL;", "", "__BEGIN_DECLS", "MPOOL\t*mpool_open(void *, int, pgno_t, pgno_t);", "void\t mpool_filter(MPOOL *, void (*)(void *, pgno_t, void *),", "\t    void (*)(void *, pgno_t, void *), void *);", "void\t*mpool_new(MPOOL *, pgno_t *);", "void\t*mpool_get(MPOOL *, pgno_t, unsigned int);", "int\t mpool_put(MPOOL *, void *, unsigned int);", "int\t mpool_sync(MPOOL *);", "int\t mpool_close(MPOOL *);", "#ifdef STATISTICS", "void\t mpool_stat(MPOOL *);", "#endif", "__END_DECLS", "", "#endif" },
    ["nameser.h"] = { "/*", " * Copyright (c) 1983, 1989, 1993", " *    The Regents of the University of California.  All rights reserved.", " * ", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " * \tThis product includes software developed by the University of", " * \tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " * ", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " */", "", "/*", " * Copyright (c) 1996-1999 by Internet Software Consortium.", " *", " * Permission to use, copy, modify, and distribute this software for any", " * purpose with or without fee is hereby granted, provided that the above", " * copyright notice and this permission notice appear in all copies.", " *", ' * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS', " * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES", " * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE", " * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL", " * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR", " * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS", " * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS", " * SOFTWARE.", " */", "", "/*", " *\t$Id: nameser.h,v 1.1 2006/03/01 19:01:36 majka Exp $", " */", "", "#ifndef _NAMESER_9_H_", "#define _NAMESER_9_H_", "", "#ifdef BIND_8_COMPAT", "#include <arpa/nameser_compat.h>", "#endif", "", "#include <sys/param.h>", "#if (!defined(BSD)) || (BSD < 199306)", "# include <sys/bitypes.h>", "#else", "# include <sys/types.h>", "#endif", "#include <sys/cdefs.h>", "", "/*", " * Revision information.  This is the release date in YYYYMMDD format.", " * It can change every day so the right thing to do with it is use it", ' * in preprocessor commands such as "#if (__NAMESER > 19931104)".  Do not', " * compare for equality; rather, use it to determine whether your libbind.a", " * contains a new enough lib/nameser/ to support the feature you need.", " */", "", "#define __NAMESER\t19991006\t/* New interface version stamp. */", "", "/*", " * Define constants based on RFC 883, RFC 1034, RFC 1035", " */", "#define NS_PACKETSZ\t512\t/* maximum packet size */", "#define NS_MAXDNAME\t1025\t/* maximum domain name */", "#define NS_MAXCDNAME\t255\t/* maximum compressed domain name */", "#define NS_MAXLABEL\t63\t/* maximum length of domain label */", "#define NS_HFIXEDSZ\t12\t/* #/bytes of fixed data in header */", "#define NS_QFIXEDSZ\t4\t/* #/bytes of fixed data in query */", "#define NS_RRFIXEDSZ\t10\t/* #/bytes of fixed data in r record */", "#define NS_INT32SZ\t4\t/* #/bytes of data in a u_int32_t */", "#define NS_INT16SZ\t2\t/* #/bytes of data in a u_int16_t */", "#define NS_INT8SZ\t1\t/* #/bytes of data in a u_int8_t */", "#define NS_INADDRSZ\t4\t/* IPv4 T_A */", "#define NS_IN6ADDRSZ\t16\t/* IPv6 T_AAAA */", "#define NS_CMPRSFLGS\t0xc0\t/* Flag bits indicating name compression. */", "#define NS_DEFAULTPORT\t53\t/* For both TCP and UDP. */", "", "/*", " * These can be expanded with synonyms, just keep ns_parse.c:ns_parserecord()", " * in synch with it.", " */", "#define ns_sect res_9_ns_sect", "typedef enum __ns_sect {", "\tns_s_qd = 0,\t\t/* Query: Question. */", "\tns_s_zn = 0,\t\t/* Update: Zone. */", "\tns_s_an = 1,\t\t/* Query: Answer. */", "\tns_s_pr = 1,\t\t/* Update: Prerequisites. */", "\tns_s_ns = 2,\t\t/* Query: Name servers. */", "\tns_s_ud = 2,\t\t/* Update: Update. */", "\tns_s_ar = 3,\t\t/* Query|Update: Additional records. */", "\tns_s_max = 4", "} ns_sect;", "", "/*", " * This is a message handle.  It is caller allocated and has no dynamic data.", " * This structure is intended to be opaque to all but ns_parse.c, thus the", " * leading _'s on the member names.  Use the accessor functions, not the _'s.", " */", "#define ns_msg res_9_ns_msg", "typedef struct __ns_msg {", "\tconst u_char\t*_msg, *_eom;", "\tu_int16_t\t_id, _flags, _counts[ns_s_max];", "\tconst u_char\t*_sections[ns_s_max];", "\tns_sect\t\t_sect;", "\tint\t\t_rrnum;", "\tconst u_char\t*_msg_ptr;", "} ns_msg;", "", "/* Private data structure - do not use from outside library. */", "#define _ns_flagdata _res_9_ns_flagdata", "struct _ns_flagdata {  int mask, shift;  };", "extern struct _ns_flagdata _ns_flagdata[];", "", "/* Accessor macros - this is part of the public interface. */", "", "#define ns_msg_id(handle) ((handle)._id + 0)", "#define ns_msg_base(handle) ((handle)._msg + 0)", "#define ns_msg_end(handle) ((handle)._eom + 0)", "#define ns_msg_size(handle) ((handle)._eom - (handle)._msg)", "#define ns_msg_count(handle, section) ((handle)._counts[section] + 0)", "", "/*", " * This is a parsed record.  It is caller allocated and has no dynamic data.", " */", "#define ns_rr res_9_ns_rr", "", "typedef\tstruct __ns_rr {", "\tchar\t\tname[NS_MAXDNAME];", "\tu_int16_t\ttype;", "\tu_int16_t\trr_class;", "\tu_int32_t\tttl;", "\tu_int16_t\trdlength;", "\tconst u_char *\trdata;", "} ns_rr;", "", "/* Accessor macros - this is part of the public interface. */", "#define ns_rr_name(rr)\t(((rr).name[0] != '\\0') ? (rr).name : \".\")", "#define ns_rr_type(rr)\t((ns_type)((rr).type + 0))", "#define ns_rr_class(rr)\t((ns_class)((rr).rr_class + 0))", "#define ns_rr_ttl(rr)\t((rr).ttl + 0)", "#define ns_rr_rdlen(rr)\t((rr).rdlength + 0)", "#define ns_rr_rdata(rr)\t((rr).rdata + 0)", "", "/*", " * These don't have to be in the same order as in the packet flags word,", " * and they can even overlap in some cases, but they will need to be kept", " * in synch with ns_parse.c:ns_flagdata[].", " */", "#define ns_flag res_9_ns_flag", "typedef enum __ns_flag {", "\tns_f_qr,\t\t/* Question/Response. */", "\tns_f_opcode,\t\t/* Operation code. */", "\tns_f_aa,\t\t/* Authoritative Answer. */", "\tns_f_tc,\t\t/* Truncation occurred. */", "\tns_f_rd,\t\t/* Recursion Desired. */", "\tns_f_ra,\t\t/* Recursion Available. */", "\tns_f_z,\t\t\t/* MBZ. */", "\tns_f_ad,\t\t/* Authentic Data (DNSSEC). */", "\tns_f_cd,\t\t/* Checking Disabled (DNSSEC). */", "\tns_f_rcode,\t\t/* Response code. */", "\tns_f_max", "} ns_flag;", "", "/*", " * Currently defined opcodes.", " */", "#define ns_opcode res_9_ns_opcode", "typedef enum __ns_opcode {", "\tns_o_query = 0,\t\t/* Standard query. */", "\tns_o_iquery = 1,\t/* Inverse query (deprecated/unsupported). */", "\tns_o_status = 2,\t/* Name server status query (unsupported). */", "\t\t\t\t/* Opcode 3 is undefined/reserved. */", "\tns_o_notify = 4,\t/* Zone change notification. */", "\tns_o_update = 5,\t/* Zone update message. */", "\tns_o_max = 6", "} ns_opcode;", "", "/*", " * Currently defined response codes.", " */", "#define ns_rcode res_9_ns_rcode", "typedef\tenum __ns_rcode {", "\tns_r_noerror = 0,\t/* No error occurred. */", "\tns_r_formerr = 1,\t/* Format error. */", "\tns_r_servfail = 2,\t/* Server failure. */", "\tns_r_nxdomain = 3,\t/* Name error. */", "\tns_r_notimpl = 4,\t/* Unimplemented. */", "\tns_r_refused = 5,\t/* Operation refused. */", "\t/* these are for BIND_UPDATE */", "\tns_r_yxdomain = 6,\t/* Name exists */", "\tns_r_yxrrset = 7,\t/* RRset exists */", "\tns_r_nxrrset = 8,\t/* RRset does not exist */", "\tns_r_notauth = 9,\t/* Not authoritative for zone */", "\tns_r_notzone = 10,\t/* Zone of record different from zone section */", "\tns_r_max = 11,", "\t/* The following are EDNS extended rcodes */", "\tns_r_badvers = 16,", "\t/* The following are TSIG errors */", "\tns_r_badsig = 16,", "\tns_r_badkey = 17,", "\tns_r_badtime = 18", "} ns_rcode;", "", "/* BIND_UPDATE */", "#define ns_update_operation res_9_ns_update_operation", "typedef enum __ns_update_operation {", "\tns_uop_delete = 0,", "\tns_uop_add = 1,", "\tns_uop_max = 2", "} ns_update_operation;", "", "/*", " * This structure is used for TSIG authenticated messages", " */", "#define ns_tsig_key res_9_ns_tsig_key", "struct ns_tsig_key {", "        char name[NS_MAXDNAME], alg[NS_MAXDNAME];", "        unsigned char *data;", "        int len;", "};", "typedef struct ns_tsig_key ns_tsig_key;", "", "/*", " * This structure is used for TSIG authenticated TCP messages", " */", "#define ns_tcp_tsig_state res_9_ns_tcp_tsig_state", "struct ns_tcp_tsig_state {", "\tint counter;", "\tstruct dst_key *key;", "\tvoid *ctx;", "\tunsigned char sig[NS_PACKETSZ];", "\tint siglen;", "};", "typedef struct ns_tcp_tsig_state ns_tcp_tsig_state;", "", "#define NS_TSIG_FUDGE 300", "#define NS_TSIG_TCP_COUNT 100", '#define NS_TSIG_ALG_HMAC_MD5 "HMAC-MD5.SIG-ALG.REG.INT"', "", "#define NS_TSIG_ERROR_NO_TSIG -10", "#define NS_TSIG_ERROR_NO_SPACE -11", "#define NS_TSIG_ERROR_FORMERR -12", "", "/*", " * Currently defined type values for resources and queries.", " */", "#define ns_typw res_9_ns_type", "typedef enum __ns_type {", "\tns_t_invalid = 0,\t/* Cookie. */", "\tns_t_a = 1,\t\t/* Host address. */", "\tns_t_ns = 2,\t\t/* Authoritative server. */", "\tns_t_md = 3,\t\t/* Mail destination. */", "\tns_t_mf = 4,\t\t/* Mail forwarder. */", "\tns_t_cname = 5,\t\t/* Canonical name. */", "\tns_t_soa = 6,\t\t/* Start of authority zone. */", "\tns_t_mb = 7,\t\t/* Mailbox domain name. */", "\tns_t_mg = 8,\t\t/* Mail group member. */", "\tns_t_mr = 9,\t\t/* Mail rename name. */", "\tns_t_null = 10,\t\t/* Null resource record. */", "\tns_t_wks = 11,\t\t/* Well known service. */", "\tns_t_ptr = 12,\t\t/* Domain name pointer. */", "\tns_t_hinfo = 13,\t/* Host information. */", "\tns_t_minfo = 14,\t/* Mailbox information. */", "\tns_t_mx = 15,\t\t/* Mail routing information. */", "\tns_t_txt = 16,\t\t/* Text strings. */", "\tns_t_rp = 17,\t\t/* Responsible person. */", "\tns_t_afsdb = 18,\t/* AFS cell database. */", "\tns_t_x25 = 19,\t\t/* X_25 calling address. */", "\tns_t_isdn = 20,\t\t/* ISDN calling address. */", "\tns_t_rt = 21,\t\t/* Router. */", "\tns_t_nsap = 22,\t\t/* NSAP address. */", "\tns_t_nsap_ptr = 23,\t/* Reverse NSAP lookup (deprecated). */", "\tns_t_sig = 24,\t\t/* Security signature. */", "\tns_t_key = 25,\t\t/* Security key. */", "\tns_t_px = 26,\t\t/* X.400 mail mapping. */", "\tns_t_gpos = 27,\t\t/* Geographical position (withdrawn). */", "\tns_t_aaaa = 28,\t\t/* Ip6 Address. */", "\tns_t_loc = 29,\t\t/* Location Information. */", "\tns_t_nxt = 30,\t\t/* Next domain (security). */", "\tns_t_eid = 31,\t\t/* Endpoint identifier. */", "\tns_t_nimloc = 32,\t/* Nimrod Locator. */", "\tns_t_srv = 33,\t\t/* Server Selection. */", "\tns_t_atma = 34,\t\t/* ATM Address */", "\tns_t_naptr = 35,\t/* Naming Authority PoinTeR */", "\tns_t_kx = 36,\t\t/* Key Exchange */", "\tns_t_cert = 37,\t\t/* Certification record */", "\tns_t_a6 = 38,\t\t/* IPv6 address (deprecates AAAA) */", "\tns_t_dname = 39,\t/* Non-terminal DNAME (for IPv6) */", "\tns_t_sink = 40,\t\t/* Kitchen sink (experimentatl) */", "\tns_t_opt = 41,\t\t/* EDNS0 option (meta-RR) */", "\tns_t_tkey = 249,\t/* Transaction key */", "\tns_t_tsig = 250,\t/* Transaction signature. */", "\tns_t_ixfr = 251,\t/* Incremental zone transfer. */", "\tns_t_axfr = 252,\t/* Transfer zone of authority. */", "\tns_t_mailb = 253,\t/* Transfer mailbox records. */", "\tns_t_maila = 254,\t/* Transfer mail agent records. */", "\tns_t_any = 255,\t\t/* Wildcard match. */", "\tns_t_zxfr = 256,\t/* BIND-specific, nonstandard. */", "\tns_t_max = 65536", "} ns_type;", "", "/* Exclusively a QTYPE? (not also an RTYPE) */", "#define\tns_t_qt_p(t) (ns_t_xfr_p(t) || (t) == ns_t_any || \\", "\t\t      (t) == ns_t_mailb || (t) == ns_t_maila)", "/* Some kind of meta-RR? (not a QTYPE, but also not an RTYPE) */", "#define\tns_t_mrr_p(t) ((t) == ns_t_tsig || (t) == ns_t_opt)", "/* Exclusively an RTYPE? (not also a QTYPE or a meta-RR) */", "#define ns_t_rr_p(t) (!ns_t_qt_p(t) && !ns_t_mrr_p(t))", "#define ns_t_udp_p(t) ((t) != ns_t_axfr && (t) != ns_t_zxfr)", "#define ns_t_xfr_p(t) ((t) == ns_t_axfr || (t) == ns_t_ixfr || \\", "\t\t       (t) == ns_t_zxfr)", "", "/*", " * Values for class field", " */", "#define ns_class res_9_ns_class", "typedef enum __ns_class {", "\tns_c_invalid = 0,\t/* Cookie. */", "\tns_c_in = 1,\t\t/* Internet. */", "\tns_c_2 = 2,\t\t/* unallocated/unsupported. */", "\tns_c_chaos = 3,\t\t/* MIT Chaos-net. */", "\tns_c_hs = 4,\t\t/* MIT Hesiod. */", "\t/* Query class values which do not appear in resource records */", "\tns_c_none = 254,\t/* for prereq. sections in update requests */", "\tns_c_any = 255,\t\t/* Wildcard match. */", "\tns_c_max = 65536", "} ns_class;", "", "/* DNSSEC constants. */", "", "#define ns_key_types res_9_ns_key_types", "typedef enum __ns_key_types {", "\tns_kt_rsa = 1,\t\t/* key type RSA/MD5 */", "\tns_kt_dh  = 2,\t\t/* Diffie Hellman */", "\tns_kt_dsa = 3,\t\t/* Digital Signature Standard (MANDATORY) */", "\tns_kt_private = 254\t/* Private key type starts with OID */", "} ns_key_types;", "", "#define ns_cert_types res_9_ns_cert_types", "typedef enum __ns_cert_types {", "\tcert_t_pkix = 1,\t/* PKIX (X.509v3) */", "\tcert_t_spki = 2,\t/* SPKI */", "\tcert_t_pgp  = 3,\t/* PGP */", "\tcert_t_url  = 253,\t/* URL private type */", "\tcert_t_oid  = 254\t/* OID private type */", "} ns_cert_types;", "", "/* Flags field of the KEY RR rdata. */", '#define\tNS_KEY_TYPEMASK\t\t0xC000\t/* Mask for "type" bits */', "#define\tNS_KEY_TYPE_AUTH_CONF\t0x0000\t/* Key usable for both */", "#define\tNS_KEY_TYPE_CONF_ONLY\t0x8000\t/* Key usable for confidentiality */", "#define\tNS_KEY_TYPE_AUTH_ONLY\t0x4000\t/* Key usable for authentication */", "#define\tNS_KEY_TYPE_NO_KEY\t0xC000\t/* No key usable for either; no key */", "/* The type bits can also be interpreted independently, as single bits: */", "#define\tNS_KEY_NO_AUTH\t\t0x8000\t/* Key unusable for authentication */", "#define\tNS_KEY_NO_CONF\t\t0x4000\t/* Key unusable for confidentiality */", "#define\tNS_KEY_RESERVED2\t0x2000\t/* Security is *mandatory* if bit=0 */", "#define\tNS_KEY_EXTENDED_FLAGS\t0x1000\t/* reserved - must be zero */", "#define\tNS_KEY_RESERVED4\t0x0800  /* reserved - must be zero */", "#define\tNS_KEY_RESERVED5\t0x0400  /* reserved - must be zero */", "#define\tNS_KEY_NAME_TYPE\t0x0300\t/* these bits determine the type */", "#define\tNS_KEY_NAME_USER\t0x0000\t/* key is assoc. with user */", "#define\tNS_KEY_NAME_ENTITY\t0x0200\t/* key is assoc. with entity eg host */", "#define\tNS_KEY_NAME_ZONE\t0x0100\t/* key is zone key */", "#define\tNS_KEY_NAME_RESERVED\t0x0300\t/* reserved meaning */", "#define\tNS_KEY_RESERVED8\t0x0080  /* reserved - must be zero */", "#define\tNS_KEY_RESERVED9\t0x0040  /* reserved - must be zero */", "#define\tNS_KEY_RESERVED10\t0x0020  /* reserved - must be zero */", "#define\tNS_KEY_RESERVED11\t0x0010  /* reserved - must be zero */", "#define\tNS_KEY_SIGNATORYMASK\t0x000F\t/* key can sign RR's of same name */", "#define\tNS_KEY_RESERVED_BITMASK ( NS_KEY_RESERVED2 | \\", "\t\t\t\t  NS_KEY_RESERVED4 | \\", "\t\t\t\t  NS_KEY_RESERVED5 | \\", "\t\t\t\t  NS_KEY_RESERVED8 | \\", "\t\t\t\t  NS_KEY_RESERVED9 | \\", "\t\t\t\t  NS_KEY_RESERVED10 | \\", "\t\t\t\t  NS_KEY_RESERVED11 )", "#define NS_KEY_RESERVED_BITMASK2 0xFFFF /* no bits defined here */", "", "/* The Algorithm field of the KEY and SIG RR's is an integer, {1..254} */", "#define\tNS_ALG_MD5RSA\t\t1\t/* MD5 with RSA */", "#define\tNS_ALG_DH               2\t/* Diffie Hellman KEY */", "#define\tNS_ALG_DSA              3\t/* DSA KEY */", "#define\tNS_ALG_DSS              NS_ALG_DSA", "#define\tNS_ALG_EXPIRE_ONLY\t253\t/* No alg, no security */", "#define\tNS_ALG_PRIVATE_OID\t254\t/* Key begins with OID giving alg */", "", "/* Protocol values  */", "/* value 0 is reserved */", "#define NS_KEY_PROT_TLS         1", "#define NS_KEY_PROT_EMAIL       2", "#define NS_KEY_PROT_DNSSEC      3", "#define NS_KEY_PROT_IPSEC       4", "#define NS_KEY_PROT_ANY\t\t255", "", "/* Signatures */", "#define\tNS_MD5RSA_MIN_BITS\t 512\t/* Size of a mod or exp in bits */", "#define\tNS_MD5RSA_MAX_BITS\t2552", "\t/* Total of binary mod and exp */", "#define\tNS_MD5RSA_MAX_BYTES\t((NS_MD5RSA_MAX_BITS+7/8)*2+3)", "\t/* Max length of text sig block */", "#define\tNS_MD5RSA_MAX_BASE64\t(((NS_MD5RSA_MAX_BYTES+2)/3)*4)", "#define NS_MD5RSA_MIN_SIZE\t((NS_MD5RSA_MIN_BITS+7)/8)", "#define NS_MD5RSA_MAX_SIZE\t((NS_MD5RSA_MAX_BITS+7)/8)", "", "#define NS_DSA_SIG_SIZE         41", "#define NS_DSA_MIN_SIZE         213", "#define NS_DSA_MAX_BYTES        405", "", "/* Offsets into SIG record rdata to find various values */", "#define\tNS_SIG_TYPE\t0\t/* Type flags */", "#define\tNS_SIG_ALG\t2\t/* Algorithm */", "#define\tNS_SIG_LABELS\t3\t/* How many labels in name */", "#define\tNS_SIG_OTTL\t4\t/* Original TTL */", "#define\tNS_SIG_EXPIR\t8\t/* Expiration time */", "#define\tNS_SIG_SIGNED\t12\t/* Signature time */", "#define\tNS_SIG_FOOT\t16\t/* Key footprint */", "#define\tNS_SIG_SIGNER\t18\t/* Domain name of who signed it */", "", "/* How RR types are represented as bit-flags in NXT records */", "#define\tNS_NXT_BITS 8", "#define\tNS_NXT_BIT_SET(  n,p) (p[(n)/NS_NXT_BITS] |=  (0x80>>((n)%NS_NXT_BITS)))", "#define\tNS_NXT_BIT_CLEAR(n,p) (p[(n)/NS_NXT_BITS] &= ~(0x80>>((n)%NS_NXT_BITS)))", "#define\tNS_NXT_BIT_ISSET(n,p) (p[(n)/NS_NXT_BITS] &   (0x80>>((n)%NS_NXT_BITS)))", "#define NS_NXT_MAX 127", "", "/*", " * EDNS0 extended flags, host order.", " */", "#define NS_OPT_DNSSEC_OK\t0x8000U", "", "/*", " * Inline versions of get/put short/long.  Pointer is advanced.", " */", "#define NS_GET16(s, cp) do { \\", "\tregister const u_char *t_cp = (const u_char *)(cp); \\", "\t(s) = ((u_int16_t)t_cp[0] << 8) \\", "\t    | ((u_int16_t)t_cp[1]) \\", "\t    ; \\", "\t(cp) += NS_INT16SZ; \\", "} while (0)", "", "#define NS_GET32(l, cp) do { \\", "\tregister const u_char *t_cp = (const u_char *)(cp); \\", "\t(l) = ((u_int32_t)t_cp[0] << 24) \\", "\t    | ((u_int32_t)t_cp[1] << 16) \\", "\t    | ((u_int32_t)t_cp[2] << 8) \\", "\t    | ((u_int32_t)t_cp[3]) \\", "\t    ; \\", "\t(cp) += NS_INT32SZ; \\", "} while (0)", "", "#define NS_PUT16(s, cp) do { \\", "\tregister u_int16_t t_s = (u_int16_t)(s); \\", "\tregister u_char *t_cp = (u_char *)(cp); \\", "\t*t_cp++ = t_s >> 8; \\", "\t*t_cp   = t_s; \\", "\t(cp) += NS_INT16SZ; \\", "} while (0)", "", "#define NS_PUT32(l, cp) do { \\", "\tregister u_int32_t t_l = (u_int32_t)(l); \\", "\tregister u_char *t_cp = (u_char *)(cp); \\", "\t*t_cp++ = t_l >> 24; \\", "\t*t_cp++ = t_l >> 16; \\", "\t*t_cp++ = t_l >> 8; \\", "\t*t_cp   = t_l; \\", "\t(cp) += NS_INT32SZ; \\", "} while (0)", "", "/*", " * ANSI C identifier hiding for bind's lib/nameser.", " */", "#define\tns_msg_getflag\t\tres_9_ns_msg_getflag", "#define ns_get16\t\tres_9_ns_get16", "#define ns_get32\t\tres_9_ns_get32", "#define ns_put16\t\tres_9_ns_put16", "#define ns_put32\t\tres_9_ns_put32", "#define ns_initparse\t\tres_9_ns_initparse", "#define ns_skiprr\t\tres_9_ns_skiprr", "#define ns_parserr\t\tres_9_ns_parserr", "#define\tns_sprintrr\t\tres_9_ns_sprintrr", "#define\tns_sprintrrf\t\tres_9_ns_sprintrrf", "#define\tns_format_ttl\t\tres_9_ns_format_ttl", "#define\tns_parse_ttl\t\tres_9_ns_parse_ttl", "#define ns_datetosecs\t\tres_9_ns_datetosecs", "#define\tns_name_ntol\t\tres_9_ns_name_ntol", "#define\tns_name_ntop\t\tres_9_ns_name_ntop", "#define\tns_name_pton\t\tres_9_ns_name_pton", "#define\tns_name_unpack\t\tres_9_ns_name_unpack", "#define\tns_name_pack\t\tres_9_ns_name_pack", "#define\tns_name_compress\tres_9_ns_name_compress", "#define\tns_name_uncompress\tres_9_ns_name_uncompress", "#define\tns_name_skip\t\tres_9_ns_name_skip", "#define\tns_name_rollback\tres_9_ns_name_rollback", "#define\tns_sign\t\t\tres_9_ns_sign", "#define\tns_sign2\t\tres_9_ns_sign2", "#define\tns_sign_tcp\t\tres_9_ns_sign_tcp", "#define\tns_sign_tcp2\t\tres_9_ns_sign_tcp2", "#define\tns_sign_tcp_init\tres_9_ns_sign_tcp_init", "#define ns_find_tsig\t\tres_9_ns_find_tsig", "#define\tns_verify\t\tres_9_ns_verify", "#define\tns_verify_tcp\t\tres_9_ns_verify_tcp", "#define\tns_verify_tcp_init\tres_9_ns_verify_tcp_init", "#define\tns_samedomain\t\tres_9_ns_samedomain", "#define\tns_subdomain\t\tres_9_ns_subdomain", "#define\tns_makecanon\t\tres_9_ns_makecanon", "#define\tns_samename\t\tres_9_ns_samename", "", "__BEGIN_DECLS", "int\t\tns_msg_getflag __P((ns_msg, int));", "u_int\t\tns_get16 __P((const u_char *));", "u_long\t\tns_get32 __P((const u_char *));", "void\t\tns_put16 __P((u_int, u_char *));", "void\t\tns_put32 __P((u_long, u_char *));", "int\t\tns_initparse __P((const u_char *, int, ns_msg *));", "int\t\tns_skiprr __P((const u_char *, const u_char *, ns_sect, int));", "int\t\tns_parserr __P((ns_msg *, ns_sect, int, ns_rr *));", "int\t\tns_sprintrr __P((const ns_msg *, const ns_rr *,", "\t\t\t\t const char *, const char *, char *, size_t));", "int\t\tns_sprintrrf __P((const u_char *, size_t, const char *,", "\t\t\t\t  ns_class, ns_type, u_long, const u_char *,", "\t\t\t\t  size_t, const char *, const char *,", "\t\t\t\t  char *, size_t));", "int\t\tns_format_ttl __P((u_long, char *, size_t));", "int\t\tns_parse_ttl __P((const char *, u_long *));", "u_int32_t\tns_datetosecs __P((const char *cp, int *errp));", "int\t\tns_name_ntol __P((const u_char *, u_char *, size_t));", "int\t\tns_name_ntop __P((const u_char *, char *, size_t));", "int\t\tns_name_pton __P((const char *, u_char *, size_t));", "int\t\tns_name_unpack __P((const u_char *, const u_char *,", "\t\t\t\t    const u_char *, u_char *, size_t));", "int\t\tns_name_pack __P((const u_char *, u_char *, int,", "\t\t\t\t  const u_char **, const u_char **));", "int\t\tns_name_uncompress __P((const u_char *, const u_char *,", "\t\t\t\t\tconst u_char *, char *, size_t));", "int\t\tns_name_compress __P((const char *, u_char *, size_t,", "\t\t\t\t      const u_char **, const u_char **));", "int\t\tns_name_skip __P((const u_char **, const u_char *));", "void\t\tns_name_rollback __P((const u_char *, const u_char **,", "\t\t\t\t      const u_char **));", "int\t\tns_sign __P((u_char *, int *, int, int, void *,", "\t\t\t     const u_char *, int, u_char *, int *, time_t));", "int\t\tns_sign2 __P((u_char *, int *, int, int, void *,", "\t\t\t      const u_char *, int, u_char *, int *, time_t,", "\t\t\t      u_char **, u_char **));", "int\t\tns_sign_tcp __P((u_char *, int *, int, int,", "\t\t\t\t ns_tcp_tsig_state *, int));", "int\t\tns_sign_tcp2 __P((u_char *, int *, int, int,", "\t\t\t\t  ns_tcp_tsig_state *, int,", "\t\t\t\t  u_char **, u_char **));", "int\t\tns_sign_tcp_init __P((void *, const u_char *, int,", "\t\t\t\t\tns_tcp_tsig_state *));", "u_char\t\t*ns_find_tsig __P((u_char *, u_char *));", "int\t\tns_verify __P((u_char *, int *, void *,", "\t\t\t       const u_char *, int, u_char *, int *,", "\t\t\t       time_t *, int));", "int\t\tns_verify_tcp __P((u_char *, int *, ns_tcp_tsig_state *, int));", "int\t\tns_verify_tcp_init __P((void *, const u_char *, int,", "\t\t\t\t\tns_tcp_tsig_state *));", "int\t\tns_samedomain __P((const char *, const char *));", "int\t\tns_subdomain __P((const char *, const char *));", "int\t\tns_makecanon __P((const char *, char *, size_t));", "int\t\tns_samename __P((const char *, const char *));", "__END_DECLS", "", "#endif /* !_NAMESER_9_H_ */" },
    ["nc_tparm.h"] = { "/****************************************************************************", " * Copyright (c) 2006 Free Software Foundation, Inc.                        *", " *                                                                          *", " * Permission is hereby granted, free of charge, to any person obtaining a  *", " * copy of this software and associated documentation files (the            *", ' * "Software"), to deal in the Software without restriction, including      *', " * without limitation the rights to use, copy, modify, merge, publish,      *", " * distribute, distribute with modifications, sublicense, and/or sell       *", " * copies of the Software, and to permit persons to whom the Software is    *", " * furnished to do so, subject to the following conditions:                 *", " *                                                                          *", " * The above copyright notice and this permission notice shall be included  *", " * in all copies or substantial portions of the Software.                   *", " *                                                                          *", ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *', " * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *", " * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *", " * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *", " * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *", " * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *", " * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *", " *                                                                          *", " * Except as contained in this notice, the name(s) of the above copyright   *", " * holders shall not be used in advertising or otherwise to promote the     *", " * sale, use or other dealings in this Software without prior written       *", " * authorization.                                                           *", " ****************************************************************************/", "", "/****************************************************************************", " *  Author: Thomas E. Dickey                        2006                    *", " ****************************************************************************/", "", "/* $Id: nc_tparm.h,v 1.4 2006/11/26 00:49:25 tom Exp $ */", "", "/*", " * Cast parameters past the formatting-string for tparm() to match the", " * assumption of the varargs code.", " */", "#define TPARM_ARG long", "#define TPARM_N(n) (TPARM_ARG)(n)", "", "#define TPARM_9(a,b,c,d,e,f,g,h,i,j) tparm(a,TPARM_N(b),TPARM_N(c),TPARM_N(d),TPARM_N(e),TPARM_N(f),TPARM_N(g),TPARM_N(h),TPARM_N(i),TPARM_N(j))", "", "#if NCURSES_TPARM_VARARGS", "#define TPARM_8(a,b,c,d,e,f,g,h,i) tparm(a,TPARM_N(b),TPARM_N(c),TPARM_N(d),TPARM_N(e),TPARM_N(f),TPARM_N(g),TPARM_N(h),TPARM_N(i))", "#define TPARM_7(a,b,c,d,e,f,g,h) tparm(a,TPARM_N(b),TPARM_N(c),TPARM_N(d),TPARM_N(e),TPARM_N(f),TPARM_N(g),TPARM_N(h))", "#define TPARM_6(a,b,c,d,e,f,g) tparm(a,TPARM_N(b),TPARM_N(c),TPARM_N(d),TPARM_N(e),TPARM_N(f),TPARM_N(g))", "#define TPARM_5(a,b,c,d,e,f) tparm(a,TPARM_N(b),TPARM_N(c),TPARM_N(d),TPARM_N(e),TPARM_N(f))", "#define TPARM_4(a,b,c,d,e) tparm(a,TPARM_N(b),TPARM_N(c),TPARM_N(d),TPARM_N(e))", "#define TPARM_3(a,b,c,d) tparm(a,TPARM_N(b),TPARM_N(c),TPARM_N(d))", "#define TPARM_2(a,b,c) tparm(a,TPARM_N(b),TPARM_N(c))", "#define TPARM_1(a,b) tparm(a,TPARM_N(b))", "#define TPARM_0(a) tparm(a)", "#else", "#define TPARM_8(a,b,c,d,e,f,g,h,i) TPARM_9(a,b,c,d,e,f,g,h,i,0)", "#define TPARM_7(a,b,c,d,e,f,g,h) TPARM_8(a,b,c,d,e,f,g,h,0)", "#define TPARM_6(a,b,c,d,e,f,g) TPARM_7(a,b,c,d,e,f,g,0)", "#define TPARM_5(a,b,c,d,e,f) TPARM_6(a,b,c,d,e,f,0)", "#define TPARM_4(a,b,c,d,e) TPARM_5(a,b,c,d,e,0)", "#define TPARM_3(a,b,c,d) TPARM_4(a,b,c,d,0)", "#define TPARM_2(a,b,c) TPARM_3(a,b,c,0)", "#define TPARM_1(a,b) TPARM_2(a,b,0)", "#define TPARM_1(a,b) TPARM_2(a,b,0)", "#define TPARM_0(a) TPARM_1(a,0)", "#endif" },
    ["ncurses.h"] = { "/****************************************************************************", " * Copyright (c) 1998-2007,2008 Free Software Foundation, Inc.              *", " *                                                                          *", " * Permission is hereby granted, free of charge, to any person obtaining a  *", " * copy of this software and associated documentation files (the            *", ' * "Software"), to deal in the Software without restriction, including      *', " * without limitation the rights to use, copy, modify, merge, publish,      *", " * distribute, distribute with modifications, sublicense, and/or sell       *", " * copies of the Software, and to permit persons to whom the Software is    *", " * furnished to do so, subject to the following conditions:                 *", " *                                                                          *", " * The above copyright notice and this permission notice shall be included  *", " * in all copies or substantial portions of the Software.                   *", " *                                                                          *", ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *', " * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *", " * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *", " * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *", " * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *", " * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *", " * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *", " *                                                                          *", " * Except as contained in this notice, the name(s) of the above copyright   *", " * holders shall not be used in advertising or otherwise to promote the     *", " * sale, use or other dealings in this Software without prior written       *", " * authorization.                                                           *", " ****************************************************************************/", "", "/****************************************************************************", " *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *", " *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *", " *     and: Thomas E. Dickey                        1996-on                 *", " ****************************************************************************/", "", "/* $Id: curses.h.in,v 1.187 2008/08/30 20:11:29 tom Exp $ */", "", "#ifndef __NCURSES_H", "#define __NCURSES_H", "", "#define CURSES 1", "#define CURSES_H 1", "", "/* This should be defined for the enhanced functionality to be visible.", " * However, some of the wide-character (enhanced) functionality is missing.", " * So we do not define it (yet).", "#define _XOPEN_CURSES 1", " */", "", "/* These are defined only in curses.h, and are used for conditional compiles */", "#define NCURSES_VERSION_MAJOR 5", "#define NCURSES_VERSION_MINOR 7", "#define NCURSES_VERSION_PATCH 20081102", "", "/* This is defined in more than one ncurses header, for identification */", "#undef  NCURSES_VERSION", '#define NCURSES_VERSION "5.7"', "", "/*", " * Identify the mouse encoding version.", " */", "#define NCURSES_MOUSE_VERSION 1", "", "/*", " * Definitions to facilitate DLL's.", " */", "#include <ncurses_dll.h>", "", "/*", " * User-definable tweak to disable the include of <stdbool.h>.", " */", "#ifndef NCURSES_ENABLE_STDBOOL_H", "#define NCURSES_ENABLE_STDBOOL_H 1", "#endif", "", "/*", " * NCURSES_ATTR_T is used to quiet compiler warnings when building ncurses", " * configured using --disable-macros.", " */", "#ifdef NCURSES_NOMACROS", "#ifndef NCURSES_ATTR_T", "#define NCURSES_ATTR_T attr_t", "#endif", "#endif /* NCURSES_NOMACROS */", "", "#ifndef NCURSES_ATTR_T", "#define NCURSES_ATTR_T int", "#endif", "", "/*", " * Expands to 'const' if ncurses is configured using --enable-const.  Note that", " * doing so makes it incompatible with other implementations of X/Open Curses.", " */", "#undef  NCURSES_CONST", "#define NCURSES_CONST /*nothing*/", "", "#undef NCURSES_INLINE", "#define NCURSES_INLINE inline", "", "/*", " * The internal type used for color values", " */", "#undef\tNCURSES_COLOR_T", "#define\tNCURSES_COLOR_T short", "", "/*", " * Definition used to make WINDOW and similar structs opaque.", " */", "#ifndef NCURSES_OPAQUE", "#define NCURSES_OPAQUE 1", "#endif", "", "/*", " * The internal type used for window dimensions.", " */", "#undef\tNCURSES_SIZE_T", "#define\tNCURSES_SIZE_T short", "", "/*", " * Control whether tparm() supports varargs or fixed-parameter list.", " */", "#undef NCURSES_TPARM_VARARGS", "#define NCURSES_TPARM_VARARGS 1", "", "/*", " * NCURSES_CH_T is used in building the library, but not used otherwise in", " * this header file, since that would make the normal/wide-character versions", " * of the header incompatible.", " */", "#undef\tNCURSES_CH_T", "#define NCURSES_CH_T cchar_t", "", "#if 0 && defined(_LP64)", "typedef unsigned chtype;", "typedef unsigned mmask_t;", "#else", "typedef unsigned int chtype;", "typedef unsigned long mmask_t;", "#endif", "", "#include <stdio.h>", "#include <unctrl.h>", "#include <stdarg.h>\t/* we need va_list */", "#ifdef _XOPEN_SOURCE_EXTENDED", "#include <stddef.h>\t/* we want wchar_t */", "#endif /* _XOPEN_SOURCE_EXTENDED */", "", "/* X/Open and SVr4 specify that curses implements 'bool'.  However, C++ may also", " * implement it.  If so, we must use the C++ compiler's type to avoid conflict", " * with other interfaces.", " *", " * A further complication is that <stdbool.h> may declare 'bool' to be a", " * different type, such as an enum which is not necessarily compatible with", " * C++.  If we have <stdbool.h>, make 'bool' a macro, so users may #undef it.", " * Otherwise, let it remain a typedef to avoid conflicts with other #define's.", " * In either case, make a typedef for NCURSES_BOOL which can be used if needed", " * from either C or C++.", " */", "", "#undef TRUE", "#define TRUE    1", "", "#undef FALSE", "#define FALSE   0", "", "typedef unsigned char NCURSES_BOOL;", "", "#if defined(__cplusplus)\t/* __cplusplus, etc. */", "", "/* use the C++ compiler's bool type */", "#define NCURSES_BOOL bool", "", "#else\t\t\t/* c89, c99, etc. */", "", "#if NCURSES_ENABLE_STDBOOL_H", "#include <stdbool.h>", "/* use whatever the C compiler decides bool really is */", "#define NCURSES_BOOL bool", "#else", "/* there is no predefined bool - use our own */", "#undef bool", "#define bool NCURSES_BOOL", "#endif", "", "#endif /* !__cplusplus, etc. */", "", "#ifdef __cplusplus", 'extern "C" {', "#define NCURSES_CAST(type,value) static_cast<type>(value)", "#else", "#define NCURSES_CAST(type,value) (type)(value)", "#endif", "", "/*", " * X/Open attributes.  In the ncurses implementation, they are identical to the", " * A_ attributes.", " */", "#define WA_ATTRIBUTES\tA_ATTRIBUTES", "#define WA_NORMAL\tA_NORMAL", "#define WA_STANDOUT\tA_STANDOUT", "#define WA_UNDERLINE\tA_UNDERLINE", "#define WA_REVERSE\tA_REVERSE", "#define WA_BLINK\tA_BLINK", "#define WA_DIM\t\tA_DIM", "#define WA_BOLD\t\tA_BOLD", "#define WA_ALTCHARSET\tA_ALTCHARSET", "#define WA_INVIS\tA_INVIS", "#define WA_PROTECT\tA_PROTECT", "#define WA_HORIZONTAL\tA_HORIZONTAL", "#define WA_LEFT\t\tA_LEFT", "#define WA_LOW\t\tA_LOW", "#define WA_RIGHT\tA_RIGHT", "#define WA_TOP\t\tA_TOP", "#define WA_VERTICAL\tA_VERTICAL", "", "/* colors */", "#define COLOR_BLACK\t0", "#define COLOR_RED\t1", "#define COLOR_GREEN\t2", "#define COLOR_YELLOW\t3", "#define COLOR_BLUE\t4", "#define COLOR_MAGENTA\t5", "#define COLOR_CYAN\t6", "#define COLOR_WHITE\t7", "", "/* line graphics */", "", "#if 0 || 0", "NCURSES_WRAPPED_VAR(chtype*, acs_map);", "#define acs_map (_nc_acs_map())", "#else", "extern NCURSES_EXPORT_VAR(chtype) acs_map[];", "#endif", "", "#define NCURSES_ACS(c)\t(acs_map[NCURSES_CAST(unsigned char,c)])", "", "/* VT100 symbols begin here */", "#define ACS_ULCORNER\tNCURSES_ACS('l') /* upper left corner */", "#define ACS_LLCORNER\tNCURSES_ACS('m') /* lower left corner */", "#define ACS_URCORNER\tNCURSES_ACS('k') /* upper right corner */", "#define ACS_LRCORNER\tNCURSES_ACS('j') /* lower right corner */", "#define ACS_LTEE\tNCURSES_ACS('t') /* tee pointing right */", "#define ACS_RTEE\tNCURSES_ACS('u') /* tee pointing left */", "#define ACS_BTEE\tNCURSES_ACS('v') /* tee pointing up */", "#define ACS_TTEE\tNCURSES_ACS('w') /* tee pointing down */", "#define ACS_HLINE\tNCURSES_ACS('q') /* horizontal line */", "#define ACS_VLINE\tNCURSES_ACS('x') /* vertical line */", "#define ACS_PLUS\tNCURSES_ACS('n') /* large plus or crossover */", "#define ACS_S1\t\tNCURSES_ACS('o') /* scan line 1 */", "#define ACS_S9\t\tNCURSES_ACS('s') /* scan line 9 */", "#define ACS_DIAMOND\tNCURSES_ACS('`') /* diamond */", "#define ACS_CKBOARD\tNCURSES_ACS('a') /* checker board (stipple) */", "#define ACS_DEGREE\tNCURSES_ACS('f') /* degree symbol */", "#define ACS_PLMINUS\tNCURSES_ACS('g') /* plus/minus */", "#define ACS_BULLET\tNCURSES_ACS('~') /* bullet */", "/* Teletype 5410v1 symbols begin here */", "#define ACS_LARROW\tNCURSES_ACS(',') /* arrow pointing left */", "#define ACS_RARROW\tNCURSES_ACS('+') /* arrow pointing right */", "#define ACS_DARROW\tNCURSES_ACS('.') /* arrow pointing down */", "#define ACS_UARROW\tNCURSES_ACS('-') /* arrow pointing up */", "#define ACS_BOARD\tNCURSES_ACS('h') /* board of squares */", "#define ACS_LANTERN\tNCURSES_ACS('i') /* lantern symbol */", "#define ACS_BLOCK\tNCURSES_ACS('0') /* solid square block */", "/*", " * These aren't documented, but a lot of System Vs have them anyway", " * (you can spot pprryyzz{{||}} in a lot of AT&T terminfo strings).", " * The ACS_names may not match AT&T's, our source didn't know them.", " */", "#define ACS_S3\t\tNCURSES_ACS('p') /* scan line 3 */", "#define ACS_S7\t\tNCURSES_ACS('r') /* scan line 7 */", "#define ACS_LEQUAL\tNCURSES_ACS('y') /* less/equal */", "#define ACS_GEQUAL\tNCURSES_ACS('z') /* greater/equal */", "#define ACS_PI\t\tNCURSES_ACS('{') /* Pi */", "#define ACS_NEQUAL\tNCURSES_ACS('|') /* not equal */", "#define ACS_STERLING\tNCURSES_ACS('}') /* UK pound sign */", "", "/*", " * Line drawing ACS names are of the form ACS_trbl, where t is the top, r", " * is the right, b is the bottom, and l is the left.  t, r, b, and l might", " * be B (blank), S (single), D (double), or T (thick).  The subset defined", " * here only uses B and S.", " */", "#define ACS_BSSB\tACS_ULCORNER", "#define ACS_SSBB\tACS_LLCORNER", "#define ACS_BBSS\tACS_URCORNER", "#define ACS_SBBS\tACS_LRCORNER", "#define ACS_SBSS\tACS_RTEE", "#define ACS_SSSB\tACS_LTEE", "#define ACS_SSBS\tACS_BTEE", "#define ACS_BSSS\tACS_TTEE", "#define ACS_BSBS\tACS_HLINE", "#define ACS_SBSB\tACS_VLINE", "#define ACS_SSSS\tACS_PLUS", "", "#undef\tERR", "#define ERR     (-1)", "", "#undef\tOK", "#define OK      (0)", "", "/* values for the _flags member */", "#define _SUBWIN         0x01\t/* is this a sub-window? */", "#define _ENDLINE        0x02\t/* is the window flush right? */", "#define _FULLWIN        0x04\t/* is the window full-screen? */", "#define _SCROLLWIN      0x08\t/* bottom edge is at screen bottom? */", "#define _ISPAD\t        0x10\t/* is this window a pad? */", "#define _HASMOVED       0x20\t/* has cursor moved since last refresh? */", "#define _WRAPPED        0x40\t/* cursor was just wrappped */", "", "/*", " * this value is used in the firstchar and lastchar fields to mark", " * unchanged lines", " */", "#define _NOCHANGE       -1", "", "/*", " * this value is used in the oldindex field to mark lines created by insertions", " * and scrolls.", " */", "#define _NEWINDEX\t-1", "", "typedef struct screen  SCREEN;", "typedef struct _win_st WINDOW;", "", "typedef\tchtype\tattr_t;\t\t/* ...must be at least as wide as chtype */", "", "#ifdef _XOPEN_SOURCE_EXTENDED", "", "#if 0", "#ifdef mblen\t\t\t/* libutf8.h defines it w/o undefining first */", "#undef mblen", "#endif", "#include <libutf8.h>", "#endif", "", "#if 1", "#include <wchar.h>\t\t/* ...to get mbstate_t, etc. */", "#endif", "", "#if 0", "typedef unsigned short wchar_t1;", "#endif", "", "#if 0", "typedef unsigned int wint_t1;", "#endif", "", "#define CCHARW_MAX\t5", "typedef struct", "{", "    attr_t\tattr;", "    wchar_t\tchars[CCHARW_MAX];", "#if 0", "#undef NCURSES_EXT_COLORS", "#define NCURSES_EXT_COLORS 20081102", "    int\t\text_color;\t/* color pair, must be more than 16-bits */", "#endif", "}", "cchar_t;", "", "#endif /* _XOPEN_SOURCE_EXTENDED */", "", "#if !NCURSES_OPAQUE", "struct ldat;", "", "struct _win_st", "{", "\tNCURSES_SIZE_T _cury, _curx; /* current cursor position */", "", "\t/* window location and size */", "\tNCURSES_SIZE_T _maxy, _maxx; /* maximums of x and y, NOT window size */", "\tNCURSES_SIZE_T _begy, _begx; /* screen coords of upper-left-hand corner */", "", "\tshort   _flags;\t\t/* window state flags */", "", "\t/* attribute tracking */", "\tattr_t  _attrs;\t\t/* current attribute for non-space character */", "\tchtype  _bkgd;\t\t/* current background char/attribute pair */", "", "\t/* option values set by user */", "\tbool\t_notimeout;\t/* no time out on function-key entry? */", "\tbool\t_clear;\t\t/* consider all data in the window invalid? */", "\tbool\t_leaveok;\t/* OK to not reset cursor on exit? */", "\tbool\t_scroll;\t/* OK to scroll this window? */", "\tbool\t_idlok;\t\t/* OK to use insert/delete line? */", "\tbool\t_idcok;\t\t/* OK to use insert/delete char? */", "\tbool\t_immed;\t\t/* window in immed mode? (not yet used) */", "\tbool\t_sync;\t\t/* window in sync mode? */", "\tbool\t_use_keypad;\t/* process function keys into KEY_ symbols? */", "\tint\t_delay;\t\t/* 0 = nodelay, <0 = blocking, >0 = delay */", "", "\tstruct ldat *_line;\t/* the actual line data */", "", "\t/* global screen state */", "\tNCURSES_SIZE_T _regtop;\t/* top line of scrolling region */", "\tNCURSES_SIZE_T _regbottom; /* bottom line of scrolling region */", "", "\t/* these are used only if this is a sub-window */", "\tint\t_parx;\t\t/* x coordinate of this window in parent */", "\tint\t_pary;\t\t/* y coordinate of this window in parent */", "\tWINDOW\t*_parent;\t/* pointer to parent if a sub-window */", "", "\t/* these are used only if this is a pad */", "\tstruct pdat", "\t{", "\t    NCURSES_SIZE_T _pad_y,      _pad_x;", "\t    NCURSES_SIZE_T _pad_top,    _pad_left;", "\t    NCURSES_SIZE_T _pad_bottom, _pad_right;", "\t} _pad;", "", "\tNCURSES_SIZE_T _yoffset; /* real begy is _begy + _yoffset */", "", "#ifdef _XOPEN_SOURCE_EXTENDED", "\tcchar_t  _bkgrnd;\t/* current background char/attribute pair */", "#if 0", "\tint\t_color;\t\t/* current color-pair for non-space character */", "#endif", "#endif", "};", "#endif /* NCURSES_OPAQUE */", "", "/*", " * This is an extension to support events...", " */", "#if 1", "#ifdef NCURSES_WGETCH_EVENTS", "#if !defined(__BEOS__) || defined(__HAIKU__)", "   /* Fix _nc_timed_wait() on BEOS... */", "#  define NCURSES_EVENT_VERSION\t1", "#endif\t/* !defined(__BEOS__) */", "", "/*", " * Bits to set in _nc_event.data.flags", " */", "#  define _NC_EVENT_TIMEOUT_MSEC\t1", "#  define _NC_EVENT_FILE\t\t2", "#  define _NC_EVENT_FILE_READABLE\t2", "#  if 0\t\t\t\t\t/* Not supported yet... */", "#    define _NC_EVENT_FILE_WRITABLE\t4", "#    define _NC_EVENT_FILE_EXCEPTION\t8", "#  endif", "", "typedef struct", "{", "    int type;", "    union", "    {", "\tlong timeout_msec;\t/* _NC_EVENT_TIMEOUT_MSEC */", "\tstruct", "\t{", "\t    unsigned int flags;", "\t    int fd;", "\t    unsigned int result;", "\t} fev;\t\t\t\t/* _NC_EVENT_FILE */", "    } data;", "} _nc_event;", "", "typedef struct", "{", "    int count;", "    int result_flags;\t/* _NC_EVENT_TIMEOUT_MSEC or _NC_EVENT_FILE_READABLE */", "    _nc_event *events[1];", "} _nc_eventlist;", "", "extern NCURSES_EXPORT(int) wgetch_events(WINDOW *, _nc_eventlist *);\t/* experimental */", "extern NCURSES_EXPORT(int) wgetnstr_events(WINDOW *,char *,int,_nc_eventlist *);/* experimental */", "", "#endif /* NCURSES_WGETCH_EVENTS */", "#endif /* NCURSES_EXT_FUNCS */", "", "/*", " * GCC (and some other compilers) define '__attribute__'; we're using this", " * macro to alert the compiler to flag inconsistencies in printf/scanf-like", " * function calls.  Just in case '__attribute__' isn't defined, make a dummy.", " * Old versions of G++ do not accept it anyway, at least not consistently with", " * GCC.", " */", "#if !(defined(__GNUC__) || defined(__GNUG__) || defined(__attribute__))", "#define __attribute__(p) /* nothing */", "#endif", "", "/*", " * We cannot define these in ncurses_cfg.h, since they require parameters to be", " * passed (that is non-portable).  If you happen to be using gcc with warnings", " * enabled, define", " *\tGCC_PRINTF", " *\tGCC_SCANF", " * to improve checking of calls to printw(), etc.", " */", "#ifndef GCC_PRINTFLIKE", "#if defined(GCC_PRINTF) && !defined(printf)", "#define GCC_PRINTFLIKE(fmt,var) __attribute__((format(printf,fmt,var)))", "#else", "#define GCC_PRINTFLIKE(fmt,var) /*nothing*/", "#endif", "#endif", "", "#ifndef GCC_SCANFLIKE", "#if defined(GCC_SCANF) && !defined(scanf)", "#define GCC_SCANFLIKE(fmt,var)  __attribute__((format(scanf,fmt,var)))", "#else", "#define GCC_SCANFLIKE(fmt,var)  /*nothing*/", "#endif", "#endif", "", "#ifndef\tGCC_NORETURN", "#define\tGCC_NORETURN /* nothing */", "#endif", "", "#ifndef\tGCC_UNUSED", "#define\tGCC_UNUSED /* nothing */", "#endif", "", "/*", " * Function prototypes.  This is the complete X/Open Curses list of required", " * functions.  Those marked `generated' will have sources generated from the", " * macro definitions later in this file, in order to satisfy XPG4.2", " * requirements.", " */", "", "extern NCURSES_EXPORT(int) addch (const chtype);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) addchnstr (const chtype *, int);\t\t/* generated */", "extern NCURSES_EXPORT(int) addchstr (const chtype *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) addnstr (const char *, int);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) addstr (const char *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) attroff (NCURSES_ATTR_T);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) attron (NCURSES_ATTR_T);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) attrset (NCURSES_ATTR_T);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) attr_get (attr_t *, short *, void *);\t/* generated */", "extern NCURSES_EXPORT(int) attr_off (attr_t, void *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) attr_on (attr_t, void *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) attr_set (attr_t, short, void *);\t\t/* generated */", "extern NCURSES_EXPORT(int) baudrate (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) beep  (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) bkgd (chtype);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(void) bkgdset (chtype);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) border (chtype,chtype,chtype,chtype,chtype,chtype,chtype,chtype);\t/* generated */", "extern NCURSES_EXPORT(int) box (WINDOW *, chtype, chtype);\t\t/* generated */", "extern NCURSES_EXPORT(bool) can_change_color (void);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) cbreak (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) chgat (int, attr_t, short, const void *);\t/* generated */", "extern NCURSES_EXPORT(int) clear (void);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) clearok (WINDOW *,bool);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) clrtobot (void);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) clrtoeol (void);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) color_content (short,short*,short*,short*);\t/* implemented */", "extern NCURSES_EXPORT(int) color_set (short,void*);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) COLOR_PAIR (int);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) copywin (const WINDOW*,WINDOW*,int,int,int,int,int,int,int);\t/* implemented */", "extern NCURSES_EXPORT(int) curs_set (int);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) def_prog_mode (void);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) def_shell_mode (void);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) delay_output (int);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) delch (void);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(void) delscreen (SCREEN *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) delwin (WINDOW *);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) deleteln (void);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(WINDOW *) derwin (WINDOW *,int,int,int,int);\t/* implemented */", "extern NCURSES_EXPORT(int) doupdate (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(WINDOW *) dupwin (WINDOW *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) echo (void);\t\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) echochar (const chtype);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) erase (void);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) endwin (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(char) erasechar (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(void) filter (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) flash (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) flushinp (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(chtype) getbkgd (WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) getch (void);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) getnstr (char *, int);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) getstr (char *);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(WINDOW *) getwin (FILE *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) halfdelay (int);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(bool) has_colors (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(bool) has_ic (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(bool) has_il (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) hline (chtype, int);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(void) idcok (WINDOW *, bool);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) idlok (WINDOW *, bool);\t\t\t/* implemented */", "extern NCURSES_EXPORT(void) immedok (WINDOW *, bool);\t\t\t/* implemented */", "extern NCURSES_EXPORT(chtype) inch (void);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) inchnstr (chtype *, int);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) inchstr (chtype *);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(WINDOW *) initscr (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) init_color (short,short,short,short);\t/* implemented */", "extern NCURSES_EXPORT(int) init_pair (short,short,short);\t\t/* implemented */", "extern NCURSES_EXPORT(int) innstr (char *, int);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) insch (chtype);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) insdelln (int);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) insertln (void);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) insnstr (const char *, int);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) insstr (const char *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) instr (char *);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) intrflush (WINDOW *,bool);\t\t\t/* implemented */", "extern NCURSES_EXPORT(bool) isendwin (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(bool) is_linetouched (WINDOW *,int);\t\t/* implemented */", "extern NCURSES_EXPORT(bool) is_wintouched (WINDOW *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(NCURSES_CONST char *) keyname (int);\t\t/* implemented */", "extern NCURSES_EXPORT(int) keypad (WINDOW *,bool);\t\t\t/* implemented */", "extern NCURSES_EXPORT(char) killchar (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) leaveok (WINDOW *,bool);\t\t\t/* implemented */", "extern NCURSES_EXPORT(char *) longname (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) meta (WINDOW *,bool);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) move (int, int);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) mvaddch (int, int, const chtype);\t\t/* generated */", "extern NCURSES_EXPORT(int) mvaddchnstr (int, int, const chtype *, int);\t/* generated */", "extern NCURSES_EXPORT(int) mvaddchstr (int, int, const chtype *);\t/* generated */", "extern NCURSES_EXPORT(int) mvaddnstr (int, int, const char *, int);\t/* generated */", "extern NCURSES_EXPORT(int) mvaddstr (int, int, const char *);\t\t/* generated */", "extern NCURSES_EXPORT(int) mvchgat (int, int, int, attr_t, short, const void *);\t/* generated */", "extern NCURSES_EXPORT(int) mvcur (int,int,int,int);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) mvdelch (int, int);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) mvderwin (WINDOW *, int, int);\t\t/* implemented */", "extern NCURSES_EXPORT(int) mvgetch (int, int);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) mvgetnstr (int, int, char *, int);\t\t/* generated */", "extern NCURSES_EXPORT(int) mvgetstr (int, int, char *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) mvhline (int, int, chtype, int);\t\t/* generated */", "extern NCURSES_EXPORT(chtype) mvinch (int, int);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) mvinchnstr (int, int, chtype *, int);\t/* generated */", "extern NCURSES_EXPORT(int) mvinchstr (int, int, chtype *);\t\t/* generated */", "extern NCURSES_EXPORT(int) mvinnstr (int, int, char *, int);\t\t/* generated */", "extern NCURSES_EXPORT(int) mvinsch (int, int, chtype);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) mvinsnstr (int, int, const char *, int);\t/* generated */", "extern NCURSES_EXPORT(int) mvinsstr (int, int, const char *);\t\t/* generated */", "extern NCURSES_EXPORT(int) mvinstr (int, int, char *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) mvprintw (int,int, const char *,...)\t\t/* implemented */", "\t\tGCC_PRINTFLIKE(3,4);", "extern NCURSES_EXPORT(int) mvscanw (int,int, NCURSES_CONST char *,...)\t/* implemented */", "\t\tGCC_SCANFLIKE(3,4);", "extern NCURSES_EXPORT(int) mvvline (int, int, chtype, int);\t\t/* generated */", "extern NCURSES_EXPORT(int) mvwaddch (WINDOW *, int, int, const chtype);\t/* generated */", "extern NCURSES_EXPORT(int) mvwaddchnstr (WINDOW *, int, int, const chtype *, int);/* generated */", "extern NCURSES_EXPORT(int) mvwaddchstr (WINDOW *, int, int, const chtype *);\t/* generated */", "extern NCURSES_EXPORT(int) mvwaddnstr (WINDOW *, int, int, const char *, int);\t/* generated */", "extern NCURSES_EXPORT(int) mvwaddstr (WINDOW *, int, int, const char *);\t/* generated */", "extern NCURSES_EXPORT(int) mvwchgat (WINDOW *, int, int, int, attr_t, short, const void *);/* generated */", "extern NCURSES_EXPORT(int) mvwdelch (WINDOW *, int, int);\t\t/* generated */", "extern NCURSES_EXPORT(int) mvwgetch (WINDOW *, int, int);\t\t/* generated */", "extern NCURSES_EXPORT(int) mvwgetnstr (WINDOW *, int, int, char *, int);\t/* generated */", "extern NCURSES_EXPORT(int) mvwgetstr (WINDOW *, int, int, char *);\t/* generated */", "extern NCURSES_EXPORT(int) mvwhline (WINDOW *, int, int, chtype, int);\t/* generated */", "extern NCURSES_EXPORT(int) mvwin (WINDOW *,int,int);\t\t\t/* implemented */", "extern NCURSES_EXPORT(chtype) mvwinch (WINDOW *, int, int);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) mvwinchnstr (WINDOW *, int, int, chtype *, int);\t/* generated */", "extern NCURSES_EXPORT(int) mvwinchstr (WINDOW *, int, int, chtype *);\t\t/* generated */", "extern NCURSES_EXPORT(int) mvwinnstr (WINDOW *, int, int, char *, int);\t\t/* generated */", "extern NCURSES_EXPORT(int) mvwinsch (WINDOW *, int, int, chtype);\t\t/* generated */", "extern NCURSES_EXPORT(int) mvwinsnstr (WINDOW *, int, int, const char *, int);\t/* generated */", "extern NCURSES_EXPORT(int) mvwinsstr (WINDOW *, int, int, const char *);\t\t/* generated */", "extern NCURSES_EXPORT(int) mvwinstr (WINDOW *, int, int, char *);\t\t/* generated */", "extern NCURSES_EXPORT(int) mvwprintw (WINDOW*,int,int, const char *,...)\t/* implemented */", "\t\tGCC_PRINTFLIKE(4,5);", "extern NCURSES_EXPORT(int) mvwscanw (WINDOW *,int,int, NCURSES_CONST char *,...)\t/* implemented */", "\t\tGCC_SCANFLIKE(4,5);", "extern NCURSES_EXPORT(int) mvwvline (WINDOW *,int, int, chtype, int);\t/* generated */", "extern NCURSES_EXPORT(int) napms (int);\t\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(WINDOW *) newpad (int,int);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(SCREEN *) newterm (NCURSES_CONST char *,FILE *,FILE *);\t/* implemented */", "extern NCURSES_EXPORT(WINDOW *) newwin (int,int,int,int);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) nl (void);\t\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) nocbreak (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) nodelay (WINDOW *,bool);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) noecho (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) nonl (void);\t\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(void) noqiflush (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) noraw (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) notimeout (WINDOW *,bool);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) overlay (const WINDOW*,WINDOW *);\t\t/* implemented */", "extern NCURSES_EXPORT(int) overwrite (const WINDOW*,WINDOW *);\t\t/* implemented */", "extern NCURSES_EXPORT(int) pair_content (short,short*,short*);\t\t/* implemented */", "extern NCURSES_EXPORT(int) PAIR_NUMBER (int);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) pechochar (WINDOW *, const chtype);\t\t/* implemented */", "extern NCURSES_EXPORT(int) pnoutrefresh (WINDOW*,int,int,int,int,int,int);/* implemented */", "extern NCURSES_EXPORT(int) prefresh (WINDOW *,int,int,int,int,int,int);\t/* implemented */", "extern NCURSES_EXPORT(int) printw (const char *,...)\t\t\t/* implemented */", "\t\tGCC_PRINTFLIKE(1,2);", "extern NCURSES_EXPORT(int) putwin (WINDOW *, FILE *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(void) qiflush (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) raw (void);\t\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) redrawwin (WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) refresh (void);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) resetty (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) reset_prog_mode (void);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) reset_shell_mode (void);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) ripoffline (int, int (*)(WINDOW *, int));\t/* implemented */", "extern NCURSES_EXPORT(int) savetty (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) scanw (NCURSES_CONST char *,...)\t\t/* implemented */", "\t\tGCC_SCANFLIKE(1,2);", "extern NCURSES_EXPORT(int) scr_dump (const char *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) scr_init (const char *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) scrl (int);\t\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) scroll (WINDOW *);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) scrollok (WINDOW *,bool);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) scr_restore (const char *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) scr_set (const char *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) setscrreg (int,int);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(SCREEN *) set_term (SCREEN *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) slk_attroff (const chtype);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) slk_attr_off (const attr_t, void *);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) slk_attron (const chtype);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) slk_attr_on (attr_t,void*);\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) slk_attrset (const chtype);\t\t\t/* implemented */", "extern NCURSES_EXPORT(attr_t) slk_attr (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) slk_attr_set (const attr_t,short,void*);\t/* implemented */", "extern NCURSES_EXPORT(int) slk_clear (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) slk_color (short);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) slk_init (int);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(char *) slk_label (int);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) slk_noutrefresh (void);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) slk_refresh (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) slk_restore (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) slk_set (int,const char *,int);\t\t/* implemented */", "extern NCURSES_EXPORT(int) slk_touch (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) standout (void);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) standend (void);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) start_color (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(WINDOW *) subpad (WINDOW *, int, int, int, int);\t/* implemented */", "extern NCURSES_EXPORT(WINDOW *) subwin (WINDOW *, int, int, int, int);\t/* implemented */", "extern NCURSES_EXPORT(int) syncok (WINDOW *, bool);\t\t\t/* implemented */", "extern NCURSES_EXPORT(chtype) termattrs (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(char *) termname (void);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(void) timeout (int);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) touchline (WINDOW *, int, int);\t\t/* generated */", "extern NCURSES_EXPORT(int) touchwin (WINDOW *);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) typeahead (int);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) ungetch (int);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) untouchwin (WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(void) use_env (bool);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) vidattr (chtype);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) vidputs (chtype, int (*)(int));\t\t/* implemented */", "extern NCURSES_EXPORT(int) vline (chtype, int);\t\t\t\t/* generated */", "extern NCURSES_EXPORT(int) vwprintw (WINDOW *, const char *,va_list);\t/* implemented */", "extern NCURSES_EXPORT(int) vw_printw (WINDOW *, const char *,va_list);\t/* generated */", "extern NCURSES_EXPORT(int) vwscanw (WINDOW *, NCURSES_CONST char *,va_list);\t/* implemented */", "extern NCURSES_EXPORT(int) vw_scanw (WINDOW *, NCURSES_CONST char *,va_list);\t/* generated */", "extern NCURSES_EXPORT(int) waddch (WINDOW *, const chtype);\t\t/* implemented */", "extern NCURSES_EXPORT(int) waddchnstr (WINDOW *,const chtype *,int);\t/* implemented */", "extern NCURSES_EXPORT(int) waddchstr (WINDOW *,const chtype *);\t\t/* generated */", "extern NCURSES_EXPORT(int) waddnstr (WINDOW *,const char *,int);\t/* implemented */", "extern NCURSES_EXPORT(int) waddstr (WINDOW *,const char *);\t\t/* generated */", "extern NCURSES_EXPORT(int) wattron (WINDOW *, int);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) wattroff (WINDOW *, int);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) wattrset (WINDOW *, int);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) wattr_get (WINDOW *, attr_t *, short *, void *);\t/* generated */", "extern NCURSES_EXPORT(int) wattr_on (WINDOW *, attr_t, void *);\t\t/* implemented */", "extern NCURSES_EXPORT(int) wattr_off (WINDOW *, attr_t, void *);\t/* implemented */", "extern NCURSES_EXPORT(int) wattr_set (WINDOW *, attr_t, short, void *);\t/* generated */", "extern NCURSES_EXPORT(int) wbkgd (WINDOW *, chtype);\t\t\t/* implemented */", "extern NCURSES_EXPORT(void) wbkgdset (WINDOW *,chtype);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) wborder (WINDOW *,chtype,chtype,chtype,chtype,chtype,chtype,chtype,chtype);\t/* implemented */", "extern NCURSES_EXPORT(int) wchgat (WINDOW *, int, attr_t, short, const void *);/* implemented */", "extern NCURSES_EXPORT(int) wclear (WINDOW *);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) wclrtobot (WINDOW *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) wclrtoeol (WINDOW *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) wcolor_set (WINDOW*,short,void*);\t\t/* implemented */", "extern NCURSES_EXPORT(void) wcursyncup (WINDOW *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) wdelch (WINDOW *);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) wdeleteln (WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) wechochar (WINDOW *, const chtype);\t\t/* implemented */", "extern NCURSES_EXPORT(int) werase (WINDOW *);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) wgetch (WINDOW *);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) wgetnstr (WINDOW *,char *,int);\t\t/* implemented */", "extern NCURSES_EXPORT(int) wgetstr (WINDOW *, char *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) whline (WINDOW *, chtype, int);\t\t/* implemented */", "extern NCURSES_EXPORT(chtype) winch (WINDOW *);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) winchnstr (WINDOW *, chtype *, int);\t\t/* implemented */", "extern NCURSES_EXPORT(int) winchstr (WINDOW *, chtype *);\t\t/* generated */", "extern NCURSES_EXPORT(int) winnstr (WINDOW *, char *, int);\t\t/* implemented */", "extern NCURSES_EXPORT(int) winsch (WINDOW *, chtype);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) winsdelln (WINDOW *,int);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) winsertln (WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) winsnstr (WINDOW *, const char *,int);\t/* implemented */", "extern NCURSES_EXPORT(int) winsstr (WINDOW *, const char *);\t\t/* generated */", "extern NCURSES_EXPORT(int) winstr (WINDOW *, char *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) wmove (WINDOW *,int,int);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) wnoutrefresh (WINDOW *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) wprintw (WINDOW *, const char *,...)\t\t/* implemented */", "\t\tGCC_PRINTFLIKE(2,3);", "extern NCURSES_EXPORT(int) wredrawln (WINDOW *,int,int);\t\t/* implemented */", "extern NCURSES_EXPORT(int) wrefresh (WINDOW *);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) wscanw (WINDOW *, NCURSES_CONST char *,...)\t/* implemented */", "\t\tGCC_SCANFLIKE(2,3);", "extern NCURSES_EXPORT(int) wscrl (WINDOW *,int);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) wsetscrreg (WINDOW *,int,int);\t\t/* implemented */", "extern NCURSES_EXPORT(int) wstandout (WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) wstandend (WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(void) wsyncdown (WINDOW *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(void) wsyncup (WINDOW *);\t\t\t\t/* implemented */", "extern NCURSES_EXPORT(void) wtimeout (WINDOW *,int);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) wtouchln (WINDOW *,int,int,int);\t\t/* implemented */", "extern NCURSES_EXPORT(int) wvline (WINDOW *,chtype,int);\t\t/* implemented */", "", "/*", " * These are also declared in <term.h>:", " */", "extern NCURSES_EXPORT(int) tigetflag (NCURSES_CONST char *);\t\t/* implemented */", "extern NCURSES_EXPORT(int) tigetnum (NCURSES_CONST char *);\t\t/* implemented */", "extern NCURSES_EXPORT(char *) tigetstr (NCURSES_CONST char *);\t\t/* implemented */", "extern NCURSES_EXPORT(int) putp (const char *);\t\t\t\t/* implemented */", "", "#if NCURSES_TPARM_VARARGS", "extern NCURSES_EXPORT(char *) tparm (NCURSES_CONST char *, ...);\t/* special */", "#else", "extern NCURSES_EXPORT(char *) tparm (NCURSES_CONST char *, long,long,long,long,long,long,long,long,long);\t/* special */", "extern NCURSES_EXPORT(char *) tparm_varargs (NCURSES_CONST char *, ...);\t/* special */", "#endif", "", "/*", " * These functions are not in X/Open, but we use them in macro definitions:", " */", "extern NCURSES_EXPORT(int) getattrs (const WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) getcurx (const WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) getcury (const WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) getbegx (const WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) getbegy (const WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) getmaxx (const WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) getmaxy (const WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) getparx (const WINDOW *);\t\t\t/* generated */", "extern NCURSES_EXPORT(int) getpary (const WINDOW *);\t\t\t/* generated */", "", "/*", " * vid_attr() was implemented originally based on a draft of X/Open curses.", " */", "#ifndef _XOPEN_SOURCE_EXTENDED", "#define vid_attr(a,pair,opts) vidattr(a)", "#endif", "", "/*", " * These functions are extensions - not in X/Open Curses.", " */", "#if 1", "#undef  NCURSES_EXT_FUNCS", "#define NCURSES_EXT_FUNCS 20081102", "typedef int (*NCURSES_WINDOW_CB)(WINDOW *, void *);", "typedef int (*NCURSES_SCREEN_CB)(SCREEN *, void *);", "extern NCURSES_EXPORT(bool) is_term_resized (int, int);", "extern NCURSES_EXPORT(char *) keybound (int, int);", "extern NCURSES_EXPORT(const char *) curses_version (void);", "extern NCURSES_EXPORT(int) assume_default_colors (int, int);", "extern NCURSES_EXPORT(int) define_key (const char *, int);", "extern NCURSES_EXPORT(int) key_defined (const char *);", "extern NCURSES_EXPORT(int) keyok (int, bool);", "extern NCURSES_EXPORT(int) resize_term (int, int);", "extern NCURSES_EXPORT(int) resizeterm (int, int);", "extern NCURSES_EXPORT(int) set_escdelay (int);", "extern NCURSES_EXPORT(int) set_tabsize (int);", "extern NCURSES_EXPORT(int) use_default_colors (void);", "extern NCURSES_EXPORT(int) use_extended_names (bool);", "extern NCURSES_EXPORT(int) use_legacy_coding (int);", "extern NCURSES_EXPORT(int) use_screen (SCREEN *, NCURSES_SCREEN_CB, void *);", "extern NCURSES_EXPORT(int) use_window (WINDOW *, NCURSES_WINDOW_CB, void *);", "extern NCURSES_EXPORT(int) wresize (WINDOW *, int, int);", "extern NCURSES_EXPORT(void) nofilter(void);", "", "/*", " * These extensions provide access to information stored in the WINDOW even", " * when NCURSES_OPAQUE is set:", " */", "extern NCURSES_EXPORT(WINDOW *) wgetparent (const WINDOW *);\t/* generated */", "extern NCURSES_EXPORT(bool) is_cleared (const WINDOW *);\t/* generated */", "extern NCURSES_EXPORT(bool) is_idcok (const WINDOW *);\t\t/* generated */", "extern NCURSES_EXPORT(bool) is_idlok (const WINDOW *);\t\t/* generated */", "extern NCURSES_EXPORT(bool) is_immedok (const WINDOW *);\t/* generated */", "extern NCURSES_EXPORT(bool) is_keypad (const WINDOW *);\t\t/* generated */", "extern NCURSES_EXPORT(bool) is_leaveok (const WINDOW *);\t/* generated */", "extern NCURSES_EXPORT(bool) is_nodelay (const WINDOW *);\t/* generated */", "extern NCURSES_EXPORT(bool) is_notimeout (const WINDOW *);\t/* generated */", "extern NCURSES_EXPORT(bool) is_scrollok (const WINDOW *);\t/* generated */", "extern NCURSES_EXPORT(bool) is_syncok (const WINDOW *);\t\t/* generated */", "extern NCURSES_EXPORT(int) wgetscrreg (const WINDOW *, int *, int *); /* generated */", "", "#else", "#define curses_version() NCURSES_VERSION", "#endif", "", "/* attributes */", "", "#define NCURSES_ATTR_SHIFT       8", "#define NCURSES_BITS(mask,shift) ((mask) << ((shift) + NCURSES_ATTR_SHIFT))", "", "#define A_NORMAL\t(1U - 1U)", "#define A_ATTRIBUTES\tNCURSES_BITS(~(1U - 1U),0)", "#define A_CHARTEXT\t(NCURSES_BITS(1U,0) - 1U)", "#define A_COLOR\t\tNCURSES_BITS(((1U) << 8) - 1U,0)", "#define A_STANDOUT\tNCURSES_BITS(1U,8)", "#define A_UNDERLINE\tNCURSES_BITS(1U,9)", "#define A_REVERSE\tNCURSES_BITS(1U,10)", "#define A_BLINK\t\tNCURSES_BITS(1U,11)", "#define A_DIM\t\tNCURSES_BITS(1U,12)", "#define A_BOLD\t\tNCURSES_BITS(1U,13)", "#define A_ALTCHARSET\tNCURSES_BITS(1U,14)", "#define A_INVIS\t\tNCURSES_BITS(1U,15)", "#define A_PROTECT\tNCURSES_BITS(1U,16)", "#define A_HORIZONTAL\tNCURSES_BITS(1U,17)", "#define A_LEFT\t\tNCURSES_BITS(1U,18)", "#define A_LOW\t\tNCURSES_BITS(1U,19)", "#define A_RIGHT\t\tNCURSES_BITS(1U,20)", "#define A_TOP\t\tNCURSES_BITS(1U,21)", "#define A_VERTICAL\tNCURSES_BITS(1U,22)", "", "/*", " * Most of the pseudo functions are macros that either provide compatibility", " * with older versions of curses, or provide inline functionality to improve", " * performance.", " */", "", "/*", " * These pseudo functions are always implemented as macros:", " */", "", "#define getyx(win,y,x)   \t(y = getcury(win), x = getcurx(win))", "#define getbegyx(win,y,x)\t(y = getbegy(win), x = getbegx(win))", "#define getmaxyx(win,y,x)\t(y = getmaxy(win), x = getmaxx(win))", "#define getparyx(win,y,x)\t(y = getpary(win), x = getparx(win))", "", "#define getsyx(y,x) do { if (newscr) { \\", "\t\t\t     if (is_leaveok(newscr)) \\", "\t\t\t\t(y) = (x) = -1; \\", "\t\t\t     else \\", "\t\t\t\t getyx(newscr,(y), (x)); \\", "\t\t\t} \\", "\t\t    } while(0)", "", "#define setsyx(y,x) do { if (newscr) { \\", "\t\t\t    if ((y) == -1 && (x) == -1) \\", "\t\t\t\tleaveok(newscr, TRUE); \\", "\t\t\t    else { \\", "\t\t\t\tleaveok(newscr, FALSE); \\", "\t\t\t\twmove(newscr, (y), (x)); \\", "\t\t\t    } \\", "\t\t\t} \\", "\t\t    } while(0)", "", "#ifndef NCURSES_NOMACROS", "", "/*", " * These miscellaneous pseudo functions are provided for compatibility:", " */", "", "#define wgetstr(w, s)\t\twgetnstr(w, s, -1)", "#define getnstr(s, n)\t\twgetnstr(stdscr, s, n)", "", "#define setterm(term)\t\tsetupterm(term, 1, (int *)0)", "", "#define fixterm()\t\treset_prog_mode()", "#define resetterm()\t\treset_shell_mode()", "#define saveterm()\t\tdef_prog_mode()", "#define crmode()\t\tcbreak()", "#define nocrmode()\t\tnocbreak()", "#define gettmode()", "", "/* It seems older SYSV curses versions define these */", "#if !NCURSES_OPAQUE", "#define getattrs(win)\t\t((win) ? (win)->_attrs : A_NORMAL)", "#define getcurx(win)\t\t((win) ? (win)->_curx : ERR)", "#define getcury(win)\t\t((win) ? (win)->_cury : ERR)", "#define getbegx(win)\t\t((win) ? (win)->_begx : ERR)", "#define getbegy(win)\t\t((win) ? (win)->_begy : ERR)", "#define getmaxx(win)\t\t((win) ? ((win)->_maxx + 1) : ERR)", "#define getmaxy(win)\t\t((win) ? ((win)->_maxy + 1) : ERR)", "#define getparx(win)\t\t((win) ? (win)->_parx : ERR)", "#define getpary(win)\t\t((win) ? (win)->_pary : ERR)", "#endif /* NCURSES_OPAQUE */", "", "#define wstandout(win)      \t(wattrset(win,A_STANDOUT))", "#define wstandend(win)      \t(wattrset(win,A_NORMAL))", "", "#define wattron(win,at)\t\twattr_on(win, NCURSES_CAST(attr_t, at), NULL)", "#define wattroff(win,at)\twattr_off(win, NCURSES_CAST(attr_t, at), NULL)", "", "#if !NCURSES_OPAQUE", "#if defined(_XOPEN_SOURCE_EXTENDED) && 0", "#define wattrset(win,at)\t((win)->_color = PAIR_NUMBER(at), \\", "\t\t\t\t (win)->_attrs = (at))", "#else", "#define wattrset(win,at)\t((win)->_attrs = (at))", "#endif", "#endif /* NCURSES_OPAQUE */", "", "#define scroll(win)\t\twscrl(win,1)", "", "#define touchwin(win)\t\twtouchln((win), 0, getmaxy(win), 1)", "#define touchline(win, s, c)\twtouchln((win), s, c, 1)", "#define untouchwin(win)\t\twtouchln((win), 0, getmaxy(win), 0)", "", "#define box(win, v, h)\t\twborder(win, v, v, h, h, 0, 0, 0, 0)", "#define border(ls, rs, ts, bs, tl, tr, bl, br)\twborder(stdscr, ls, rs, ts, bs, tl, tr, bl, br)", "#define hline(ch, n)\t\twhline(stdscr, ch, n)", "#define vline(ch, n)\t\twvline(stdscr, ch, n)", "", "#define winstr(w, s)\t\twinnstr(w, s, -1)", "#define winchstr(w, s)\t\twinchnstr(w, s, -1)", "#define winsstr(w, s)\t\twinsnstr(w, s, -1)", "", "#if !NCURSES_OPAQUE", "#define redrawwin(win)\t\twredrawln(win, 0, (win)->_maxy+1)", "#endif /* NCURSES_OPAQUE */", "", "#define waddstr(win,str)\twaddnstr(win,str,-1)", "#define waddchstr(win,str)\twaddchnstr(win,str,-1)", "", "/*", " * These apply to the first 256 color pairs.", " */", "#define COLOR_PAIR(n)\tNCURSES_BITS(n, 0)", "#define PAIR_NUMBER(a)\t(NCURSES_CAST(int,(((a) & A_COLOR) >> NCURSES_ATTR_SHIFT)))", "", "/*", " * pseudo functions for standard screen", " */", "", "#define addch(ch)\t\twaddch(stdscr,ch)", "#define addchnstr(str,n)\twaddchnstr(stdscr,str,n)", "#define addchstr(str)\t\twaddchstr(stdscr,str)", "#define addnstr(str,n)\t\twaddnstr(stdscr,str,n)", "#define addstr(str)\t\twaddnstr(stdscr,str,-1)", "#define attroff(at)\t\twattroff(stdscr,at)", "#define attron(at)\t\twattron(stdscr,at)", "#define attrset(at)\t\twattrset(stdscr,at)", "#define attr_get(ap,cp,o)\twattr_get(stdscr,ap,cp,o)", "#define attr_off(a,o)\t\twattr_off(stdscr,a,o)", "#define attr_on(a,o)\t\twattr_on(stdscr,a,o)", "#define attr_set(a,c,o)\t\twattr_set(stdscr,a,c,o)", "#define bkgd(ch)\t\twbkgd(stdscr,ch)", "#define bkgdset(ch)\t\twbkgdset(stdscr,ch)", "#define chgat(n,a,c,o)\t\twchgat(stdscr,n,a,c,o)", "#define clear()\t\t\twclear(stdscr)", "#define clrtobot()\t\twclrtobot(stdscr)", "#define clrtoeol()\t\twclrtoeol(stdscr)", "#define color_set(c,o)\t\twcolor_set(stdscr,c,o)", "#define delch()\t\t\twdelch(stdscr)", "#define deleteln()\t\twinsdelln(stdscr,-1)", "#define echochar(c)\t\twechochar(stdscr,c)", "#define erase()\t\t\twerase(stdscr)", "#define getch()\t\t\twgetch(stdscr)", "#define getstr(str)\t\twgetstr(stdscr,str)", "#define inch()\t\t\twinch(stdscr)", "#define inchnstr(s,n)\t\twinchnstr(stdscr,s,n)", "#define inchstr(s)\t\twinchstr(stdscr,s)", "#define innstr(s,n)\t\twinnstr(stdscr,s,n)", "#define insch(c)\t\twinsch(stdscr,c)", "#define insdelln(n)\t\twinsdelln(stdscr,n)", "#define insertln()\t\twinsdelln(stdscr,1)", "#define insnstr(s,n)\t\twinsnstr(stdscr,s,n)", "#define insstr(s)\t\twinsstr(stdscr,s)", "#define instr(s)\t\twinstr(stdscr,s)", "#define move(y,x)\t\twmove(stdscr,y,x)", "#define refresh()\t\twrefresh(stdscr)", "#define scrl(n)\t\t\twscrl(stdscr,n)", "#define setscrreg(t,b)\t\twsetscrreg(stdscr,t,b)", "#define standend()\t\twstandend(stdscr)", "#define standout()\t\twstandout(stdscr)", "#define timeout(delay)\t\twtimeout(stdscr,delay)", "#define wdeleteln(win)\t\twinsdelln(win,-1)", "#define winsertln(win)\t\twinsdelln(win,1)", "", "/*", " * mv functions", " */", "", "#define mvwaddch(win,y,x,ch)\t\t(wmove(win,y,x) == ERR ? ERR : waddch(win,ch))", "#define mvwaddchnstr(win,y,x,str,n)\t(wmove(win,y,x) == ERR ? ERR : waddchnstr(win,str,n))", "#define mvwaddchstr(win,y,x,str)\t(wmove(win,y,x) == ERR ? ERR : waddchnstr(win,str,-1))", "#define mvwaddnstr(win,y,x,str,n)\t(wmove(win,y,x) == ERR ? ERR : waddnstr(win,str,n))", "#define mvwaddstr(win,y,x,str)\t\t(wmove(win,y,x) == ERR ? ERR : waddnstr(win,str,-1))", "#define mvwdelch(win,y,x)\t\t(wmove(win,y,x) == ERR ? ERR : wdelch(win))", "#define mvwchgat(win,y,x,n,a,c,o)\t(wmove(win,y,x) == ERR ? ERR : wchgat(win,n,a,c,o))", "#define mvwgetch(win,y,x)\t\t(wmove(win,y,x) == ERR ? ERR : wgetch(win))", "#define mvwgetnstr(win,y,x,str,n)\t(wmove(win,y,x) == ERR ? ERR : wgetnstr(win,str,n))", "#define mvwgetstr(win,y,x,str)\t\t(wmove(win,y,x) == ERR ? ERR : wgetstr(win,str))", "#define mvwhline(win,y,x,c,n)\t\t(wmove(win,y,x) == ERR ? ERR : whline(win,c,n))", "#define mvwinch(win,y,x)\t\t(wmove(win,y,x) == ERR ? NCURSES_CAST(chtype, ERR) : winch(win))", "#define mvwinchnstr(win,y,x,s,n)\t(wmove(win,y,x) == ERR ? ERR : winchnstr(win,s,n))", "#define mvwinchstr(win,y,x,s)\t\t(wmove(win,y,x) == ERR ? ERR : winchstr(win,s))", "#define mvwinnstr(win,y,x,s,n)\t\t(wmove(win,y,x) == ERR ? ERR : winnstr(win,s,n))", "#define mvwinsch(win,y,x,c)\t\t(wmove(win,y,x) == ERR ? ERR : winsch(win,c))", "#define mvwinsnstr(win,y,x,s,n)\t\t(wmove(win,y,x) == ERR ? ERR : winsnstr(win,s,n))", "#define mvwinsstr(win,y,x,s)\t\t(wmove(win,y,x) == ERR ? ERR : winsstr(win,s))", "#define mvwinstr(win,y,x,s)\t\t(wmove(win,y,x) == ERR ? ERR : winstr(win,s))", "#define mvwvline(win,y,x,c,n)\t\t(wmove(win,y,x) == ERR ? ERR : wvline(win,c,n))", "", "#define mvaddch(y,x,ch)\t\t\tmvwaddch(stdscr,y,x,ch)", "#define mvaddchnstr(y,x,str,n)\t\tmvwaddchnstr(stdscr,y,x,str,n)", "#define mvaddchstr(y,x,str)\t\tmvwaddchstr(stdscr,y,x,str)", "#define mvaddnstr(y,x,str,n)\t\tmvwaddnstr(stdscr,y,x,str,n)", "#define mvaddstr(y,x,str)\t\tmvwaddstr(stdscr,y,x,str)", "#define mvchgat(y,x,n,a,c,o)\t\tmvwchgat(stdscr,y,x,n,a,c,o)", "#define mvdelch(y,x)\t\t\tmvwdelch(stdscr,y,x)", "#define mvgetch(y,x)\t\t\tmvwgetch(stdscr,y,x)", "#define mvgetnstr(y,x,str,n)\t\tmvwgetnstr(stdscr,y,x,str,n)", "#define mvgetstr(y,x,str)\t\tmvwgetstr(stdscr,y,x,str)", "#define mvhline(y,x,c,n)\t\tmvwhline(stdscr,y,x,c,n)", "#define mvinch(y,x)\t\t\tmvwinch(stdscr,y,x)", "#define mvinchnstr(y,x,s,n)\t\tmvwinchnstr(stdscr,y,x,s,n)", "#define mvinchstr(y,x,s)\t\tmvwinchstr(stdscr,y,x,s)", "#define mvinnstr(y,x,s,n)\t\tmvwinnstr(stdscr,y,x,s,n)", "#define mvinsch(y,x,c)\t\t\tmvwinsch(stdscr,y,x,c)", "#define mvinsnstr(y,x,s,n)\t\tmvwinsnstr(stdscr,y,x,s,n)", "#define mvinsstr(y,x,s)\t\t\tmvwinsstr(stdscr,y,x,s)", "#define mvinstr(y,x,s)\t\t\tmvwinstr(stdscr,y,x,s)", "#define mvvline(y,x,c,n)\t\tmvwvline(stdscr,y,x,c,n)", "", "/*", " * Some wide-character functions can be implemented without the extensions.", " */", "#if !NCURSES_OPAQUE", "#define getbkgd(win)                    ((win)->_bkgd)", "#endif /* NCURSES_OPAQUE */", "", "#define slk_attr_off(a,v)\t\t((v) ? ERR : slk_attroff(a))", "#define slk_attr_on(a,v)\t\t((v) ? ERR : slk_attron(a))", "", "#if !NCURSES_OPAQUE", "#if defined(_XOPEN_SOURCE_EXTENDED) && 0", "#define wattr_set(win,a,p,opts)\t\t((win)->_attrs = ((a) & ~A_COLOR), \\", "\t\t\t\t\t (win)->_color = (p), \\", "\t\t\t\t\t OK)", "#define wattr_get(win,a,p,opts)\t\t((void)((a) != (void *)0 && (*(a) = (win)->_attrs)), \\", "\t\t\t\t\t (void)((p) != (void *)0 && (*(p) = (win)->_color)), \\", "\t\t\t\t\t OK)", "#else", "#define wattr_set(win,a,p,opts)\t\t((win)->_attrs = (((a) & ~A_COLOR) | COLOR_PAIR(p)), OK)", "#define wattr_get(win,a,p,opts)\t\t((void)((a) != (void *)0 && (*(a) = (win)->_attrs)), \\", "\t\t\t\t\t (void)((p) != (void *)0 && (*(p) = PAIR_NUMBER((win)->_attrs))), \\", "\t\t\t\t\t OK)", "#endif", "#endif /* NCURSES_OPAQUE */", "", "/*", " * X/Open curses deprecates SVr4 vwprintw/vwscanw, which are supposed to use", " * varargs.h.  It adds new calls vw_printw/vw_scanw, which are supposed to", " * use POSIX stdarg.h.  The ncurses versions of vwprintw/vwscanw already", " * use stdarg.h, so...", " */", "#define vw_printw\t\tvwprintw", "#define vw_scanw\t\tvwscanw", "", "/*", " * Export fallback function for use in C++ binding.", " */", "#if !1", "#define vsscanf(a,b,c) _nc_vsscanf(a,b,c)", "NCURSES_EXPORT(int) vsscanf(const char *, const char *, va_list);", "#endif", "", "/*", " * These macros are extensions - not in X/Open Curses.", " */", "#if 1", "#if !NCURSES_OPAQUE", "#define is_cleared(win)\t\t((win)->_clear)", "#define is_idcok(win)\t\t((win)->_idcok)", "#define is_idlok(win)\t\t((win)->_idlok)", "#define is_immedok(win)\t\t((win)->_immed)", "#define is_keypad(win)\t\t((win)->_use_keypad)", "#define is_leaveok(win)\t\t((win)->_leaveok)", "#define is_nodelay(win)\t\t((win)->_delay == 0)", "#define is_notimeout(win)\t((win)->_notimeout)", "#define is_scrollok(win)\t((win)->_scroll)", "#define is_syncok(win)\t\t((win)->_sync)", "#define wgetparent(win)\t\t((win) ? (win)->_parent : 0)", "#define wgetscrreg(win,t,b)\t((win) ? (*(t) = (win)->_regtop, *(b) = (win)->_regbottom, OK) : ERR)", "#endif", "#endif", "", "#endif /* NCURSES_NOMACROS */", "", "/*", " * Public variables.", " *", " * Notes:", " *\ta. ESCDELAY was an undocumented feature under AIX curses.", " *\t   It gives the ESC expire time in milliseconds.", " *\tb. ttytype is needed for backward compatibility", " */", "#if 0", "", "NCURSES_WRAPPED_VAR(WINDOW *, curscr);", "NCURSES_WRAPPED_VAR(WINDOW *, newscr);", "NCURSES_WRAPPED_VAR(WINDOW *, stdscr);", "NCURSES_WRAPPED_VAR(char *, ttytype);", "NCURSES_WRAPPED_VAR(int, COLORS);", "NCURSES_WRAPPED_VAR(int, COLOR_PAIRS);", "NCURSES_WRAPPED_VAR(int, COLS);", "NCURSES_WRAPPED_VAR(int, ESCDELAY);", "NCURSES_WRAPPED_VAR(int, LINES);", "NCURSES_WRAPPED_VAR(int, TABSIZE);", "", "#define curscr      NCURSES_PUBLIC_VAR(curscr())", "#define newscr      NCURSES_PUBLIC_VAR(newscr())", "#define stdscr      NCURSES_PUBLIC_VAR(stdscr())", "#define ttytype     NCURSES_PUBLIC_VAR(ttytype())", "#define COLORS      NCURSES_PUBLIC_VAR(COLORS())", "#define COLOR_PAIRS NCURSES_PUBLIC_VAR(COLOR_PAIRS())", "#define COLS        NCURSES_PUBLIC_VAR(COLS())", "#define ESCDELAY    NCURSES_PUBLIC_VAR(ESCDELAY())", "#define LINES       NCURSES_PUBLIC_VAR(LINES())", "#define TABSIZE     NCURSES_PUBLIC_VAR(TABSIZE())", "", "#else", "", "extern NCURSES_EXPORT_VAR(WINDOW *) curscr;", "extern NCURSES_EXPORT_VAR(WINDOW *) newscr;", "extern NCURSES_EXPORT_VAR(WINDOW *) stdscr;", "extern NCURSES_EXPORT_VAR(char) ttytype[];", "extern NCURSES_EXPORT_VAR(int) COLORS;", "extern NCURSES_EXPORT_VAR(int) COLOR_PAIRS;", "extern NCURSES_EXPORT_VAR(int) COLS;", "extern NCURSES_EXPORT_VAR(int) ESCDELAY;", "extern NCURSES_EXPORT_VAR(int) LINES;", "extern NCURSES_EXPORT_VAR(int) TABSIZE;", "", "#endif", "", "/*", " * Pseudo-character tokens outside ASCII range.  The curses wgetch() function", " * will return any given one of these only if the corresponding k- capability", " * is defined in your terminal's terminfo entry.", " *", " * Some keys (KEY_A1, etc) are arranged like this:", " *\ta1     up    a3", " *\tleft   b2    right", " *\tc1     down  c3", " *", " * A few key codes do not depend upon the terminfo entry.", " */", "#define KEY_CODE_YES\t0400\t\t/* A wchar_t contains a key code */", "#define KEY_MIN\t\t0401\t\t/* Minimum curses key */", "#define KEY_BREAK\t0401\t\t/* Break key (unreliable) */", "#define KEY_SRESET\t0530\t\t/* Soft (partial) reset (unreliable) */", "#define KEY_RESET\t0531\t\t/* Reset or hard reset (unreliable) */", "/*", " * These definitions were generated by /SourceCache/ncurses/ncurses-42/ncurses/include/MKkey_defs.sh /SourceCache/ncurses/ncurses-42/ncurses/include/Caps", " */", "#define KEY_DOWN\t0402\t\t/* down-arrow key */", "#define KEY_UP\t\t0403\t\t/* up-arrow key */", "#define KEY_LEFT\t0404\t\t/* left-arrow key */", "#define KEY_RIGHT\t0405\t\t/* right-arrow key */", "#define KEY_HOME\t0406\t\t/* home key */", "#define KEY_BACKSPACE\t0407\t\t/* backspace key */", "#define KEY_F0\t\t0410\t\t/* Function keys.  Space for 64 */", "#define KEY_F(n)\t(KEY_F0+(n))\t/* Value of function key n */", "#define KEY_DL\t\t0510\t\t/* delete-line key */", "#define KEY_IL\t\t0511\t\t/* insert-line key */", "#define KEY_DC\t\t0512\t\t/* delete-character key */", "#define KEY_IC\t\t0513\t\t/* insert-character key */", "#define KEY_EIC\t\t0514\t\t/* sent by rmir or smir in insert mode */", "#define KEY_CLEAR\t0515\t\t/* clear-screen or erase key */", "#define KEY_EOS\t\t0516\t\t/* clear-to-end-of-screen key */", "#define KEY_EOL\t\t0517\t\t/* clear-to-end-of-line key */", "#define KEY_SF\t\t0520\t\t/* scroll-forward key */", "#define KEY_SR\t\t0521\t\t/* scroll-backward key */", "#define KEY_NPAGE\t0522\t\t/* next-page key */", "#define KEY_PPAGE\t0523\t\t/* previous-page key */", "#define KEY_STAB\t0524\t\t/* set-tab key */", "#define KEY_CTAB\t0525\t\t/* clear-tab key */", "#define KEY_CATAB\t0526\t\t/* clear-all-tabs key */", "#define KEY_ENTER\t0527\t\t/* enter/send key */", "#define KEY_PRINT\t0532\t\t/* print key */", "#define KEY_LL\t\t0533\t\t/* lower-left key (home down) */", "#define KEY_A1\t\t0534\t\t/* upper left of keypad */", "#define KEY_A3\t\t0535\t\t/* upper right of keypad */", "#define KEY_B2\t\t0536\t\t/* center of keypad */", "#define KEY_C1\t\t0537\t\t/* lower left of keypad */", "#define KEY_C3\t\t0540\t\t/* lower right of keypad */", "#define KEY_BTAB\t0541\t\t/* back-tab key */", "#define KEY_BEG\t\t0542\t\t/* begin key */", "#define KEY_CANCEL\t0543\t\t/* cancel key */", "#define KEY_CLOSE\t0544\t\t/* close key */", "#define KEY_COMMAND\t0545\t\t/* command key */", "#define KEY_COPY\t0546\t\t/* copy key */", "#define KEY_CREATE\t0547\t\t/* create key */", "#define KEY_END\t\t0550\t\t/* end key */", "#define KEY_EXIT\t0551\t\t/* exit key */", "#define KEY_FIND\t0552\t\t/* find key */", "#define KEY_HELP\t0553\t\t/* help key */", "#define KEY_MARK\t0554\t\t/* mark key */", "#define KEY_MESSAGE\t0555\t\t/* message key */", "#define KEY_MOVE\t0556\t\t/* move key */", "#define KEY_NEXT\t0557\t\t/* next key */", "#define KEY_OPEN\t0560\t\t/* open key */", "#define KEY_OPTIONS\t0561\t\t/* options key */", "#define KEY_PREVIOUS\t0562\t\t/* previous key */", "#define KEY_REDO\t0563\t\t/* redo key */", "#define KEY_REFERENCE\t0564\t\t/* reference key */", "#define KEY_REFRESH\t0565\t\t/* refresh key */", "#define KEY_REPLACE\t0566\t\t/* replace key */", "#define KEY_RESTART\t0567\t\t/* restart key */", "#define KEY_RESUME\t0570\t\t/* resume key */", "#define KEY_SAVE\t0571\t\t/* save key */", "#define KEY_SBEG\t0572\t\t/* shifted begin key */", "#define KEY_SCANCEL\t0573\t\t/* shifted cancel key */", "#define KEY_SCOMMAND\t0574\t\t/* shifted command key */", "#define KEY_SCOPY\t0575\t\t/* shifted copy key */", "#define KEY_SCREATE\t0576\t\t/* shifted create key */", "#define KEY_SDC\t\t0577\t\t/* shifted delete-character key */", "#define KEY_SDL\t\t0600\t\t/* shifted delete-line key */", "#define KEY_SELECT\t0601\t\t/* select key */", "#define KEY_SEND\t0602\t\t/* shifted end key */", "#define KEY_SEOL\t0603\t\t/* shifted clear-to-end-of-line key */", "#define KEY_SEXIT\t0604\t\t/* shifted exit key */", "#define KEY_SFIND\t0605\t\t/* shifted find key */", "#define KEY_SHELP\t0606\t\t/* shifted help key */", "#define KEY_SHOME\t0607\t\t/* shifted home key */", "#define KEY_SIC\t\t0610\t\t/* shifted insert-character key */", "#define KEY_SLEFT\t0611\t\t/* shifted left-arrow key */", "#define KEY_SMESSAGE\t0612\t\t/* shifted message key */", "#define KEY_SMOVE\t0613\t\t/* shifted move key */", "#define KEY_SNEXT\t0614\t\t/* shifted next key */", "#define KEY_SOPTIONS\t0615\t\t/* shifted options key */", "#define KEY_SPREVIOUS\t0616\t\t/* shifted previous key */", "#define KEY_SPRINT\t0617\t\t/* shifted print key */", "#define KEY_SREDO\t0620\t\t/* shifted redo key */", "#define KEY_SREPLACE\t0621\t\t/* shifted replace key */", "#define KEY_SRIGHT\t0622\t\t/* shifted right-arrow key */", "#define KEY_SRSUME\t0623\t\t/* shifted resume key */", "#define KEY_SSAVE\t0624\t\t/* shifted save key */", "#define KEY_SSUSPEND\t0625\t\t/* shifted suspend key */", "#define KEY_SUNDO\t0626\t\t/* shifted undo key */", "#define KEY_SUSPEND\t0627\t\t/* suspend key */", "#define KEY_UNDO\t0630\t\t/* undo key */", "#define KEY_MOUSE\t0631\t\t/* Mouse event has occurred */", "#define KEY_RESIZE\t0632\t\t/* Terminal resize event */", "#define KEY_EVENT\t0633\t\t/* We were interrupted by an event */", "", "#define KEY_MAX\t\t0777\t\t/* Maximum key value is 0633 */", "/* $Id: curses.wide,v 1.34 2007/03/10 17:52:23 tom Exp $ */", "/*", " * vile:cmode:", " * This file is part of ncurses, designed to be appended after curses.h.in", " * (see that file for the relevant copyright).", " */", "#ifdef _XOPEN_SOURCE_EXTENDED", "", "extern NCURSES_EXPORT_VAR(cchar_t *) _nc_wacs;", "", "#define NCURSES_WACS(c)\t(&_nc_wacs[(unsigned char)c])", "", "#define WACS_BSSB\tNCURSES_WACS('l')", "#define WACS_SSBB\tNCURSES_WACS('m')", "#define WACS_BBSS\tNCURSES_WACS('k')", "#define WACS_SBBS\tNCURSES_WACS('j')", "#define WACS_SBSS\tNCURSES_WACS('u')", "#define WACS_SSSB\tNCURSES_WACS('t')", "#define WACS_SSBS\tNCURSES_WACS('v')", "#define WACS_BSSS\tNCURSES_WACS('w')", "#define WACS_BSBS\tNCURSES_WACS('q')", "#define WACS_SBSB\tNCURSES_WACS('x')", "#define WACS_SSSS\tNCURSES_WACS('n')", "", "#define WACS_ULCORNER\tWACS_BSSB", "#define WACS_LLCORNER\tWACS_SSBB", "#define WACS_URCORNER\tWACS_BBSS", "#define WACS_LRCORNER\tWACS_SBBS", "#define WACS_RTEE\tWACS_SBSS", "#define WACS_LTEE\tWACS_SSSB", "#define WACS_BTEE\tWACS_SSBS", "#define WACS_TTEE\tWACS_BSSS", "#define WACS_HLINE\tWACS_BSBS", "#define WACS_VLINE\tWACS_SBSB", "#define WACS_PLUS\tWACS_SSSS", "", "#define WACS_S1\t\tNCURSES_WACS('o') /* scan line 1 */", "#define WACS_S9 \tNCURSES_WACS('s') /* scan line 9 */", "#define WACS_DIAMOND\tNCURSES_WACS('`') /* diamond */", "#define WACS_CKBOARD\tNCURSES_WACS('a') /* checker board */", "#define WACS_DEGREE\tNCURSES_WACS('f') /* degree symbol */", "#define WACS_PLMINUS\tNCURSES_WACS('g') /* plus/minus */", "#define WACS_BULLET\tNCURSES_WACS('~') /* bullet */", "", "\t/* Teletype 5410v1 symbols */", "#define WACS_LARROW\tNCURSES_WACS(',') /* arrow left */", "#define WACS_RARROW\tNCURSES_WACS('+') /* arrow right */", "#define WACS_DARROW\tNCURSES_WACS('.') /* arrow down */", "#define WACS_UARROW\tNCURSES_WACS('-') /* arrow up */", "#define WACS_BOARD\tNCURSES_WACS('h') /* board of squares */", "#define WACS_LANTERN\tNCURSES_WACS('i') /* lantern symbol */", "#define WACS_BLOCK\tNCURSES_WACS('0') /* solid square block */", "", "\t/* ncurses extensions */", "#define WACS_S3\t\tNCURSES_WACS('p') /* scan line 3 */", "#define WACS_S7\t\tNCURSES_WACS('r') /* scan line 7 */", "#define WACS_LEQUAL\tNCURSES_WACS('y') /* less/equal */", "#define WACS_GEQUAL\tNCURSES_WACS('z') /* greater/equal */", "#define WACS_PI\t\tNCURSES_WACS('{') /* Pi */", "#define WACS_NEQUAL\tNCURSES_WACS('|') /* not equal */", "#define WACS_STERLING\tNCURSES_WACS('}') /* UK pound sign */", "", "/*", " * Function prototypes for wide-character operations.", " *", ' * "generated" comments should include ":WIDEC" to make the corresponding', " * functions ifdef'd in lib_gen.c", " *", ' * "implemented" comments do not need this marker.', " */", "", "extern NCURSES_EXPORT(int) add_wch (const cchar_t *);\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) add_wchnstr (const cchar_t *, int);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) add_wchstr (const cchar_t *);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) addnwstr (const wchar_t *, int);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) addwstr (const wchar_t *);\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) bkgrnd (const cchar_t *);\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(void) bkgrndset (const cchar_t *);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) border_set (const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*); /* generated:WIDEC */", "extern NCURSES_EXPORT(int) box_set (WINDOW *, const cchar_t *, const cchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) echo_wchar (const cchar_t *);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) erasewchar (wchar_t*);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) get_wch (wint_t *);\t\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) get_wstr (wint_t *);\t\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) getbkgrnd (cchar_t *);\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) getcchar (const cchar_t *, wchar_t*, attr_t*, short*, void*);\t/* implemented */", "extern NCURSES_EXPORT(int) getn_wstr (wint_t *, int);\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) hline_set (const cchar_t *, int);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) in_wch (cchar_t *);\t\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) in_wchnstr (cchar_t *, int);\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) in_wchstr (cchar_t *);\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) innwstr (wchar_t *, int);\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) ins_nwstr (const wchar_t *, int);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) ins_wch (const cchar_t *);\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) ins_wstr (const wchar_t *);\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) inwstr (wchar_t *);\t\t\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(NCURSES_CONST char*) key_name (wchar_t);\t\t/* implemented */", "extern NCURSES_EXPORT(int) killwchar (wchar_t *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) mvadd_wch (int, int, const cchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvadd_wchnstr (int, int, const cchar_t *, int);/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvadd_wchstr (int, int, const cchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvaddnwstr (int, int, const wchar_t *, int);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvaddwstr (int, int, const wchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvget_wch (int, int, wint_t *);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvget_wstr (int, int, wint_t *);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvgetn_wstr (int, int, wint_t *, int);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvhline_set (int, int, const cchar_t *, int);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvin_wch (int, int, cchar_t *);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvin_wchnstr (int, int, cchar_t *, int);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvin_wchstr (int, int, cchar_t *);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvinnwstr (int, int, wchar_t *, int);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvins_nwstr (int, int, const wchar_t *, int);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvins_wch (int, int, const cchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvins_wstr (int, int, const wchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvinwstr (int, int, wchar_t *);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvvline_set (int, int, const cchar_t *, int);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwadd_wch (WINDOW *, int, int, const cchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwadd_wchnstr (WINDOW *, int, int, const cchar_t *, int); /* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwadd_wchstr (WINDOW *, int, int, const cchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwaddnwstr (WINDOW *, int, int, const wchar_t *, int);/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwaddwstr (WINDOW *, int, int, const wchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwget_wch (WINDOW *, int, int, wint_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwget_wstr (WINDOW *, int, int, wint_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwgetn_wstr (WINDOW *, int, int, wint_t *, int);/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwhline_set (WINDOW *, int, int, const cchar_t *, int);/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwin_wch (WINDOW *, int, int, cchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwin_wchnstr (WINDOW *, int,int, cchar_t *,int);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwin_wchstr (WINDOW *, int, int, cchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwinnwstr (WINDOW *, int, int, wchar_t *, int);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwins_nwstr (WINDOW *, int,int, const wchar_t *,int); /* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwins_wch (WINDOW *, int, int, const cchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwins_wstr (WINDOW *, int, int, const wchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwinwstr (WINDOW *, int, int, wchar_t *);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) mvwvline_set (WINDOW *, int,int, const cchar_t *,int); /* generated:WIDEC */", "extern NCURSES_EXPORT(int) pecho_wchar (WINDOW *, const cchar_t *);\t/* implemented */", "extern NCURSES_EXPORT(int) setcchar (cchar_t *, const wchar_t *, const attr_t, short, const void *);\t/* implemented */", "extern NCURSES_EXPORT(int) slk_wset (int, const wchar_t *, int);\t/* implemented */", "extern NCURSES_EXPORT(attr_t) term_attrs (void);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) unget_wch (const wchar_t);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) vid_attr (attr_t, short, void *);\t\t/* implemented */", "extern NCURSES_EXPORT(int) vid_puts (attr_t, short, void *, int (*)(int)); /* implemented */", "extern NCURSES_EXPORT(int) vline_set (const cchar_t *, int);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) wadd_wch (WINDOW *,const cchar_t *);\t\t/* implemented */", "extern NCURSES_EXPORT(int) wadd_wchnstr (WINDOW *,const cchar_t *,int);\t/* implemented */", "extern NCURSES_EXPORT(int) wadd_wchstr (WINDOW *,const cchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) waddnwstr (WINDOW *,const wchar_t *,int);\t/* implemented */", "extern NCURSES_EXPORT(int) waddwstr (WINDOW *,const wchar_t *);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) wbkgrnd (WINDOW *,const cchar_t *);\t\t/* implemented */", "extern NCURSES_EXPORT(void) wbkgrndset (WINDOW *,const cchar_t *);\t/* implemented */", "extern NCURSES_EXPORT(int) wborder_set (WINDOW *,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*);\t/* implemented */", "extern NCURSES_EXPORT(int) wecho_wchar (WINDOW *, const cchar_t *);\t/* implemented */", "extern NCURSES_EXPORT(int) wget_wch (WINDOW *, wint_t *);\t\t/* implemented */", "extern NCURSES_EXPORT(int) wget_wstr (WINDOW *, wint_t *);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) wgetbkgrnd (WINDOW *, cchar_t *);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) wgetn_wstr (WINDOW *,wint_t *, int);\t\t/* implemented */", "extern NCURSES_EXPORT(int) whline_set (WINDOW *, const cchar_t *, int);\t/* implemented */", "extern NCURSES_EXPORT(int) win_wch (WINDOW *, cchar_t *);\t\t/* implemented */", "extern NCURSES_EXPORT(int) win_wchnstr (WINDOW *, cchar_t *, int);\t/* implemented */", "extern NCURSES_EXPORT(int) win_wchstr (WINDOW *, cchar_t *);\t\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) winnwstr (WINDOW *, wchar_t *, int);\t\t/* implemented */", "extern NCURSES_EXPORT(int) wins_nwstr (WINDOW *, const wchar_t *, int);\t/* implemented */", "extern NCURSES_EXPORT(int) wins_wch (WINDOW *, const cchar_t *);\t/* implemented */", "extern NCURSES_EXPORT(int) wins_wstr (WINDOW *, const wchar_t *);\t/* generated:WIDEC */", "extern NCURSES_EXPORT(int) winwstr (WINDOW *, wchar_t *);\t\t/* implemented */", "extern NCURSES_EXPORT(wchar_t*) wunctrl (cchar_t *);\t\t\t/* implemented */", "extern NCURSES_EXPORT(int) wvline_set (WINDOW *, const cchar_t *, int);\t/* implemented */", "", "#ifndef NCURSES_NOMACROS", "", "/*", " * XSI curses macros for XPG4 conformance.", " */", "#define add_wch(c)\t\t\twadd_wch(stdscr,c)", "#define add_wchnstr(str,n)\t\twadd_wchnstr(stdscr,str,n)", "#define add_wchstr(str)\t\t\twadd_wchstr(stdscr,str)", "#define addnwstr(wstr,n)\t\twaddnwstr(stdscr,wstr,n)", "#define addwstr(wstr)\t\t\twaddwstr(stdscr,wstr)", "#define bkgrnd(c)\t\t\twbkgrnd(stdscr,c)", "#define bkgrndset(c)\t\t\twbkgrndset(stdscr,c)", "#define border_set(l,r,t,b,tl,tr,bl,br) wborder_set(stdscr,l,r,t,b,tl,tr,bl,br)", "#define box_set(w,v,h)\t\t\twborder_set(w,v,v,h,h,0,0,0,0)", "#define echo_wchar(c)\t\t\twecho_wchar(stdscr,c)", "#define get_wch(c)\t\t\twget_wch(stdscr,c)", "#define get_wstr(t)\t\t\twget_wstr(stdscr,t)", "#define getbkgrnd(wch)\t\t\twgetbkgrnd(stdscr,wch)", "#define getn_wstr(t,n)\t\t\twgetn_wstr(stdscr,t,n)", "#define hline_set(c,n)\t\t\twhline_set(stdscr,c,n)", "#define in_wch(c)\t\t\twin_wch(stdscr,c)", "#define in_wchnstr(c,n)\t\t\twin_wchnstr(stdscr,c,n)", "#define in_wchstr(c)\t\t\twin_wchstr(stdscr,c)", "#define innwstr(c,n)\t\t\twinnwstr(stdscr,c,n)", "#define ins_nwstr(t,n)\t\t\twins_nwstr(stdscr,t,n)", "#define ins_wch(c)\t\t\twins_wch(stdscr,c)", "#define ins_wstr(t)\t\t\twins_wstr(stdscr,t)", "#define inwstr(c)\t\t\twinwstr(stdscr,c)", "#define vline_set(c,n)\t\t\twvline_set(stdscr,c,n)", "#define wadd_wchstr(win,str)\t\twadd_wchnstr(win,str,-1)", "#define waddwstr(win,wstr)\t\twaddnwstr(win,wstr,-1)", "#define wget_wstr(w,t)\t\t\twgetn_wstr(w,t,-1)", "#define win_wchstr(w,c)\t\t\twin_wchnstr(w,c,-1)", "#define wins_wstr(w,t)\t\t\twins_nwstr(w,t,-1)", "", "#if !NCURSES_OPAQUE", "#define wgetbkgrnd(win,wch)\t\t(*wch = win->_bkgrnd, OK)", "#endif", "", "#define mvadd_wch(y,x,c)\t\tmvwadd_wch(stdscr,y,x,c)", "#define mvadd_wchnstr(y,x,s,n)\t\tmvwadd_wchnstr(stdscr,y,x,s,n)", "#define mvadd_wchstr(y,x,s)\t\tmvwadd_wchstr(stdscr,y,x,s)", "#define mvaddnwstr(y,x,wstr,n)\t\tmvwaddnwstr(stdscr,y,x,wstr,n)", "#define mvaddwstr(y,x,wstr)\t\tmvwaddwstr(stdscr,y,x,wstr)", "#define mvget_wch(y,x,c)\t\tmvwget_wch(stdscr,y,x,c)", "#define mvget_wstr(y,x,t)\t\tmvwget_wstr(stdscr,y,x,t)", "#define mvgetn_wstr(y,x,t,n)\t\tmvwgetn_wstr(stdscr,y,x,t,n)", "#define mvhline_set(y,x,c,n)\t\tmvwhline_set(stdscr,y,x,c,n)", "#define mvin_wch(y,x,c)\t\t\tmvwin_wch(stdscr,y,x,c)", "#define mvin_wchnstr(y,x,c,n)\t\tmvwin_wchnstr(stdscr,y,x,c,n)", "#define mvin_wchstr(y,x,c)\t\tmvwin_wchstr(stdscr,y,x,c)", "#define mvinnwstr(y,x,c,n)\t\tmvwinnwstr(stdscr,y,x,c,n)", "#define mvins_nwstr(y,x,t,n)\t\tmvwins_nwstr(stdscr,y,x,t,n)", "#define mvins_wch(y,x,c)\t\tmvwins_wch(stdscr,y,x,c)", "#define mvins_wstr(y,x,t)\t\tmvwins_wstr(stdscr,y,x,t)", "#define mvinwstr(y,x,c)\t\t\tmvwinwstr(stdscr,y,x,c)", "#define mvvline_set(y,x,c,n)\t\tmvwvline_set(stdscr,y,x,c,n)", "", "#define mvwadd_wch(win,y,x,c)\t\t(wmove(win,y,x) == ERR ? ERR : wadd_wch(win,c))", "#define mvwadd_wchnstr(win,y,x,s,n)\t(wmove(win,y,x) == ERR ? ERR : wadd_wchnstr(win,s,n))", "#define mvwadd_wchstr(win,y,x,s)\t(wmove(win,y,x) == ERR ? ERR : wadd_wchstr(win,s))", "#define mvwaddnwstr(win,y,x,wstr,n)\t(wmove(win,y,x) == ERR ? ERR : waddnwstr(win,wstr,n))", "#define mvwaddwstr(win,y,x,wstr)\t(wmove(win,y,x) == ERR ? ERR : waddwstr(win,wstr))", "#define mvwget_wch(win,y,x,c)\t\t(wmove(win,y,x) == ERR ? ERR : wget_wch(win,c))", "#define mvwget_wstr(win,y,x,t)\t\t(wmove(win,y,x) == ERR ? ERR : wget_wstr(win,t))", "#define mvwgetn_wstr(win,y,x,t,n)\t(wmove(win,y,x) == ERR ? ERR : wgetn_wstr(win,t,n))", "#define mvwhline_set(win,y,x,c,n)\t(wmove(win,y,x) == ERR ? ERR : whline_set(win,c,n))", "#define mvwin_wch(win,y,x,c)\t\t(wmove(win,y,x) == ERR ? ERR : win_wch(win,c))", "#define mvwin_wchnstr(win,y,x,c,n)\t(wmove(win,y,x) == ERR ? ERR : win_wchnstr(win,c,n))", "#define mvwin_wchstr(win,y,x,c)\t\t(wmove(win,y,x) == ERR ? ERR : win_wchstr(win,c))", "#define mvwinnwstr(win,y,x,c,n)\t\t(wmove(win,y,x) == ERR ? ERR : winnwstr(win,c,n))", "#define mvwins_nwstr(win,y,x,t,n)\t(wmove(win,y,x) == ERR ? ERR : wins_nwstr(win,t,n))", "#define mvwins_wch(win,y,x,c)\t\t(wmove(win,y,x) == ERR ? ERR : wins_wch(win,c))", "#define mvwins_wstr(win,y,x,t)\t\t(wmove(win,y,x) == ERR ? ERR : wins_wstr(win,t))", "#define mvwinwstr(win,y,x,c)\t\t(wmove(win,y,x) == ERR ? ERR : winwstr(win,c))", "#define mvwvline_set(win,y,x,c,n)\t(wmove(win,y,x) == ERR ? ERR : wvline_set(win,c,n))", "", "#endif /* NCURSES_NOMACROS */", "", "#if defined(TRACE) || defined(NCURSES_TEST)", "extern NCURSES_EXPORT(const char *) _nc_viswbuf(const wchar_t *);", "extern NCURSES_EXPORT(const char *) _nc_viswibuf(const wint_t *);", "#endif", "", "#endif /* _XOPEN_SOURCE_EXTENDED */", "/* $Id: curses.tail,v 1.16 2008/07/05 20:20:38 tom Exp $ */", "/*", " * vile:cmode:", " * This file is part of ncurses, designed to be appended after curses.h.in", " * (see that file for the relevant copyright).", " */", "", "/* mouse interface */", "", "#if NCURSES_MOUSE_VERSION > 1", "#define NCURSES_MOUSE_MASK(b,m) ((m) << (((b) - 1) * 5))", "#else", "#define NCURSES_MOUSE_MASK(b,m) ((m) << (((b) - 1) * 6))", "#endif", "", "#define\tNCURSES_BUTTON_RELEASED\t001L", "#define\tNCURSES_BUTTON_PRESSED\t002L", "#define\tNCURSES_BUTTON_CLICKED\t004L", "#define\tNCURSES_DOUBLE_CLICKED\t010L", "#define\tNCURSES_TRIPLE_CLICKED\t020L", "#define\tNCURSES_RESERVED_EVENT\t040L", "", "/* event masks */", "#define\tBUTTON1_RELEASED\tNCURSES_MOUSE_MASK(1, NCURSES_BUTTON_RELEASED)", "#define\tBUTTON1_PRESSED\t\tNCURSES_MOUSE_MASK(1, NCURSES_BUTTON_PRESSED)", "#define\tBUTTON1_CLICKED\t\tNCURSES_MOUSE_MASK(1, NCURSES_BUTTON_CLICKED)", "#define\tBUTTON1_DOUBLE_CLICKED\tNCURSES_MOUSE_MASK(1, NCURSES_DOUBLE_CLICKED)", "#define\tBUTTON1_TRIPLE_CLICKED\tNCURSES_MOUSE_MASK(1, NCURSES_TRIPLE_CLICKED)", "", "#define\tBUTTON2_RELEASED\tNCURSES_MOUSE_MASK(2, NCURSES_BUTTON_RELEASED)", "#define\tBUTTON2_PRESSED\t\tNCURSES_MOUSE_MASK(2, NCURSES_BUTTON_PRESSED)", "#define\tBUTTON2_CLICKED\t\tNCURSES_MOUSE_MASK(2, NCURSES_BUTTON_CLICKED)", "#define\tBUTTON2_DOUBLE_CLICKED\tNCURSES_MOUSE_MASK(2, NCURSES_DOUBLE_CLICKED)", "#define\tBUTTON2_TRIPLE_CLICKED\tNCURSES_MOUSE_MASK(2, NCURSES_TRIPLE_CLICKED)", "", "#define\tBUTTON3_RELEASED\tNCURSES_MOUSE_MASK(3, NCURSES_BUTTON_RELEASED)", "#define\tBUTTON3_PRESSED\t\tNCURSES_MOUSE_MASK(3, NCURSES_BUTTON_PRESSED)", "#define\tBUTTON3_CLICKED\t\tNCURSES_MOUSE_MASK(3, NCURSES_BUTTON_CLICKED)", "#define\tBUTTON3_DOUBLE_CLICKED\tNCURSES_MOUSE_MASK(3, NCURSES_DOUBLE_CLICKED)", "#define\tBUTTON3_TRIPLE_CLICKED\tNCURSES_MOUSE_MASK(3, NCURSES_TRIPLE_CLICKED)", "", "#define\tBUTTON4_RELEASED\tNCURSES_MOUSE_MASK(4, NCURSES_BUTTON_RELEASED)", "#define\tBUTTON4_PRESSED\t\tNCURSES_MOUSE_MASK(4, NCURSES_BUTTON_PRESSED)", "#define\tBUTTON4_CLICKED\t\tNCURSES_MOUSE_MASK(4, NCURSES_BUTTON_CLICKED)", "#define\tBUTTON4_DOUBLE_CLICKED\tNCURSES_MOUSE_MASK(4, NCURSES_DOUBLE_CLICKED)", "#define\tBUTTON4_TRIPLE_CLICKED\tNCURSES_MOUSE_MASK(4, NCURSES_TRIPLE_CLICKED)", "", "/*", " * In 32 bits the version-1 scheme does not provide enough space for a 5th", " * button, unless we choose to change the ABI by omitting the reserved-events.", " */", "#if NCURSES_MOUSE_VERSION > 1", "", "#define\tBUTTON5_RELEASED\tNCURSES_MOUSE_MASK(5, NCURSES_BUTTON_RELEASED)", "#define\tBUTTON5_PRESSED\t\tNCURSES_MOUSE_MASK(5, NCURSES_BUTTON_PRESSED)", "#define\tBUTTON5_CLICKED\t\tNCURSES_MOUSE_MASK(5, NCURSES_BUTTON_CLICKED)", "#define\tBUTTON5_DOUBLE_CLICKED\tNCURSES_MOUSE_MASK(5, NCURSES_DOUBLE_CLICKED)", "#define\tBUTTON5_TRIPLE_CLICKED\tNCURSES_MOUSE_MASK(5, NCURSES_TRIPLE_CLICKED)", "", "#define\tBUTTON_CTRL\t\tNCURSES_MOUSE_MASK(6, 0001L)", "#define\tBUTTON_SHIFT\t\tNCURSES_MOUSE_MASK(6, 0002L)", "#define\tBUTTON_ALT\t\tNCURSES_MOUSE_MASK(6, 0004L)", "#define\tREPORT_MOUSE_POSITION\tNCURSES_MOUSE_MASK(6, 0010L)", "", "#else", "", "#define\tBUTTON1_RESERVED_EVENT\tNCURSES_MOUSE_MASK(1, NCURSES_RESERVED_EVENT)", "#define\tBUTTON2_RESERVED_EVENT\tNCURSES_MOUSE_MASK(2, NCURSES_RESERVED_EVENT)", "#define\tBUTTON3_RESERVED_EVENT\tNCURSES_MOUSE_MASK(3, NCURSES_RESERVED_EVENT)", "#define\tBUTTON4_RESERVED_EVENT\tNCURSES_MOUSE_MASK(4, NCURSES_RESERVED_EVENT)", "", "#define\tBUTTON_CTRL\t\tNCURSES_MOUSE_MASK(5, 0001L)", "#define\tBUTTON_SHIFT\t\tNCURSES_MOUSE_MASK(5, 0002L)", "#define\tBUTTON_ALT\t\tNCURSES_MOUSE_MASK(5, 0004L)", "#define\tREPORT_MOUSE_POSITION\tNCURSES_MOUSE_MASK(5, 0010L)", "", "#endif", "", "#define\tALL_MOUSE_EVENTS\t(REPORT_MOUSE_POSITION - 1)", "", "/* macros to extract single event-bits from masks */", "#define\tBUTTON_RELEASE(e, x)\t\t((e) & NCURSES_MOUSE_MASK(x, 001))", "#define\tBUTTON_PRESS(e, x)\t\t((e) & NCURSES_MOUSE_MASK(x, 002))", "#define\tBUTTON_CLICK(e, x)\t\t((e) & NCURSES_MOUSE_MASK(x, 004))", "#define\tBUTTON_DOUBLE_CLICK(e, x)\t((e) & NCURSES_MOUSE_MASK(x, 010))", "#define\tBUTTON_TRIPLE_CLICK(e, x)\t((e) & NCURSES_MOUSE_MASK(x, 020))", "#define\tBUTTON_RESERVED_EVENT(e, x)\t((e) & NCURSES_MOUSE_MASK(x, 040))", "", "typedef struct", "{", "    short id;\t\t/* ID to distinguish multiple devices */", "    int x, y, z;\t/* event coordinates (character-cell) */", "    mmask_t bstate;\t/* button state bits */", "}", "MEVENT;", "", "extern NCURSES_EXPORT(int) getmouse (MEVENT *);", "extern NCURSES_EXPORT(int) ungetmouse (MEVENT *);", "extern NCURSES_EXPORT(mmask_t) mousemask (mmask_t, mmask_t *);", "extern NCURSES_EXPORT(bool) wenclose (const WINDOW *, int, int);", "extern NCURSES_EXPORT(int) mouseinterval (int);", "extern NCURSES_EXPORT(bool) wmouse_trafo (const WINDOW*, int*, int*, bool);", "extern NCURSES_EXPORT(bool) mouse_trafo (int*, int*, bool);              /* generated */", "", "#define mouse_trafo(y,x,to_screen) wmouse_trafo(stdscr,y,x,to_screen)", "", "/* other non-XSI functions */", "", "extern NCURSES_EXPORT(int) mcprint (char *, int);\t/* direct data to printer */", "extern NCURSES_EXPORT(int) has_key (int);\t\t/* do we have given key? */", "", "/* Debugging : use with libncurses_g.a */", "", "extern NCURSES_EXPORT(void) _tracef (const char *, ...) GCC_PRINTFLIKE(1,2);", "extern NCURSES_EXPORT(void) _tracedump (const char *, WINDOW *);", "extern NCURSES_EXPORT(char *) _traceattr (attr_t);", "extern NCURSES_EXPORT(char *) _traceattr2 (int, chtype);", "extern NCURSES_EXPORT(char *) _nc_tracebits (void);", "extern NCURSES_EXPORT(char *) _tracechar (int);", "extern NCURSES_EXPORT(char *) _tracechtype (chtype);", "extern NCURSES_EXPORT(char *) _tracechtype2 (int, chtype);", "#ifdef _XOPEN_SOURCE_EXTENDED", "#define _tracech_t\t\t_tracecchar_t", "extern NCURSES_EXPORT(char *) _tracecchar_t (const cchar_t *);", "#define _tracech_t2\t\t_tracecchar_t2", "extern NCURSES_EXPORT(char *) _tracecchar_t2 (int, const cchar_t *);", "#else", "#define _tracech_t\t\t_tracechtype", "#define _tracech_t2\t\t_tracechtype2", "#endif", "extern NCURSES_EXPORT(char *) _tracemouse (const MEVENT *);", "extern NCURSES_EXPORT(void) trace (const unsigned int);", "", "/* trace masks */", "#define TRACE_DISABLE\t0x0000\t/* turn off tracing */", "#define TRACE_TIMES\t0x0001\t/* trace user and system times of updates */", "#define TRACE_TPUTS\t0x0002\t/* trace tputs calls */", "#define TRACE_UPDATE\t0x0004\t/* trace update actions, old & new screens */", "#define TRACE_MOVE\t0x0008\t/* trace cursor moves and scrolls */", "#define TRACE_CHARPUT\t0x0010\t/* trace all character outputs */", "#define TRACE_ORDINARY\t0x001F\t/* trace all update actions */", "#define TRACE_CALLS\t0x0020\t/* trace all curses calls */", "#define TRACE_VIRTPUT\t0x0040\t/* trace virtual character puts */", "#define TRACE_IEVENT\t0x0080\t/* trace low-level input processing */", "#define TRACE_BITS\t0x0100\t/* trace state of TTY control bits */", "#define TRACE_ICALLS\t0x0200\t/* trace internal/nested calls */", "#define TRACE_CCALLS\t0x0400\t/* trace per-character calls */", "#define TRACE_DATABASE\t0x0800\t/* trace read/write of terminfo/termcap data */", "#define TRACE_ATTRS\t0x1000\t/* trace attribute updates */", "", "#define TRACE_SHIFT\t13\t/* number of bits in the trace masks */", "#define TRACE_MAXIMUM\t((1 << TRACE_SHIFT) - 1) /* maximum trace level */", "", "#if defined(TRACE) || defined(NCURSES_TEST)", "extern NCURSES_EXPORT_VAR(int) _nc_optimize_enable;\t\t/* enable optimizations */", "extern NCURSES_EXPORT(const char *) _nc_visbuf (const char *);", "#define OPTIMIZE_MVCUR\t\t0x01\t/* cursor movement optimization */", "#define OPTIMIZE_HASHMAP\t0x02\t/* diff hashing to detect scrolls */", "#define OPTIMIZE_SCROLL\t\t0x04\t/* scroll optimization */", "#define OPTIMIZE_ALL\t\t0xff\t/* enable all optimizations (dflt) */", "#endif", "", "#ifdef __cplusplus", "", "#ifndef NCURSES_NOMACROS", "", "/* these names conflict with STL */", "#undef box", "#undef clear", "#undef erase", "#undef move", "#undef refresh", "", "#endif /* NCURSES_NOMACROS */", "", "}", "#endif", "", "#endif /* __NCURSES_H */" },
    ["ncurses_dll.h"] = { "/****************************************************************************", " * Copyright (c) 1998-2006,2007 Free Software Foundation, Inc.              *", " *                                                                          *", " * Permission is hereby granted, free of charge, to any person obtaining a  *", " * copy of this software and associated documentation files (the            *", ' * "Software"), to deal in the Software without restriction, including      *', " * without limitation the rights to use, copy, modify, merge, publish,      *", " * distribute, distribute with modifications, sublicense, and/or sell       *", " * copies of the Software, and to permit persons to whom the Software is    *", " * furnished to do so, subject to the following conditions:                 *", " *                                                                          *", " * The above copyright notice and this permission notice shall be included  *", " * in all copies or substantial portions of the Software.                   *", " *                                                                          *", ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *', " * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *", " * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *", " * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *", " * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *", " * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *", " * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *", " *                                                                          *", " * Except as contained in this notice, the name(s) of the above copyright   *", " * holders shall not be used in advertising or otherwise to promote the     *", " * sale, use or other dealings in this Software without prior written       *", " * authorization.                                                           *", " ****************************************************************************/", "/* $Id: ncurses_dll.h,v 1.6 2007/03/10 19:21:49 tom Exp $ */", "", "#ifndef NCURSES_DLL_H_incl", "#define NCURSES_DLL_H_incl 1", "", "/* no longer needed on cygwin or mingw, thanks to auto-import       */", "/* but this structure may be useful at some point for an MSVC build */", "/* so, for now unconditionally define the important flags           */", '/* "the right way" for proper static and dll+auto-import behavior   */', "#undef NCURSES_DLL", "#define NCURSES_STATIC", "", "#if defined(__CYGWIN__)", "#  if defined(NCURSES_DLL)", "#    if defined(NCURSES_STATIC)", "#      undef NCURSES_STATIC", "#    endif", "#  endif", "#  undef NCURSES_IMPEXP", "#  undef NCURSES_API", "#  undef NCURSES_EXPORT", "#  undef NCURSES_EXPORT_VAR", "#  if defined(NCURSES_DLL)", "/* building a DLL */", "#    define NCURSES_IMPEXP __declspec(dllexport)", "#  elif defined(NCURSES_STATIC)", "/* building or linking to a static library */", "#    define NCURSES_IMPEXP /* nothing */", "#  else", "/* linking to the DLL */", "#    define NCURSES_IMPEXP __declspec(dllimport)", "#  endif", "#  define NCURSES_API __cdecl", "#  define NCURSES_EXPORT(type) NCURSES_IMPEXP type NCURSES_API", "#  define NCURSES_EXPORT_VAR(type) NCURSES_IMPEXP type", "#endif", "", "/* Take care of non-cygwin platforms */", "#if !defined(NCURSES_IMPEXP)", "#  define NCURSES_IMPEXP /* nothing */", "#endif", "#if !defined(NCURSES_API)", "#  define NCURSES_API /* nothing */", "#endif", "#if !defined(NCURSES_EXPORT)", "#  define NCURSES_EXPORT(type) NCURSES_IMPEXP type NCURSES_API", "#endif", "#if !defined(NCURSES_EXPORT_VAR)", "#  define NCURSES_EXPORT_VAR(type) NCURSES_IMPEXP type", "#endif", "", "/*", " * For reentrant code, we map the various global variables into SCREEN by", " * using functions to access them.", " */", "#define NCURSES_PUBLIC_VAR(name) _nc_##name", "#define NCURSES_WRAPPED_VAR(type,name) extern type NCURSES_PUBLIC_VAR(name)(void)", "", "#endif /* NCURSES_DLL_H_incl */" },
    ["ndbm.h"] = { "/*", " * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/*-", " * Copyright (c) 1990, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * This code is derived from software contributed to Berkeley by", " * Margo Seltzer.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)ndbm.h\t8.1 (Berkeley) 6/2/93", " */", "", "#ifndef _NDBM_H_", "#define\t_NDBM_H_", "", "#include <_types.h>", "#include <sys/_types/_mode_t.h>", "#include <sys/_types/_size_t.h>", "", "#if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))", "/* Map dbm interface onto db(3). */", "#include <fcntl.h>", "#define DBM_RDONLY\tO_RDONLY", "#endif", "", "/* Flags to dbm_store(). */", "#define DBM_INSERT      0", "#define DBM_REPLACE     1", "", "#if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))", "/*", " * The db(3) support for ndbm(3) always appends this suffix to the", " * file name to avoid overwriting the user's original database.", " */", '#define\tDBM_SUFFIX\t".db"', "#endif", "", "typedef struct {", "\tvoid *dptr;", "\tsize_t dsize;", "} datum;", "", "#ifndef _DBM", "#define _DBM", "typedef struct {", "    char __opaque[sizeof(int) + 8 * sizeof(void *)];", "} DBM;", "#endif /* _DBM */", "", "#if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))", "#define\tdbm_pagfno(a)\tDBM_PAGFNO_NOT_AVAILABLE", "#endif", "", "__BEGIN_DECLS", "int\t dbm_clearerr( DBM *);", "void\t dbm_close(DBM *);", "int\t dbm_delete(DBM *, datum);", "#if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))", "int\t dbm_dirfno(DBM *);", "#endif", "int\t dbm_error( DBM *);", "datum\t dbm_fetch(DBM *, datum);", "datum\t dbm_firstkey(DBM *);", "#if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))", "long\t dbm_forder(DBM *, datum);", "#endif", "datum\t dbm_nextkey(DBM *);", "DBM\t*dbm_open(const char *, int, mode_t);", "int\t dbm_store(DBM *, datum, datum, int);", "__END_DECLS", "", "#endif /* !_NDBM_H_ */" },
    ["netdb.h"] = { "/*", " * Copyright (c) 2000-2009 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/*", " * ++Copyright++ 1980, 1983, 1988, 1993", " * -", " * Copyright (c) 1980, 1983, 1988, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " * -", " * Portions Copyright (c) 1993 by Digital Equipment Corporation.", " *", " * Permission to use, copy, modify, and distribute this software for any", " * purpose with or without fee is hereby granted, provided that the above", " * copyright notice and this permission notice appear in all copies, and that", " * the name of Digital Equipment Corporation not be used in advertising or", " * publicity pertaining to distribution of the document or software without", " * specific, written prior permission.", " *", ' * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL', " * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES", " * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT", " * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL", " * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR", " * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS", " * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS", " * SOFTWARE.", " * -", " * --Copyright--", " */", "", "/*", " *      @(#)netdb.h\t8.1 (Berkeley) 6/2/93", " */", "", "#ifndef _NETDB_H_", "#define _NETDB_H_", "", "#include <_types.h>", "#include <sys/_types/_size_t.h>", "#include <sys/_types/_socklen_t.h>", "", "#include <stdint.h>", "#include <netinet/in.h>\t\t/* IPPORT_RESERVED */", "", "#ifndef _PATH_HEQUIV", '# define\t_PATH_HEQUIV\t"/etc/hosts.equiv"', "#endif", '#define\t_PATH_HOSTS\t"/etc/hosts"', '#define\t_PATH_NETWORKS\t"/etc/networks"', '#define\t_PATH_PROTOCOLS\t"/etc/protocols"', '#define\t_PATH_SERVICES\t"/etc/services"', "", "extern int h_errno;", "", "#ifndef IPPORT_RESERVED", "#define\tIPPORT_RESERVED\t\t__DARWIN_IPPORT_RESERVED", "#endif", "", "/*", " * Structures returned by network data base library.  All addresses are", " * supplied in host order, and returned in network order (suitable for", " * use in system calls).", " */", "struct hostent {", "\tchar\t*h_name;\t/* official name of host */", "\tchar\t**h_aliases;\t/* alias list */", "\tint\th_addrtype;\t/* host address type */", "\tint\th_length;\t/* length of address */", "\tchar\t**h_addr_list;\t/* list of addresses from name server */", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "#define\th_addr\th_addr_list[0]\t/* address, for backward compatibility */", "#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */", "};", "", "/*", " * Assumption here is that a network number", " * fits in an unsigned long -- probably a poor one.", " */", "struct netent {", "\tchar\t\t*n_name;\t/* official name of net */", "\tchar\t\t**n_aliases;\t/* alias list */", "\tint\t\tn_addrtype;\t/* net address type */", "\tuint32_t\tn_net;\t\t/* network # */", "};", "", "struct servent {", "\tchar\t*s_name;\t/* official service name */", "\tchar\t**s_aliases;\t/* alias list */", "\tint\ts_port;\t\t/* port # */", "\tchar\t*s_proto;\t/* protocol to use */", "};", "", "struct protoent {", "\tchar\t*p_name;\t/* official protocol name */", "\tchar\t**p_aliases;\t/* alias list */", "\tint\tp_proto;\t/* protocol # */", "};", "", "struct addrinfo {", "\tint\tai_flags;\t/* AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST */", "\tint\tai_family;\t/* PF_xxx */", "\tint\tai_socktype;\t/* SOCK_xxx */", "\tint\tai_protocol;\t/* 0 or IPPROTO_xxx for IPv4 and IPv6 */", "\tsocklen_t ai_addrlen;\t/* length of ai_addr */", "\tchar\t*ai_canonname;\t/* canonical name for hostname */", "\tstruct\tsockaddr *ai_addr;\t/* binary address */", "\tstruct\taddrinfo *ai_next;\t/* next structure in linked list */", "};", "", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "struct rpcent {", "        char    *r_name;        /* name of server for this rpc program */", "        char    **r_aliases;    /* alias list */", "        int     r_number;       /* rpc program number */", "};", "#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */", "", "/*", " * Error return codes from gethostbyname() and gethostbyaddr()", " * (left in h_errno).", " */", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "#define\tNETDB_INTERNAL\t-1\t/* see errno */", "#define\tNETDB_SUCCESS\t0\t/* no problem */", "#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */", "#define\tHOST_NOT_FOUND\t1 /* Authoritative Answer Host not found */", "#define\tTRY_AGAIN\t2 /* Non-Authoritative Host not found, or SERVERFAIL */", "#define\tNO_RECOVERY\t3 /* Non recoverable errors, FORMERR, REFUSED, NOTIMP */", "#define\tNO_DATA\t\t4 /* Valid name, no data record of requested type */", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "#define\tNO_ADDRESS\tNO_DATA\t\t/* no address, look for MX record */", "#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */", "/*", " * Error return codes from getaddrinfo()", " */", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "#define\tEAI_ADDRFAMILY\t 1\t/* address family for hostname not supported */", "#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */", "#define\tEAI_AGAIN\t 2\t/* temporary failure in name resolution */", "#define\tEAI_BADFLAGS\t 3\t/* invalid value for ai_flags */", "#define\tEAI_FAIL\t 4\t/* non-recoverable failure in name resolution */", "#define\tEAI_FAMILY\t 5\t/* ai_family not supported */", "#define\tEAI_MEMORY\t 6\t/* memory allocation failure */", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "#define\tEAI_NODATA\t 7\t/* no address associated with hostname */", "#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */", "#define\tEAI_NONAME\t 8\t/* hostname nor servname provided, or not known */", "#define\tEAI_SERVICE\t 9\t/* servname not supported for ai_socktype */", "#define\tEAI_SOCKTYPE\t10\t/* ai_socktype not supported */", "#define\tEAI_SYSTEM\t11\t/* system error returned in errno */", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "#define\tEAI_BADHINTS\t12\t/* invalid value for hints */", "#define\tEAI_PROTOCOL\t13\t/* resolved protocol is unknown */", "#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */", "#define\tEAI_OVERFLOW\t14\t/* argument buffer overflow */", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "#define\tEAI_MAX\t\t15", "#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */", "", "/*", " * Flag values for getaddrinfo()", " */", "#define\tAI_PASSIVE\t0x00000001 /* get address to use bind() */", "#define\tAI_CANONNAME\t0x00000002 /* fill ai_canonname */", "#define\tAI_NUMERICHOST\t0x00000004 /* prevent host name resolution */", "#define\tAI_NUMERICSERV\t0x00001000 /* prevent service name resolution */", "/* valid flags for addrinfo (not a standard def, apps should not use it) */", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "#define AI_MASK \\", "    (AI_PASSIVE | AI_CANONNAME | AI_NUMERICHOST | AI_NUMERICSERV | \\", "    AI_ADDRCONFIG)", "", "#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */", "#define\tAI_ALL\t\t0x00000100 /* IPv6 and IPv4-mapped (with AI_V4MAPPED) */", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "#define\tAI_V4MAPPED_CFG\t0x00000200 /* accept IPv4-mapped if kernel supports */", "#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */", "#define\tAI_ADDRCONFIG\t0x00000400 /* only if any address is assigned */", "#define\tAI_V4MAPPED\t0x00000800 /* accept IPv4-mapped IPv6 address */", "/* special recommended flags for getipnodebyname */", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "#define\tAI_DEFAULT\t(AI_V4MAPPED_CFG | AI_ADDRCONFIG)", "#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */", "", "/*", " * Constants for getnameinfo()", " */", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "#define\tNI_MAXHOST\t1025", "#define\tNI_MAXSERV\t32", "#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */", "/*", " * Flag values for getnameinfo()", " */", "#define\tNI_NOFQDN\t0x00000001", "#define\tNI_NUMERICHOST\t0x00000002", "#define\tNI_NAMEREQD\t0x00000004", "#define\tNI_NUMERICSERV\t0x00000008", "#define\tNI_DGRAM\t0x00000010", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "#define NI_WITHSCOPEID\t0x00000020", "", "/*", " * Scope delimit character", " */", "#define\tSCOPE_DELIMITER\t'%'", "#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */", "", "__BEGIN_DECLS", "", "void\t\tendhostent(void);", "void\t\tendnetent(void);", "void\t\tendprotoent(void);", "void\t\tendservent(void);", "", "void\t\tfreeaddrinfo(struct addrinfo *);", "const char\t*gai_strerror(int);", "int\t\tgetaddrinfo(const char * __restrict, const char * __restrict,", "\t\t\t    const struct addrinfo * __restrict,", "\t\t\t    struct addrinfo ** __restrict);", "struct hostent\t*gethostbyaddr(const void *, socklen_t, int);", "struct hostent\t*gethostbyname(const char *);", "struct hostent\t*gethostent(void);", "int             getnameinfo(const struct sockaddr * __restrict, socklen_t,", "\t\t\t      char * __restrict, socklen_t, char * __restrict,", "\t\t\t      socklen_t, int);", "struct netent\t*getnetbyaddr(uint32_t, int);", "struct netent\t*getnetbyname(const char *);", "struct netent\t*getnetent(void);", "struct protoent\t*getprotobyname(const char *);", "struct protoent\t*getprotobynumber(int);", "struct protoent\t*getprotoent(void);", "struct servent\t*getservbyname(const char *, const char *);", "struct servent\t*getservbyport(int, const char *);", "struct servent\t*getservent(void);", "void\t\tsethostent(int);", "/* void\t\tsethostfile(const char *); */", "void\t\tsetnetent(int);", "void\t\tsetprotoent(int);", "void\t\tsetservent(int);", "", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "void\t\tfreehostent(struct hostent *);", "struct hostent\t*gethostbyname2(const char *, int);", "struct hostent\t*getipnodebyaddr(const void *, size_t, int, int *);", "struct hostent\t*getipnodebyname(const char *, int, int, int *);", "struct rpcent\t*getrpcbyname(const char *name);", "#ifdef __LP64__", "struct rpcent\t*getrpcbynumber(int number);", "#else", "struct rpcent\t*getrpcbynumber(long number);", "#endif", "struct rpcent\t*getrpcent(void);", "void\t\tsetrpcent(int stayopen);", "void\t\tendrpcent(void);", "void\t\therror(const char *);", "const char\t*hstrerror(int);", "int\t\t\tinnetgr(const char *, const char *, const char *, const char *);", "int\t\t\tgetnetgrent(char **, char **, char **);", "void\t\tendnetgrent(void);", "void\t\tsetnetgrent(const char *);", "#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */", "", "__END_DECLS", "", "#endif /* !_NETDB_H_ */" },
    ["nl_types.h"] = { "/*\t$NetBSD: nl_types.h,v 1.9 2000/10/03 19:53:32 sommerfeld Exp $\t*/", "", "/*-", " * Copyright (c) 1996 The NetBSD Foundation, Inc.", " * All rights reserved.", " *", " * This code is derived from software contributed to The NetBSD Foundation", " * by J.T. Conklin.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *        This product includes software developed by the NetBSD", " *        Foundation, Inc. and its contributors.", " * 4. Neither the name of The NetBSD Foundation nor the names of its", " *    contributors may be used to endorse or promote products derived", " *    from this software without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS", " * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED", " * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR", " * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS", " * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR", " * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF", " * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS", " * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN", " * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)", " * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE", " * POSSIBILITY OF SUCH DAMAGE.", " *", " * $FreeBSD: src/include/nl_types.h,v 1.11 2005/02/27 16:20:53 phantom Exp $", " */", "", "#ifndef _NL_TYPES_H_", "#define _NL_TYPES_H_", "", "#include <sys/cdefs.h>", "#include <sys/types.h>", "#include <_types.h>", "", "#ifdef _NLS_PRIVATE", "/*", " * MESSAGE CATALOG FILE FORMAT.", " *", " * The NetBSD/FreeBSD message catalog format is similar to the format used by", " * Svr4 systems.  The differences are:", " *   * fixed byte order (big endian)", " *   * fixed data field sizes", " *", " * A message catalog contains four data types: a catalog header, one", " * or more set headers, one or more message headers, and one or more", " * text strings.", " */", "", "#define _NLS_MAGIC\t0xff88ff89", "", "struct _nls_cat_hdr {", "\tint32_t __magic;", "\tint32_t __nsets;", "\tint32_t __mem;", "\tint32_t __msg_hdr_offset;", "\tint32_t __msg_txt_offset;", "} ;", "", "struct _nls_set_hdr {", "\tint32_t __setno;\t/* set number: 0 < x <= NL_SETMAX */", "\tint32_t __nmsgs;\t/* number of messages in the set  */", "\tint32_t __index;\t/* index of first msg_hdr in msg_hdr table */", "} ;", "", "struct _nls_msg_hdr {", "\tint32_t __msgno;\t/* msg number: 0 < x <= NL_MSGMAX */", "\tint32_t __msglen;", "\tint32_t __offset;", "} ;", "", "#endif\t/* _NLS_PRIVATE */", "", "#define\tNL_SETD\t\t1", "#define\tNL_CAT_LOCALE\t1", "", "typedef struct __nl_cat_d {", "\tvoid\t*__data;", "\tint\t__size;", "} *nl_catd;", "", "#include <_types/_nl_item.h>", "", "__BEGIN_DECLS", "nl_catd  catopen(const char *, int);", "char    *catgets(nl_catd, int, int, const char *)", "\t__attribute__((__format_arg__(4)));", "int\t catclose(nl_catd);", "__END_DECLS", "", "#endif\t/* _NL_TYPES_H_ */" },
    ["nlist.h"] = { "/*-", " * Copyright (c) 1991, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " * (c) UNIX System Laboratories, Inc.", " * All or some portions of this file are derived from material licensed", " * to the University of California by American Telephone and Telegraph", " * Co. or Unix System Laboratories, Inc. and are reproduced herein with", " * the permission of UNIX System Laboratories, Inc.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)nlist.h\t8.2 (Berkeley) 1/21/94", " */", "", "#ifndef _NLIST_H_", "#define\t_NLIST_H_", "", "/*", " * Symbol table entry format.  The #ifdef's are so that programs including", " * nlist.h can initialize nlist structures statically.", " */", "struct nlist {", "#ifdef _AOUT_INCLUDE_", "\tunion {", "\t\tchar *n_name;\t/* symbol name (in memory) */", "\t\tlong n_strx;\t/* file string table offset (on disk) */", "\t} n_un;", "#else", "\tchar *n_name;\t\t/* symbol name (in memory) */", "#endif", "", "#define\tN_UNDF\t0x00\t\t/* undefined */", "#define\tN_ABS\t0x02\t\t/* absolute address */", "#define\tN_TEXT\t0x04\t\t/* text segment */", "#define\tN_DATA\t0x06\t\t/* data segment */", "#define\tN_BSS\t0x08\t\t/* bss segment */", "#define\tN_COMM\t0x12\t\t/* common reference */", "#define\tN_FN\t0x1e\t\t/* file name */", "", "#define\tN_EXT\t0x01\t\t/* external (global) bit, OR'ed in */", "#define\tN_TYPE\t0x1e\t\t/* mask for all the type bits */", "\tunsigned char n_type;\t/* type defines */", "", "\tchar n_other;\t\t/* spare */", "#define\tn_hash\tn_desc\t\t/* used internally by ld(1); XXX */", "\tshort n_desc;\t\t/* used by stab entries */", "\tunsigned long n_value;\t/* address/value of the symbol */", "};", "", '#define\tN_FORMAT\t"%08x"\t/* namelist value format; XXX */', "#define\tN_STAB\t\t0x0e0\t/* mask for debugger symbols -- stab(5) */", "", "#include <sys/cdefs.h>", "", "__BEGIN_DECLS", "int nlist(const char *, struct nlist *);", "__END_DECLS", "", "#endif /* !_NLIST_H_ */" },
    ["notify.h"] = { "/*", " * Copyright (c) 2003-2010 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * Portions Copyright (c) 2003-2010 Apple Inc.  All Rights Reserved.", " *", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "", "#ifndef __NOTIFICATION_H__", "#define __NOTIFICATION_H__", "", "#include <sys/cdefs.h>", "#include <stdint.h>", "#include <mach/message.h>", "#include <Availability.h>", "#ifdef __BLOCKS__", "#include <dispatch/dispatch.h>", "#endif /* __BLOCKS__ */", "", "/*! @header", " * These routines allow processes to exchange stateless notification events.", " * Processes post notifications to a single system-wide notification server,", " * which then distributes notifications to client processes that have", " * registered to receive those notifications, including processes run by", " * other users.", " *", " * Notifications are associated with names in a namespace shared by all", " * clients of the system.  Clients may post notifications for names, and", " * may monitor names for posted notifications.  Clients may request", " * notification delivery by a number of different methods.", " *", " * Clients desiring to monitor names in the notification system must", " * register with the system, providing a name and other information", " * required for the desired notification delivery method.  Clients are", " * given an integer token representing the registration.", " *", " * Note that the kernel provides limited queues for mach message and file", " * descriptor messages.  It is important to make sure that clients read", " * mach ports and file descriptors frequently to prevent messages from", " * being lost due to resource limitations.  Clients that use signal-based", " * notification should be aware that signals are not delivered to", " * a process while it is running in a signal handler.  This may affect", " * the delivery of signals in close succession.", " *", " * Notifications may be coalesced in some cases.  Multiple events posted", " * for a name in rapid succession may result in a single notification sent", " * to clients registered for notification for that name.  Clients checking", " * for changes using the notify_check() routine cannot determine if", " * more than one event pas been posted since a previous call to ", " * notify_check() for that name.", " *", ' * "False positives" may occur in notify_check() when used with a token', " * generated by notify_register_check() due to implementation constraints.", " * This behavior may vary in future releases.  ", " *", " * Synchronization between two processes may be achieved using the", " * notify_set_state() and notify_get_state() routines.", " */", "", "/*! @defineblock Status Codes", " * Status codes returned by the API.", " */", "#define NOTIFY_STATUS_OK 0", "#define NOTIFY_STATUS_INVALID_NAME 1", "#define NOTIFY_STATUS_INVALID_TOKEN 2", "#define NOTIFY_STATUS_INVALID_PORT 3", "#define NOTIFY_STATUS_INVALID_FILE 4", "#define NOTIFY_STATUS_INVALID_SIGNAL 5", "#define NOTIFY_STATUS_INVALID_REQUEST 6", "#define NOTIFY_STATUS_NOT_AUTHORIZED 7", "#define NOTIFY_STATUS_FAILED 1000000", "/*! @/defineblock */", "", "/*!", " * Flag bits used for registration.", " */", "#define NOTIFY_REUSE 0x00000001", "", "", "__BEGIN_DECLS", "", "/*!", " * Post a notification for a name.", " *", " * This is the only call that is required for a notification producer.", " * Returns status.", " */", "uint32_t notify_post(const char *name);", "", "", "#ifdef __BLOCKS__", "typedef void (^notify_handler_t)(int token);", "", "/*!", " * @function   notify_register", " * @abstract   Request notification delivery to a dispatch queue.", " * @discussion When notifications are received by the process, the notify", " *             subsystem will deliver the registered Block to the target", " *             dispatch queue.  Notification blocks are not re-entrant,", " *             and subsequent notification Blocks will not be delivered", " *             for the same registration until the previous Block has", " *             returned.", " * @param name (input) The notification name.", " * @param out_token (output) The registration token.", " * @param queue (input) The dispatch queue to which the Block is submitted.", " *              The dispatch queue is retained by the notify subsystem while", " *              the notification is registered, and will be released when", " *              notification is canceled.", " * @param block (input) The Block to invoke on the dispatch queue in response", " *              to a notification.  The notification token is passed to the", " *              Block as an argument so that the callee can modify the state", " *              of the notification or cancel the registration.", " * @result Returns status.", " */", "uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)", "__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_3_2);", "#endif /* __BLOCKS__ */", "", "/*!", " * Creates a registration token be used with notify_check(),", " * but no active notifications will be delivered.", " *", " * @param name", " *    (input) notification name", " * @param out_token", " *    (output) registration token", " * @result Returns status.", " */", "uint32_t notify_register_check(const char *name, int *out_token);", "", "/*!", " * Request notification delivery by UNIX signal.", " *", " * A client may request signal notification for multiple names.  After a signal", " * is delivered, the notify_check() routine may be called with each notification ", " * token to determine which name (if any) generated the signal notification.", " *", " * @param name (input) notification name", " * @param sig (input) signal number (see signal(3))", " * @param out_token (output) notification token", " * @result Returns status.", " */", "uint32_t notify_register_signal(const char *name, int sig, int *out_token);", "", "/*!", " * Request notification by mach message.  ", " *", " * Notifications are delivered by an empty message sent to a mach port.", " * By default, a new port is allocated and a pointer to it is returned", ' * as the value of "notify_port".  A mach port previously returned by a ', " * call to this routine may be used for notifications if a pointer to that", " * port is passed in to the routine and NOTIFY_REUSE is set in the flags", " * parameter.  The notification service must be able to extract send", " * rights to the port.", " *", " * Note that the kernel limits the size of the message queue for any port.", " * If it is important that notifications should not be lost due to queue", " * overflow, clients should service messages quickly, and be careful about", " * using the same port for notifications for more than one name.", " *", " * A notification message has an empty message body.  The msgh_id field", " * in the mach message header will have the value of the notification", " * token.  If a port is reused for multiple notification registrations,", " * the msgh_id value may be used to determine which name generated", " * the notification.", " *", " * @param name", " *     (input) notification name", " * @param  out_token", " *     (output) notification token", " * @param  notify_port", " *     (input/output) pointer to a mach port", " * @result Returns status.", " */", "uint32_t notify_register_mach_port(const char *name, mach_port_t *notify_port, int flags, int *out_token);", "", "/*", " * Request notification by a write to a file descriptor. ", " *", " * Notifications are delivered by a write to a file descriptor.", " * By default, a new file descriptor is created and a pointer to it", ' * is returned as the value of "notify_fd".  A file descriptor created', " * by a previous call to this routine may be used for notifications if", " * a pointer to that file descriptor is passed in to the routine and", " * NOTIFY_REUSE is set in the flags parameter. ", " *", " * Note that the kernel limits the buffer space for queued writes on a", " * file descriptor.  If it is important that notifications should not be", " * lost due to queue overflow, clients should service messages quickly,", " * and be careful about using the same file descriptor for notifications", " * for more than one name.", " *", " * Notifications are delivered by an integer value written to the", " * file descriptor.  The value will match the notification token", " * for which the notification was generated.", " *", " * @param name", " *     (input) notification name", " * @param out_token", " *     (output) notification token", " * @param notify_fd", " *     (input/output) pointer to a file descriptor", " * @result Returns status.", " */", "uint32_t notify_register_file_descriptor(const char *name, int *notify_fd, int flags, int *out_token);", "", "/*!", " * Check if any notifications have been posted.", " *", " * Output parameter check is set to 0 for false, 1 for true.  Returns status.", " * check is set to true the first time notify_check is called for a token.", " * Subsequent calls set check to true when notifications have been posted for", " * the name associated with the notification token.  This routine is independent", " * of notify_post().  That is, check will be true if an application calls", " * notify_post() for a name and then calls notify_check() for a token associated", " * with that name.", " *", " * @param token", " *     (input)notification token", " * @param check", " *     (output) true/false indication", " * @result Returns status.", " */", "uint32_t notify_check(int token, int *check);", "", "/*!", " * Cancel notification and free resources associated with a notification", " * token.  Mach ports and file descriptor associated with a token are released ", " * (deallocated or closed) when all registration tokens associated with ", " * the port or file descriptor have been cancelled.", " *", " * @param token", " *     (input) notification token", " * @result Returns status.", " */", "uint32_t notify_cancel(int token);", "", "/*!", " * Suspend delivery of notifications for a token. Notifications for this token will be", " * pended and coalesced, then delivered following a matching call to notify_resume.", " * Calls to notify_suspend may be nested.  Notifications remain suspended until", " * an equal number of calls have been made to notify_resume.", " *", " * @param token", " *     (input) notification token", " * @result Returns status.", " */", "uint32_t notify_suspend(int token)", "__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0);", "", "/*!", " * Removes one level of suspension for a token previously suspended", " * by a call to notify_suspend.  Notifications will resume when a matching", " * call to notify_resume is made for each previous call to notify_suspend.", " * Notifications posted while a token is suspended are coalesced into", " * a single notification sent following a resumption.", " *", " * @param token", " *     (input) notification token", " * @result Returns status.", " */", "uint32_t notify_resume(int token)", "__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0);", "", "/*!", " * Set or get a state value associated with a notification token.", " * Each key in the notification namespace has an associated integer value available", " * for use by clients as for application-specific purposes.  A common usage is to ", " * allow two processes or threads to synchronize their activities.  For example, a", " * server process may need send a notification when a resource becomes available.", " * A client process can register for the notification, but when it starts up it will", " * not know whether the resource is available.  The server can set the state value,", " * and the client can check the value at startup time to synchronize with the server.", " *", " * Set the 64-bit integer state value.", " *", " * @param token", " *     (input) notification token", " * @param state64", " *     (input) 64-bit unsigned integer value", " * @result Returns status.", " */", "uint32_t notify_set_state(int token, uint64_t state64)", "__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_2_0);", "", "/*!", " * Get the 64-bit integer state value.", " *", " * @param token", " *     (input) notification token", " * @param state64", " *     (output) 64-bit unsigned integer value", " * @result Returns status.", " */", "uint32_t notify_get_state(int token, uint64_t *state64)", "__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_2_0);", "", "__END_DECLS", "", "#endif /* __NOTIFICATION_H__ */" },
    ["notify_keys.h"] = { "/*", " * Copyright (c) 2007-2009 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * Portions Copyright (c) 2007-2009 Apple Inc.  All Rights Reserved.", " *", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "", "/*", " * This file lists notification keys that are posted using the ", " * notify_post() API by various Mac OS X system services.", " * The exact circumstances under which services post these", " * notifications is controlled by those services, and may change", " * in future software releases.", " */", "", "/*", " * Directory Service notifications", " * These are posted by the DirectoryService daemon to advise clients that", " * cached data should be invalidated.", " */", '#define kNotifyDSCacheInvalidation "com.apple.system.DirectoryService.InvalidateCache"', '#define kNotifyDSCacheInvalidationGroup "com.apple.system.DirectoryService.InvalidateCache.group"', '#define kNotifyDSCacheInvalidationHost "com.apple.system.DirectoryService.InvalidateCache.host"', '#define kNotifyDSCacheInvalidationService "com.apple.system.DirectoryService.InvalidateCache.service"', '#define kNotifyDSCacheInvalidationUser "com.apple.system.DirectoryService.InvalidateCache.user"', "", "/*", " * File System notifications", " * These advise clients of various filesystem events.", " */", '#define kNotifyVFSMount "com.apple.system.kernel.mount"', '#define kNotifyVFSUnmount "com.apple.system.kernel.unmount"', '#define kNotifyVFSUpdate "com.apple.system.kernel.mountupdate"', '#define kNotifyVFSLowDiskSpace "com.apple.system.lowdiskspace"', '#define kNotifyVFSLowDiskSpaceRootFS "com.apple.system.lowdiskspace.system"', '#define kNotifyVFSLowDiskSpaceOtherFS "com.apple.system.lowdiskspace.user"', "", "/*", " * System Configuration notifications", " * These advise clients of changes in the system configuration", " * managed by the system configuration server (configd).", " * Note that a much richer set of notifications are available to", " * clients using the SCDynamicStore API.", " */", '#define kNotifySCHostNameChange "com.apple.system.hostname"', '#define kNotifySCNetworkChange "com.apple.system.config.network_change"', "", "/*", " * ASL notifications", " * Sent by syslogd to advise clients that new log messages have been", " * added to the ASL database.", " */", '#define kNotifyASLDBUpdate "com.apple.system.logger.message"', "", "/*", " * Time Zone change notification", " * Sent by notifyd when the system's timezone changes.", " */", '#define kNotifyTimeZoneChange "com.apple.system.timezone"', "", "/*", " * System clock change notification", " * Sent when a process modifies the system clock using the settimeofday system call.", " */", '#define kNotifyClockSet "com.apple.system.clock_set"' },
    ["ntsid.h"] = { "/*", " * Copyright (c) 2004 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " *", " * The contents of this file constitute Original Code as defined in and", " * are subject to the Apple Public Source License Version 1.1 (the", ' * "License").  You may not use this file except in compliance with the', " * License.  Please obtain a copy of the License at", " * http://www.apple.com/publicsource and read it before using this file.", " *", " * This Original Code and all software distributed under the License are", ' * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER', " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the", " * License for the specific language governing rights and limitations", " * under the License.", " *", " * @APPLE_LICENSE_HEADER_END@", " */", "", "#ifndef _NTSID_H_", "#define _NTSID_H_", "", "#include <sys/types.h>", "", "#define NTSID_MAX_AUTHORITIES 16", "", "typedef struct {", "\tu_int8_t\t\tsid_kind;", "\tu_int8_t\t\tsid_authcount;", "\tu_int8_t\t\tsid_authority[6];", "\tu_int32_t\t\tsid_authorities[NTSID_MAX_AUTHORITIES];", "} nt_sid_t;", "", "#endif /* !_NTSID_H_ */" },
    ["panel.h"] = { "/****************************************************************************", " * Copyright (c) 1998-2001,2006 Free Software Foundation, Inc.              *", " *                                                                          *", " * Permission is hereby granted, free of charge, to any person obtaining a  *", " * copy of this software and associated documentation files (the            *", ' * "Software"), to deal in the Software without restriction, including      *', " * without limitation the rights to use, copy, modify, merge, publish,      *", " * distribute, distribute with modifications, sublicense, and/or sell       *", " * copies of the Software, and to permit persons to whom the Software is    *", " * furnished to do so, subject to the following conditions:                 *", " *                                                                          *", " * The above copyright notice and this permission notice shall be included  *", " * in all copies or substantial portions of the Software.                   *", " *                                                                          *", ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *', " * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *", " * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *", " * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *", " * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *", " * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *", " * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *", " *                                                                          *", " * Except as contained in this notice, the name(s) of the above copyright   *", " * holders shall not be used in advertising or otherwise to promote the     *", " * sale, use or other dealings in this Software without prior written       *", " * authorization.                                                           *", " ****************************************************************************/", "", "/****************************************************************************", " *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1995                    *", " *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *", " ****************************************************************************/", "", "/* $Id: panel.h,v 1.10 2006/05/27 19:49:40 tom Exp $ */", "", "/* panel.h -- interface file for panels library */", "", "#ifndef NCURSES_PANEL_H_incl", "#define NCURSES_PANEL_H_incl 1", "", "#include <curses.h>", "", "typedef struct panel", "{", "  WINDOW *win;", "  struct panel *below;", "  struct panel *above;", "  NCURSES_CONST void *user;", "} PANEL;", "", "#if\tdefined(__cplusplus)", 'extern "C" {', "#endif", "", "extern NCURSES_EXPORT(WINDOW*) panel_window (const PANEL *);", "extern NCURSES_EXPORT(void)    update_panels (void);", "extern NCURSES_EXPORT(int)     hide_panel (PANEL *);", "extern NCURSES_EXPORT(int)     show_panel (PANEL *);", "extern NCURSES_EXPORT(int)     del_panel (PANEL *);", "extern NCURSES_EXPORT(int)     top_panel (PANEL *);", "extern NCURSES_EXPORT(int)     bottom_panel (PANEL *);", "extern NCURSES_EXPORT(PANEL*)  new_panel (WINDOW *);", "extern NCURSES_EXPORT(PANEL*)  panel_above (const PANEL *);", "extern NCURSES_EXPORT(PANEL*)  panel_below (const PANEL *);", "extern NCURSES_EXPORT(int)     set_panel_userptr (PANEL *, NCURSES_CONST void *);", "extern NCURSES_EXPORT(NCURSES_CONST void*) panel_userptr (const PANEL *);", "extern NCURSES_EXPORT(int)     move_panel (PANEL *, int, int);", "extern NCURSES_EXPORT(int)     replace_panel (PANEL *,WINDOW *);", "extern NCURSES_EXPORT(int)     panel_hidden (const PANEL *);", "", "#if\tdefined(__cplusplus)", "}", "#endif", "", "#endif /* NCURSES_PANEL_H_incl */", "", "/* end of panel.h */" },
    ["paths.h"] = { "/*", " * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/*\t$OpenBSD: paths.h,v 1.10 1997/11/09 00:29:02 bri Exp $\t*/", "/*\t$NetBSD: paths.h,v 1.10 1997/04/23 09:41:38 lukem Exp $\t*/", "", "/*", " * Copyright (c) 1989, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)paths.h\t8.1 (Berkeley) 6/2/93", " */", "", "#ifndef _PATHS_H_", "#define\t_PATHS_H_", "", "/* Default search path. */", '#define\t_PATH_DEFPATH\t"/usr/bin:/bin"', "/* All standard utilities path. */", '#define\t_PATH_STDPATH\t"/usr/bin:/bin:/usr/sbin:/sbin"', "", '#define\t_PATH_BSHELL\t"/bin/sh"', '#define\t_PATH_CONSOLE\t"/dev/console"', '#define\t_PATH_CSHELL\t"/bin/csh"', '#define _PATH_DEFTAPE\t"/dev/nrst0"', '#define\t_PATH_DEVDB\t"/var/run/dev.db"', '#define\t_PATH_DEVNULL\t"/dev/null"', '#define\t_PATH_DRUM\t"/dev/drum"', '#define\t_PATH_FSIRAND\t"/sbin/fsirand"', '#define\t_PATH_KMEM\t"/dev/kmem"', '#define\t_PATH_KVMDB\t"/var/db/kvm.db"', '#define\t_PATH_LOCALE\t"/usr/share/locale"', '#define\t_PATH_MAILDIR\t"/var/mail"', '#define\t_PATH_MAN\t"/usr/share/man"', '#define\t_PATH_MEM\t"/dev/mem"', '#define\t_PATH_NOLOGIN\t"/etc/nologin"', '#define\t_PATH_RSH\t"/usr/bin/rsh"', '#define\t_PATH_SENDMAIL\t"/usr/sbin/sendmail"', '#define\t_PATH_SHELLS\t"/etc/shells"', '#define\t_PATH_TTY\t"/dev/tty"', '#define\t_PATH_UNIX\t"/mach"', '#define\t_PATH_VI\t"/usr/bin/vi"', "", "/* Provide trailing slash, since mostly used for building pathnames. */", '#define\t_PATH_DEV\t"/dev/"', '#define\t_PATH_TMP\t"/tmp/"', '#define\t_PATH_UUCPLOCK\t"/var/spool/lock/"', '#define\t_PATH_VARDB\t"/var/db/"', '#define\t_PATH_VARRUN\t"/var/run/"', '#define\t_PATH_VARTMP\t"/var/tmp/"', "", "#include <sys/paths.h>", "", "#endif /* !_PATHS_H_ */" },
    ["pcap-bpf.h"] = { "/*-", " * Copyright (c) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * This code is derived from the Stanford/CMU enet packet filter,", " * (net/enet.c) distributed as part of 4.3BSD, and code contributed", " * to Berkeley by Steven McCanne and Van Jacobson both of Lawrence ", " * Berkeley Laboratory.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *      This product includes software developed by the University of", " *      California, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " * @(#) $Header: /tcpdump/master/libpcap/pcap-bpf.h,v 1.50 2007-04-01 21:43:55 guy Exp $ (LBL)", " */", "", "/*", " * For backwards compatibility.", " *", " * Note to OS vendors: do NOT get rid of this file!  Some applications", " * might expect to be able to include <pcap-bpf.h>.", " */", "#include <pcap/bpf.h>" },
    ["pcap-namedb.h"] = { "/*", " * Copyright (c) 1994, 1996", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the Computer Systems", " *\tEngineering Group at Lawrence Berkeley Laboratory.", " * 4. Neither the name of the University nor of the Laboratory may be used", " *    to endorse or promote products derived from this software without", " *    specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " * @(#) $Header: /tcpdump/master/libpcap/pcap-namedb.h,v 1.13 2006-10-04 18:13:32 guy Exp $ (LBL)", " */", "", "/*", " * For backwards compatibility.", " *", " * Note to OS vendors: do NOT get rid of this file!  Some applications", " * might expect to be able to include <pcap-namedb.h>.", " */", "#include <pcap/namedb.h>" },
    ["pcap.h"] = { "/*", " * Copyright (c) 1993, 1994, 1995, 1996, 1997", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the Computer Systems", " *\tEngineering Group at Lawrence Berkeley Laboratory.", " * 4. Neither the name of the University nor of the Laboratory may be used", " *    to endorse or promote products derived from this software without", " *    specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " * @(#) $Header: /tcpdump/master/libpcap/pcap.h,v 1.59 2006-10-04 18:09:22 guy Exp $ (LBL)", " */", "", "/*", " * For backwards compatibility.", " *", " * Note to OS vendors: do NOT get rid of this file!  Many applications", " * expect to be able to include <pcap.h>, and at least some of them", " * go through contortions in their configure scripts to try to detect", ' * OSes that have "helpfully" moved pcap.h to <pcap/pcap.h> without', " * leaving behind a <pcap.h> file.", " */", "#include <pcap/pcap.h>" },
    ["poll.h"] = { "/*", " * Copyright (c) 2004 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "#include <sys/poll.h>", "", "", "" },
    ["printerdb.h"] = { "/*", " * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * Portions Copyright (c) 1999 Apple Computer, Inc.  All Rights", " * Reserved.  This file contains Original Code and/or Modifications of", " * Original Code as defined in and that are subject to the Apple Public", ' * Source License Version 1.1 (the "License").  You may not use this file', " * except in compliance with the License.  Please obtain a copy of the", " * License at http://www.apple.com/publicsource and read it before using", " * this file.", " * ", " * The Original Code and all software distributed under the License are", ' * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER', " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE OR NON- INFRINGEMENT.  Please see the", " * License for the specific language governing rights and limitations", " * under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/* ", " * Printer database lookup routines", " * Copyright (c) 1989 by NeXT, Inc. ", " */", "", "#ifndef _PRDB_H_", "#define _PRDB_H_", "", "typedef struct prdb_property {", "\tchar *pp_key;", "\tchar *pp_value;", "} prdb_property;", "", "typedef struct prdb_ent {", "\tchar **pe_name;", "\tunsigned pe_nprops;", "\tprdb_property *pe_prop;", "} prdb_ent;", "", "#include <sys/cdefs.h>", "", "__BEGIN_DECLS", "", "void prdb_set __P((const char *));", "const prdb_ent *prdb_get __P((void));", "const prdb_ent *prdb_getbyname __P((const char *));", "void prdb_end __P((void));", "", "__END_DECLS", "", "#endif /* !_PRDB_H_ */" },
    ["printf.h"] = { "/*-", " * Copyright (c) 2005 Poul-Henning Kamp", " * All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " *", " * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " * $FreeBSD: src/include/printf.h,v 1.5 2011/03/06 17:45:37 pjd Exp $", " */", "", "#ifndef _PRINTF_H_", "#define _PRINTF_H_", "", "/****************************************************************************", " * This is the header file for extensible printf, a set of APIs that allow", " * adding/modifying conversion specifier(s) for stdio formatted printing.", " * It is based on the GLIBC API documented in:", " *", " *   http://www.gnu.org/software/libc/manual/html_node/Customizing-Printf.html", " *", " * Because that API affects printf behavior process-wide and so is unsafe,", " * we adapt a modified form, based on the concept of printf domains in which", " * changes to conversion specifiers can be made independent of one another", " * and which don't affect the normal printf behavior.  In addition, there", " * is now a set of printf variants that take a printf domain as an argument.", " *", " * See xprintf(5) for more details.", " ****************************************************************************/", "", "#include <stdio.h>", "#include <wchar.h>", "#include <xlocale.h>", "#include <Availability.h>", "", "#ifdef __GNUC__", "#define __XPRINTF_ATTR(x)\t__attribute__(x)", "#else /* !__GNUC__ */", "#define __XPRINTF_ATTR(x)\t/* nothing */", "#endif /* !__GNUC__ */", "", "/*", " * The API defined by GLIBC allows a renderer to take multiple arguments", " * This is obviously usable for things like (ptr+len) pairs etc.", " * The current limit is to deal with up to __PRINTFMAXARG arguments (any", " * above this limit are ignored).", " */", "#define __PRINTFMAXARG\t\t2", "", "struct printf_info {", "\t/* Mac OS X extensions */", "\tvoid\t\t*context;\t\t/* User context pointer */", "\tlocale_t\tloc;\t\t\t/* Extended locale */", "\twchar_t\t\tvsep;\t\t\t/* Vector separator char */", "\t\t\t\t\t\t/* one of ,:;_ flag or X by default */", "", "\t/* GLIBC compatible */", "\tint\t\tprec;\t\t\t/* precision */", "\tint\t\twidth;\t\t\t/* Width */", "\twchar_t\t\tspec;\t\t\t/* Format letter */", "\twchar_t\t\tpad;\t\t\t/* Padding char */", "\t\t\t\t\t\t/* 0 if 0 flag set, otherwise space */", "", "\t/* FreeBSD extensions */", "\twchar_t\t\tsignchar;\t\t/* Sign char */", "", "\t/* GLIBC compatible flags */", "\tunsigned\tis_long_double\t:1;\t/* L or ll flag */", "\tunsigned\tis_char\t\t:1;\t/* hh flag */", "\tunsigned\tis_short\t:1;\t/* h flag */", "\tunsigned\tis_long\t\t:1;\t/* l flag */", "\tunsigned\talt\t\t:1;\t/* # flag */", "\tunsigned\tspace\t\t:1;\t/* Space flag */", "\tunsigned\tleft\t\t:1;\t/* - flag */", "\tunsigned\tshowsign\t:1;\t/* + flag */", "\tunsigned\tgroup\t\t:1;\t/* ' flag */", "\tunsigned\textra\t\t:1;\t/* For special use (currently unused) */", "\tunsigned\twide\t\t:1;\t/* Nonzero for wide character streams (currently unused) */", "", "\t/* FreeBSD flags */", "\tunsigned\tis_quad\t\t:1;\t/* q flag */", "\tunsigned\tis_intmax\t:1;\t/* j flag */", "\tunsigned\tis_ptrdiff\t:1;\t/* t flag */", "\tunsigned\tis_size\t\t:1;\t/* z flag */", "", "\t/* Mac OS X flags */", "\tunsigned\tis_vec\t\t:1;\t/* v flag */", "", "\t/* private */", "\tint\t\tsofar;", "\tunsigned\tget_width;", "\tunsigned\tget_prec;", "\tconst char\t*begin;", "\tconst char\t*end;", "\tvoid \t\t*arg[__PRINTFMAXARG];", "};", "", "enum {", "\tPA_INT\t\t= (1 << 0),\t/* int */", "\tPA_CHAR\t\t= (1 << 1),\t/* int, cast to char */", "\tPA_WCHAR\t= (1 << 2),\t/* wide char */", "\tPA_STRING\t= (1 << 3),\t/* const char * (with '\\0') */", "\tPA_WSTRING\t= (1 << 4),\t/* const wchar_t * */", "\tPA_POINTER\t= (1 << 5),\t/* void * */", "\tPA_FLOAT\t= (1 << 6),\t/* float (Defined but unused; best to avoid.) */", "\tPA_DOUBLE\t= (1 << 7), \t/* double */", "\tPA_VECTOR\t= (1 << 8), \t/* vector */", "};", "", "#define\tPA_FLAG_MASK\t\t0xff0000", "#define\tPA_FLAG_LONG_LONG\t(1 << 16)", "#define\tPA_FLAG_LONG\t\t(1 << 17)", "#define\tPA_FLAG_SHORT\t\t(1 << 18)", "#define\tPA_FLAG_PTR\t\t(1 << 19)", "#define\tPA_FLAG_QUAD\t\t(1 << 20)", "#define\tPA_FLAG_INTMAX\t\t(1 << 21)", "#define\tPA_FLAG_SIZE\t\t(1 << 22)", "#define\tPA_FLAG_PTRDIFF\t\t(1 << 23)", "#define\tPA_FLAG_LONG_DOUBLE\tPA_FLAG_LONG_LONG", "", "/************************ Basic Extensible Printf APIs ************************/", "", "typedef int printf_arginfo_function(const struct printf_info *__info,", "\t     size_t __n, int *__argtypes);", "typedef int printf_function(FILE *__stream,", "\t     const struct printf_info *__info, const void *const *__args);", "", "/*", " * We don't support the GLIBC register_printf_function() or FreeBSD", " * register_printf_render_std(), because they affect printf globally", " * and are unsafe.", " */", "", "/*************** Extensible Printf Domains APIs ****************/", "", "struct _printf_domain; /* forward reference */", "typedef struct _printf_domain *printf_domain_t;", "", "__BEGIN_DECLS", "", "printf_domain_t\tcopy_printf_domain(printf_domain_t __domain)", "\t\t __XPRINTF_ATTR((__nonnull__(1)))", "\t\t __OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_7_0);", "void\t\tfree_printf_domain(printf_domain_t __domain)", "\t\t __OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_7_0);", "printf_domain_t\tnew_printf_domain(void)", "\t\t __XPRINTF_ATTR((__malloc__))", "\t\t __OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_7_0);", "int\tregister_printf_domain_function(printf_domain_t __domain,", "\t int __spec, printf_function *__render,", "\t printf_arginfo_function *__arginfo, void *__context)", "\t __XPRINTF_ATTR((__nonnull__(1)))", "\t __OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_7_0);", "int\tregister_printf_domain_render_std(printf_domain_t __domain,", "\t const char *__specs)", "\t __XPRINTF_ATTR((__nonnull__(1)))", "\t __OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_7_0);", "", "/**** All-in-one extensible printf variants ****/", "int\tasxprintf(char ** __restrict __ret,", "\t printf_domain_t __restrict __domain, locale_t __restrict __loc,", "\t const char * __restrict __format, ...)", "\t __XPRINTF_ATTR((__nonnull__(1, 2, 4)))", "\t __OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_7_0);", "int\tdxprintf(int __fd, printf_domain_t __restrict __domain,", "\t locale_t __restrict __loc, const char * __restrict __format, ...)", "\t __XPRINTF_ATTR((__nonnull__(2, 4)))", "\t __OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_7_0);", "int\tfxprintf(FILE * __restrict __stream,", "\t printf_domain_t __restrict __domain, locale_t __restrict __loc,", "\t const char * __restrict __format, ...)", "\t __XPRINTF_ATTR((__nonnull__(1, 2, 4)))", "\t __OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_7_0);", "int\tsxprintf(char * __restrict __str, size_t __size,", "\t printf_domain_t __restrict __domain, locale_t __restrict __loc,", "\t const char * __restrict __format, ...)", "\t __XPRINTF_ATTR((__nonnull__(1, 3, 5)))", "\t __OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_7_0);", "int\txprintf(printf_domain_t __restrict __domain,", "\t locale_t __restrict __loc, const char * __restrict __format, ...)", "\t __XPRINTF_ATTR((__nonnull__(1, 3)))", "\t __OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_7_0);", "", "int\tvasxprintf(char ** __restrict __ret,", "\t printf_domain_t __restrict __domain, locale_t __restrict __loc,", "\t const char * __restrict __format, va_list __ap)", "\t __XPRINTF_ATTR((__nonnull__(1, 2, 4)))", "\t __OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_7_0);", "int\tvdxprintf(int __fd, printf_domain_t __restrict __domain,", "\t locale_t __restrict __loc, const char * __restrict __format,", "\t va_list __ap)", "\t __XPRINTF_ATTR((__nonnull__(2, 4)))", "\t __OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_7_0);", "int\tvfxprintf(FILE * __restrict __stream,", "\t printf_domain_t __restrict __domain, locale_t __restrict __loc,", "\t const char * __restrict __format, va_list __ap)", "\t __XPRINTF_ATTR((__nonnull__(1, 2, 4)))", "\t __OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_7_0);", "int\tvsxprintf(char * __restrict __str, size_t __size,", "\t printf_domain_t __restrict __domain, locale_t __restrict __loc,", "\t const char * __restrict __format, va_list __ap)", "\t __XPRINTF_ATTR((__nonnull__(1, 3, 5)))", "\t __OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_7_0);", "int\tvxprintf(printf_domain_t __restrict __domain,", "\t locale_t __restrict __loc, const char * __restrict __format,", "\t va_list __ap)", "\t __XPRINTF_ATTR((__nonnull__(1, 3)))", "\t __OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_7_0);", "", "__END_DECLS", "", "/******** Extensible Printf Compilation/Execution APIs *********/", "struct _printf_compiled; /* forward reference */", "typedef struct _printf_compiled *printf_comp_t;", "", "__BEGIN_DECLS", "", "void\t\tfree_printf_comp(printf_comp_t __pc)", "\t\t __OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_7_0);", "printf_comp_t\tnew_printf_comp(printf_domain_t __restrict __domain,", "\t\t locale_t __restrict __loc, const char * __restrict __fmt)", "\t\t __XPRINTF_ATTR((__nonnull__(1, 3)))", "\t\t __OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_7_0);", "", "/**** Extensible printf execution ****/", "int\tasxprintf_exec(char ** __restrict __ret,", "\t printf_comp_t __restrict __pc, ...)", "\t __XPRINTF_ATTR((__nonnull__(1, 2)))", "\t __OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_7_0);", "int\tdxprintf_exec(int __fd, printf_comp_t __restrict __pc, ...)", "\t __XPRINTF_ATTR((__nonnull__(2)))", "\t __OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_7_0);", "int\tfxprintf_exec(FILE * __restrict __stream,", "\t printf_comp_t __restrict __pc, ...)", "\t __XPRINTF_ATTR((__nonnull__(1, 2)))", "\t __OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_7_0);", "int\tsxprintf_exec(char * __restrict __str, size_t __size,", "\t printf_comp_t __restrict __pc, ...)", "\t __XPRINTF_ATTR((__nonnull__(1, 3)))", "\t __OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_7_0);", "int\txprintf_exec(printf_comp_t __restrict __pc, ...)", "\t __XPRINTF_ATTR((__nonnull__(1)))", "\t __OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_7_0);", "", "int\tvasxprintf_exec(char ** __restrict __ret,", "\t printf_comp_t __restrict __pc, va_list __ap)", "\t __XPRINTF_ATTR((__nonnull__(1, 2)))", "\t __OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_7_0);", "int\tvdxprintf_exec(int __fd, printf_comp_t __restrict __pc,", "\t va_list __ap)", "\t __XPRINTF_ATTR((__nonnull__(2)))", "\t __OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_7_0);", "int\tvfxprintf_exec(FILE * __restrict __stream,", "\t printf_comp_t __restrict __pc, va_list __ap)", "\t __XPRINTF_ATTR((__nonnull__(1, 2)))", "\t __OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_7_0);", "int\tvsxprintf_exec(char * __restrict __str, size_t __size,", "\t printf_comp_t __restrict __pc, va_list __ap)", "\t __XPRINTF_ATTR((__nonnull__(1, 3)))", "\t __OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_7_0);", "int\tvxprintf_exec(printf_comp_t __restrict __pc, va_list __ap)", "\t __XPRINTF_ATTR((__nonnull__(1)))", "\t __OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_7_0);", "", "__END_DECLS", "", "#endif /* !_PRINTF_H */" },
    ["profile.h"] = { "/*", " * This file is auto generated.  Please do not edit it.", " */", "", "#ifndef __KERBEROSPROFILE__", "#define __KERBEROSPROFILE__", "", "/*", " * profile.h", " */", "", "#ifndef _KRB5_PROFILE_H", "#define _KRB5_PROFILE_H", "", "#if defined(_WIN32)", "#include <win-mac.h>", "#endif", "", "#if defined(__MACH__) && defined(__APPLE__)", "#    include <TargetConditionals.h>", "#    if TARGET_RT_MAC_CFM", '#        error "Use KfM 4.0 SDK headers for CFM compilation."', "#    endif", "#endif", "", "#ifndef KRB5_CALLCONV", "#define KRB5_CALLCONV", "#define KRB5_CALLCONV_C", "#endif", "", "typedef struct _profile_t *profile_t;", "", "/*", " * Used by the profile iterator in prof_get.c", " */", "#define PROFILE_ITER_LIST_SECTION\t0x0001", "#define PROFILE_ITER_SECTIONS_ONLY\t0x0002", "#define PROFILE_ITER_RELATIONS_ONLY\t0x0004", "", "#ifdef __cplusplus", 'extern "C" {', "#endif /* __cplusplus */", "", "typedef char* profile_filespec_t;\t/* path as C string */", "typedef char* profile_filespec_list_t;\t/* list of : separated paths, C string */", "typedef const char * const_profile_filespec_t;\t/* path as C string */", "typedef const char * const_profile_filespec_list_t;\t/* list of : separated paths, C string */", "", "long KRB5_CALLCONV profile_init", "\t(const_profile_filespec_t *files, profile_t *ret_profile);", "", "long KRB5_CALLCONV profile_init_path", "\t(const_profile_filespec_list_t filelist, profile_t *ret_profile);", "", "void KRB5_CALLCONV profile_configuration_updated", "\t(void);", "", "long KRB5_CALLCONV profile_flush", "\t(profile_t profile);", "long KRB5_CALLCONV profile_flush_to_file", "\t(profile_t profile, const_profile_filespec_t outfile);", "long KRB5_CALLCONV profile_flush_to_buffer", "\t(profile_t profile, char **bufp);", "void KRB5_CALLCONV profile_free_buffer", "\t(profile_t profile, char *buf);", "", "long KRB5_CALLCONV profile_is_writable", "\t(profile_t profile, int *writable);", "long KRB5_CALLCONV profile_is_modified", "\t(profile_t profile, int *modified);", "", "void KRB5_CALLCONV profile_abandon", "\t(profile_t profile);", "", "void KRB5_CALLCONV profile_release", "\t(profile_t profile);", "", "long KRB5_CALLCONV profile_get_values", "\t(profile_t profile, const char *const *names, char ***ret_values);", "", "void KRB5_CALLCONV profile_free_list", "\t(char **list);", "", "long KRB5_CALLCONV profile_get_string", "\t(profile_t profile, const char *name, const char *subname, ", "\t\t\tconst char *subsubname, const char *def_val,", "\t\t\tchar **ret_string);", "long KRB5_CALLCONV profile_get_integer", "\t(profile_t profile, const char *name, const char *subname,", "\t\t\tconst char *subsubname, int def_val,", "\t\t\tint *ret_default);", "", "long KRB5_CALLCONV profile_get_boolean", "\t(profile_t profile, const char *name, const char *subname,", "\t\t\tconst char *subsubname, int def_val,", "\t\t\tint *ret_default);", "", "long KRB5_CALLCONV profile_get_relation_names", "\t(profile_t profile, const char **names, char ***ret_names);", "", "long KRB5_CALLCONV profile_get_subsection_names", "\t(profile_t profile, const char **names, char ***ret_names);", "", "long KRB5_CALLCONV profile_iterator_create", "\t(profile_t profile, const char *const *names,", "\t\t   int flags, void **ret_iter);", "", "void KRB5_CALLCONV profile_iterator_free", "\t(void **iter_p);", "\t", "long KRB5_CALLCONV profile_iterator", "\t(void\t**iter_p, char **ret_name, char **ret_value);", "", "void KRB5_CALLCONV profile_release_string (char *str);", "", "long KRB5_CALLCONV profile_update_relation", "\t(profile_t profile, const char **names, ", "\t\t   const char *old_value, const char *new_value);", "", "long KRB5_CALLCONV profile_clear_relation", "\t(profile_t profile, const char **names);", "", "long KRB5_CALLCONV profile_rename_section", "\t(profile_t profile, const char **names, ", "\t\t   const char *new_name);", "", "long KRB5_CALLCONV profile_add_relation", "\t(profile_t profile, const char **names, ", "\t\t   const char *new_value);", "", "#ifdef __cplusplus", "}", "#endif /* __cplusplus */", "", "#endif /* _KRB5_PROFILE_H */", "/*", " * et-h-prof_err.h:", " * This file is automatically generated; please do not edit it.", " */", "", "#include <com_err.h>", "", "#define PROF_VERSION                             (-1429577728L)", "#define PROF_MAGIC_NODE                          (-1429577727L)", "#define PROF_NO_SECTION                          (-1429577726L)", "#define PROF_NO_RELATION                         (-1429577725L)", "#define PROF_ADD_NOT_SECTION                     (-1429577724L)", "#define PROF_SECTION_WITH_VALUE                  (-1429577723L)", "#define PROF_BAD_LINK_LIST                       (-1429577722L)", "#define PROF_BAD_GROUP_LVL                       (-1429577721L)", "#define PROF_BAD_PARENT_PTR                      (-1429577720L)", "#define PROF_MAGIC_ITERATOR                      (-1429577719L)", "#define PROF_SET_SECTION_VALUE                   (-1429577718L)", "#define PROF_EINVAL                              (-1429577717L)", "#define PROF_READ_ONLY                           (-1429577716L)", "#define PROF_SECTION_NOTOP                       (-1429577715L)", "#define PROF_SECTION_SYNTAX                      (-1429577714L)", "#define PROF_RELATION_SYNTAX                     (-1429577713L)", "#define PROF_EXTRA_CBRACE                        (-1429577712L)", "#define PROF_MISSING_OBRACE                      (-1429577711L)", "#define PROF_MAGIC_PROFILE                       (-1429577710L)", "#define PROF_MAGIC_SECTION                       (-1429577709L)", "#define PROF_TOPSECTION_ITER_NOSUPP              (-1429577708L)", "#define PROF_INVALID_SECTION                     (-1429577707L)", "#define PROF_END_OF_SECTIONS                     (-1429577706L)", "#define PROF_BAD_NAMESET                         (-1429577705L)", "#define PROF_NO_PROFILE                          (-1429577704L)", "#define PROF_MAGIC_FILE                          (-1429577703L)", "#define PROF_FAIL_OPEN                           (-1429577702L)", "#define PROF_EXISTS                              (-1429577701L)", "#define PROF_BAD_BOOLEAN                         (-1429577700L)", "#define PROF_BAD_INTEGER                         (-1429577699L)", "#define PROF_MAGIC_FILE_DATA                     (-1429577698L)", "#define ERROR_TABLE_BASE_prof (-1429577728L)", "", "extern const struct error_table et_prof_error_table;", "", "#if !defined(_WIN32)", "/* for compatibility with older versions... */", "extern void initialize_prof_error_table (void) /*@modifies internalState@*/;", "#else", "#define initialize_prof_error_table()", "#endif", "", "#if !defined(_WIN32)", "#define init_prof_err_tbl initialize_prof_error_table", "#define prof_err_base ERROR_TABLE_BASE_prof", "#endif", "", "#endif /* __KERBEROSPROFILE__ */" },
    ["pthread.h"] = { "/*", " * Copyright (c) 2000-2012 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " *", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " *", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " *", " * @APPLE_LICENSE_HEADER_END@", " */", "/*", " * Copyright 1996 1995 by Open Software Foundation, Inc. 1997 1996 1995 1994 1993 1992 1991", " *              All Rights Reserved", " *", " * Permission to use, copy, modify, and distribute this software and", " * its documentation for any purpose and without fee is hereby granted,", " * provided that the above copyright notice appears in all copies and", " * that both the copyright notice and this permission notice appear in", " * supporting documentation.", " *", " * OSF DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE", " * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS", " * FOR A PARTICULAR PURPOSE.", " *", " * IN NO EVENT SHALL OSF BE LIABLE FOR ANY SPECIAL, INDIRECT, OR", " * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM", " * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,", " * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION", " * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.", " *", " */", "/*", " * MkLinux", " */", "", "/*", " * POSIX Threads - IEEE 1003.1c", " */", "", "#ifndef _PTHREAD_H", "#define _PTHREAD_H", "", "#include <_types.h>", "#ifndef __POSIX_LIB__", "#include <pthread_impl.h>", "#endif", "#include <sched.h>", "#include <time.h>", "#include <sys/_types/_pthread_attr_t.h>", "#include <sys/_types/_pthread_cond_t.h>", "#include <sys/_types/_pthread_condattr_t.h>", "#include <sys/_types/_pthread_key_t.h>", "#include <sys/_types/_pthread_mutex_t.h>", "#include <sys/_types/_pthread_mutexattr_t.h>", "#include <sys/_types/_pthread_once_t.h>", "#include <sys/_types/_pthread_rwlock_t.h>", "#include <sys/_types/_pthread_rwlockattr_t.h>", "#include <sys/_types/_pthread_t.h>", "", "#if (!defined(_POSIX_C_SOURCE) && !defined(_XOPEN_SOURCE)) || defined(_DARWIN_C_SOURCE)", "", "#include <sys/_types/_mach_port_t.h>", "#include <sys/_types/_sigset_t.h>", "", "#endif /* (!_POSIX_C_SOURCE && !_XOPEN_SOURCE) || _DARWIN_C_SOURCE */", "", "/*", " * These symbols indicate which [optional] features are available", " * They can be tested at compile time via '#ifdef XXX'", " * The way to check for pthreads is like so:", "", " * #include <unistd.h>", " * #ifdef _POSIX_THREADS", " * #include <pthread.h>", " * #endif", "", " */", "", "/* These will be moved to unistd.h */", "", "/*", " * Note: These data structures are meant to be opaque.  Only enough", " * structure is exposed to support initializers.", " * All of the typedefs will be moved to <sys/types.h>", " */", "", "#include <sys/cdefs.h>", "#include <Availability.h>", "", "__BEGIN_DECLS", "/*", " * Threads", " */", "", "", "/*", " * Cancel cleanup handler management.  Note, since these are implemented as macros,", " * they *MUST* occur in matched pairs!", " */", "", "#define pthread_cleanup_push(func, val) \\", "   { \\", "\t     struct __darwin_pthread_handler_rec __handler; \\", "\t     pthread_t __self = pthread_self(); \\", "\t     __handler.__routine = func; \\", "\t     __handler.__arg = val; \\", "\t     __handler.__next = __self->__cleanup_stack; \\", "\t     __self->__cleanup_stack = &__handler;", "", "#define pthread_cleanup_pop(execute) \\", "\t     /* Note: 'handler' must be in this same lexical context! */ \\", "\t     __self->__cleanup_stack = __handler.__next; \\", "\t     if (execute) (__handler.__routine)(__handler.__arg); \\", "   }", "", "/*", " * Thread attributes", " */", "", "#define PTHREAD_CREATE_JOINABLE      1", "#define PTHREAD_CREATE_DETACHED      2", "", "#define PTHREAD_INHERIT_SCHED        1", "#define PTHREAD_EXPLICIT_SCHED       2", "", "#define PTHREAD_CANCEL_ENABLE        0x01  /* Cancel takes place at next cancellation point */", "#define PTHREAD_CANCEL_DISABLE       0x00  /* Cancel postponed */", "#define PTHREAD_CANCEL_DEFERRED      0x02  /* Cancel waits until cancellation point */", "#define PTHREAD_CANCEL_ASYNCHRONOUS  0x00  /* Cancel occurs immediately */", "", "/* Value returned from pthread_join() when a thread is canceled */", "#define PTHREAD_CANCELED\t     ((void *) 1)", "", "/* We only support PTHREAD_SCOPE_SYSTEM */", "#define PTHREAD_SCOPE_SYSTEM         1", "#define PTHREAD_SCOPE_PROCESS        2", "", "/* We only support PTHREAD_PROCESS_PRIVATE */", "#define PTHREAD_PROCESS_SHARED         1", "#define PTHREAD_PROCESS_PRIVATE        2", "", "/*", " * Mutex protocol attributes", " */", "#define PTHREAD_PRIO_NONE            0", "#define PTHREAD_PRIO_INHERIT         1", "#define PTHREAD_PRIO_PROTECT         2", "", "/*", " * Mutex type attributes", " */", "#define PTHREAD_MUTEX_NORMAL\t\t0", "#define PTHREAD_MUTEX_ERRORCHECK\t1", "#define PTHREAD_MUTEX_RECURSIVE\t\t2", "#define PTHREAD_MUTEX_DEFAULT\t\tPTHREAD_MUTEX_NORMAL", "", "/*", " * RWLock variables", " */", "#define PTHREAD_RWLOCK_INITIALIZER {_PTHREAD_RWLOCK_SIG_init, {0}}", "", "/*", " * Mutex variables", " */", "#define PTHREAD_MUTEX_INITIALIZER {_PTHREAD_MUTEX_SIG_init, {0}}", "", "/* <rdar://problem/10854763> */", "#if ((__MAC_OS_X_VERSION_MIN_REQUIRED && __MAC_OS_X_VERSION_MIN_REQUIRED >= 1070) || (__IPHONE_OS_VERSION_MIN_REQUIRED && __IPHONE_OS_VERSION_MIN_REQUIRED >= 50000))", "#\tif (!defined(_POSIX_C_SOURCE) && !defined(_XOPEN_SOURCE)) || defined(_DARWIN_C_SOURCE)", "#\t\tdefine PTHREAD_ERRORCHECK_MUTEX_INITIALIZER {_PTHREAD_ERRORCHECK_MUTEX_SIG_init, {0}}", "#\t\tdefine PTHREAD_RECURSIVE_MUTEX_INITIALIZER {_PTHREAD_RECURSIVE_MUTEX_SIG_init, {0}}", "#\tendif /* (!_POSIX_C_SOURCE && !_XOPEN_SOURCE) || _DARWIN_C_SOURCE */", "#endif", "", "/*", " * Condition variable attributes", " */", "", "/*", " * Condition variables", " */", "", "#define PTHREAD_COND_INITIALIZER {_PTHREAD_COND_SIG_init, {0}}", "", "/*", " * Initialization control (once) variables", " */", "", "#define PTHREAD_ONCE_INIT {_PTHREAD_ONCE_SIG_init, {0}}", "", "/*", " * Prototypes for all PTHREAD interfaces", " */", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_atfork(void (*)(void), void (*)(void), void (*)(void));", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_attr_destroy(pthread_attr_t *);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_attr_getdetachstate(const pthread_attr_t *, int *);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_attr_getguardsize(const pthread_attr_t * __restrict, size_t * __restrict);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_attr_getinheritsched(const pthread_attr_t * __restrict, int * __restrict);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_attr_getschedparam(const pthread_attr_t * __restrict,", "\t\tstruct sched_param * __restrict);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_attr_getschedpolicy(const pthread_attr_t * __restrict, int * __restrict);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_attr_getscope(const pthread_attr_t * __restrict, int * __restrict);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_attr_getstack(const pthread_attr_t * __restrict, void ** __restrict,", "\t\tsize_t * __restrict);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_attr_getstackaddr(const pthread_attr_t * __restrict, void ** __restrict);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_attr_getstacksize(const pthread_attr_t * __restrict, size_t * __restrict);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_attr_init(pthread_attr_t *);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_attr_setdetachstate(pthread_attr_t *, int);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_attr_setguardsize(pthread_attr_t *, size_t);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_attr_setinheritsched(pthread_attr_t *, int);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_attr_setschedparam(pthread_attr_t * __restrict,", "\t\tconst struct sched_param * __restrict);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_attr_setschedpolicy(pthread_attr_t *, int);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_attr_setscope(pthread_attr_t *, int);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_attr_setstack(pthread_attr_t *, void *, size_t);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_attr_setstackaddr(pthread_attr_t *, void *);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_attr_setstacksize(pthread_attr_t *, size_t);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_cancel(pthread_t) __DARWIN_ALIAS(pthread_cancel);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_cond_broadcast(pthread_cond_t *);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_cond_destroy(pthread_cond_t *);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_cond_init(pthread_cond_t * __restrict,", "\t\tconst pthread_condattr_t * __restrict) __DARWIN_ALIAS(pthread_cond_init);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_cond_signal(pthread_cond_t *);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_cond_timedwait(pthread_cond_t * __restrict, pthread_mutex_t * __restrict,", "\t\tconst struct timespec * __restrict) __DARWIN_ALIAS_C(pthread_cond_timedwait);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_cond_wait(pthread_cond_t * __restrict,", "\t\tpthread_mutex_t * __restrict) __DARWIN_ALIAS_C(pthread_cond_wait);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_condattr_destroy(pthread_condattr_t *);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_condattr_init(pthread_condattr_t *);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_condattr_getpshared(const pthread_condattr_t * __restrict,", "\t\tint * __restrict);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_condattr_setpshared(pthread_condattr_t *, int);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_create(pthread_t * __restrict, const pthread_attr_t * __restrict,", "\t\tvoid *(*)(void *), void * __restrict);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_detach(pthread_t);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_equal(pthread_t, pthread_t);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "void pthread_exit(void *) __dead2;", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_getconcurrency(void);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_getschedparam(pthread_t , int * __restrict,", "\t\tstruct sched_param * __restrict);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "void* pthread_getspecific(pthread_key_t);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_join(pthread_t , void **) __DARWIN_ALIAS_C(pthread_join);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_key_create(pthread_key_t *, void (*)(void *));", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_key_delete(pthread_key_t);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_mutex_destroy(pthread_mutex_t *);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_mutex_getprioceiling(const pthread_mutex_t * __restrict,", "\t\tint * __restrict);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_mutex_init(pthread_mutex_t * __restrict,", "\t\tconst pthread_mutexattr_t * __restrict);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_mutex_lock(pthread_mutex_t *);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_mutex_setprioceiling(pthread_mutex_t * __restrict, int,", "\t\tint * __restrict);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_mutex_trylock(pthread_mutex_t *);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_mutex_unlock(pthread_mutex_t *);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_mutexattr_destroy(pthread_mutexattr_t *) __DARWIN_ALIAS(pthread_mutexattr_destroy);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t * __restrict,", "\t\tint * __restrict);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_mutexattr_getprotocol(const pthread_mutexattr_t * __restrict,", "\t\tint * __restrict);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_mutexattr_getpshared(const pthread_mutexattr_t * __restrict,", "\t\tint * __restrict);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_mutexattr_gettype(const pthread_mutexattr_t * __restrict,", "\t\tint * __restrict);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_mutexattr_init(pthread_mutexattr_t *);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_mutexattr_settype(pthread_mutexattr_t *, int);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_once(pthread_once_t *, void (*)(void));", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_rwlock_destroy(pthread_rwlock_t * ) __DARWIN_ALIAS(pthread_rwlock_destroy);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_rwlock_init(pthread_rwlock_t * __restrict,", "\t\tconst pthread_rwlockattr_t * __restrict) __DARWIN_ALIAS(pthread_rwlock_init);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_rwlock_rdlock(pthread_rwlock_t *) __DARWIN_ALIAS(pthread_rwlock_rdlock);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_rwlock_tryrdlock(pthread_rwlock_t *) __DARWIN_ALIAS(pthread_rwlock_tryrdlock);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_rwlock_trywrlock(pthread_rwlock_t *) __DARWIN_ALIAS(pthread_rwlock_trywrlock);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_rwlock_wrlock(pthread_rwlock_t *) __DARWIN_ALIAS(pthread_rwlock_wrlock);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_rwlock_unlock(pthread_rwlock_t *) __DARWIN_ALIAS(pthread_rwlock_unlock);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t * __restrict,", "\t\tint * __restrict);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_rwlockattr_init(pthread_rwlockattr_t *);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "pthread_t pthread_self(void);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_setcancelstate(int , int *) __DARWIN_ALIAS(pthread_setcancelstate);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_setcanceltype(int , int *) __DARWIN_ALIAS(pthread_setcanceltype);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_setconcurrency(int);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_setschedparam(pthread_t, int, const struct sched_param *);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_setspecific(pthread_key_t , const void *);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "void pthread_testcancel(void) __DARWIN_ALIAS(pthread_testcancel);", "", "#if (!defined(_POSIX_C_SOURCE) && !defined(_XOPEN_SOURCE)) || defined(_DARWIN_C_SOURCE)", "", "/* returns non-zero if pthread_create or cthread_fork have been called */", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_is_threaded_np(void);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2)", "int pthread_threadid_np(pthread_t,__uint64_t*);", "", "/*SPI to set and get pthread name*/", "__OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2)", "int\tpthread_getname_np(pthread_t,char*,size_t);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2)", "int\tpthread_setname_np(const char*);", "", "/* returns non-zero if the current thread is the main thread */", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int\tpthread_main_np(void);", "", "/* return the mach thread bound to the pthread */", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "mach_port_t pthread_mach_thread_np(pthread_t);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "size_t pthread_get_stacksize_np(pthread_t);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "void* pthread_get_stackaddr_np(pthread_t);", "", "/* Like pthread_cond_signal(), but only wake up the specified pthread */", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_cond_signal_thread_np(pthread_cond_t *, pthread_t);", "", "/* Like pthread_cond_timedwait, but use a relative timeout */", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_cond_timedwait_relative_np(pthread_cond_t *, pthread_mutex_t *,", "\t\tconst struct timespec *);", "", "/* Like pthread_create(), but leaves the thread suspended */", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_create_suspended_np(pthread_t *, const pthread_attr_t *,", "\t\tvoid *(*)(void *), void *);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_kill(pthread_t, int);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0)", "pthread_t pthread_from_mach_thread_np(mach_port_t);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "int pthread_sigmask(int, const sigset_t *, sigset_t *) __DARWIN_ALIAS(pthread_sigmask);", "", "__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)", "void pthread_yield_np(void);", "", "#endif /* (!_POSIX_C_SOURCE && !_XOPEN_SOURCE) || _DARWIN_C_SOURCE */", "__END_DECLS", "#endif /* _PTHREAD_H */" },
    ["pthread_impl.h"] = { "/*", " * Copyright (c) 2000-2003 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "", "#ifndef _PTHREAD_IMPL_H_", "#define _PTHREAD_IMPL_H_", "/*", " * Internal implementation details", " */", "", "/* This whole header file will disappear, so don't depend on it... */", "", "#ifndef __POSIX_LIB__", "", "/*", " * [Internal] data structure signatures", " */", "#define _PTHREAD_MUTEX_SIG_init\t\t0x32AAABA7", "", "#define _PTHREAD_ERRORCHECK_MUTEX_SIG_init      0x32AAABA1", "#define _PTHREAD_RECURSIVE_MUTEX_SIG_init       0x32AAABA2", "#define _PTHREAD_FIRSTFIT_MUTEX_SIG_init       0x32AAABA3", "", "#define _PTHREAD_COND_SIG_init\t\t0x3CB0B1BB", "#define _PTHREAD_ONCE_SIG_init\t\t0x30B1BCBA", "#define _PTHREAD_RWLOCK_SIG_init    0x2DA8B3B4", "", "/*", " * POSIX scheduling policies", " */", "#define SCHED_OTHER                1", "#define SCHED_FIFO                 4", "#define SCHED_RR                   2", "", "#define __SCHED_PARAM_SIZE__       4", "", "#endif /* __POSIX_LIB__ */", "", "#endif /* _PTHREAD_IMPL_H_ */" },
    ["pthread_spis.h"] = { "/*", " * Copyright (c) 2000-2012 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " *", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " *", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " *", " * @APPLE_LICENSE_HEADER_END@", " */", "/*", " * Copyright 1996 1995 by Open Software Foundation, Inc. 1997 1996 1995 1994 1993 1992 1991", " *              All Rights Reserved", " *", " * Permission to use, copy, modify, and distribute this software and", " * its documentation for any purpose and without fee is hereby granted,", " * provided that the above copyright notice appears in all copies and", " * that both the copyright notice and this permission notice appear in", " * supporting documentation.", " *", " * OSF DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE", " * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS", " * FOR A PARTICULAR PURPOSE.", " *", " * IN NO EVENT SHALL OSF BE LIABLE FOR ANY SPECIAL, INDIRECT, OR", " * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM", " * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,", " * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION", " * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.", " *", " */", "/*", " * MkLinux", " */", "", "/*", " * Extension SPIs.", " */", "", "#ifndef _PTHREAD_SPIS_H", "#define _PTHREAD_SPIS_H", "", "", "#include <pthread.h>", "", "__BEGIN_DECLS", "", "#if (!defined(_POSIX_C_SOURCE) && !defined(_XOPEN_SOURCE)) || defined(_DARWIN_C_SOURCE)", "/* firstfit */", "#define PTHREAD_FIRSTFIT_MUTEX_INITIALIZER {_PTHREAD_FIRSTFIT_MUTEX_SIG_init, {0}}", "/*", " * Mutex attributes", " */", "#define _PTHREAD_MUTEX_POLICY_NONE\t\t0", "#define _PTHREAD_MUTEX_POLICY_FAIRSHARE\t\t1", "#define _PTHREAD_MUTEX_POLICY_FIRSTFIT\t\t2", "", "/* sets the mutex policy attributes */", "__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)", "int pthread_mutexattr_setpolicy_np(pthread_mutexattr_t *, int );", "", "#endif /* (!_POSIX_C_SOURCE && !_XOPEN_SOURCE) || _DARWIN_C_SOURCE */", "", "__END_DECLS", "", "#endif /* _PTHREAD_SPIS_H */" },
    ["pwd.h"] = { "/*-", " * Copyright (c) 1989, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " * (c) UNIX System Laboratories, Inc.", " * All or some portions of this file are derived from material licensed", " * to the University of California by American Telephone and Telegraph", " * Co. or Unix System Laboratories, Inc. and are reproduced herein with", " * the permission of UNIX System Laboratories, Inc.", " * Portions Copyright(C) 1995, Jason Downs.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)pwd.h\t8.2 (Berkeley) 1/21/94", " */", "/* Portions copyright (c) 2000-2011 Apple Inc. All rights reserved. */", "", "#ifndef _PWD_H_", "#define\t_PWD_H_", "", "#include <_types.h>", "#include <sys/_types/_gid_t.h>", "#include <sys/_types/_size_t.h>", "#include <sys/_types/_uid_t.h>", "", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", '#define\t_PATH_PWD\t\t"/etc"', '#define\t_PATH_PASSWD\t\t"/etc/passwd"', '#define\t_PASSWD\t\t\t"passwd"', '#define\t_PATH_MASTERPASSWD\t"/etc/master.passwd"', '#define\t_PATH_MASTERPASSWD_LOCK\t"/etc/ptmp"', '#define\t_MASTERPASSWD\t\t"master.passwd"', "", '#define\t_PATH_MP_DB\t\t"/etc/pwd.db"', '#define\t_MP_DB\t\t\t"pwd.db"', '#define\t_PATH_SMP_DB\t\t"/etc/spwd.db"', '#define\t_SMP_DB\t\t\t"spwd.db"', "", '#define\t_PATH_PWD_MKDB\t\t"/usr/sbin/pwd_mkdb"', "", "#define\t_PW_KEYBYNAME\t\t'1'\t/* stored by name */", "#define\t_PW_KEYBYNUM\t\t'2'\t/* stored by entry in the \"file\" */", "#define\t_PW_KEYBYUID\t\t'3'\t/* stored by uid */", "", "#define\t_PASSWORD_EFMT1\t\t'_'\t/* extended encryption format */", "", "#define\t_PASSWORD_LEN\t\t128\t/* max length, not counting NULL */", "", "#define _PASSWORD_NOUID\t\t0x01\t/* flag for no specified uid. */", "#define _PASSWORD_NOGID\t\t0x02\t/* flag for no specified gid. */", "#define _PASSWORD_NOCHG\t\t0x04\t/* flag for no specified change. */", "#define _PASSWORD_NOEXP\t\t0x08\t/* flag for no specified expire. */", "", "#define _PASSWORD_WARNDAYS\t14\t/* days to warn about expiry */", "#define _PASSWORD_CHGNOW\t-1\t/* special day to force password", "\t\t\t\t\t * change at next login */", "#endif", "", "struct passwd {", "\tchar\t*pw_name;\t\t/* user name */", "\tchar\t*pw_passwd;\t\t/* encrypted password */", "\tuid_t\tpw_uid;\t\t\t/* user uid */", "\tgid_t\tpw_gid;\t\t\t/* user gid */", "\t__darwin_time_t pw_change;\t\t/* password change time */", "\tchar\t*pw_class;\t\t/* user access class */", "\tchar\t*pw_gecos;\t\t/* Honeywell login info */", "\tchar\t*pw_dir;\t\t/* home directory */", "\tchar\t*pw_shell;\t\t/* default shell */", "\t__darwin_time_t pw_expire;\t\t/* account expiration */", "};", "", "#include <sys/cdefs.h>", "", "__BEGIN_DECLS", "struct passwd\t*getpwuid(uid_t);", "struct passwd\t*getpwnam(const char *);", "int\t\t getpwuid_r(uid_t, struct passwd *, char *, size_t, struct passwd **);", "int\t\t getpwnam_r(const char *, struct passwd *, char *, size_t, struct passwd **);", "struct passwd\t*getpwent(void);", "void\t\t setpwent(void);", "void\t\t endpwent(void);", "__END_DECLS", "", "#if (!defined(_POSIX_C_SOURCE) && !defined(_XOPEN_SOURCE)) || defined(_DARWIN_C_SOURCE)", "#include <uuid/uuid.h>", "__BEGIN_DECLS", "int\t\t setpassent(int);", "char \t\t*user_from_uid(uid_t, int);", "struct passwd\t*getpwuuid(uuid_t);", "int\t\t getpwuuid_r(uuid_t, struct passwd *, char *, size_t, struct passwd **);", "__END_DECLS", "#endif", "", "#endif /* !_PWD_H_ */" },
    ["ranlib.h"] = { "/*", " * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */", "/*", " * Copyright (c) 1990, 1982, 1985, 1986, 1988, 1993, 1994", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)ranlib.h\t8.1 (Berkeley) 6/2/93", " */", "#ifndef _RANLIB_H_", "#define _RANLIB_H_", "", "#include <sys/types.h>\t\t/* off_t */", "", "/*", " * There are two known orders of table of contents for archives.  The first is", " * the order ranlib(1) originally produced and still produces without any", ' * options.  This table of contents has the archive member name "__.SYMDEF"', " * This order has the ranlib structures in the order the objects appear in the", " * archive and the symbol names of those objects in the order of symbol table.", " * The second know order is sorted by symbol name and is produced with the -s", " * option to ranlib(1).  This table of contents has the archive member name", " * \"__.SYMDEF SORTED\" and many programs (notably the 1.0 version of ld(1) can't", " * tell the difference between names because of the imbedded blank in the name", " * and works with either table of contents).  This second order is used by the", " * post 1.0 link editor to produce faster linking.  The original 1.0 version of", " * ranlib(1) gets confused when it is run on a archive with the second type of", " * table of contents because it and ar(1) which it uses use different ways to", " * determined the member name (ar(1) treats all blanks in the name as", " * significant and ranlib(1) only checks for the first one).", " */", '#define SYMDEF\t\t"__.SYMDEF"', '#define SYMDEF_SORTED\t"__.SYMDEF SORTED"', "", '#define\tRANLIBMAG\t"__.SYMDEF"\t/* archive file name */', "#define\tRANLIBSKEW\t3\t\t/* creation time offset */", "", "/*", " * Structure of the __.SYMDEF table of contents for an archive.", " * __.SYMDEF begins with a long giving the size in bytes of the ranlib", " * structures which immediately follow, and then continues with a string", " * table consisting of a long giving the number of bytes of strings which", " * follow and then the strings themselves.  The ran_strx fields index the", " * string table whose first byte is numbered 0.", " */", "struct\tranlib {", "\tunion {", "\t\toff_t\tran_strx;\t/* string table index of */", "\t\tchar\t*ran_name;\t/* symbol defined by */", "\t} ran_un;", "\toff_t\tran_off;\t\t/* library member at this offset */", "};", "#endif /* ! _RANLIB_H_ */" },
    ["readpassphrase.h"] = { "/*\t$OpenBSD: /usr/local/www/cvsroot/OpenBSD/src/include/readpassphrase.h,v 1.2 2002/02/16 21:27:17 millert Exp $\t*/", "/*\t$FreeBSD: /repoman/r/ncvs/src/include/readpassphrase.h,v 1.2 2002/03/08 20:52:52 green Exp $\t*/", "", "/*", " * Copyright (c) 2000 Todd C. Miller <Todd.Miller@courtesan.com>", " * All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. The name of the author may not be used to endorse or promote products", " *    derived from this software without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,", " * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY", " * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL", " * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,", " * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,", " * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;", " * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,", " * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR", " * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF", " * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.", " */", "", "#ifndef _READPASSPHRASE_H_", "#define _READPASSPHRASE_H_", "", "#define RPP_ECHO_OFF    0x00\t\t/* Turn off echo (default). */", "#define RPP_ECHO_ON     0x01\t\t/* Leave echo on. */", "#define RPP_REQUIRE_TTY 0x02\t\t/* Fail if there is no tty. */", "#define RPP_FORCELOWER  0x04\t\t/* Force input to lower case. */", "#define RPP_FORCEUPPER  0x08\t\t/* Force input to upper case. */", "#define RPP_SEVENBIT    0x10\t\t/* Strip the high bit from input. */", "", "#include <_types.h>", "#include <sys/_types/_size_t.h>", "", "__BEGIN_DECLS", "char * readpassphrase(const char *, char *, size_t, int);", "__END_DECLS", "", "#endif /* !_READPASSPHRASE_H_ */" },
    ["regex.h"] = { "/*", " * Copyright (c) 2000, 2011 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/*", " * Copyright (c) 2001-2009 Ville Laurikari <vl@iki.fi>", " * All rights reserved.", " * ", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * ", " *   1. Redistributions of source code must retain the above copyright", " *      notice, this list of conditions and the following disclaimer.", " * ", " *   2. Redistributions in binary form must reproduce the above copyright", " *      notice, this list of conditions and the following disclaimer in the", " *      documentation and/or other materials provided with the distribution.", " * ", " * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS", " * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT", " * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR", " * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT", " * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,", " * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT", " * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,", " * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY", " * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT", " * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE", " * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.", " */", "/*-", " * Copyright (c) 1992 Henry Spencer.", " * Copyright (c) 1992, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * This code is derived from software contributed to Berkeley by", " * Henry Spencer of the University of Toronto.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)regex.h\t8.2 (Berkeley) 1/3/94", " */", "", "#ifndef _REGEX_H_", "#define\t_REGEX_H_", "", "#include <_types.h>", "#include <Availability.h>", "#include <sys/_types/_size_t.h>", "", "/*********/", "/* types */", "/*********/", "#if __DARWIN_C_LEVEL >= __DARWIN_C_FULL", "#include <sys/_types/_wchar_t.h>", "#endif /* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */", "", "typedef __darwin_off_t regoff_t;", "", "typedef struct {", "\tint re_magic;", "\tsize_t re_nsub;\t\t/* number of parenthesized subexpressions */", "\tconst char *re_endp;\t/* end pointer for REG_PEND */", "\tstruct re_guts *re_g;\t/* none of your business :-) */", "} regex_t;", "", "typedef struct {", "\tregoff_t rm_so;\t\t/* start of match */", "\tregoff_t rm_eo;\t\t/* end of match */", "} regmatch_t;", "", "/*******************/", "/* regcomp() flags */", "/*******************/", "#if __DARWIN_C_LEVEL >= __DARWIN_C_FULL", "#define\tREG_BASIC\t0000\t/* Basic regular expressions (synonym for 0) */", "#endif /* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */", "", "#define\tREG_EXTENDED\t0001\t/* Extended regular expressions */", "#define\tREG_ICASE\t0002\t/* Compile ignoring upper/lower case */", "#define\tREG_NOSUB\t0004\t/* Compile only reporting success/failure */", "#define\tREG_NEWLINE\t0010\t/* Compile for newline-sensitive matching */", "", "#if __DARWIN_C_LEVEL >= __DARWIN_C_FULL", "#define\tREG_NOSPEC\t0020\t/* Compile turning off all special characters */", "", "#if __MAC_OS_X_VERSION_MIN_REQUIRED  >= __MAC_10_8 \\", " || __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_6_0", "#define\tREG_LITERAL\tREG_NOSPEC", "#endif", "", "#define\tREG_PEND\t0040\t/* Use re_endp as end pointer */", "", "#if __MAC_OS_X_VERSION_MIN_REQUIRED  >= __MAC_10_8 \\", " || __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_6_0", "#define\tREG_MINIMAL\t0100\t/* Compile using minimal repetition */", "#define\tREG_UNGREEDY\tREG_MINIMAL", "#endif", "", "#define\tREG_DUMP\t0200\t/* Unused */", "", "#if __MAC_OS_X_VERSION_MIN_REQUIRED  >= __MAC_10_8 \\", " || __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_6_0", "#define\tREG_ENHANCED\t0400\t/* Additional (non-POSIX) features */", "#endif", "#endif /* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */", "", "/********************/", "/* regerror() flags */", "/********************/", "#define\tREG_ENOSYS\t (-1)\t/* Reserved */", "#define\tREG_NOMATCH\t 1\t/* regexec() function failed to match */", "#define\tREG_BADPAT\t 2\t/* invalid regular expression */", "#define\tREG_ECOLLATE\t 3\t/* invalid collating element */", "#define\tREG_ECTYPE\t 4\t/* invalid character class */", "#define\tREG_EESCAPE\t 5\t/* trailing backslash (\\) */", "#define\tREG_ESUBREG\t 6\t/* invalid backreference number */", "#define\tREG_EBRACK\t 7\t/* brackets ([ ]) not balanced */", "#define\tREG_EPAREN\t 8\t/* parentheses not balanced */", "#define\tREG_EBRACE\t 9\t/* braces not balanced */", "#define\tREG_BADBR\t10\t/* invalid repetition count(s) */", "#define\tREG_ERANGE\t11\t/* invalid character range */", "#define\tREG_ESPACE\t12\t/* out of memory */", "#define\tREG_BADRPT\t13\t/* repetition-operator operand invalid */", "", "#if __DARWIN_C_LEVEL >= __DARWIN_C_FULL", "#define\tREG_EMPTY\t14\t/* Unused */", "#define\tREG_ASSERT\t15\t/* Unused */", "#define\tREG_INVARG\t16\t/* invalid argument to regex routine */", "#define\tREG_ILLSEQ\t17\t/* illegal byte sequence */", "", "#define\tREG_ATOI\t255\t/* convert name to number (!) */", "#define\tREG_ITOA\t0400\t/* convert number to name (!) */", "#endif /* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */", "", "/*******************/", "/* regexec() flags */", "/*******************/", "#define\tREG_NOTBOL\t00001\t/* First character not at beginning of line */", "#define\tREG_NOTEOL\t00002\t/* Last character not at end of line */", "", "#if __DARWIN_C_LEVEL >= __DARWIN_C_FULL", "#define\tREG_STARTEND\t00004\t/* String start/end in pmatch[0] */", "#define\tREG_TRACE\t00400\t/* Unused */", "#define\tREG_LARGE\t01000\t/* Unused */", "#define\tREG_BACKR\t02000\t/* force use of backref code */", "", "#if __MAC_OS_X_VERSION_MIN_REQUIRED  >= __MAC_10_8 \\", " || __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_6_0", "#define\tREG_BACKTRACKING_MATCHER\tREG_BACKR", "#endif", "#endif /* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */", "", "__BEGIN_DECLS", "int\tregcomp(regex_t * __restrict, const char * __restrict, int) __DARWIN_ALIAS(regcomp);", "size_t\tregerror(int, const regex_t * __restrict, char * __restrict, size_t);", "/*", " * gcc under c99 mode won't compile \"[ __restrict]\" by itself.  As a workaround,", " * a dummy argument name is added.", " */", "int\tregexec(const regex_t * __restrict, const char * __restrict, size_t,", "\t    regmatch_t __pmatch[ __restrict], int);", "void\tregfree(regex_t *);", "", "#if __DARWIN_C_LEVEL >= __DARWIN_C_FULL", "", "/* Darwin extensions */", "int\tregncomp(regex_t * __restrict, const char * __restrict, size_t, int)", "\t    __OSX_AVAILABLE_STARTING(__MAC_10_8, __IPHONE_6_0);", "int\tregnexec(const regex_t * __restrict, const char * __restrict, size_t,", "\t    size_t, regmatch_t __pmatch[ __restrict], int)", "\t    __OSX_AVAILABLE_STARTING(__MAC_10_8, __IPHONE_6_0);", "int\tregwcomp(regex_t * __restrict, const wchar_t * __restrict, int)", "\t    __OSX_AVAILABLE_STARTING(__MAC_10_8, __IPHONE_6_0);", "int\tregwexec(const regex_t * __restrict, const wchar_t * __restrict, size_t,", "\t    regmatch_t __pmatch[ __restrict], int)", "\t    __OSX_AVAILABLE_STARTING(__MAC_10_8, __IPHONE_6_0);", "int\tregwncomp(regex_t * __restrict, const wchar_t * __restrict, size_t, int)", "\t    __OSX_AVAILABLE_STARTING(__MAC_10_8, __IPHONE_6_0);", "int\tregwnexec(const regex_t * __restrict, const wchar_t * __restrict,", "\t    size_t, size_t, regmatch_t __pmatch[ __restrict], int)", "\t    __OSX_AVAILABLE_STARTING(__MAC_10_8, __IPHONE_6_0);", "", "#endif /* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */", "__END_DECLS", "", "#ifdef _USE_EXTENDED_LOCALES_", "#include <xlocale/_regex.h>", "#endif /* _USE_EXTENDED_LOCALES_ */", "", "#endif /* !_REGEX_H_ */" },
    ["removefile.h"] = { "/*", " * Copyright (c) 2006 Apple Computer, Inc.  All rights reserved.", " */", "", "#ifndef __REMOVEFILE_H__", "#define __REMOVEFILE_H__", "", "#include <stdint.h>", "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "", "/*", " * Flags", " */", "typedef uint32_t removefile_flags_t;", "", "enum {", "\tREMOVEFILE_RECURSIVE = (1 << 0),\t\t\t// If path is a directory, recurse (depth first traversal)", "\tREMOVEFILE_KEEP_PARENT = (1 << 1),\t\t\t// Remove contents but not directory itself", "\tREMOVEFILE_SECURE_7_PASS = (1 << 2),\t\t// 7 pass DoD algorithm", "\tREMOVEFILE_SECURE_35_PASS  = (1 << 3),\t// 35-pass Gutmann algorithm (overrides REMOVEFILE_SECURE_7_PASS)", "\tREMOVEFILE_SECURE_1_PASS = (1 << 4),\t// 1 pass single overwrite", "\tREMOVEFILE_SECURE_3_PASS = (1 << 5),\t// 3 pass overwrite", "\tREMOVEFILE_SECURE_1_PASS_ZERO = (1 << 6),\t// Single-pass overwrite, with 0 instead of random data", "};", "", "/*", " * State object to pass in callback information", " */ ", "typedef struct _removefile_state * removefile_state_t;", "", "removefile_state_t removefile_state_alloc(void);", "int removefile_state_free(removefile_state_t);", "", "int removefile_state_get(removefile_state_t state, uint32_t key, void * dst);", "int removefile_state_set(removefile_state_t state, uint32_t key, const void* value);", "", "enum {", "\tREMOVEFILE_STATE_CONFIRM_CALLBACK = 1,\t// removefile_callback_t", "\tREMOVEFILE_STATE_CONFIRM_CONTEXT = 2,\t\t// void*", "\tREMOVEFILE_STATE_ERROR_CALLBACK = 3,\t\t// removefile_callback_t", "\tREMOVEFILE_STATE_ERROR_CONTEXT = 4,\t\t// void*", "\tREMOVEFILE_STATE_ERRNO = 5,\t\t\t\t\t// int (read-only)", "\tREMOVEFILE_STATE_STATUS_CALLBACK = 6,\t\t// removefile_callback_t", "\tREMOVEFILE_STATE_STATUS_CONTEXT = 7,\t\t// void*", "};", "", "typedef int (*removefile_callback_t)(removefile_state_t state, const char* path, void* context);", "", "/* ", " * Callback return values", " */ ", "enum {", "\tREMOVEFILE_PROCEED = 0,", "\tREMOVEFILE_SKIP = 1,", "\tREMOVEFILE_STOP = 2,", "};", "", "", "int removefile(const char* path, removefile_state_t state, removefile_flags_t flags);", "", "int removefile_cancel(removefile_state_t state);", "", "#ifdef __cplusplus", "}", "#endif", "", "#endif /* __REMOVEFILE_H__ */" },
    ["resolv.h"] = { "/*", " * Copyright (c) 1983, 1987, 1989", " *    The Regents of the University of California.  All rights reserved.", " * ", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " * \tThis product includes software developed by the University of", " * \tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " * ", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " */", "", "/*", " * Portions Copyright (c) 1996-1999 by Internet Software Consortium.", " *", " * Permission to use, copy, modify, and distribute this software for any", " * purpose with or without fee is hereby granted, provided that the above", " * copyright notice and this permission notice appear in all copies.", " *", ' * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS', " * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES", " * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE", " * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL", " * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR", " * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS", " * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS", " * SOFTWARE.", " */", "", "/*", " *\t@(#)resolv.h\t8.1 (Berkeley) 6/2/93", " *\t$Id: resolv.h,v 1.1 2006/03/01 19:01:39 majka Exp $", " */", "", "/*", " * Important note regarding the BIND-9 API on Mac OS", " * -------------------------------------------------", " * ", " * Mac OS supports a DNS query routing API (see <dns.h>) which is used by", " * most system services to access DNS.  The BIND-9 APIs described here are", " * a lower-level that does not do query routing or search amongst multiple", " * resolver clients.  The results of DNS queries from this API may differ", " * significantly from the results of queries sent to the <dns.h> API.  We", " * strongly encourage developers to use higher-level APIs where possible.", " */", "", "#ifndef _RESOLV_9_H_", "#define\t_RESOLV_9_H_", "", "#include <sys/param.h>", "#if (!defined(BSD)) || (BSD < 199306)", "# include <sys/bitypes.h>", "#else", "# include <sys/types.h>", "#endif", "#include <sys/cdefs.h>", "#include <sys/socket.h>", "#include <netinet/in.h>", "#include <stdio.h>", "#include <nameser.h>", "", "/*", " * Revision information.  This is the release date in YYYYMMDD format.", " * It can change every day so the right thing to do with it is use it", ' * in preprocessor commands such as "#if (__RES > 19931104)".  Do not', " * compare for equality; rather, use it to determine whether your resolver", " * is new enough to contain a certain feature.", " */", "", "#define\t__RES\t19991006", "", "#define __h_errno_set _res_9_h_errno_set", "#define RES_SET_H_ERRNO(r,x) __h_errno_set(r,x)", "", "#define __res_state __res_9_state", "struct __res_state; /* forward */", "", "__BEGIN_DECLS", "void __h_errno_set(struct __res_state *res, int err);", "__END_DECLS", "", "/*", " * Resolver configuration file.", " * Normally not present, but may contain the address of the", " * inital name server(s) to query and the domain search list.", " *", " * Apple Note:  The default DNS resolver client configuration", " * is now stored in a system configuration database, not in", " */", "", "#ifndef _PATH_RESCONF", '#define _PATH_RESCONF        "/etc/resolv.conf"', "#endif", "", "#define res_goahead res_9_goahead", "#define res_nextns res_9_nextns", "#define res_modified res_9_modified", "#define res_done res_9_done", "#define res_error res_9_error", "#define res_sendhookact res_9_sendhookact", "", "typedef enum", "{", "\tres_goahead,", "\tres_nextns,", "\tres_modified,", "\tres_done,", "\tres_error", "} res_sendhookact;", "", "typedef res_sendhookact (*res_send_qhook)__P((struct sockaddr * const *ns,", "\t\t\t\t\t      const u_char **query,", "\t\t\t\t\t      int *querylen,", "\t\t\t\t\t      u_char *ans,", "\t\t\t\t\t      int anssiz,", "\t\t\t\t\t      int *resplen));", "", "typedef res_sendhookact (*res_send_rhook)__P((const struct sockaddr *ns,", "\t\t\t\t\t      const u_char *query,", "\t\t\t\t\t      int querylen,", "\t\t\t\t\t      u_char *ans,", "\t\t\t\t\t      int anssiz,", "\t\t\t\t\t      int *resplen));", "", "#define res_sym res_9_sym", "", "struct res_sym", "{", "\tint\t\tnumber;\t   /* Identifying number, like T_MX */", '\tconst char *\tname;\t   /* Its symbolic name, like "MX" */', '\tconst char *\thumanname; /* Its fun name, like "mail exchanger" */', "};", "", "/*", " * Global defines and variables for resolver stub.", " */", "#define\tMAXNS\t\t\t3\t/* max # name servers we'll track */", "#define\tMAXDFLSRCH\t\t3\t/* # default domain levels to try */", "#define\tMAXDNSRCH\t\t6\t/* max # domains in search path */", '#define\tLOCALDOMAINPARTS\t2\t/* min levels in name that is "local" */', "", "#define\tRES_TIMEOUT\t\t5\t/* min. seconds between retries */", "#define\tMAXRESOLVSORT\t\t10\t/* number of net to sort on */", "#define\tRES_MAXNDOTS\t\t15\t/* should reflect bit field size */", "#define\tRES_MAXRETRANS\t\t30\t/* only for resolv.conf/RES_OPTIONS */", "#define\tRES_MAXRETRY\t\t5\t/* only for resolv.conf/RES_OPTIONS */", "#define\tRES_DFLRETRY\t\t2\t/* Default #/tries. */", "#define\tRES_MAXTIME\t\t65535\t/* Infinity, in milliseconds. */", "", "#define __res_state_ext __res_9_state_ext", "struct __res_state_ext;", "", "#define __res_state __res_9_state", "struct __res_state {", "\tint\tretrans;\t \t/* retransmition time interval */", "\tint\tretry;\t\t\t/* number of times to transmit (attempts, not retries) */", "#ifdef sun", "\tu_int\toptions;\t\t/* option flags - see below. */", "#else", "\tu_long\toptions;\t\t/* option flags - see below. */", "#endif", "\tint\tnscount;\t\t/* number of name servers */", "\tstruct sockaddr_in", "\t\tnsaddr_list[MAXNS];\t/* address of name server */", "#define\tnsaddr\tnsaddr_list[0]\t\t/* for backward compatibility */", "\tu_short\tid;\t\t\t/* current message id */", "\tchar\t*dnsrch[MAXDNSRCH+1];\t/* components of domain to search */", "\tchar\tdefdname[256];\t\t/* default domain (deprecated) */", "#ifdef sun", "\tu_int\tpfcode;\t\t\t/* RES_PRF_ flags - see below. */", "#else", "\tu_long\tpfcode;\t\t\t/* RES_PRF_ flags - see below. */", "#endif", "\tunsigned ndots:4;\t\t/* threshold for initial abs. query */", "\tunsigned nsort:4;\t\t/* number of elements in sort_list[] */", "\tchar\tunused[3];", "\tstruct {", "\t\tstruct in_addr\taddr;", "\t\tu_int32_t\tmask;", "\t} sort_list[MAXRESOLVSORT];", "\tres_send_qhook qhook;\t\t/* query hook */", "\tres_send_rhook rhook;\t\t/* response hook */", "\tint\tres_h_errno;\t\t/* last one set for this context */", "\tint\t_vcsock;\t\t/* PRIVATE: for res_send VC i/o */", "\tu_int\t_flags;\t\t\t/* PRIVATE: see below */", "\tu_int\t_pad;\t\t\t/* make _u 64 bit aligned */", "\tunion {", "\t\t/* On an 32-bit arch this means 512b total. */", "\t\tchar\tpad[72 - 4*sizeof (int) - 2*sizeof (void *)];", "\t\tstruct {", "\t\t\tu_int16_t\t\tnscount;", "\t\t\tu_int16_t\t\tnstimes[MAXNS];\t/* ms. */", "\t\t\tint\t\t\tnssocks[MAXNS];", "\t\t\tstruct __res_state_ext *ext;\t/* extention for IPv6 */", "\t\t} _ext;", "\t} _u;", "};", "", "#define res_state res_9_state", "", "typedef struct __res_state *res_state;", "", "#define res_sockaddr_union res_9_sockaddr_union", "", "union res_sockaddr_union {", "\tstruct sockaddr_in\tsin;", "#ifdef IN6ADDR_ANY_INIT", "\tstruct sockaddr_in6\tsin6;", "#endif", "#ifdef ISC_ALIGN64", "\tint64_t\t\t\t__align64;\t/* 64bit alignment */", "#else", "\tint32_t\t\t\t__align32;\t/* 32bit alignment */", "#endif", "\tchar\t\t\t__space[128];   /* max size */", "};", "", "/*", " * Resolver flags (used to be discrete per-module statics ints).", " */", "#define\tRES_F_VC\t\t\t0x00000001\t/* socket is TCP */", "#define\tRES_F_CONN\t\t0x00000002\t/* socket is connected */", "#define\tRES_F_EDNS0ERR\t0x00000004\t/* EDNS0 caused errors */", "", "/* res_findzonecut2() options */", "#define\tRES_EXHAUSTIVE\t0x00000001\t/* always do all queries */", "#define\tRES_IPV4ONLY\t\t0x00000002\t/* IPv4 only */", "#define\tRES_IPV6ONLY\t\t0x00000004\t/* IPv6 only */", "", "/*", " * Resolver options (keep these in synch with res_debug.c, please)", " */", "#define RES_INIT\t\t\t0x00000001\t/* address initialized */", "#define RES_DEBUG\t\t0x00000002\t/* print debug messages */", "#define RES_AAONLY\t\t0x00000004\t/* authoritative answers only (!IMPL)*/", "#define RES_USEVC\t\t0x00000008\t/* use virtual circuit */", "#define RES_PRIMARY\t\t0x00000010\t/* query primary server only (!IMPL) */", "#define RES_IGNTC\t\t0x00000020\t/* ignore trucation errors */", "#define RES_RECURSE\t\t0x00000040\t/* recursion desired */", "#define RES_DEFNAMES\t\t0x00000080\t/* use default domain name */", "#define RES_STAYOPEN\t\t0x00000100\t/* Keep TCP socket open */", "#define RES_DNSRCH\t\t0x00000200\t/* search up local domain tree */", "#define\tRES_INSECURE1\t0x00000400\t/* type 1 security disabled */", "#define\tRES_INSECURE2\t0x00000800\t/* type 2 security disabled */", "#define\tRES_NOALIASES\t0x00001000\t/* shuts off HOSTALIASES feature */", "#define\tRES_USE_INET6\t0x00002000\t/* use/map IPv6 in gethostbyname() */", "#define RES_ROTATE\t\t0x00004000\t/* rotate ns list after each query */", "#define\tRES_NOCHECKNAME\t0x00008000\t/* do not check names for sanity. */", "#define\tRES_KEEPTSIG\t\t0x00010000\t/* do not strip TSIG records */", "#define\tRES_BLAST\t\t0x00020000\t/* blast all recursive servers */", "#define RES_NO_NIBBLE\t0x00040000\t/* disable IPv6 nibble mode reverse */", "#define RES_NO_BITSTRING 0x00080000\t/* disable IPv6 bitstring mode reverse */", "#define RES_NOTLDQUERY\t0x00100000\t/* don't unqualified name as a tld */", "#define RES_USE_DNSSEC\t0x00200000\t/* use DNSSEC using OK bit in OPT */", "/* KAME extensions: use higher bit to avoid conflict with ISC use */", "#define RES_USE_DNAME\t0x10000000\t/* use DNAME */", "#define RES_USE_A6\t\t0x20000000\t/* use A6 */", "#define RES_USE_EDNS0\t0x40000000\t/* use EDNS0 if configured */", "#define RES_NO_NIBBLE2\t0x80000000\t/* disable alternate nibble lookup */", "", "#define RES_DEFAULT\t(RES_RECURSE | RES_DEFNAMES | RES_DNSRCH | RES_INSECURE1)", "", "/*", ' * Resolver "pfcode" values.  Used by dig.', " */", "#define RES_PRF_STATS\t0x00000001", "#define RES_PRF_UPDATE\t0x00000002", "#define RES_PRF_CLASS   0x00000004", "#define RES_PRF_CMD\t\t0x00000008", "#define RES_PRF_QUES\t\t0x00000010", "#define RES_PRF_ANS\t\t0x00000020", "#define RES_PRF_AUTH\t\t0x00000040", "#define RES_PRF_ADD\t\t0x00000080", "#define RES_PRF_HEAD1\t0x00000100", "#define RES_PRF_HEAD2\t0x00000200", "#define RES_PRF_TTLID\t0x00000400", "#define RES_PRF_HEADX\t0x00000800", "#define RES_PRF_QUERY\t0x00001000", "#define RES_PRF_REPLY\t0x00002000", "#define RES_PRF_INIT\t\t0x00004000", "#define RES_PRF_TRUNC\t0x00008000", "/*\t\t\t0x00010000\t*/", "", "/* Things involving an internal (static) resolver context. */", "#ifndef __BIND_NOSTATIC", "extern struct __res_state _res;", "#endif", "", "#ifndef __BIND_NOSTATIC", "#define fp_nquery\t\tres_9_fp_nquery", "#define fp_query\t\t\tres_9_fp_query", "#define hostalias\t\tres_9_hostalias_1", "#define p_query\t\t\tres_9_p_query", "#define res_close\t\tres_9_close", "#define res_init\t\t\tres_9_init", "#define res_isourserver\tres_9_isourserver", "#define res_mkquery\t\tres_9_mkquery", "#define res_query\t\tres_9_query", "#define res_querydomain\tres_9_querydomain", "#define res_search\t\tres_9_search", "#define res_send\t\t\tres_9_send", "#define res_sendsigned\tres_9_sendsigned", "", "__BEGIN_DECLS", "void\t\tfp_nquery __P((const u_char *, int, FILE *));", "void\t\tfp_query __P((const u_char *, FILE *));", "const char *hostalias __P((const char *));", "void\t\tp_query __P((const u_char *));", "void\t\tres_close __P((void));", "int\t\tres_init __P((void));", "int\t\tres_isourserver __P((const struct sockaddr_in *));", "int\t\tres_mkquery __P((int, const char *, int, int, const u_char *,", "\t\t\t\t int, const u_char *, u_char *, int));", "int\t\tres_query __P((const char *, int, int, u_char *, int));", "int\t\tres_querydomain __P((const char *, const char *, int, int,", "\t\t\t\t     u_char *, int));", "int\t\tres_search __P((const char *, int, int, u_char *, int));", "int\t\tres_send __P((const u_char *, int, u_char *, int));", "int\t\tres_sendsigned __P((const u_char *, int, ns_tsig_key *,", "\t\t\t\t    u_char *, int));", "__END_DECLS", "#endif", "", "#if !defined(SHARED_LIBBIND) || defined(LIB)", "/*", " * If libbind is a shared object (well, DLL anyway)", " * these externs break the linker when resolv.h is ", " * included by a lib client (like named)", " * Make them go away if a client is including this", " *", " */", "#define res_sym res_9_sym", "#define __p_key_syms __res_9_p_key_syms", "#define __p_cert_syms __res_9_p_cert_syms", "#define __p_class_syms __res_9_p_class_syms", "#define __p_type_syms __res_9_p_type_syms", "#define __p_rcode_syms __res_9_p_rcode_syms", "", "extern const struct res_sym __p_key_syms[];", "extern const struct res_sym __p_cert_syms[];", "extern const struct res_sym __p_class_syms[];", "extern const struct res_sym __p_type_syms[];", "extern const struct res_sym __p_rcode_syms[];", "#endif /* SHARED_LIBBIND */", "", "#define b64_ntop\t\t\t\t\tres_9_b64_ntop", "#define b64_pton\t\t\t\t\tres_9_b64_pton", "#define dn_comp\t\t\t\t\tres_9_dn_comp", "#define dn_count_labels\t\t\tres_9_dn_count_labels", "#define dn_expand\t\t\t\tres_9_dn_expand", "#define dn_skipname\t\t\t\tres_9_dn_skipname", "#define fp_resstat\t\t\t\tres_9_fp_resstat", "#define loc_aton\t\t\t\t\tres_9_loc_aton", "#define loc_ntoa\t\t\t\t\tres_9_loc_ntoa", "#define p_cdname\t\t\t\t\tres_9_p_cdname", "#define p_cdnname\t\t\t\tres_9_p_cdnname", "#define p_class\t\t\t\t\tres_9_p_class", "#define p_fqname\t\t\t\t\tres_9_p_fqname", "#define p_fqnname\t\t\t\tres_9_p_fqnname", "#define p_option\t\t\t\t\tres_9_p_option", "#define p_secstodate\t\t\t\tres_9_p_secstodate", "#define p_section\t\t\t\tres_9_p_section", "#define p_time\t\t\t\t\tres_9_p_time", "#define p_type\t\t\t\t\tres_9_p_type", "#define p_rcode\t\t\t\t\tres_9_p_rcode", "#define putlong\t\t\t\t\tres_9_putlong", "#define putshort\t\t\t\t\tres_9_putshort", "#define res_dnok\t\t\t\t\tres_9_dnok", "#define res_findzonecut\t\t\tres_9_findzonecut", "#define res_findzonecut2\t\t\tres_9_findzonecut2", "#define res_hnok\t\t\t\t\tres_9_hnok", "#define res_hostalias\t\t\tres_9_hostalias_2", "#define res_mailok\t\t\t\tres_9_mailok", "#define res_nameinquery\t\t\tres_9_nameinquery", "#define res_nclose\t\t\t\tres_9_nclose", "#define res_ninit\t\t\t\tres_9_ninit", "#define res_nmkquery\t\t\t\tres_9_nmkquery", "#define res_pquery\t\t\t\tres_9_pquery", "#define res_nquery\t\t\t\tres_9_nquery", "#define res_nquerydomain\t\t\tres_9_nquerydomain", "#define res_nsearch\t\t\t\tres_9_nsearch", "#define res_nsend\t\t\t\tres_9_nsend", "#define res_nsendsigned\t\t\tres_9_nsendsigned", "#define res_nisourserver\t\t\tres_9_nisourserver", "#define res_ownok\t\t\t\tres_9_ownok", "#define res_queriesmatch\t\t\tres_9_queriesmatch", "#define res_randomid\t\t\t\tres_9_randomid", "#define sym_ntop\t\t\t\t\tres_9_sym_ntop", "#define sym_ntos\t\t\t\t\tres_9_sym_ntos", "#define sym_ston\t\t\t\t\tres_9_sym_ston", "#define res_nopt\t\t\t\t\tres_9_nopt", "#define res_ndestroy\t\t\t\tres_9_ndestroy", "#define res_nametoclass\t\t\tres_9_nametoclass", "#define res_nametotype\t\t\tres_9_nametotype", "#define res_setservers\t\t\tres_9_setservers", "#define res_getservers\t\t\tres_9_getservers", "#define _getshort\t\t\t\tres_9_getshort", "#define _getlong\t\t\t\t\tres_9_getlong", "#define __res_vinit\t\t\t\tres_9_vinit", "", "__BEGIN_DECLS", "int\t\tres_hnok __P((const char *));", "int\t\tres_ownok __P((const char *));", "int\t\tres_mailok __P((const char *));", "int\t\tres_dnok __P((const char *));", "int\t\tsym_ston __P((const struct res_sym *, const char *, int *));", "const char *\tsym_ntos __P((const struct res_sym *, int, int *));", "const char *sym_ntop __P((const struct res_sym *, int, int *));", "int\t\tb64_ntop __P((u_char const *, size_t, char *, size_t));", "int\t\tb64_pton __P((char const *, u_char *, size_t));", "int\t\tloc_aton __P((const char *ascii, u_char *binary));", "const char *\tloc_ntoa __P((const u_char *binary, char *ascii));", "int\t\tdn_skipname __P((const u_char *, const u_char *));", "void\t\tputlong __P((u_int32_t, u_char *));", "void\t\tputshort __P((u_int16_t, u_char *));", "#ifndef __ultrix__", "u_int16_t\t_getshort __P((const u_char *src));", "u_int32_t\t_getlong __P((const u_char *src));", "#endif", "const char * p_class __P((int));", "const char * p_time __P((u_int32_t));", "const char * p_type __P((int));", "const char * p_rcode __P((int));", "const u_char * p_cdnname __P((const u_char *, const u_char *, int, FILE *));", "const u_char * p_cdname __P((const u_char *, const u_char *, FILE *));", "const u_char * p_fqnname __P((const u_char *cp, const u_char *msg, int, char *, int));", "const u_char * p_fqname __P((const u_char *, const u_char *, FILE *));", "const char * p_option __P((u_long option));", "char * p_secstodate __P((u_long));", "int\t\tdn_count_labels __P((const char *));", "int\t\tdn_comp __P((const char *, u_char *, int, u_char **, u_char **));", "int\t\tdn_expand __P((const u_char *, const u_char *, const u_char *, char *, int));", "u_int\t\tres_randomid __P((void));", "int\t\tres_nameinquery __P((const char *, int, int, const u_char *, const u_char *));", "int\t\tres_queriesmatch __P((const u_char *, const u_char *, const u_char *, const u_char *));", "const char * p_section __P((int section, int opcode));", "", "/* Things involving a resolver context. */", "int\t\tres_ninit __P((res_state));", "int\t\tres_nisourserver __P((const res_state, const struct sockaddr_in *));", "void\t\tfp_resstat __P((const res_state, FILE *));", "void\t\tres_pquery __P((const res_state, const u_char *, int, FILE *));", "const char *res_hostalias __P((const res_state, const char *, char *, size_t));", "int\t\tres_nquery __P((res_state, const char *, int, int, u_char *, int));", "int\t\tres_nsearch __P((res_state, const char *, int, int, u_char *, int));", "int\t\tres_nquerydomain __P((res_state, const char *, const char *, int, int, u_char *, int));", "int\t\tres_nmkquery __P((res_state, int, const char *, int, int, const u_char *, int, const u_char *, u_char *, int));", "int\t\tres_nsend __P((res_state, const u_char *, int, u_char *, int));", "int\t\tres_nsendsigned __P((res_state, const u_char *, int, ns_tsig_key *, u_char *, int));", "int\t\tres_findzonecut __P((res_state, const char *, ns_class, int, char *, size_t, struct in_addr *, int));", "int\t\tres_findzonecut2 __P((res_state, const char *, ns_class, int, char *, size_t, union res_sockaddr_union *, int));", "void\t\tres_nclose __P((res_state));", "int\t\tres_nopt __P((res_state, int, u_char *, int, int));", "void\t\tres_send_setqhook __P((res_send_qhook hook));", "void\t\tres_send_setrhook __P((res_send_rhook hook));", "int\t\t__res_vinit __P((res_state, int));", "void\t\tres_destroyservicelist __P((void));", "const char *\tres_servicename __P((u_int16_t port, const char *proto));", "const char *\tres_protocolname __P((int num));", "void\t\tres_destroyprotolist __P((void));", "void\t\tres_buildprotolist __P((void));", "const char *\tres_get_nibblesuffix __P((res_state));", "const char *\tres_get_nibblesuffix2 __P((res_state));", "const char *\tres_get_bitstringsuffix __P((res_state));", "void\t\tres_ndestroy __P((res_state));", "u_int16_t\tres_nametoclass __P((const char *buf, int *success));", "u_int16_t\tres_nametotype __P((const char *buf, int *success));", "void\t\tres_setservers __P((res_state, const union res_sockaddr_union *, int));", "int\t\tres_getservers __P((res_state, union res_sockaddr_union *, int));", "__END_DECLS", "", "#endif /* !_RESOLV_9_H_ */" },
    ["rune.h"] = { "/*-", " * Copyright (c) 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * This code is derived from software contributed to Berkeley by", " * Paul Borman at Krystal Technologies.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)rune.h\t8.1 (Berkeley) 6/27/93", " */", "", "#ifndef\t_RUNE_H_", "#define\t_RUNE_H_", "", "#include <runetype.h>", "#include <stdio.h>", "#include <Availability.h>", "", "/*--------------------------- DEPRECIATED -------------------------------", " * This interface is depreciated and will eventually be removed.  The ISO C99", " * extended multibyte and wide character facilities should be used instead.", " * See multibyte(3) and related man pages for further details.", " *--------------------------- DEPRECIATED -------------------------------*/", "", '#define\t_PATH_LOCALE\t"/usr/share/locale"', "", "#define _INVALID_RUNE   _CurrentRuneLocale->__invalid_rune", "", "#define __sgetrune      _CurrentRuneLocale->__sgetrune", "#define __sputrune      _CurrentRuneLocale->__sputrune", "", "#define sgetrune(s, n, r)       (*__sgetrune)((s), (n), (r))", "#define sputrune(c, s, n, r)    (*__sputrune)((c), (s), (n), (r))", "", "__BEGIN_DECLS", "char\t*mbrune(const char *, rune_t) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_4, __IPHONE_NA, __IPHONE_NA);", "char\t*mbrrune(const char *, rune_t) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_4, __IPHONE_NA, __IPHONE_NA);", "char\t*mbmb(const char *, char *) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_4, __IPHONE_NA, __IPHONE_NA);", "long\t fgetrune(FILE *) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_4, __IPHONE_NA, __IPHONE_NA);", "int\t fputrune(rune_t, FILE *) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_4, __IPHONE_NA, __IPHONE_NA);", "int\t fungetrune(rune_t, FILE *) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_4, __IPHONE_NA, __IPHONE_NA);", "int\t setrunelocale(char *) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_4, __IPHONE_NA, __IPHONE_NA);", "void\t setinvalidrune(rune_t) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_4, __IPHONE_NA, __IPHONE_NA);", "__END_DECLS", "", "#endif\t/*! _RUNE_H_ */" },
    ["runetype.h"] = { "/*-", " * Copyright (c) 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * This code is derived from software contributed to Berkeley by", " * Paul Borman at Krystal Technologies.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)runetype.h\t8.1 (Berkeley) 6/2/93", " */", "", "#ifndef\t_RUNETYPE_H_", "#define\t_RUNETYPE_H_", "", "#include <_types.h>", "", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "", "#include <sys/_types/_size_t.h>", "#include <sys/_types/_ct_rune_t.h>", "#include <sys/_types/_rune_t.h>", "#include <sys/_types/_wchar_t.h>", "#include <sys/_types/_wint_t.h>", "", "#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */", "", "#define\t_CACHED_RUNES\t(1 <<8 )\t/* Must be a power of 2 */", "#define\t_CRMASK\t\t(~(_CACHED_RUNES - 1))", "", "/*", " * The lower 8 bits of runetype[] contain the digit value of the rune.", " */", "typedef struct {", "\t__darwin_rune_t\t__min;\t\t/* First rune of the range */", "\t__darwin_rune_t\t__max;\t\t/* Last rune (inclusive) of the range */", "\t__darwin_rune_t\t__map;\t\t/* What first maps to in maps */", "\t__uint32_t\t*__types;\t/* Array of types in range */", "} _RuneEntry;", "", "typedef struct {", "\tint\t\t__nranges;\t/* Number of ranges stored */", "\t_RuneEntry\t*__ranges;\t/* Pointer to the ranges */", "} _RuneRange;", "", "typedef struct {", "\tchar\t\t__name[14];\t/* CHARCLASS_NAME_MAX = 14 */", "\t__uint32_t\t__mask;\t\t/* charclass mask */", "} _RuneCharClass;", "", "typedef struct {", "\tchar\t\t__magic[8];\t/* Magic saying what version we are */", "\tchar\t\t__encoding[32];\t/* ASCII name of this encoding */", "", "\t__darwin_rune_t\t(*__sgetrune)(const char *, __darwin_size_t, char const **);", "\tint\t\t(*__sputrune)(__darwin_rune_t, char *, __darwin_size_t, char **);", "\t__darwin_rune_t\t__invalid_rune;", "", "\t__uint32_t\t__runetype[_CACHED_RUNES];", "\t__darwin_rune_t\t__maplower[_CACHED_RUNES];", "\t__darwin_rune_t\t__mapupper[_CACHED_RUNES];", "", "\t/*", "\t * The following are to deal with Runes larger than _CACHED_RUNES - 1.", "\t * Their data is actually contiguous with this structure so as to make", "\t * it easier to read/write from/to disk.", "\t */", "\t_RuneRange\t__runetype_ext;", "\t_RuneRange\t__maplower_ext;", "\t_RuneRange\t__mapupper_ext;", "", "\tvoid\t\t*__variable;\t/* Data which depends on the encoding */", "\tint\t\t__variable_len;\t/* how long that data is */", "", "\t/*", "\t * extra fields to deal with arbitrary character classes", "\t */", "\tint\t\t__ncharclasses;", "\t_RuneCharClass\t*__charclasses;", "} _RuneLocale;", "", '#define\t_RUNE_MAGIC_A\t"RuneMagA"\t/* Indicates version A of RuneLocale */', "", "__BEGIN_DECLS", "extern _RuneLocale _DefaultRuneLocale;", "extern _RuneLocale *_CurrentRuneLocale;", "__END_DECLS", "", "#endif\t/* !_RUNETYPE_H_ */" },
    ["sandbox.h"] = { "/*", " * Copyright (c) 2006-2011 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "", "", "/*", " * This header is deprecated and may be removed in a future release.", " * Developers who wish to sandbox an app should instead adopt the App Sandbox", " * feature described in the App Sandbox Design Guide.", " */", "", "", "#ifndef _SANDBOX_H_", "#define _SANDBOX_H_", "", "#include <Availability.h>", "#include <sys/cdefs.h>", "#include <stdint.h>", "", "__BEGIN_DECLS", "", "/*", " * @function sandbox_init", " * Places the current process in a sandbox with a profile as", " * specified.  If the process is already in a sandbox, the new profile", " * is ignored and sandbox_init() returns an error.", " *", " * @param profile (input)   The Sandbox profile to be used.  The format", " * and meaning of this parameter is modified by the `flags' parameter.", " *", " * @param flags (input)   Must be SANDBOX_NAMED.  All other", " * values are reserved.", " *", " * @param errorbuf (output)   In the event of an error, sandbox_init", " * will set `*errorbuf' to a pointer to a NUL-terminated string", " * describing the error. This string may contain embedded newlines.", " * This error information is suitable for developers and is not", " * intended for end users.", " *", " * If there are no errors, `*errorbuf' will be set to NULL.  The", " * buffer `*errorbuf' should be deallocated with `sandbox_free_error'.", " *", " * @result 0 on success, -1 otherwise.", " */", "__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5,__MAC_10_8,__IPHONE_2_0,__IPHONE_6_0)", "int sandbox_init(const char *profile, uint64_t flags, char **errorbuf);", "", "/*", " * @define SANDBOX_NAMED  The `profile' argument specifies a Sandbox", " * profile named by one of the kSBXProfile* string constants.", " */", "#define SANDBOX_NAMED\t\t0x0001", "", "/*", " * Available Sandbox profiles.", " */", "", "/* TCP/IP networking is prohibited. */", "__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5,__MAC_10_8,__IPHONE_2_0,__IPHONE_6_0)", "extern const char kSBXProfileNoInternet[];", "", "/* All sockets-based networking is prohibited. */", "__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5,__MAC_10_8,__IPHONE_2_0,__IPHONE_6_0)", "extern const char kSBXProfileNoNetwork[];", "", "/* File system writes are prohibited. */", "__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5,__MAC_10_8,__IPHONE_2_0,__IPHONE_6_0)", "extern const char kSBXProfileNoWrite[];", "", "/* File system writes are restricted to temporary folders /var/tmp and", " * confstr(_CS_DARWIN_USER_DIR, ...).", " */", "__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5,__MAC_10_8,__IPHONE_2_0,__IPHONE_6_0)", "extern const char kSBXProfileNoWriteExceptTemporary[];", "", "/* All operating system services are prohibited. */", "__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5,__MAC_10_8,__IPHONE_2_0,__IPHONE_6_0)", "extern const char kSBXProfilePureComputation[];", "", "/*", " * @function sandbox_free_error", " * Deallocates an error string previously allocated by sandbox_init.", " *", " * @param errorbuf (input)   The buffer to be freed.  Must be a pointer", " * previously returned by sandbox_init in the `errorbuf' argument, or NULL.", " *", " * @result void", " */", "__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5,__MAC_10_8,__IPHONE_2_0,__IPHONE_6_0)", "void sandbox_free_error(char *errorbuf);", "", "__END_DECLS", "", "#endif /* _SANDBOX_H_ */" },
    ["sched.h"] = { "/*", " * Copyright (c) 2000-2003 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "", "#ifndef _SCHED_H_", "#define _SCHED_H_", "", "#include <pthread_impl.h>", "#include <sys/cdefs.h>", "", "__BEGIN_DECLS", "/*", " * Scheduling paramters", " */", "#ifndef __POSIX_LIB__", "struct sched_param { int sched_priority;  char __opaque[__SCHED_PARAM_SIZE__]; };", "#endif", "", "extern int sched_yield(void);", "extern int sched_get_priority_min(int);", "extern int sched_get_priority_max(int);", "__END_DECLS", "", "#endif /* _SCHED_H_ */", "" },
    ["search.h"] = { "/*-", " * Written by J.T. Conklin <jtc@netbsd.org>", " * Public domain.", " *", " *\t$NetBSD: search.h,v 1.12 1999/02/22 10:34:28 christos Exp $", " * $FreeBSD: src/include/search.h,v 1.10 2002/10/16 14:29:23 robert Exp $", " */", "", "#ifndef _SEARCH_H_", "#define _SEARCH_H_", "", "#include <sys/cdefs.h>", "#include <_types.h>", "#include <sys/_types/_size_t.h>", "", "typedef\tstruct entry {", "\tchar\t*key;", "\tvoid\t*data;", "} ENTRY;", "", "typedef\tenum {", "\tFIND, ENTER", "} ACTION;", "", "typedef\tenum {", "\tpreorder,", "\tpostorder,", "\tendorder,", "\tleaf", "} VISIT;", "", "#ifdef _SEARCH_PRIVATE", "typedef\tstruct node {", "\tchar         *key;", "\tstruct node  *llink, *rlink;", "} node_t;", "", "struct que_elem {", "\tstruct que_elem *next;", "\tstruct que_elem *prev;", "};", "#endif", "", "__BEGIN_DECLS", "int\t hcreate(size_t);", "void\t hdestroy(void);", "ENTRY\t*hsearch(ENTRY, ACTION);", "void\t insque(void *, void *);", "void\t*lfind(const void *, const void *, size_t *, size_t,", "\t    int (*)(const void *, const void *));", "void\t*lsearch(const void *, void *, size_t *, size_t,", "\t    int (*)(const void *, const void *));", "void\t remque(void *);", "void\t*tdelete(const void * __restrict, void ** __restrict,", "\t    int (*)(const void *, const void *));", "void\t*tfind(const void *, void * const *,", "\t    int (*)(const void *, const void *));", "void\t*tsearch(const void *, void **, int (*)(const void *, const void *));", "void\t twalk(const void *, void (*)(const void *, VISIT, int));", "__END_DECLS", "", "#endif /* !_SEARCH_H_ */" },
    ["semaphore.h"] = { "/*", " * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "#ifndef _BSD_SEMAPHORE_H", "#define _BSD_SEMAPHORE_H", "", "#include <sys/types.h>", "#include <sys/fcntl.h>", "", "#include <sys/semaphore.h>", "", "#endif /* _BSD_SEMAPHORE_H */" },
    ["setjmp.h"] = { "/*", " * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "#ifndef _BSD_SETJMP_H", "#define _BSD_SETJMP_H", "", "#include <sys/cdefs.h>", "", "#if defined(__x86_64__)", "/*", " * _JBLEN is number of ints required to save the following:", " * rflags, rip, rbp, rsp, rbx, r12, r13, r14, r15... these are 8 bytes each", " * mxcsr, fp control word, sigmask... these are 4 bytes each", " * add 16 ints for future expansion needs...", " */", "#define _JBLEN ((9 * 2) + 3 + 16)", "typedef int jmp_buf[_JBLEN];", "typedef int sigjmp_buf[_JBLEN + 1];", "", "#elif defined(__i386__)", "", "/*", " * _JBLEN is number of ints required to save the following:", " * eax, ebx, ecx, edx, edi, esi, ebp, esp, ss, eflags, eip,", " * cs, de, es, fs, gs == 16 ints", " * onstack, mask = 2 ints", " */", "", "#define _JBLEN (18)", "typedef int jmp_buf[_JBLEN];", "typedef int sigjmp_buf[_JBLEN + 1];", "", "#elif defined(__arm__)", "", "#include <machine/signal.h>", "", "/*", " *\t_JBLEN is number of ints required to save the following:", " *\tr4-r8, r10, fp, sp, lr, sig  == 10 register_t sized", " *\ts16-s31 == 16 register_t sized + 1 int for FSTMX", " *\t1 extra int for future use", " */", "#define _JBLEN\t\t(10 + 16 + 2)", "#define _JBLEN_MAX\t_JBLEN", "", "typedef int jmp_buf[_JBLEN];", "typedef int sigjmp_buf[_JBLEN + 1];", "", "#else", "#\terror Undefined platform for setjmp", "#endif", "", "__BEGIN_DECLS", "extern int\tsetjmp(jmp_buf);", "extern void longjmp(jmp_buf, int) __dead2;", "", "#ifndef _ANSI_SOURCE", "int\t_setjmp(jmp_buf);", "void\t_longjmp(jmp_buf, int) __dead2;", "int\tsigsetjmp(sigjmp_buf, int);", "void\tsiglongjmp(sigjmp_buf, int) __dead2;", "#endif /* _ANSI_SOURCE  */", "", "#if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))", "void\tlongjmperror(void);", "#endif /* neither ANSI nor POSIX */", "__END_DECLS", "", "#endif /* _BSD_SETJMP_H */" },
    ["sgtty.h"] = { "/*", " * Copyright (c) 1985, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)sgtty.h\t8.1 (Berkeley) 6/2/93", " */", "", "#ifndef _SGTTY_H_", "#define _SGTTY_H_", "", "#include <sys/cdefs.h>", "", "#ifndef USE_OLD_TTY", "#define\tUSE_OLD_TTY", "#endif", "#include <sys/ioctl.h>", "", "__BEGIN_DECLS", "int\tgtty(int, struct sgttyb *);", "int\tstty(int, struct sgttyb *);", "__END_DECLS", "", "#define\tgtty(fd, buf)\tioctl(fd, TIOCGETP, buf)", "#define\tstty(fd, buf)\tioctl(fd, TIOCSETP, buf)", "", "#endif /* _SGTTY_H_ */" },
    ["signal.h"] = { "/*", " * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/*-", " * Copyright (c) 1991, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)signal.h\t8.3 (Berkeley) 3/30/94", " */", "", "#ifndef _USER_SIGNAL_H", "#define _USER_SIGNAL_H", "", "#include <sys/cdefs.h>", "#include <_types.h>", "#include <sys/signal.h>", "#include <sys/_types/_pthread_t.h>", "", "#if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))", "extern __const char *__const sys_signame[NSIG];", "extern __const char *__const sys_siglist[NSIG];", "#endif", "", "__BEGIN_DECLS", "int\traise(int);", "__END_DECLS", "", "#ifndef\t_ANSI_SOURCE", "__BEGIN_DECLS", "void\t(*bsd_signal(int, void (*)(int)))(int);", "int\tkill(pid_t, int) __DARWIN_ALIAS(kill);", "int\tkillpg(pid_t, int) __DARWIN_ALIAS(killpg);", "int\tpthread_kill(pthread_t, int);", "int\tpthread_sigmask(int, const sigset_t *, sigset_t *) __DARWIN_ALIAS(pthread_sigmask);", "int\tsigaction(int, const struct sigaction * __restrict,", "\t    struct sigaction * __restrict);", "int\tsigaddset(sigset_t *, int);", "int\tsigaltstack(const stack_t * __restrict, stack_t * __restrict)  __DARWIN_ALIAS(sigaltstack);", "int\tsigdelset(sigset_t *, int);", "int\tsigemptyset(sigset_t *);", "int\tsigfillset(sigset_t *);", "int\tsighold(int);", "int\tsigignore(int);", "int\tsiginterrupt(int, int);", "int\tsigismember(const sigset_t *, int);", "int\tsigpause(int) __DARWIN_ALIAS_C(sigpause);", "int\tsigpending(sigset_t *);", "int\tsigprocmask(int, const sigset_t * __restrict, sigset_t * __restrict);", "int\tsigrelse(int);", "void    (*sigset(int, void (*)(int)))(int); ", "int\tsigsuspend(const sigset_t *) __DARWIN_ALIAS_C(sigsuspend);", "int\tsigwait(const sigset_t * __restrict, int * __restrict) __DARWIN_ALIAS_C(sigwait);", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "void\tpsignal(unsigned int, const char *);", "int\tsigblock(int);", "int\tsigsetmask(int);", "int\tsigvec(int, struct sigvec *, struct sigvec *);", "#endif\t/* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */", "__END_DECLS", "", "/* List definitions after function declarations, or Reiser cpp gets upset. */", "#if defined(__i386__) || defined(__x86_64__)", "/* The left shift operator on intel is modulo 32 */", "__header_always_inline int", "__sigbits(int __signo)", "{", "    return __signo > __DARWIN_NSIG ? 0 : (1 << (__signo - 1));", "}", "#else /* !__i386__ && !__x86_64__ */", "#define __sigbits(signo)\t(1 << ((signo) - 1))", "#endif /* __i386__ || __x86_64__ */", "", "#define\tsigaddset(set, signo)\t(*(set) |= __sigbits(signo), 0)", "#define\tsigdelset(set, signo)\t(*(set) &= ~__sigbits(signo), 0)", "#define\tsigismember(set, signo)\t((*(set) & __sigbits(signo)) != 0)", "#define\tsigemptyset(set)\t(*(set) = 0, 0)", "#define\tsigfillset(set)\t\t(*(set) = ~(sigset_t)0, 0)", "#endif\t/* !_ANSI_SOURCE */", "", "#endif\t/* !_USER_SIGNAL_H */" },
    ["slapi-plugin.h"] = { "/* $OpenLDAP$ */", "/* This work is part of OpenLDAP Software <http://www.openldap.org/>.", " *", " * Copyright 1998-2011 The OpenLDAP Foundation.", " * Portions Copyright 1997,2002,2003 IBM Corporation.", " * All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted only as authorized by the OpenLDAP", " * Public License.", " *", " * A copy of this license is available in file LICENSE in the", " * top-level directory of the distribution or, alternatively, at", " * <http://www.OpenLDAP.org/license.html>.", " */", "", "/*", " * This header is used in development of SLAPI plugins for", " * OpenLDAP slapd(8) and other directory servers supporting", " * this interface.  Your portability mileage may vary.", " */", "", "#ifndef _SLAPI_PLUGIN_H", "#define _SLAPI_PLUGIN_H", "", "#include <ldap.h>", "", "typedef struct slapi_pblock\t\tSlapi_PBlock;", "typedef struct slapi_entry\t\tSlapi_Entry;", "typedef struct slapi_attr\t\tSlapi_Attr;", "typedef struct slapi_value\t\tSlapi_Value;", "typedef struct slapi_valueset\t\tSlapi_ValueSet;", "typedef struct slapi_filter\t\tSlapi_Filter;", "typedef struct BackendDB\t\tSlapi_Backend;", "typedef struct Operation\t\tSlapi_Operation;", "typedef struct Connection\t\tSlapi_Connection;", "typedef struct slapi_dn\t\t\tSlapi_DN;", "typedef struct slapi_rdn\t\tSlapi_RDN;", "typedef struct slapi_mod\t\tSlapi_Mod;", "typedef struct slapi_mods\t\tSlapi_Mods;", "typedef struct slapi_componentid\tSlapi_ComponentId;", "", '#define SLAPI_ATTR_UNIQUEID\t"entryUUID"', '#define SLAPI_ATTR_OBJECTCLASS\t"objectClass"', "", "/* pblock routines */", "int slapi_pblock_get( Slapi_PBlock *pb, int arg, void *value );", "int slapi_pblock_set( Slapi_PBlock *pb, int arg, void *value );", "Slapi_PBlock *slapi_pblock_new( void );", "void slapi_pblock_destroy( Slapi_PBlock *pb );", "", "/* entry/attr/dn routines */", "Slapi_Entry *slapi_str2entry( char *s, int flags );", "#define SLAPI_STR2ENTRY_REMOVEDUPVALS\t1", "#define SLAPI_STR2ENTRY_ADDRDNVALS\t2", "#define SLAPI_STR2ENTRY_BIGENTRY\t4", "#define SLAPI_STR2ENTRY_TOMBSTONE_CHECK\t8", "#define SLAPI_STR2ENTRY_IGNORE_STATE\t16", "#define SLAPI_STR2ENTRY_INCLUDE_VERSION_STR\t32", "#define SLAPI_STR2ENTRY_EXPAND_OBJECTCLASSES\t64", "#define SLAPI_STR2ENTRY_NOT_WELL_FORMED_LDIF\t128", "char *slapi_entry2str( Slapi_Entry *e, int *len );", "char *slapi_entry_get_dn( Slapi_Entry *e );", "int slapi_x_entry_get_id( Slapi_Entry *e );", "void slapi_entry_set_dn( Slapi_Entry *e, char *dn );", "Slapi_Entry *slapi_entry_dup( Slapi_Entry *e );", "int slapi_entry_attr_delete( Slapi_Entry *e, char *type );", "Slapi_Entry *slapi_entry_alloc();", "void slapi_entry_free( Slapi_Entry *e );", "int slapi_entry_attr_merge( Slapi_Entry *e, char *type, struct berval **vals );", "int slapi_entry_attr_find( Slapi_Entry *e, char *type, Slapi_Attr **attr );", "char *slapi_entry_attr_get_charptr( const Slapi_Entry *e, const char *type );", "int slapi_entry_attr_get_int( const Slapi_Entry *e, const char *type );", "long slapi_entry_attr_get_long( const Slapi_Entry *e, const char *type );", "unsigned int slapi_entry_attr_get_uint( const Slapi_Entry *e, const char *type );", "unsigned long slapi_entry_attr_get_ulong( const Slapi_Entry *e, const char *type );", "int slapi_attr_get_values( Slapi_Attr *attr, struct berval ***vals );", "char *slapi_dn_normalize( char *dn );", "char *slapi_dn_normalize_case( char *dn );", "int slapi_dn_issuffix( char *dn, char *suffix );", "char *slapi_dn_beparent( Slapi_PBlock *pb, const char *dn );", "int slapi_dn_isbesuffix( Slapi_PBlock *pb, char *dn );", "char *slapi_dn_parent( const char *dn );", "int slapi_dn_isparent( const char *parentdn, const char *childdn );", "char *slapi_dn_ignore_case( char *dn );", "int slapi_rdn2typeval( char *rdn, char **type, struct berval *bv );", "char *slapi_dn_plus_rdn(const char *dn, const char *rdn);", "", "/* DS 5.x SLAPI */", "int slapi_access_allowed( Slapi_PBlock *pb, Slapi_Entry *e, char *attr, struct berval *val, int access );", "int slapi_acl_check_mods( Slapi_PBlock *pb, Slapi_Entry *e, LDAPMod **mods, char **errbuf );", "Slapi_Attr *slapi_attr_new( void );", "Slapi_Attr *slapi_attr_init( Slapi_Attr *a, const char *type );", "void slapi_attr_free( Slapi_Attr **a );", "Slapi_Attr *slapi_attr_dup( const Slapi_Attr *attr );", "int slapi_attr_add_value( Slapi_Attr *a, const Slapi_Value *v );", "int slapi_attr_type2plugin( const char *type, void **pi );", "int slapi_attr_get_type( const Slapi_Attr *attr, char **type );", "int slapi_attr_get_oid_copy( const Slapi_Attr *attr, char **oidp );", "int slapi_attr_get_flags( const Slapi_Attr *attr, unsigned long *flags );", "int slapi_attr_flag_is_set( const Slapi_Attr *attr, unsigned long flag );", "int slapi_attr_value_cmp( const Slapi_Attr *attr, const struct berval *v1, const struct berval *v2 );", "int slapi_attr_value_find( const Slapi_Attr *a, struct berval *v );", "#define SLAPI_TYPE_CMP_EXACT\t0", "#define SLAPI_TYPE_CMP_BASE\t1", "#define SLAPI_TYPE_CMP_SUBTYPE\t2", "int slapi_attr_type_cmp( const char *t1, const char *t2, int opt );", "int slapi_attr_types_equivalent( const char *t1, const char *t2 );", "int slapi_attr_first_value( Slapi_Attr *a, Slapi_Value **v );", "int slapi_attr_next_value( Slapi_Attr *a, int hint, Slapi_Value **v );", "int slapi_attr_get_numvalues( const Slapi_Attr *a, int *numValues );", "int slapi_attr_get_valueset( const Slapi_Attr *a, Slapi_ValueSet **vs );", "int slapi_attr_get_bervals_copy( Slapi_Attr *a, struct berval ***vals );", "int slapi_entry_attr_hasvalue( Slapi_Entry *e, const char *type, const char *value );", "int slapi_entry_attr_merge_sv( Slapi_Entry *e, const char *type, Slapi_Value **vals );", "void slapi_entry_attr_set_charptr(Slapi_Entry* e, const char *type, const char *value);", "void slapi_entry_attr_set_int( Slapi_Entry* e, const char *type, int l);", "void slapi_entry_attr_set_uint( Slapi_Entry* e, const char *type, unsigned int l);", "void slapi_entry_attr_set_long(Slapi_Entry* e, const char *type, long l);", "void slapi_entry_attr_set_ulong(Slapi_Entry* e, const char *type, unsigned long l);", "int slapi_entry_has_children(const Slapi_Entry *e);", "size_t slapi_entry_size(Slapi_Entry *e);", "int slapi_is_rootdse( const char *dn );", "int slapi_entry_attr_merge_sv( Slapi_Entry *e, const char *type, Slapi_Value **vals );", "int slapi_entry_add_values_sv( Slapi_Entry *e, const char *type, Slapi_Value **vals );", "int slapi_entry_add_valueset(Slapi_Entry *e, const char *type, Slapi_ValueSet *vs);", "int slapi_entry_delete_values_sv( Slapi_Entry *e, const char *type, Slapi_Value **vals );", "int slapi_entry_merge_values_sv( Slapi_Entry *e, const char *type, Slapi_Value **vals );", "int slapi_entry_attr_replace_sv( Slapi_Entry *e, const char *type, Slapi_Value **vals );", "int slapi_entry_add_value(Slapi_Entry *e, const char *type, const Slapi_Value *value);", "int slapi_entry_add_string(Slapi_Entry *e, const char *type, const char *value);", "int slapi_entry_delete_string(Slapi_Entry *e, const char *type, const char *value);", "int slapi_entry_first_attr( const Slapi_Entry *e, Slapi_Attr **attr );", "int slapi_entry_next_attr( const Slapi_Entry *e, Slapi_Attr *prevattr, Slapi_Attr **attr );", "const char *slapi_entry_get_uniqueid( const Slapi_Entry *e );", "void slapi_entry_set_uniqueid( Slapi_Entry *e, char *uniqueid );", "int slapi_entry_schema_check( Slapi_PBlock *pb, Slapi_Entry *e );", "int slapi_entry_rdn_values_present( const Slapi_Entry *e );", "int slapi_entry_add_rdn_values( Slapi_Entry *e );", "char *slapi_attr_syntax_normalize( const char *s );", "", "Slapi_Value *slapi_value_new( void );", "Slapi_Value *slapi_value_new_berval(const struct berval *bval);", "Slapi_Value *slapi_value_new_value(const Slapi_Value *v);", "Slapi_Value *slapi_value_new_string(const char *s);", "Slapi_Value *slapi_value_init(Slapi_Value *v);", "Slapi_Value *slapi_value_init_berval(Slapi_Value *v, struct berval *bval);", "Slapi_Value *slapi_value_init_string(Slapi_Value *v, const char *s);", "Slapi_Value *slapi_value_dup(const Slapi_Value *v);", "void slapi_value_free(Slapi_Value **value);", "const struct berval *slapi_value_get_berval( const Slapi_Value *value );", "Slapi_Value *slapi_value_set_berval( Slapi_Value *value, const struct berval *bval );", "Slapi_Value *slapi_value_set_value( Slapi_Value *value, const Slapi_Value *vfrom);", "Slapi_Value *slapi_value_set( Slapi_Value *value, void *val, unsigned long len);", "int slapi_value_set_string(Slapi_Value *value, const char *strVal);", "int slapi_value_set_int(Slapi_Value *value, int intVal);", "const char*slapi_value_get_string(const Slapi_Value *value);", "int slapi_value_get_int(const Slapi_Value *value); ", "unsigned int slapi_value_get_uint(const Slapi_Value *value); ", "long slapi_value_get_long(const Slapi_Value *value); ", "unsigned long slapi_value_get_ulong(const Slapi_Value *value); ", "size_t slapi_value_get_length(const Slapi_Value *value);", "int slapi_value_compare(const Slapi_Attr *a, const Slapi_Value *v1, const Slapi_Value *v2);", "", "Slapi_ValueSet *slapi_valueset_new( void );", "void slapi_valueset_free(Slapi_ValueSet *vs);", "void slapi_valueset_init(Slapi_ValueSet *vs);", "void slapi_valueset_done(Slapi_ValueSet *vs);", "void slapi_valueset_add_value(Slapi_ValueSet *vs, const Slapi_Value *addval);", "int slapi_valueset_first_value( Slapi_ValueSet *vs, Slapi_Value **v );", "int slapi_valueset_next_value( Slapi_ValueSet *vs, int index, Slapi_Value **v);", "int slapi_valueset_count( const Slapi_ValueSet *vs);", "void slapi_valueset_set_valueset(Slapi_ValueSet *vs1, const Slapi_ValueSet *vs2);", "", "/* DNs */", "Slapi_DN *slapi_sdn_new( void );", "Slapi_DN *slapi_sdn_new_dn_byval( const char *dn );", "Slapi_DN *slapi_sdn_new_ndn_byval( const char *ndn );", "Slapi_DN *slapi_sdn_new_dn_byref( const char *dn );", "Slapi_DN *slapi_sdn_new_ndn_byref( const char *ndn );", "Slapi_DN *slapi_sdn_new_dn_passin( const char *dn );", "Slapi_DN *slapi_sdn_set_dn_byval( Slapi_DN *sdn, const char *dn );", "Slapi_DN *slapi_sdn_set_dn_byref( Slapi_DN *sdn, const char *dn );", "Slapi_DN *slapi_sdn_set_dn_passin( Slapi_DN *sdn, const char *dn );", "Slapi_DN *slapi_sdn_set_ndn_byval( Slapi_DN *sdn, const char *ndn );", "Slapi_DN *slapi_sdn_set_ndn_byref( Slapi_DN *sdn, const char *ndn );", "void slapi_sdn_done( Slapi_DN *sdn );", "void slapi_sdn_free( Slapi_DN **sdn );", "const char * slapi_sdn_get_dn( const Slapi_DN *sdn );", "const char * slapi_sdn_get_ndn( const Slapi_DN *sdn );", "void slapi_sdn_get_parent( const Slapi_DN *sdn,Slapi_DN *sdn_parent );", "void slapi_sdn_get_backend_parent( const Slapi_DN *sdn, Slapi_DN *sdn_parent, const Slapi_Backend *backend );", "Slapi_DN * slapi_sdn_dup( const Slapi_DN *sdn );", "void slapi_sdn_copy( const Slapi_DN *from, Slapi_DN *to );", "int slapi_sdn_compare( const Slapi_DN *sdn1, const Slapi_DN *sdn2 );", "int slapi_sdn_isempty( const Slapi_DN *sdn );", "int slapi_sdn_issuffix(const Slapi_DN *sdn, const Slapi_DN *suffixsdn );", "int slapi_sdn_isparent( const Slapi_DN *parent, const Slapi_DN *child );", "int slapi_sdn_isgrandparent( const Slapi_DN *parent, const Slapi_DN *child );", "int slapi_sdn_get_ndn_len( const Slapi_DN *sdn );", "int slapi_sdn_scope_test( const Slapi_DN *dn, const Slapi_DN *base, int scope );", "void slapi_sdn_get_rdn( const Slapi_DN *sdn,Slapi_RDN *rdn );", "Slapi_DN *slapi_sdn_set_rdn( Slapi_DN *sdn, const Slapi_RDN *rdn );", "Slapi_DN *slapi_sdn_set_parent( Slapi_DN *sdn, const Slapi_DN *parentdn );", "int slapi_sdn_is_rdn_component( const Slapi_DN *rdn, const Slapi_Attr *a, const Slapi_Value *v );", "char * slapi_moddn_get_newdn( Slapi_DN *dn_olddn, char *newrdn, char *newsuperiordn );", "", "/* RDNs */", "Slapi_RDN *slapi_rdn_new( void );", "Slapi_RDN *slapi_rdn_new_dn( const char *dn );", "Slapi_RDN *slapi_rdn_new_sdn( const Slapi_DN *sdn );", "Slapi_RDN *slapi_rdn_new_rdn( const Slapi_RDN *fromrdn ); ", "void slapi_rdn_init( Slapi_RDN *rdn );", "void slapi_rdn_init_dn( Slapi_RDN *rdn, const char *dn );", "void slapi_rdn_init_sdn( Slapi_RDN *rdn, const Slapi_DN *sdn );", "void slapi_rdn_init_rdn( Slapi_RDN *rdn, const Slapi_RDN *fromrdn ); ", "void slapi_rdn_set_dn( Slapi_RDN *rdn, const char *dn );", "void slapi_rdn_set_sdn( Slapi_RDN *rdn, const Slapi_DN *sdn );", "void slapi_rdn_set_rdn( Slapi_RDN *rdn, const Slapi_RDN *fromrdn );", "void slapi_rdn_free( Slapi_RDN **rdn );", "void slapi_rdn_done( Slapi_RDN *rdn );", "int slapi_rdn_get_first( Slapi_RDN *rdn, char **type, char **value );", "int slapi_rdn_get_next( Slapi_RDN *rdn, int index, char **type, char **value );", "int slapi_rdn_get_index( Slapi_RDN *rdn, const char *type, const char *value, size_t length );", "int slapi_rdn_get_index_attr( Slapi_RDN *rdn, const char *type, char **value );", "int slapi_rdn_contains( Slapi_RDN *rdn, const char *type, const char *value,size_t length );", "int slapi_rdn_contains_attr( Slapi_RDN *rdn, const char *type, char **value );", "int slapi_rdn_add( Slapi_RDN *rdn, const char *type, const char *value );", "int slapi_rdn_remove_index( Slapi_RDN *rdn, int atindex );", "int slapi_rdn_remove( Slapi_RDN *rdn, const char *type, const char *value, size_t length );", "int slapi_rdn_remove_attr( Slapi_RDN *rdn, const char *type );", "int slapi_rdn_isempty( const Slapi_RDN *rdn );", "int slapi_rdn_get_num_components( Slapi_RDN *rdn );", "int slapi_rdn_compare( Slapi_RDN *rdn1, Slapi_RDN *rdn2 );", "const char *slapi_rdn_get_rdn( const Slapi_RDN *rdn );", "const char *slapi_rdn_get_nrdn( const Slapi_RDN *rdn );", "Slapi_DN *slapi_sdn_add_rdn( Slapi_DN *sdn, const Slapi_RDN *rdn );", "", "/* locks and synchronization */", "typedef struct slapi_mutex\tSlapi_Mutex;", "typedef struct slapi_condvar\tSlapi_CondVar;", "Slapi_Mutex *slapi_new_mutex( void );", "void slapi_destroy_mutex( Slapi_Mutex *mutex );", "void slapi_lock_mutex( Slapi_Mutex *mutex );", "int slapi_unlock_mutex( Slapi_Mutex *mutex );", "Slapi_CondVar *slapi_new_condvar( Slapi_Mutex *mutex );", "void slapi_destroy_condvar( Slapi_CondVar *cvar );", "int slapi_wait_condvar( Slapi_CondVar *cvar, struct timeval *timeout );", "int slapi_notify_condvar( Slapi_CondVar *cvar, int notify_all );", "", "/* thread-safe LDAP connections */", "LDAP *slapi_ldap_init( char *ldaphost, int ldapport, int secure, int shared );", "void slapi_ldap_unbind( LDAP *ld );", "", "char *slapi_ch_malloc( unsigned long size );", "void slapi_ch_free( void **ptr );", "void slapi_ch_free_string( char **ptr );", "char *slapi_ch_calloc( unsigned long nelem, unsigned long size );", "char *slapi_ch_realloc( char *block, unsigned long size );", "char *slapi_ch_strdup( const char *s );", "void slapi_ch_array_free( char **arrayp );", "struct berval *slapi_ch_bvdup(const struct berval *v);", "struct berval **slapi_ch_bvecdup(const struct berval **v);", "", "/* LDAP V3 routines */", "int slapi_control_present( LDAPControl **controls, char *oid,", "\tstruct berval **val, int *iscritical);", "void slapi_register_supported_control(char *controloid,", "\tunsigned long controlops);", "#define SLAPI_OPERATION_BIND            0x00000001L", "#define SLAPI_OPERATION_UNBIND          0x00000002L", "#define SLAPI_OPERATION_SEARCH          0x00000004L", "#define SLAPI_OPERATION_MODIFY          0x00000008L", "#define SLAPI_OPERATION_ADD             0x00000010L", "#define SLAPI_OPERATION_DELETE          0x00000020L", "#define SLAPI_OPERATION_MODDN           0x00000040L", "#define SLAPI_OPERATION_MODRDN          SLAPI_OPERATION_MODDN", "#define SLAPI_OPERATION_COMPARE         0x00000080L", "#define SLAPI_OPERATION_ABANDON         0x00000100L", "#define SLAPI_OPERATION_EXTENDED        0x00000200L", "#define SLAPI_OPERATION_ANY             0xFFFFFFFFL", "#define SLAPI_OPERATION_NONE            0x00000000L", "int slapi_get_supported_controls(char ***ctrloidsp, unsigned long **ctrlopsp);", "LDAPControl *slapi_dup_control(LDAPControl *ctrl);", "void slapi_register_supported_saslmechanism(char *mechanism);", "char **slapi_get_supported_saslmechanisms();", "char **slapi_get_supported_extended_ops(void);", "", "/* operation */", "int slapi_op_abandoned( Slapi_PBlock *pb );", "unsigned long slapi_op_get_type(Slapi_Operation * op);", "void slapi_operation_set_flag(Slapi_Operation *op, unsigned long flag);", "void slapi_operation_clear_flag(Slapi_Operation *op, unsigned long flag);", "int slapi_operation_is_flag_set(Slapi_Operation *op, unsigned long flag);", "char *slapi_op_type_to_string(unsigned long type);", "", "/* send ldap result back */", "void slapi_send_ldap_result( Slapi_PBlock *pb, int err, char *matched,", "\tchar *text, int nentries, struct berval **urls );", "int slapi_send_ldap_search_entry( Slapi_PBlock *pb, Slapi_Entry *e,", "\tLDAPControl **ectrls, char **attrs, int attrsonly );", "int slapi_send_ldap_search_reference( Slapi_PBlock *pb, Slapi_Entry *e,", "\tstruct berval **urls, LDAPControl **ectrls, struct berval **v2refs );", "", "/* filter routines */", "Slapi_Filter *slapi_str2filter( char *str );", "Slapi_Filter *slapi_filter_dup( Slapi_Filter *f );", "void slapi_filter_free( Slapi_Filter *f, int recurse );", "int slapi_filter_get_choice( Slapi_Filter *f);", "int slapi_filter_get_ava( Slapi_Filter *f, char **type, struct berval **bval );", "Slapi_Filter *slapi_filter_list_first( Slapi_Filter *f );", "Slapi_Filter *slapi_filter_list_next( Slapi_Filter *f, Slapi_Filter *fprev );", "int slapi_filter_get_attribute_type( Slapi_Filter *f, char **type ); ", "int slapi_x_filter_set_attribute_type( Slapi_Filter *f, const char *type );", "int slapi_filter_get_subfilt( Slapi_Filter *f, char **type, char **initial,", "\tchar ***any, char **final );", "Slapi_Filter *slapi_filter_join( int ftype, Slapi_Filter *f1, Slapi_Filter *f2);", "int slapi_x_filter_append( int choice, Slapi_Filter **pContainingFilter,", "\tSlapi_Filter **pNextFilter, Slapi_Filter *filterToAppend );", "int slapi_filter_test( Slapi_PBlock *pb, Slapi_Entry *e, Slapi_Filter *f,", "\tint verify_access );", "int slapi_filter_test_simple( Slapi_Entry *e, Slapi_Filter *f );", "typedef int (*FILTER_APPLY_FN)( Slapi_Filter *f, void *arg );", "int slapi_filter_apply( Slapi_Filter *f, FILTER_APPLY_FN fn, void *arg, int *error_code );", "#define SLAPI_FILTER_SCAN_STOP\t\t\t-1 /* set by callback */", "#define SLAPI_FILTER_SCAN_ERROR\t\t\t-2 /* set by callback */", "#define SLAPI_FILTER_SCAN_NOMORE\t\t0 /* set by callback */", "#define SLAPI_FILTER_SCAN_CONTINUE\t\t1 /* set by callback */", "#define SLAPI_FILTER_UNKNOWN_FILTER_TYPE\t2 /* set by slapi_filter_apply() */", "", "/* internal add/delete/search/modify routines */", "Slapi_PBlock *slapi_search_internal( char *base, int scope, char *filter, ", "\tLDAPControl **controls, char **attrs, int attrsonly );", "Slapi_PBlock *slapi_modify_internal( char *dn, LDAPMod **mods,", "        LDAPControl **controls, int log_change );", "Slapi_PBlock *slapi_add_internal( char * dn, LDAPMod **attrs,", "\tLDAPControl **controls, int log_changes );", "Slapi_PBlock *slapi_add_entry_internal( Slapi_Entry * e,", "\tLDAPControl **controls, int log_change );", "Slapi_PBlock *slapi_delete_internal( char * dn,  LDAPControl **controls,", "\tint log_change );", "Slapi_PBlock *slapi_modrdn_internal( char * olddn, char * newrdn,", "\tint deloldrdn, LDAPControl **controls,", "\tint log_change );", "Slapi_PBlock *slapi_rename_internal( const char * olddn, const char *newrdn,", "\tconst char *newsuperior, int delolrdn,", "\tLDAPControl **controls, int log_change );", "void slapi_free_search_results_internal(Slapi_PBlock *pb);", "", "/* new internal add/delete/search/modify routines */", "typedef void (*plugin_result_callback)( int rc, void *callback_data );", "typedef int (*plugin_referral_entry_callback)( char * referral,", "\tvoid *callback_data );", "typedef int (*plugin_search_entry_callback)( Slapi_Entry *e,", "\tvoid *callback_data );", "void slapi_free_search_results_internal( Slapi_PBlock *pb );", "", "#define SLAPI_OP_FLAG_NEVER_CHAIN\t0x0800", "", "int slapi_search_internal_pb( Slapi_PBlock *pb );", "int slapi_search_internal_callback_pb( Slapi_PBlock *pb, void *callback_data,", "\tplugin_result_callback prc, plugin_search_entry_callback psec,", "\tplugin_referral_entry_callback prec );", "int slapi_add_internal_pb( Slapi_PBlock *pb );", "int slapi_modify_internal_pb( Slapi_PBlock *pb );", "int slapi_modrdn_internal_pb( Slapi_PBlock *pb );", "int slapi_delete_internal_pb( Slapi_PBlock *pb );", "", "int slapi_seq_internal_callback_pb(Slapi_PBlock *pb, void *callback_data,", "        plugin_result_callback res_callback,", "        plugin_search_entry_callback srch_callback,", "        plugin_referral_entry_callback ref_callback);", "", "void slapi_search_internal_set_pb( Slapi_PBlock *pb, const char *base,", "\tint scope, const char *filter, char **attrs, int attrsonly,", "\tLDAPControl **controls, const char *uniqueid,", "\tSlapi_ComponentId *plugin_identity, int operation_flags );", "void slapi_add_entry_internal_set_pb( Slapi_PBlock *pb, Slapi_Entry *e,", "\tLDAPControl **controls, Slapi_ComponentId *plugin_identity,", "\tint operation_flags );", "int slapi_add_internal_set_pb( Slapi_PBlock *pb, const char *dn,", "\tLDAPMod **attrs, LDAPControl **controls,", "\tSlapi_ComponentId *plugin_identity, int operation_flags );", "void slapi_modify_internal_set_pb( Slapi_PBlock *pb, const char *dn,", "\tLDAPMod **mods, LDAPControl **controls, const char *uniqueid,", "\tSlapi_ComponentId *plugin_identity, int operation_flags );", "void slapi_rename_internal_set_pb( Slapi_PBlock *pb, const char *olddn,", "\tconst char *newrdn, const char *newsuperior, int deloldrdn,", "\tLDAPControl **controls, const char *uniqueid,", "\tSlapi_ComponentId *plugin_identity, int operation_flags );", "void slapi_delete_internal_set_pb( Slapi_PBlock *pb, const char *dn,", "\tLDAPControl **controls, const char *uniqueid,", "\tSlapi_ComponentId *plugin_identity, int operation_flags );", "void slapi_seq_internal_set_pb( Slapi_PBlock *pb, char *ibase, int type,", "\tchar *attrname, char *val, char **attrs, int attrsonly,", "\tLDAPControl **controls, Slapi_ComponentId *plugin_identity,", "\tint operation_flags );", "", "/* connection related routines */", "int slapi_is_connection_ssl(Slapi_PBlock *pPB, int *isSSL);", "int slapi_get_client_port(Slapi_PBlock *pPB, int *fromPort);", "", "/* computed attributes */", "typedef struct _computed_attr_context computed_attr_context;", "typedef int (*slapi_compute_output_t)(computed_attr_context *c, Slapi_Attr *a, Slapi_Entry *e);", "typedef int (*slapi_compute_callback_t)(computed_attr_context *c, char *type, Slapi_Entry *e, slapi_compute_output_t outputfn);", "typedef int (*slapi_search_rewrite_callback_t)(Slapi_PBlock *pb);", "int slapi_compute_add_evaluator(slapi_compute_callback_t function);", "int slapi_compute_add_search_rewriter(slapi_search_rewrite_callback_t function);", "int compute_rewrite_search_filter(Slapi_PBlock *pb);", "int compute_evaluator(computed_attr_context *c, char *type, Slapi_Entry *e, slapi_compute_output_t outputfn);", "int slapi_x_compute_get_pblock(computed_attr_context *c, Slapi_PBlock **pb);", "", "/* backend routines */", "void slapi_be_set_readonly( Slapi_Backend *be, int readonly );", "int slapi_be_get_readonly( Slapi_Backend *be );", "const char *slapi_x_be_get_updatedn( Slapi_Backend *be );", "Slapi_Backend *slapi_be_select( const Slapi_DN *sdn );", "", "/* ACL plugins; only SLAPI_PLUGIN_ACL_ALLOW_ACCESS supported now */", "typedef int (*slapi_acl_callback_t)(Slapi_PBlock *pb,", "\tSlapi_Entry *e,", "\tconst char *attr,", "\tstruct berval *berval,", "\tint access,", "\tvoid *state);", "", "/* object extensions */", "typedef void *(*slapi_extension_constructor_fnptr)(void *object, void *parent);", "", "typedef void (*slapi_extension_destructor_fnptr)(void *extension,", "\tvoid *object, void *parent);", "", "int slapi_register_object_extension( const char *pluginname,", "\tconst char *objectname, slapi_extension_constructor_fnptr constructor,", "\tslapi_extension_destructor_fnptr destructor, int *objecttype,", "\tint *extensionhandle);", "", '#define SLAPI_EXT_CONNECTION    "Connection"', '#define SLAPI_EXT_OPERATION     "Operation"', '#define SLAPI_EXT_ENTRY         "Entry"', '#define SLAPI_EXT_MTNODE        "Mapping Tree Node"', "", "void *slapi_get_object_extension(int objecttype, void *object,", "\tint extensionhandle);", "void slapi_set_object_extension(int objecttype, void *object,", "\tint extensionhandle, void *extension);", "", "int slapi_x_backend_get_flags( const Slapi_Backend *be, unsigned long *flags );", "", "/* parameters currently supported */", "", "/*", " * Attribute flags returned by slapi_attr_get_flags()", " */", "#define SLAPI_ATTR_FLAG_SINGLE\t\t0x0001", "#define SLAPI_ATTR_FLAG_OPATTR\t\t0x0002", "#define SLAPI_ATTR_FLAG_READONLY\t0x0004", "#define SLAPI_ATTR_FLAG_STD_ATTR\tSLAPI_ATTR_FLAG_READONLY", "#define SLAPI_ATTR_FLAG_OBSOLETE\t0x0040", "#define SLAPI_ATTR_FLAG_COLLECTIVE\t0x0080", "#define SLAPI_ATTR_FLAG_NOUSERMOD\t0x0100", "", "/*", " * Backend flags returned by slapi_x_backend_get_flags()", " */", "#define SLAPI_BACKEND_FLAG_NOLASTMOD\t\t0x0001U", "#define SLAPI_BACKEND_FLAG_NO_SCHEMA_CHECK\t0x0002U", "#define SLAPI_BACKEND_FLAG_GLUE_INSTANCE\t0x0010U\t/* a glue backend */", "#define SLAPI_BACKEND_FLAG_GLUE_SUBORDINATE\t0x0020U\t/* child of a glue hierarchy */", "#define SLAPI_BACKEND_FLAG_GLUE_LINKED\t\t0x0040U\t/* child is connected to parent */", "#define SLAPI_BACKEND_FLAG_OVERLAY\t\t0x0080U\t/* this db struct is an overlay */", "#define SLAPI_BACKEND_FLAG_GLOBAL_OVERLAY\t0x0100U\t/* this db struct is a global overlay */", "#define SLAPI_BACKEND_FLAG_SHADOW\t\t0x8000U /* a shadow */", "#define SLAPI_BACKEND_FLAG_SYNC_SHADOW\t\t0x1000U /* a sync shadow */", "#define SLAPI_BACKEND_FLAG_SLURP_SHADOW\t\t0x2000U /* a slurp shadow */", "", "/*", " * ACL levels", " */", "#define SLAPI_ACL_COMPARE       0x01", "#define SLAPI_ACL_SEARCH        0x02", "#define SLAPI_ACL_READ          0x04", "#define SLAPI_ACL_WRITE         0x08", "#define SLAPI_ACL_DELETE        0x10    ", "#define SLAPI_ACL_ADD           0x20", "#define SLAPI_ACL_SELF          0x40", "#define SLAPI_ACL_PROXY         0x80", "#define SLAPI_ACL_ALL           0x7f", "", "/* plugin types supported */", "", "#define SLAPI_PLUGIN_DATABASE           1", "#define SLAPI_PLUGIN_EXTENDEDOP         2", "#define SLAPI_PLUGIN_PREOPERATION       3", "#define SLAPI_PLUGIN_POSTOPERATION      4", "#define SLAPI_PLUGIN_MATCHINGRULE       5", "#define SLAPI_PLUGIN_SYNTAX             6", "#define SLAPI_PLUGIN_AUDIT              7   ", "", "/* misc params */", "", "#define SLAPI_BACKEND\t\t\t\t130", "#define SLAPI_CONNECTION\t\t\t131", "#define SLAPI_OPERATION\t\t\t\t132", "#define SLAPI_REQUESTOR_ISROOT\t\t\t133", "#define SLAPI_BE_MONITORDN\t\t\t134", "#define SLAPI_BE_TYPE           \t\t135", "#define SLAPI_BE_READONLY       \t\t136", "#define SLAPI_BE_LASTMOD       \t\t\t137", "#define SLAPI_CONN_ID        \t\t\t139", "", "/* operation params */", "#define SLAPI_OPINITIATED_TIME\t\t\t140", "#define SLAPI_REQUESTOR_DN\t\t\t141", "#define SLAPI_IS_REPLICATED_OPERATION\t\t142", "#define SLAPI_REQUESTOR_ISUPDATEDN\t\tSLAPI_IS_REPLICATED_OPERATION", "", "/* connection  structure params*/", "#define SLAPI_CONN_DN        \t\t\t143", "#define SLAPI_CONN_AUTHTYPE    \t\t\t144", "#define SLAPI_CONN_CLIENTIP\t\t\t145", "#define SLAPI_CONN_SERVERIP\t\t\t146", "/* OpenLDAP extensions */", "#define SLAPI_X_CONN_CLIENTPATH\t\t\t1300", "#define SLAPI_X_CONN_SERVERPATH\t\t\t1301", "#define SLAPI_X_CONN_IS_UDP\t\t\t1302", "#define SLAPI_X_CONN_SSF\t\t\t1303", "#define SLAPI_X_CONN_SASL_CONTEXT\t\t1304", "#define SLAPI_X_OPERATION_DELETE_GLUE_PARENT\t1305", "#define SLAPI_X_RELAX\t\t\t1306", "#define SLAPI_X_MANAGEDIT\t\t\tSLAPI_X_RELAX", "#define SLAPI_X_OPERATION_NO_SCHEMA_CHECK\t1307", "#define SLAPI_X_ADD_STRUCTURAL_CLASS\t\t1308", "#define SLAPI_X_OPERATION_NO_SUBORDINATE_GLUE\t1309", "", "/*  Authentication types */", '#define SLAPD_AUTH_NONE   "none"', '#define SLAPD_AUTH_SIMPLE "simple"', '#define SLAPD_AUTH_SSL    "SSL"', '#define SLAPD_AUTH_SASL   "SASL " ', "", "/* plugin configuration parmams */", "#define SLAPI_PLUGIN\t\t\t\t3", "#define SLAPI_PLUGIN_PRIVATE\t\t\t4", "#define SLAPI_PLUGIN_TYPE\t\t\t5", "#define SLAPI_PLUGIN_ARGV\t\t\t6", "#define SLAPI_PLUGIN_ARGC\t\t\t7", "#define SLAPI_PLUGIN_VERSION\t\t\t8", "#define SLAPI_PLUGIN_OPRETURN\t\t\t9", "#define SLAPI_PLUGIN_OBJECT\t\t\t10", "#define SLAPI_PLUGIN_DESTROY_FN\t\t\t11", "#define SLAPI_PLUGIN_DESCRIPTION\t\t12", "#define SLAPI_PLUGIN_IDENTITY\t\t\t13", "", "/* internal opreations params */", "#define SLAPI_PLUGIN_INTOP_RESULT\t\t15", "#define SLAPI_PLUGIN_INTOP_SEARCH_ENTRIES\t16", "#define SLAPI_PLUGIN_INTOP_SEARCH_REFERRALS\t17", "", "/* transaction arguments */", "#define SLAPI_PARENT_TXN\t\t\t190", "#define SLAPI_TXN\t\t\t\t191", "", "/* function pointer params for backends */", "#define SLAPI_PLUGIN_DB_BIND_FN\t\t\t200", "#define SLAPI_PLUGIN_DB_UNBIND_FN\t\t201", "#define SLAPI_PLUGIN_DB_SEARCH_FN\t\t202", "#define SLAPI_PLUGIN_DB_COMPARE_FN\t\t203", "#define SLAPI_PLUGIN_DB_MODIFY_FN\t\t204", "#define SLAPI_PLUGIN_DB_MODRDN_FN\t\t205", "#define SLAPI_PLUGIN_DB_ADD_FN\t\t\t206", "#define SLAPI_PLUGIN_DB_DELETE_FN\t\t207", "#define SLAPI_PLUGIN_DB_ABANDON_FN\t\t208", "#define SLAPI_PLUGIN_DB_CONFIG_FN\t\t209", "#define SLAPI_PLUGIN_CLOSE_FN\t\t\t210", "#define SLAPI_PLUGIN_DB_FLUSH_FN\t\t211", "#define SLAPI_PLUGIN_START_FN\t\t\t212", "#define SLAPI_PLUGIN_DB_SEQ_FN\t\t\t213", "#define SLAPI_PLUGIN_DB_ENTRY_FN\t\t214", "#define SLAPI_PLUGIN_DB_REFERRAL_FN\t\t215", "#define SLAPI_PLUGIN_DB_RESULT_FN\t\t216", "#define SLAPI_PLUGIN_DB_LDIF2DB_FN\t\t217", "#define SLAPI_PLUGIN_DB_DB2LDIF_FN\t\t218", "#define SLAPI_PLUGIN_DB_BEGIN_FN\t\t219", "#define SLAPI_PLUGIN_DB_COMMIT_FN\t\t220", "#define SLAPI_PLUGIN_DB_ABORT_FN\t\t221", "#define SLAPI_PLUGIN_DB_ARCHIVE2DB_FN\t\t222", "#define SLAPI_PLUGIN_DB_DB2ARCHIVE_FN\t\t223", "#define SLAPI_PLUGIN_DB_NEXT_SEARCH_ENTRY_FN\t224", "#define SLAPI_PLUGIN_DB_FREE_RESULT_SET_FN\t225", "#define\tSLAPI_PLUGIN_DB_SIZE_FN\t\t\t226", "#define\tSLAPI_PLUGIN_DB_TEST_FN\t\t\t227", "", "", "/*  functions pointers for LDAP V3 extended ops */", "#define SLAPI_PLUGIN_EXT_OP_FN\t\t\t300", "#define SLAPI_PLUGIN_EXT_OP_OIDLIST\t\t301", "", "/* preoperation */", "#define SLAPI_PLUGIN_PRE_BIND_FN\t\t401", "#define SLAPI_PLUGIN_PRE_UNBIND_FN\t\t402", "#define SLAPI_PLUGIN_PRE_SEARCH_FN\t\t403", "#define SLAPI_PLUGIN_PRE_COMPARE_FN\t\t404", "#define SLAPI_PLUGIN_PRE_MODIFY_FN\t\t405", "#define SLAPI_PLUGIN_PRE_MODRDN_FN\t\t406", "#define SLAPI_PLUGIN_PRE_ADD_FN\t\t\t407", "#define SLAPI_PLUGIN_PRE_DELETE_FN\t\t408", "#define SLAPI_PLUGIN_PRE_ABANDON_FN\t\t409", "#define SLAPI_PLUGIN_PRE_ENTRY_FN\t\t410", "#define SLAPI_PLUGIN_PRE_REFERRAL_FN\t\t411", "#define SLAPI_PLUGIN_PRE_RESULT_FN\t\t412", "", "/* internal preoperation */", "#define SLAPI_PLUGIN_INTERNAL_PRE_ADD_FN\t420", "#define SLAPI_PLUGIN_INTERNAL_PRE_MODIFY_FN\t421", "#define SLAPI_PLUGIN_INTERNAL_PRE_MODRDN_FN\t422", "#define SLAPI_PLUGIN_INTERNAL_PRE_DELETE_FN\t423", "", "/* backend preoperation */", "#define SLAPI_PLUGIN_BE_PRE_ADD_FN\t\t450", "#define SLAPI_PLUGIN_BE_PRE_MODIFY_FN\t\t451", "#define SLAPI_PLUGIN_BE_PRE_MODRDN_FN\t\t452", "#define SLAPI_PLUGIN_BE_PRE_DELETE_FN\t\t453", "", "/* postoperation */", "#define SLAPI_PLUGIN_POST_BIND_FN\t\t501", "#define SLAPI_PLUGIN_POST_UNBIND_FN\t\t502", "#define SLAPI_PLUGIN_POST_SEARCH_FN\t\t503", "#define SLAPI_PLUGIN_POST_COMPARE_FN\t\t504", "#define SLAPI_PLUGIN_POST_MODIFY_FN\t\t505", "#define SLAPI_PLUGIN_POST_MODRDN_FN\t\t506", "#define SLAPI_PLUGIN_POST_ADD_FN\t\t507", "#define SLAPI_PLUGIN_POST_DELETE_FN\t\t508", "#define SLAPI_PLUGIN_POST_ABANDON_FN\t\t509", "#define SLAPI_PLUGIN_POST_ENTRY_FN\t\t510", "#define SLAPI_PLUGIN_POST_REFERRAL_FN\t\t511", "#define SLAPI_PLUGIN_POST_RESULT_FN\t\t512", "", "/* internal postoperation */", "#define SLAPI_PLUGIN_INTERNAL_POST_ADD_FN\t520", "#define SLAPI_PLUGIN_INTERNAL_POST_MODIFY_FN\t521", "#define SLAPI_PLUGIN_INTERNAL_POST_MODRDN_FN\t522", "#define SLAPI_PLUGIN_INTERNAL_POST_DELETE_FN\t523", "", "/* backend postoperation */", "#define SLAPI_PLUGIN_BE_POST_ADD_FN\t\t550", "#define SLAPI_PLUGIN_BE_POST_MODIFY_FN\t\t551", "#define SLAPI_PLUGIN_BE_POST_MODRDN_FN\t\t552", "#define SLAPI_PLUGIN_BE_POST_DELETE_FN\t\t553", "", "#define SLAPI_OPERATION_TYPE\t\t\t590", "#define SLAPI_OPERATION_MSGID\t\t\t591", "", "#define SLAPI_PLUGIN_MR_FILTER_CREATE_FN\t600", "#define SLAPI_PLUGIN_MR_INDEXER_CREATE_FN\t601", "#define SLAPI_PLUGIN_MR_FILTER_MATCH_FN\t\t602", "#define SLAPI_PLUGIN_MR_FILTER_INDEX_FN\t\t603", "#define SLAPI_PLUGIN_MR_FILTER_RESET_FN\t\t604", "#define SLAPI_PLUGIN_MR_INDEX_FN\t\t605", "#define SLAPI_PLUGIN_MR_OID\t\t\t610", "#define SLAPI_PLUGIN_MR_TYPE\t\t\t611", "#define SLAPI_PLUGIN_MR_VALUE\t\t\t612", "#define SLAPI_PLUGIN_MR_VALUES\t\t\t613", "#define SLAPI_PLUGIN_MR_KEYS\t\t\t614", "#define SLAPI_PLUGIN_MR_FILTER_REUSABLE\t\t615", "#define SLAPI_PLUGIN_MR_QUERY_OPERATOR\t\t616", "#define SLAPI_PLUGIN_MR_USAGE\t\t\t617", "", "#define SLAPI_MATCHINGRULE_NAME\t\t\t1", "#define SLAPI_MATCHINGRULE_OID\t\t\t2", "#define SLAPI_MATCHINGRULE_DESC\t\t\t3", "#define SLAPI_MATCHINGRULE_SYNTAX\t\t4", "#define SLAPI_MATCHINGRULE_OBSOLETE\t\t5", "", "#define SLAPI_OP_LESS\t\t\t\t\t1", "#define SLAPI_OP_LESS_OR_EQUAL\t\t\t\t2", "#define SLAPI_OP_EQUAL\t\t\t\t\t3", "#define SLAPI_OP_GREATER_OR_EQUAL\t\t\t4", "#define SLAPI_OP_GREATER\t\t\t\t5", "#define SLAPI_OP_SUBSTRING\t\t\t\t6", "", "#define SLAPI_PLUGIN_MR_USAGE_INDEX\t\t0", "#define SLAPI_PLUGIN_MR_USAGE_SORT\t\t1", "", "#define SLAPI_PLUGIN_SYNTAX_FILTER_AVA\t\t700", "#define SLAPI_PLUGIN_SYNTAX_FILTER_SUB\t\t701", "#define SLAPI_PLUGIN_SYNTAX_VALUES2KEYS\t\t702", "#define SLAPI_PLUGIN_SYNTAX_ASSERTION2KEYS_AVA\t703", "#define SLAPI_PLUGIN_SYNTAX_ASSERTION2KEYS_SUB\t704", "#define SLAPI_PLUGIN_SYNTAX_NAMES\t\t705", "#define SLAPI_PLUGIN_SYNTAX_OID\t\t\t706", "#define SLAPI_PLUGIN_SYNTAX_FLAGS\t\t707", "#define SLAPI_PLUGIN_SYNTAX_COMPARE\t\t708", "", "#define SLAPI_PLUGIN_SYNTAX_FLAG_ORKEYS\t\t\t1", "#define SLAPI_PLUGIN_SYNTAX_FLAG_ORDERING\t\t2", "", "#define SLAPI_PLUGIN_ACL_INIT\t\t\t730", "#define SLAPI_PLUGIN_ACL_SYNTAX_CHECK\t\t731", "#define SLAPI_PLUGIN_ACL_ALLOW_ACCESS\t\t732", "#define SLAPI_PLUGIN_ACL_MODS_ALLOWED\t\t733", "#define SLAPI_PLUGIN_ACL_MODS_UPDATE\t\t734", "", "#define SLAPI_OPERATION_AUTHTYPE                741", "#define SLAPI_OPERATION_ID                      742", "#define SLAPI_CONN_CERT                         743", "#define SLAPI_CONN_AUTHMETHOD                   746", "#define SLAPI_IS_INTERNAL_OPERATION \t\t748", "", "#define SLAPI_RESULT_CODE                       881", "#define SLAPI_RESULT_TEXT                       882", "#define SLAPI_RESULT_MATCHED                    883", "", "/* managedsait control */", "#define SLAPI_MANAGEDSAIT       \t\t1000", "", "/* audit plugin defines */", "#define SLAPI_PLUGIN_AUDIT_DATA                1100", "#define SLAPI_PLUGIN_AUDIT_FN                  1101", "", "/* backend_group extension */", "#define SLAPI_X_PLUGIN_PRE_GROUP_FN\t\t1202 ", "#define SLAPI_X_PLUGIN_POST_GROUP_FN\t\t1203", "", "#define SLAPI_X_GROUP_ENTRY\t\t\t1250 /* group entry */", "#define SLAPI_X_GROUP_ATTRIBUTE\t\t\t1251 /* member attribute */", "#define SLAPI_X_GROUP_OPERATION_DN\t\t1252 /* asserted value */", "#define SLAPI_X_GROUP_TARGET_ENTRY\t\t1253 /* target entry */", "", "/* internal preoperation extensions */", "#define SLAPI_PLUGIN_INTERNAL_PRE_BIND_FN\t1260", "#define SLAPI_PLUGIN_INTERNAL_PRE_UNBIND_FN\t1261", "#define SLAPI_PLUGIN_INTERNAL_PRE_SEARCH_FN\t1262", "#define SLAPI_PLUGIN_INTERNAL_PRE_COMPARE_FN\t1263", "#define SLAPI_PLUGIN_INTERNAL_PRE_ABANDON_FN\t1264", "", "/* internal postoperation extensions */", "#define SLAPI_PLUGIN_INTERNAL_POST_BIND_FN\t1270", "#define SLAPI_PLUGIN_INTERNAL_POST_UNBIND_FN\t1271", "#define SLAPI_PLUGIN_INTERNAL_POST_SEARCH_FN\t1272", "#define SLAPI_PLUGIN_INTERNAL_POST_COMPARE_FN\t1273", "#define SLAPI_PLUGIN_INTERNAL_POST_ABANDON_FN\t1274", "", "/* config stuff */", "#define SLAPI_CONFIG_FILENAME\t\t\t40", "#define SLAPI_CONFIG_LINENO\t\t\t41", "#define SLAPI_CONFIG_ARGC\t\t\t42", "#define SLAPI_CONFIG_ARGV\t\t\t43", "", "/*  operational params */", "#define SLAPI_TARGET_ADDRESS\t\t\t48", "#define SLAPI_TARGET_UNIQUEID\t\t\t49", "#define SLAPI_TARGET_DN\t\t\t\t50", "", "/* server LDAPv3 controls  */", "#define SLAPI_REQCONTROLS\t\t\t51", "#define SLAPI_RESCONTROLS\t\t\t55", "#define SLAPI_ADD_RESCONTROL\t\t\t56\t", "#define SLAPI_CONTROLS_ARG\t\t\t58", "", "/* add params */", "#define SLAPI_ADD_TARGET\t\t\tSLAPI_TARGET_DN", "#define SLAPI_ADD_ENTRY\t\t\t\t60", "#define SLAPI_ADD_EXISTING_DN_ENTRY\t\t61", "#define SLAPI_ADD_PARENT_ENTRY\t\t\t62", "#define SLAPI_ADD_PARENT_UNIQUEID\t\t63", "#define SLAPI_ADD_EXISTING_UNIQUEID_ENTRY\t64", "", "/* bind params */", "#define SLAPI_BIND_TARGET\t\t\tSLAPI_TARGET_DN", "#define SLAPI_BIND_METHOD\t\t\t70", "#define SLAPI_BIND_CREDENTIALS\t\t\t71\t", "#define SLAPI_BIND_SASLMECHANISM\t\t72\t", "#define SLAPI_BIND_RET_SASLCREDS\t\t73\t", "", "/* compare params */", "#define SLAPI_COMPARE_TARGET\t\t\tSLAPI_TARGET_DN", "#define SLAPI_COMPARE_TYPE\t\t\t80", "#define SLAPI_COMPARE_VALUE\t\t\t81", "", "/* delete params */", "#define SLAPI_DELETE_TARGET\t\t\tSLAPI_TARGET_DN", "#define SLAPI_DELETE_EXISTING_ENTRY\t\tSLAPI_ADD_EXISTING_DN_ENTRY", "", "/* modify params */", "#define SLAPI_MODIFY_TARGET\t\t\tSLAPI_TARGET_DN", "#define SLAPI_MODIFY_MODS\t\t\t90", "#define SLAPI_MODIFY_EXISTING_ENTRY\t\tSLAPI_ADD_EXISTING_DN_ENTRY", "", "/* modrdn params */", "#define SLAPI_MODRDN_TARGET\t\t\tSLAPI_TARGET_DN", "#define SLAPI_MODRDN_NEWRDN\t\t\t100", "#define SLAPI_MODRDN_DELOLDRDN\t\t\t101", "#define SLAPI_MODRDN_NEWSUPERIOR\t\t102\t/* v3 only */", "#define SLAPI_MODRDN_EXISTING_ENTRY             SLAPI_ADD_EXISTING_DN_ENTRY", "#define SLAPI_MODRDN_PARENT_ENTRY\t\t104", "#define SLAPI_MODRDN_NEWPARENT_ENTRY\t\t105", "#define SLAPI_MODRDN_TARGET_ENTRY\t\t106", "#define SLAPI_MODRDN_NEWSUPERIOR_ADDRESS\t107", "", "/* search params */", "#define SLAPI_SEARCH_TARGET\t\t\tSLAPI_TARGET_DN", "#define SLAPI_SEARCH_SCOPE\t\t\t110", "#define SLAPI_SEARCH_DEREF\t\t\t111", "#define SLAPI_SEARCH_SIZELIMIT\t\t\t112", "#define SLAPI_SEARCH_TIMELIMIT\t\t\t113", "#define SLAPI_SEARCH_FILTER\t\t\t114", "#define SLAPI_SEARCH_STRFILTER\t\t\t115", "#define SLAPI_SEARCH_ATTRS\t\t\t116", "#define SLAPI_SEARCH_ATTRSONLY\t\t\t117", "", "/* abandon params */", "#define SLAPI_ABANDON_MSGID\t\t\t120", "", "/* extended operation params */", "#define SLAPI_EXT_OP_REQ_OID\t\t\t160", "#define SLAPI_EXT_OP_REQ_VALUE\t\t161\t", "", "/* extended operation return codes */", "#define SLAPI_EXT_OP_RET_OID\t\t\t162\t", "#define SLAPI_EXT_OP_RET_VALUE\t\t163\t", "", "#define SLAPI_PLUGIN_EXTENDED_SENT_RESULT\t-1", "", "#define SLAPI_FAIL_DISKFULL\t\t-2", "#define SLAPI_FAIL_GENERAL\t\t-1", "#define SLAPI_PLUGIN_EXTENDED_NOT_HANDLED -2", "#define SLAPI_BIND_SUCCESS\t\t0", "#define SLAPI_BIND_FAIL\t\t\t2", "#define SLAPI_BIND_ANONYMOUS\t\t3", "", "/* Search result params */", "#define SLAPI_SEARCH_RESULT_SET\t\t\t193", "#define\tSLAPI_SEARCH_RESULT_ENTRY\t\t194", "#define\tSLAPI_NENTRIES\t\t\t\t195", "#define SLAPI_SEARCH_REFERRALS\t\t\t196", "", "/* filter types */", "#ifndef LDAP_FILTER_AND", "#define LDAP_FILTER_AND         0xa0L", "#endif", "#ifndef LDAP_FILTER_OR", "#define LDAP_FILTER_OR          0xa1L", "#endif", "#ifndef LDAP_FILTER_NOT", "#define LDAP_FILTER_NOT         0xa2L", "#endif", "#ifndef LDAP_FILTER_EQUALITY", "#define LDAP_FILTER_EQUALITY    0xa3L", "#endif", "#ifndef LDAP_FILTER_SUBSTRINGS", "#define LDAP_FILTER_SUBSTRINGS  0xa4L", "#endif", "#ifndef LDAP_FILTER_GE", "#define LDAP_FILTER_GE          0xa5L", "#endif", "#ifndef LDAP_FILTER_LE", "#define LDAP_FILTER_LE          0xa6L", "#endif", "#ifndef LDAP_FILTER_PRESENT", "#define LDAP_FILTER_PRESENT     0x87L", "#endif", "#ifndef LDAP_FILTER_APPROX", "#define LDAP_FILTER_APPROX      0xa8L", "#endif", "#ifndef LDAP_FILTER_EXT_MATCH", "#define LDAP_FILTER_EXT_MATCH   0xa9L", "#endif", "", "int slapi_log_error( int severity, char *subsystem, char *fmt, ... );", "#define SLAPI_LOG_FATAL                 0", "#define SLAPI_LOG_TRACE                 1", "#define SLAPI_LOG_PACKETS               2", "#define SLAPI_LOG_ARGS                  3", "#define SLAPI_LOG_CONNS                 4", "#define SLAPI_LOG_BER                   5", "#define SLAPI_LOG_FILTER                6", "#define SLAPI_LOG_CONFIG                7", "#define SLAPI_LOG_ACL                   8", "#define SLAPI_LOG_SHELL                 9", "#define SLAPI_LOG_PARSE                 10", "#define SLAPI_LOG_HOUSE                 11", "#define SLAPI_LOG_REPL                  12", "#define SLAPI_LOG_CACHE                 13", "#define SLAPI_LOG_PLUGIN                14", "#define SLAPI_LOG_TIMING                15", "", "#define SLAPI_PLUGIN_DESCRIPTION\t12", "typedef struct slapi_plugindesc {", "        char    *spd_id;", "        char    *spd_vendor;", "        char    *spd_version;", "        char    *spd_description;", "} Slapi_PluginDesc;", "", '#define SLAPI_PLUGIN_VERSION_01         "01"', '#define SLAPI_PLUGIN_VERSION_02         "02"', '#define SLAPI_PLUGIN_VERSION_03         "03"', "#define SLAPI_PLUGIN_CURRENT_VERSION    SLAPI_PLUGIN_VERSION_03", "", "#endif /* _SLAPI_PLUGIN_H */", "" },
    ["spawn.h"] = { "/*", " * Copyright (c) 2006, 2010 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "", "", "#ifndef\t_SPAWN_H_", "#define\t_SPAWN_H_", "", "/*", " * [SPN] Support for _POSIX_SPAWN", " */", "", "#include <sys/cdefs.h> ", "#include <_types.h>", "#include <sys/spawn.h>\t/* shared types */", "", "#include <Availability.h>", "", "/*", " * [SPN] Inclusion of the <spawn.h> header may make visible symbols defined", " * in the <sched.h>, <signal.h>, and <sys/types.h> headers.", " */", "#include <sys/_types/_pid_t.h>", "#include <sys/_types/_sigset_t.h>", "#include <sys/_types/_mode_t.h>", "", "/*", " * Opaque types for use with posix_spawn() family functions.  Internals are", " * not defined, and should not be accessed directly.  Types are defined as", " * mandated by POSIX.", " */", "typedef  void *posix_spawnattr_t;", "typedef  void *posix_spawn_file_actions_t;", "", "__BEGIN_DECLS", "/*", " * gcc under c99 mode won't compile \"[ __restrict]\" by itself.  As a workaround,", " * a dummy argument name is added.", " */", "int\tposix_spawn(pid_t * __restrict, const char * __restrict,", "\t\tconst posix_spawn_file_actions_t *,", "\t\tconst posix_spawnattr_t * __restrict,", "\t\tchar *const __argv[ __restrict],", "\t\tchar *const __envp[ __restrict]) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int\tposix_spawnp(pid_t * __restrict, const char * __restrict,", "\t\tconst posix_spawn_file_actions_t *,", "\t\tconst posix_spawnattr_t * __restrict,", "\t\tchar *const __argv[ __restrict],", "\t\tchar *const __envp[ __restrict]) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int\tposix_spawn_file_actions_addclose(posix_spawn_file_actions_t *, int) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int\tposix_spawn_file_actions_adddup2(posix_spawn_file_actions_t *, int,", "\t\tint) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int\tposix_spawn_file_actions_addopen(", "\t\tposix_spawn_file_actions_t * __restrict, int,", "\t\tconst char * __restrict, int, mode_t) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int\tposix_spawn_file_actions_destroy(posix_spawn_file_actions_t *) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int\tposix_spawn_file_actions_init(posix_spawn_file_actions_t *) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int\tposix_spawnattr_destroy(posix_spawnattr_t *) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int\tposix_spawnattr_getsigdefault(const posix_spawnattr_t * __restrict,", "\t\tsigset_t * __restrict) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int\tposix_spawnattr_getflags(const posix_spawnattr_t * __restrict,", "\t\tshort * __restrict) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int\tposix_spawnattr_getpgroup(const posix_spawnattr_t * __restrict,", "\t\tpid_t * __restrict) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int\tposix_spawnattr_getsigmask(const posix_spawnattr_t * __restrict,", "\t\tsigset_t * __restrict) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int\tposix_spawnattr_init(posix_spawnattr_t *) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int\tposix_spawnattr_setsigdefault(posix_spawnattr_t * __restrict,", "\t\tconst sigset_t * __restrict) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int\tposix_spawnattr_setflags(posix_spawnattr_t *, short) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int\tposix_spawnattr_setpgroup(posix_spawnattr_t *, pid_t) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int\tposix_spawnattr_setsigmask(posix_spawnattr_t * __restrict,", "\t\tconst sigset_t * __restrict) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "", "#if 0\t/* _POSIX_PRIORITY_SCHEDULING [PS] : not supported */", "int\tposix_spawnattr_setschedparam(posix_spawnattr_t * __restrict,", "\t\tconst struct sched_param * __restrict);", "int\tposix_spawnattr_setschedpolicy(posix_spawnattr_t *, int);", "int\tposix_spawnattr_getschedparam(const posix_spawnattr_t * __restrict,", "\t\tstruct sched_param * __restrict);", "int\tposix_spawnattr_getschedpolicy(const posix_spawnattr_t * __restrict,", "\t\tint * __restrict);", "#endif\t/* 0 */", "", "__END_DECLS", "", "#if\t!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "/*", " * Darwin-specific extensions below", " */", "#include <mach/exception_types.h>", "#include <mach/machine.h>", "#include <mach/port.h>", "", "#include <sys/_types/_size_t.h>", "", "__BEGIN_DECLS", "", "int\tposix_spawnattr_getbinpref_np(const posix_spawnattr_t * __restrict,", "\t\tsize_t, cpu_type_t *__restrict, size_t *__restrict) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int\tposix_spawnattr_setauditsessionport_np(posix_spawnattr_t *__restrict,", "\t\tmach_port_t) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);", "int\tposix_spawnattr_setbinpref_np(posix_spawnattr_t * __restrict,", "\t\tsize_t, cpu_type_t *__restrict, size_t *__restrict) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int\tposix_spawnattr_setexceptionports_np(posix_spawnattr_t *__restrict,", "\t\texception_mask_t, mach_port_t,", "\t\texception_behavior_t, thread_state_flavor_t) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int\tposix_spawnattr_setspecialport_np(posix_spawnattr_t *__restrict,", "\t\tmach_port_t, int) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int\tposix_spawn_file_actions_addinherit_np(posix_spawn_file_actions_t *,", "\t\tint) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);", "", "__END_DECLS", "", "#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */", "#endif\t/* _SPAWN_H_ */" },
    ["sqlite3.h"] = { "/*", "** 2001 September 15", "**", "** The author disclaims copyright to this source code.  In place of", "** a legal notice, here is a blessing:", "**", "**    May you do good and not evil.", "**    May you find forgiveness for yourself and forgive others.", "**    May you share freely, never taking more than you give.", "**", "*************************************************************************", "** This header file defines the interface that the SQLite library", "** presents to client programs.  If a C-function, structure, datatype,", "** or constant definition does not appear in this file, then it is", "** not a published API of SQLite, is subject to change without", "** notice, and should not be referenced by programs that use SQLite.", "**", "** Some of the definitions that are in this file are marked as", '** "experimental".  Experimental interfaces are normally new', "** features recently added to SQLite.  We do not anticipate changes", "** to experimental interfaces but reserve the right to make minor changes", '** if experience from use "in the wild" suggest such changes are prudent.', "**", "** The official C-language API documentation for SQLite is derived", "** from comments in this file.  This file is the authoritative source", "** on how SQLite interfaces are suppose to operate.", "**", '** The name of this file under configuration management is "sqlite.h.in".', "** The makefile makes some minor changes to this file (such as inserting", '** the version number) and changes its name to "sqlite3.h" as', "** part of the build process.", "*/", "#ifndef _SQLITE3_H_", "#define _SQLITE3_H_", "#include <stdarg.h>     /* Needed for the definition of va_list */", "", "/*", "** Make sure we can call this stuff from C++.", "*/", "#ifdef __cplusplus", 'extern "C" {', "#endif", "", "", "/*", "** Add the ability to override 'extern'", "*/", "#ifndef SQLITE_EXTERN", "# define SQLITE_EXTERN extern", "#endif", "", "#ifndef SQLITE_API", "# define SQLITE_API", "#endif", "", "", "/*", "** These no-op macros are used in front of interfaces to mark those", "** interfaces as either deprecated or experimental.  New applications", "** should not use deprecated interfaces - they are support for backwards", "** compatibility only.  Application writers should be aware that", "** experimental interfaces are subject to change in point releases.", "**", "** These macros used to resolve to various kinds of compiler magic that", "** would generate warning messages when they were used.  But that", "** compiler magic ended up generating such a flurry of bug reports", "** that we have taken it all out and gone back to using simple", "** noop macros.", "*/", "#define SQLITE_DEPRECATED", "#define SQLITE_EXPERIMENTAL", "#ifndef __OSX_AVAILABLE_BUT_DEPRECATED", "#define __OSX_AVAILABLE_BUT_DEPRECATED(MacOSAvailable, MacOSDeprecated, iPhoneOSAvailable, iPhoneOSDeprecated)", "#endif", "", "/*", "** Ensure these symbols were not defined by some previous header file.", "*/", "#ifdef SQLITE_VERSION", "# undef SQLITE_VERSION", "#endif", "#ifdef SQLITE_VERSION_NUMBER", "# undef SQLITE_VERSION_NUMBER", "#endif", "", "/*", "** CAPI3REF: Compile-Time Library Version Numbers", "**", "** ^(The [SQLITE_VERSION] C preprocessor macro in the sqlite3.h header", "** evaluates to a string literal that is the SQLite version in the", '** format "X.Y.Z" where X is the major version number (always 3 for', "** SQLite3) and Y is the minor version number and Z is the release number.)^", "** ^(The [SQLITE_VERSION_NUMBER] C preprocessor macro resolves to an integer", "** with the value (X*1000000 + Y*1000 + Z) where X, Y, and Z are the same", "** numbers used in [SQLITE_VERSION].)^", "** The SQLITE_VERSION_NUMBER for any given release of SQLite will also", "** be larger than the release from which it is derived.  Either Y will", "** be held constant and Z will be incremented or else Y will be incremented", "** and Z will be reset to zero.", "**", "** Since version 3.6.18, SQLite source code has been stored in the", '** <a href="http://www.fossil-scm.org/">Fossil configuration management', "** system</a>.  ^The SQLITE_SOURCE_ID macro evaluates to", "** a string which identifies a particular check-in of SQLite", "** within its configuration management system.  ^The SQLITE_SOURCE_ID", "** string contains the date and time of the check-in (UTC) and an SHA1", "** hash of the entire source tree.", "**", "** See also: [sqlite3_libversion()],", "** [sqlite3_libversion_number()], [sqlite3_sourceid()],", "** [sqlite_version()] and [sqlite_source_id()].", "*/", '#define SQLITE_VERSION        "3.7.13"', "#define SQLITE_VERSION_NUMBER 3007013", '#define SQLITE_SOURCE_ID      "2012-07-17 17:46:21 65035912264e3acbced5a3e16793327f0a2f17bb"', "", "/*", "** CAPI3REF: Run-Time Library Version Numbers", "** KEYWORDS: sqlite3_version, sqlite3_sourceid", "**", "** These interfaces provide the same information as the [SQLITE_VERSION],", "** [SQLITE_VERSION_NUMBER], and [SQLITE_SOURCE_ID] C preprocessor macros", "** but are associated with the library instead of the header file.  ^(Cautious", "** programmers might include assert() statements in their application to", "** verify that values returned by these interfaces match the macros in", "** the header, and thus insure that the application is", "** compiled with matching library and header files.", "**", "** <blockquote><pre>", "** assert( sqlite3_libversion_number()==SQLITE_VERSION_NUMBER );", "** assert( strcmp(sqlite3_sourceid(),SQLITE_SOURCE_ID)==0 );", "** assert( strcmp(sqlite3_libversion(),SQLITE_VERSION)==0 );", "** </pre></blockquote>)^", "**", "** ^The sqlite3_version[] string constant contains the text of [SQLITE_VERSION]", "** macro.  ^The sqlite3_libversion() function returns a pointer to the", "** to the sqlite3_version[] string constant.  The sqlite3_libversion()", "** function is provided for use in DLLs since DLL users usually do not have", "** direct access to string constants within the DLL.  ^The", "** sqlite3_libversion_number() function returns an integer equal to", "** [SQLITE_VERSION_NUMBER].  ^The sqlite3_sourceid() function returns ", "** a pointer to a string constant whose value is the same as the ", "** [SQLITE_SOURCE_ID] C preprocessor macro.", "**", "** See also: [sqlite_version()] and [sqlite_source_id()].", "*/", "SQLITE_API SQLITE_EXTERN const char sqlite3_version[];", "SQLITE_API const char *sqlite3_libversion(void);", "SQLITE_API const char *sqlite3_sourceid(void);", "SQLITE_API int sqlite3_libversion_number(void);", "", "/*", "** CAPI3REF: Run-Time Library Compilation Options Diagnostics", "**", "** ^The sqlite3_compileoption_used() function returns 0 or 1 ", "** indicating whether the specified option was defined at ", "** compile time.  ^The SQLITE_ prefix may be omitted from the ", "** option name passed to sqlite3_compileoption_used().  ", "**", "** ^The sqlite3_compileoption_get() function allows iterating", "** over the list of options that were defined at compile time by", "** returning the N-th compile time option string.  ^If N is out of range,", "** sqlite3_compileoption_get() returns a NULL pointer.  ^The SQLITE_ ", "** prefix is omitted from any strings returned by ", "** sqlite3_compileoption_get().", "**", "** ^Support for the diagnostic functions sqlite3_compileoption_used()", "** and sqlite3_compileoption_get() may be omitted by specifying the ", "** [SQLITE_OMIT_COMPILEOPTION_DIAGS] option at compile time.", "**", "** See also: SQL functions [sqlite_compileoption_used()] and", "** [sqlite_compileoption_get()] and the [compile_options pragma].", "*/", "#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS", "SQLITE_API int sqlite3_compileoption_used(const char *zOptName);", "SQLITE_API const char *sqlite3_compileoption_get(int N);", "#endif", "", "/*", "** CAPI3REF: Test To See If The Library Is Threadsafe", "**", "** ^The sqlite3_threadsafe() function returns zero if and only if", "** SQLite was compiled with mutexing code omitted due to the", "** [SQLITE_THREADSAFE] compile-time option being set to 0.", "**", "** SQLite can be compiled with or without mutexes.  When", "** the [SQLITE_THREADSAFE] C preprocessor macro is 1 or 2, mutexes", "** are enabled and SQLite is threadsafe.  When the", "** [SQLITE_THREADSAFE] macro is 0, ", "** the mutexes are omitted.  Without the mutexes, it is not safe", "** to use SQLite concurrently from more than one thread.", "**", "** Enabling mutexes incurs a measurable performance penalty.", "** So if speed is of utmost importance, it makes sense to disable", "** the mutexes.  But for maximum safety, mutexes should be enabled.", "** ^The default behavior is for mutexes to be enabled.", "**", "** This interface can be used by an application to make sure that the", "** version of SQLite that it is linking against was compiled with", "** the desired setting of the [SQLITE_THREADSAFE] macro.", "**", "** This interface only reports on the compile-time mutex setting", "** of the [SQLITE_THREADSAFE] flag.  If SQLite is compiled with", "** SQLITE_THREADSAFE=1 or =2 then mutexes are enabled by default but", "** can be fully or partially disabled using a call to [sqlite3_config()]", "** with the verbs [SQLITE_CONFIG_SINGLETHREAD], [SQLITE_CONFIG_MULTITHREAD],", "** or [SQLITE_CONFIG_MUTEX].  ^(The return value of the", "** sqlite3_threadsafe() function shows only the compile-time setting of", "** thread safety, not any run-time changes to that setting made by", "** sqlite3_config(). In other words, the return value from sqlite3_threadsafe()", "** is unchanged by calls to sqlite3_config().)^", "**", "** See the [threading mode] documentation for additional information.", "*/", "SQLITE_API int sqlite3_threadsafe(void);", "", "/*", "** CAPI3REF: Database Connection Handle", "** KEYWORDS: {database connection} {database connections}", "**", "** Each open SQLite database is represented by a pointer to an instance of", '** the opaque structure named "sqlite3".  It is useful to think of an sqlite3', "** pointer as an object.  The [sqlite3_open()], [sqlite3_open16()], and", "** [sqlite3_open_v2()] interfaces are its constructors, and [sqlite3_close()]", "** is its destructor.  There are many other interfaces (such as", "** [sqlite3_prepare_v2()], [sqlite3_create_function()], and", "** [sqlite3_busy_timeout()] to name but three) that are methods on an", "** sqlite3 object.", "*/", "typedef struct sqlite3 sqlite3;", "", "/*", "** CAPI3REF: 64-Bit Integer Types", "** KEYWORDS: sqlite_int64 sqlite_uint64", "**", "** Because there is no cross-platform way to specify 64-bit integer types", "** SQLite includes typedefs for 64-bit signed and unsigned integers.", "**", "** The sqlite3_int64 and sqlite3_uint64 are the preferred type definitions.", "** The sqlite_int64 and sqlite_uint64 types are supported for backwards", "** compatibility only.", "**", "** ^The sqlite3_int64 and sqlite_int64 types can store integer values", "** between -9223372036854775808 and +9223372036854775807 inclusive.  ^The", "** sqlite3_uint64 and sqlite_uint64 types can store integer values ", "** between 0 and +18446744073709551615 inclusive.", "*/", "#ifdef SQLITE_INT64_TYPE", "  typedef SQLITE_INT64_TYPE sqlite_int64;", "  typedef unsigned SQLITE_INT64_TYPE sqlite_uint64;", "#elif defined(_MSC_VER) || defined(__BORLANDC__)", "  typedef __int64 sqlite_int64;", "  typedef unsigned __int64 sqlite_uint64;", "#else", "  typedef long long int sqlite_int64;", "  typedef unsigned long long int sqlite_uint64;", "#endif", "typedef sqlite_int64 sqlite3_int64;", "typedef sqlite_uint64 sqlite3_uint64;", "", "/*", "** If compiling for a processor that lacks floating point support,", "** substitute integer for floating-point.", "*/", "#ifdef SQLITE_OMIT_FLOATING_POINT", "# define double sqlite3_int64", "#endif", "", "/*", "** CAPI3REF: Closing A Database Connection", "**", "** ^The sqlite3_close() routine is the destructor for the [sqlite3] object.", "** ^Calls to sqlite3_close() return SQLITE_OK if the [sqlite3] object is", "** successfully destroyed and all associated resources are deallocated.", "**", "** Applications must [sqlite3_finalize | finalize] all [prepared statements]", "** and [sqlite3_blob_close | close] all [BLOB handles] associated with", "** the [sqlite3] object prior to attempting to close the object.  ^If", "** sqlite3_close() is called on a [database connection] that still has", "** outstanding [prepared statements] or [BLOB handles], then it returns", "** SQLITE_BUSY.", "**", "** ^If [sqlite3_close()] is invoked while a transaction is open,", "** the transaction is automatically rolled back.", "**", "** The C parameter to [sqlite3_close(C)] must be either a NULL", "** pointer or an [sqlite3] object pointer obtained", "** from [sqlite3_open()], [sqlite3_open16()], or", "** [sqlite3_open_v2()], and not previously closed.", "** ^Calling sqlite3_close() with a NULL pointer argument is a ", "** harmless no-op.", "*/", "SQLITE_API int sqlite3_close(sqlite3 *);", "", "/*", "** The type for a callback function.", "** This is legacy and deprecated.  It is included for historical", "** compatibility and is not documented.", "*/", "typedef int (*sqlite3_callback)(void*,int,char**, char**);", "", "/*", "** CAPI3REF: One-Step Query Execution Interface", "**", "** The sqlite3_exec() interface is a convenience wrapper around", "** [sqlite3_prepare_v2()], [sqlite3_step()], and [sqlite3_finalize()],", "** that allows an application to run multiple statements of SQL", "** without having to use a lot of C code. ", "**", "** ^The sqlite3_exec() interface runs zero or more UTF-8 encoded,", "** semicolon-separate SQL statements passed into its 2nd argument,", "** in the context of the [database connection] passed in as its 1st", "** argument.  ^If the callback function of the 3rd argument to", "** sqlite3_exec() is not NULL, then it is invoked for each result row", "** coming out of the evaluated SQL statements.  ^The 4th argument to", "** sqlite3_exec() is relayed through to the 1st argument of each", "** callback invocation.  ^If the callback pointer to sqlite3_exec()", "** is NULL, then no callback is ever invoked and result rows are", "** ignored.", "**", "** ^If an error occurs while evaluating the SQL statements passed into", "** sqlite3_exec(), then execution of the current statement stops and", "** subsequent statements are skipped.  ^If the 5th parameter to sqlite3_exec()", "** is not NULL then any error message is written into memory obtained", "** from [sqlite3_malloc()] and passed back through the 5th parameter.", "** To avoid memory leaks, the application should invoke [sqlite3_free()]", "** on error message strings returned through the 5th parameter of", "** of sqlite3_exec() after the error message string is no longer needed.", "** ^If the 5th parameter to sqlite3_exec() is not NULL and no errors", "** occur, then sqlite3_exec() sets the pointer in its 5th parameter to", "** NULL before returning.", "**", "** ^If an sqlite3_exec() callback returns non-zero, the sqlite3_exec()", "** routine returns SQLITE_ABORT without invoking the callback again and", "** without running any subsequent SQL statements.", "**", "** ^The 2nd argument to the sqlite3_exec() callback function is the", "** number of columns in the result.  ^The 3rd argument to the sqlite3_exec()", "** callback is an array of pointers to strings obtained as if from", "** [sqlite3_column_text()], one for each column.  ^If an element of a", "** result row is NULL then the corresponding string pointer for the", "** sqlite3_exec() callback is a NULL pointer.  ^The 4th argument to the", "** sqlite3_exec() callback is an array of pointers to strings where each", "** entry represents the name of corresponding result column as obtained", "** from [sqlite3_column_name()].", "**", "** ^If the 2nd parameter to sqlite3_exec() is a NULL pointer, a pointer", "** to an empty string, or a pointer that contains only whitespace and/or ", "** SQL comments, then no SQL statements are evaluated and the database", "** is not changed.", "**", "** Restrictions:", "**", "** <ul>", "** <li> The application must insure that the 1st parameter to sqlite3_exec()", "**      is a valid and open [database connection].", "** <li> The application must not close [database connection] specified by", "**      the 1st parameter to sqlite3_exec() while sqlite3_exec() is running.", "** <li> The application must not modify the SQL statement text passed into", "**      the 2nd parameter of sqlite3_exec() while sqlite3_exec() is running.", "** </ul>", "*/", "SQLITE_API int sqlite3_exec(", "  sqlite3*,                                  /* An open database */", "  const char *sql,                           /* SQL to be evaluated */", "  int (*callback)(void*,int,char**,char**),  /* Callback function */", "  void *,                                    /* 1st argument to callback */", "  char **errmsg                              /* Error msg written here */", ");", "", "/*", "** CAPI3REF: Result Codes", "** KEYWORDS: SQLITE_OK {error code} {error codes}", "** KEYWORDS: {result code} {result codes}", "**", "** Many SQLite functions return an integer result code from the set shown", "** here in order to indicate success or failure.", "**", "** New error codes may be added in future versions of SQLite.", "**", "** See also: [SQLITE_IOERR_READ | extended result codes],", "** [sqlite3_vtab_on_conflict()] [SQLITE_ROLLBACK | result codes].", "*/", "#define SQLITE_OK           0   /* Successful result */", "/* beginning-of-error-codes */", "#define SQLITE_ERROR        1   /* SQL error or missing database */", "#define SQLITE_INTERNAL     2   /* Internal logic error in SQLite */", "#define SQLITE_PERM         3   /* Access permission denied */", "#define SQLITE_ABORT        4   /* Callback routine requested an abort */", "#define SQLITE_BUSY         5   /* The database file is locked */", "#define SQLITE_LOCKED       6   /* A table in the database is locked */", "#define SQLITE_NOMEM        7   /* A malloc() failed */", "#define SQLITE_READONLY     8   /* Attempt to write a readonly database */", "#define SQLITE_INTERRUPT    9   /* Operation terminated by sqlite3_interrupt()*/", "#define SQLITE_IOERR       10   /* Some kind of disk I/O error occurred */", "#define SQLITE_CORRUPT     11   /* The database disk image is malformed */", "#define SQLITE_NOTFOUND    12   /* Unknown opcode in sqlite3_file_control() */", "#define SQLITE_FULL        13   /* Insertion failed because database is full */", "#define SQLITE_CANTOPEN    14   /* Unable to open the database file */", "#define SQLITE_PROTOCOL    15   /* Database lock protocol error */", "#define SQLITE_EMPTY       16   /* Database is empty */", "#define SQLITE_SCHEMA      17   /* The database schema changed */", "#define SQLITE_TOOBIG      18   /* String or BLOB exceeds size limit */", "#define SQLITE_CONSTRAINT  19   /* Abort due to constraint violation */", "#define SQLITE_MISMATCH    20   /* Data type mismatch */", "#define SQLITE_MISUSE      21   /* Library used incorrectly */", "#define SQLITE_NOLFS       22   /* Uses OS features not supported on host */", "#define SQLITE_AUTH        23   /* Authorization denied */", "#define SQLITE_FORMAT      24   /* Auxiliary database format error */", "#define SQLITE_RANGE       25   /* 2nd parameter to sqlite3_bind out of range */", "#define SQLITE_NOTADB      26   /* File opened that is not a database file */", "#define SQLITE_ROW         100  /* sqlite3_step() has another row ready */", "#define SQLITE_DONE        101  /* sqlite3_step() has finished executing */", "/* end-of-error-codes */", "", "/*", "** CAPI3REF: Extended Result Codes", "** KEYWORDS: {extended error code} {extended error codes}", "** KEYWORDS: {extended result code} {extended result codes}", "**", "** In its default configuration, SQLite API routines return one of 26 integer", "** [SQLITE_OK | result codes].  However, experience has shown that many of", "** these result codes are too coarse-grained.  They do not provide as", "** much information about problems as programmers might like.  In an effort to", "** address this, newer versions of SQLite (version 3.3.8 and later) include", "** support for additional result codes that provide more detailed information", "** about errors. The extended result codes are enabled or disabled", "** on a per database connection basis using the", "** [sqlite3_extended_result_codes()] API.", "**", "** Some of the available extended result codes are listed here.", "** One may expect the number of extended result codes will be expand", "** over time.  Software that uses extended result codes should expect", "** to see new result codes in future releases of SQLite.", "**", "** The SQLITE_OK result code will never be extended.  It will always", "** be exactly zero.", "*/", "#define SQLITE_IOERR_READ              (SQLITE_IOERR | (1<<8))", "#define SQLITE_IOERR_SHORT_READ        (SQLITE_IOERR | (2<<8))", "#define SQLITE_IOERR_WRITE             (SQLITE_IOERR | (3<<8))", "#define SQLITE_IOERR_FSYNC             (SQLITE_IOERR | (4<<8))", "#define SQLITE_IOERR_DIR_FSYNC         (SQLITE_IOERR | (5<<8))", "#define SQLITE_IOERR_TRUNCATE          (SQLITE_IOERR | (6<<8))", "#define SQLITE_IOERR_FSTAT             (SQLITE_IOERR | (7<<8))", "#define SQLITE_IOERR_UNLOCK            (SQLITE_IOERR | (8<<8))", "#define SQLITE_IOERR_RDLOCK            (SQLITE_IOERR | (9<<8))", "#define SQLITE_IOERR_DELETE            (SQLITE_IOERR | (10<<8))", "#define SQLITE_IOERR_BLOCKED           (SQLITE_IOERR | (11<<8))", "#define SQLITE_IOERR_NOMEM             (SQLITE_IOERR | (12<<8))", "#define SQLITE_IOERR_ACCESS            (SQLITE_IOERR | (13<<8))", "#define SQLITE_IOERR_CHECKRESERVEDLOCK (SQLITE_IOERR | (14<<8))", "#define SQLITE_IOERR_LOCK              (SQLITE_IOERR | (15<<8))", "#define SQLITE_IOERR_CLOSE             (SQLITE_IOERR | (16<<8))", "#define SQLITE_IOERR_DIR_CLOSE         (SQLITE_IOERR | (17<<8))", "#define SQLITE_IOERR_SHMOPEN           (SQLITE_IOERR | (18<<8))", "#define SQLITE_IOERR_SHMSIZE           (SQLITE_IOERR | (19<<8))", "#define SQLITE_IOERR_SHMLOCK           (SQLITE_IOERR | (20<<8))", "#define SQLITE_IOERR_SHMMAP            (SQLITE_IOERR | (21<<8))", "#define SQLITE_IOERR_SEEK              (SQLITE_IOERR | (22<<8))", "#define SQLITE_LOCKED_SHAREDCACHE      (SQLITE_LOCKED |  (1<<8))", "#define SQLITE_BUSY_RECOVERY           (SQLITE_BUSY   |  (1<<8))", "#define SQLITE_CANTOPEN_NOTEMPDIR      (SQLITE_CANTOPEN | (1<<8))", "#define SQLITE_CANTOPEN_ISDIR          (SQLITE_CANTOPEN | (2<<8))", "#define SQLITE_CORRUPT_VTAB            (SQLITE_CORRUPT | (1<<8))", "#define SQLITE_READONLY_RECOVERY       (SQLITE_READONLY | (1<<8))", "#define SQLITE_READONLY_CANTLOCK       (SQLITE_READONLY | (2<<8))", "#define SQLITE_ABORT_ROLLBACK          (SQLITE_ABORT | (2<<8))", "", "/*", "** CAPI3REF: Flags For File Open Operations", "**", "** These bit values are intended for use in the", "** 3rd parameter to the [sqlite3_open_v2()] interface and", "** in the 4th parameter to the [sqlite3_vfs.xOpen] method.", "*/", "#define SQLITE_OPEN_READONLY         0x00000001  /* Ok for sqlite3_open_v2() */", "#define SQLITE_OPEN_READWRITE        0x00000002  /* Ok for sqlite3_open_v2() */", "#define SQLITE_OPEN_CREATE           0x00000004  /* Ok for sqlite3_open_v2() */", "#define SQLITE_OPEN_DELETEONCLOSE    0x00000008  /* VFS only */", "#define SQLITE_OPEN_EXCLUSIVE        0x00000010  /* VFS only */", "#define SQLITE_OPEN_AUTOPROXY        0x00000020  /* VFS only */", "#define SQLITE_OPEN_URI              0x00000040  /* Ok for sqlite3_open_v2() */", "#define SQLITE_OPEN_MEMORY           0x00000080  /* Ok for sqlite3_open_v2() */", "#define SQLITE_OPEN_MAIN_DB          0x00000100  /* VFS only */", "#define SQLITE_OPEN_TEMP_DB          0x00000200  /* VFS only */", "#define SQLITE_OPEN_TRANSIENT_DB     0x00000400  /* VFS only */", "#define SQLITE_OPEN_MAIN_JOURNAL     0x00000800  /* VFS only */", "#define SQLITE_OPEN_TEMP_JOURNAL     0x00001000  /* VFS only */", "#define SQLITE_OPEN_SUBJOURNAL       0x00002000  /* VFS only */", "#define SQLITE_OPEN_MASTER_JOURNAL   0x00004000  /* VFS only */", "#define SQLITE_OPEN_NOMUTEX          0x00008000  /* Ok for sqlite3_open_v2() */", "#define SQLITE_OPEN_FULLMUTEX        0x00010000  /* Ok for sqlite3_open_v2() */", "#define SQLITE_OPEN_SHAREDCACHE      0x00020000  /* Ok for sqlite3_open_v2() */", "#define SQLITE_OPEN_PRIVATECACHE     0x00040000  /* Ok for sqlite3_open_v2() */", "#define SQLITE_OPEN_WAL              0x00080000  /* VFS only */", "#define SQLITE_OPEN_FILEPROTECTION_COMPLETE                             0x00100000", "#define SQLITE_OPEN_FILEPROTECTION_COMPLETEUNLESSOPEN                   0x00200000", "#define SQLITE_OPEN_FILEPROTECTION_COMPLETEUNTILFIRSTUSERAUTHENTICATION 0x00300000", "#define SQLITE_OPEN_FILEPROTECTION_NONE                                 0x00400000", "#define SQLITE_OPEN_FILEPROTECTION_MASK                                 0x00700000", "", "/* Reserved:                         0x00F00000 */", "", "/*", "** CAPI3REF: Device Characteristics", "**", "** The xDeviceCharacteristics method of the [sqlite3_io_methods]", "** object returns an integer which is a vector of the these", "** bit values expressing I/O characteristics of the mass storage", "** device that holds the file that the [sqlite3_io_methods]", "** refers to.", "**", "** The SQLITE_IOCAP_ATOMIC property means that all writes of", "** any size are atomic.  The SQLITE_IOCAP_ATOMICnnn values", "** mean that writes of blocks that are nnn bytes in size and", "** are aligned to an address which is an integer multiple of", "** nnn are atomic.  The SQLITE_IOCAP_SAFE_APPEND value means", "** that when data is appended to a file, the data is appended", "** first then the size of the file is extended, never the other", "** way around.  The SQLITE_IOCAP_SEQUENTIAL property means that", "** information is written to disk in the same order as calls", "** to xWrite().  The SQLITE_IOCAP_POWERSAFE_OVERWRITE property means that", "** after reboot following a crash or power loss, the only bytes in a", "** file that were written at the application level might have changed", "** and that adjacent bytes, even bytes within the same sector are", "** guaranteed to be unchanged.", "*/", "#define SQLITE_IOCAP_ATOMIC                 0x00000001", "#define SQLITE_IOCAP_ATOMIC512              0x00000002", "#define SQLITE_IOCAP_ATOMIC1K               0x00000004", "#define SQLITE_IOCAP_ATOMIC2K               0x00000008", "#define SQLITE_IOCAP_ATOMIC4K               0x00000010", "#define SQLITE_IOCAP_ATOMIC8K               0x00000020", "#define SQLITE_IOCAP_ATOMIC16K              0x00000040", "#define SQLITE_IOCAP_ATOMIC32K              0x00000080", "#define SQLITE_IOCAP_ATOMIC64K              0x00000100", "#define SQLITE_IOCAP_SAFE_APPEND            0x00000200", "#define SQLITE_IOCAP_SEQUENTIAL             0x00000400", "#define SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN  0x00000800", "#define SQLITE_IOCAP_POWERSAFE_OVERWRITE    0x00001000", "", "/*", "** CAPI3REF: File Locking Levels", "**", "** SQLite uses one of these integer values as the second", "** argument to calls it makes to the xLock() and xUnlock() methods", "** of an [sqlite3_io_methods] object.", "*/", "#define SQLITE_LOCK_NONE          0", "#define SQLITE_LOCK_SHARED        1", "#define SQLITE_LOCK_RESERVED      2", "#define SQLITE_LOCK_PENDING       3", "#define SQLITE_LOCK_EXCLUSIVE     4", "", "/*", "** CAPI3REF: Synchronization Type Flags", "**", "** When SQLite invokes the xSync() method of an", "** [sqlite3_io_methods] object it uses a combination of", "** these integer values as the second argument.", "**", "** When the SQLITE_SYNC_DATAONLY flag is used, it means that the", "** sync operation only needs to flush data to mass storage.  Inode", "** information need not be flushed. If the lower four bits of the flag", "** equal SQLITE_SYNC_NORMAL, that means to use normal fsync() semantics.", "** If the lower four bits equal SQLITE_SYNC_FULL, that means", "** to use Mac OS X style fullsync instead of fsync().", "**", "** Do not confuse the SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags", "** with the [PRAGMA synchronous]=NORMAL and [PRAGMA synchronous]=FULL", "** settings.  The [synchronous pragma] determines when calls to the", "** xSync VFS method occur and applies uniformly across all platforms.", "** The SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags determine how", "** energetic or rigorous or forceful the sync operations are and", "** only make a difference on Mac OSX for the default SQLite code.", "** (Third-party VFS implementations might also make the distinction", "** between SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL, but among the", "** operating systems natively supported by SQLite, only Mac OSX", "** cares about the difference.)", "*/", "#define SQLITE_SYNC_NORMAL        0x00002", "#define SQLITE_SYNC_FULL          0x00003", "#define SQLITE_SYNC_DATAONLY      0x00010", "", "/*", "** CAPI3REF: OS Interface Open File Handle", "**", "** An [sqlite3_file] object represents an open file in the ", "** [sqlite3_vfs | OS interface layer].  Individual OS interface", "** implementations will", "** want to subclass this object by appending additional fields", "** for their own use.  The pMethods entry is a pointer to an", "** [sqlite3_io_methods] object that defines methods for performing", "** I/O operations on the open file.", "*/", "typedef struct sqlite3_file sqlite3_file;", "struct sqlite3_file {", "  const struct sqlite3_io_methods *pMethods;  /* Methods for an open file */", "};", "", "/*", "** CAPI3REF: OS Interface File Virtual Methods Object", "**", "** Every file opened by the [sqlite3_vfs.xOpen] method populates an", "** [sqlite3_file] object (or, more commonly, a subclass of the", "** [sqlite3_file] object) with a pointer to an instance of this object.", "** This object defines the methods used to perform various operations", "** against the open file represented by the [sqlite3_file] object.", "**", "** If the [sqlite3_vfs.xOpen] method sets the sqlite3_file.pMethods element ", "** to a non-NULL pointer, then the sqlite3_io_methods.xClose method", "** may be invoked even if the [sqlite3_vfs.xOpen] reported that it failed.  The", "** only way to prevent a call to xClose following a failed [sqlite3_vfs.xOpen]", "** is for the [sqlite3_vfs.xOpen] to set the sqlite3_file.pMethods element", "** to NULL.", "**", "** The flags argument to xSync may be one of [SQLITE_SYNC_NORMAL] or", "** [SQLITE_SYNC_FULL].  The first choice is the normal fsync().", "** The second choice is a Mac OS X style fullsync.  The [SQLITE_SYNC_DATAONLY]", "** flag may be ORed in to indicate that only the data of the file", "** and not its inode needs to be synced.", "**", "** The integer values to xLock() and xUnlock() are one of", "** <ul>", "** <li> [SQLITE_LOCK_NONE],", "** <li> [SQLITE_LOCK_SHARED],", "** <li> [SQLITE_LOCK_RESERVED],", "** <li> [SQLITE_LOCK_PENDING], or", "** <li> [SQLITE_LOCK_EXCLUSIVE].", "** </ul>", "** xLock() increases the lock. xUnlock() decreases the lock.", "** The xCheckReservedLock() method checks whether any database connection,", "** either in this process or in some other process, is holding a RESERVED,", "** PENDING, or EXCLUSIVE lock on the file.  It returns true", "** if such a lock exists and false otherwise.", "**", "** The xFileControl() method is a generic interface that allows custom", "** VFS implementations to directly control an open file using the", '** [sqlite3_file_control()] interface.  The second "op" argument is an', "** integer opcode.  The third argument is a generic pointer intended to", "** point to a structure that may contain arguments or space in which to", "** write return values.  Potential uses for xFileControl() might be", "** functions to enable blocking locks with timeouts, to change the", "** locking strategy (for example to use dot-file locks), to inquire", "** about the status of a lock, or to break stale locks.  The SQLite", "** core reserves all opcodes less than 100 for its own use.", "** A [SQLITE_FCNTL_LOCKSTATE | list of opcodes] less than 100 is available.", "** Applications that define a custom xFileControl method should use opcodes", "** greater than 100 to avoid conflicts.  VFS implementations should", "** return [SQLITE_NOTFOUND] for file control opcodes that they do not", "** recognize.", "**", "** The xSectorSize() method returns the sector size of the", "** device that underlies the file.  The sector size is the", "** minimum write that can be performed without disturbing", "** other bytes in the file.  The xDeviceCharacteristics()", "** method returns a bit vector describing behaviors of the", "** underlying device:", "**", "** <ul>", "** <li> [SQLITE_IOCAP_ATOMIC]", "** <li> [SQLITE_IOCAP_ATOMIC512]", "** <li> [SQLITE_IOCAP_ATOMIC1K]", "** <li> [SQLITE_IOCAP_ATOMIC2K]", "** <li> [SQLITE_IOCAP_ATOMIC4K]", "** <li> [SQLITE_IOCAP_ATOMIC8K]", "** <li> [SQLITE_IOCAP_ATOMIC16K]", "** <li> [SQLITE_IOCAP_ATOMIC32K]", "** <li> [SQLITE_IOCAP_ATOMIC64K]", "** <li> [SQLITE_IOCAP_SAFE_APPEND]", "** <li> [SQLITE_IOCAP_SEQUENTIAL]", "** </ul>", "**", "** The SQLITE_IOCAP_ATOMIC property means that all writes of", "** any size are atomic.  The SQLITE_IOCAP_ATOMICnnn values", "** mean that writes of blocks that are nnn bytes in size and", "** are aligned to an address which is an integer multiple of", "** nnn are atomic.  The SQLITE_IOCAP_SAFE_APPEND value means", "** that when data is appended to a file, the data is appended", "** first then the size of the file is extended, never the other", "** way around.  The SQLITE_IOCAP_SEQUENTIAL property means that", "** information is written to disk in the same order as calls", "** to xWrite().", "**", "** If xRead() returns SQLITE_IOERR_SHORT_READ it must also fill", "** in the unread portions of the buffer with zeros.  A VFS that", "** fails to zero-fill short reads might seem to work.  However,", "** failure to zero-fill short reads will eventually lead to", "** database corruption.", "*/", "typedef struct sqlite3_io_methods sqlite3_io_methods;", "struct sqlite3_io_methods {", "  int iVersion;", "  int (*xClose)(sqlite3_file*);", "  int (*xRead)(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);", "  int (*xWrite)(sqlite3_file*, const void*, int iAmt, sqlite3_int64 iOfst);", "  int (*xTruncate)(sqlite3_file*, sqlite3_int64 size);", "  int (*xSync)(sqlite3_file*, int flags);", "  int (*xFileSize)(sqlite3_file*, sqlite3_int64 *pSize);", "  int (*xLock)(sqlite3_file*, int);", "  int (*xUnlock)(sqlite3_file*, int);", "  int (*xCheckReservedLock)(sqlite3_file*, int *pResOut);", "  int (*xFileControl)(sqlite3_file*, int op, void *pArg);", "  int (*xSectorSize)(sqlite3_file*);", "  int (*xDeviceCharacteristics)(sqlite3_file*);", "  /* Methods above are valid for version 1 */", "  int (*xShmMap)(sqlite3_file*, int iPg, int pgsz, int, void volatile**);", "  int (*xShmLock)(sqlite3_file*, int offset, int n, int flags);", "  void (*xShmBarrier)(sqlite3_file*);", "  int (*xShmUnmap)(sqlite3_file*, int deleteFlag);", "  /* Methods above are valid for version 2 */", "  /* Additional methods may be added in future releases */", "};", "", "/*", "** CAPI3REF: Standard File Control Opcodes", "**", "** These integer constants are opcodes for the xFileControl method", "** of the [sqlite3_io_methods] object and for the [sqlite3_file_control()]", "** interface.", "**", "** The [SQLITE_FCNTL_LOCKSTATE] opcode is used for debugging.  This", "** opcode causes the xFileControl method to write the current state of", "** the lock (one of [SQLITE_LOCK_NONE], [SQLITE_LOCK_SHARED],", "** [SQLITE_LOCK_RESERVED], [SQLITE_LOCK_PENDING], or [SQLITE_LOCK_EXCLUSIVE])", "** into an integer that the pArg argument points to. This capability", "** is used during testing and only needs to be supported when SQLITE_TEST", "** is defined.", "** <ul>", "** <li>[[SQLITE_FCNTL_SIZE_HINT]]", "** The [SQLITE_FCNTL_SIZE_HINT] opcode is used by SQLite to give the VFS", "** layer a hint of how large the database file will grow to be during the", "** current transaction.  This hint is not guaranteed to be accurate but it", "** is often close.  The underlying VFS might choose to preallocate database", "** file space based on this hint in order to help writes to the database", "** file run faster.", "**", "** <li>[[SQLITE_FCNTL_CHUNK_SIZE]]", "** The [SQLITE_FCNTL_CHUNK_SIZE] opcode is used to request that the VFS", "** extends and truncates the database file in chunks of a size specified", "** by the user. The fourth argument to [sqlite3_file_control()] should ", "** point to an integer (type int) containing the new chunk-size to use", "** for the nominated database. Allocating database file space in large", "** chunks (say 1MB at a time), may reduce file-system fragmentation and", "** improve performance on some systems.", "**", "** <li>[[SQLITE_FCNTL_FILE_POINTER]]", "** The [SQLITE_FCNTL_FILE_POINTER] opcode is used to obtain a pointer", "** to the [sqlite3_file] object associated with a particular database", "** connection.  See the [sqlite3_file_control()] documentation for", "** additional information.", "**", "** <li>[[SQLITE_FCNTL_SYNC_OMITTED]]", "** ^(The [SQLITE_FCNTL_SYNC_OMITTED] opcode is generated internally by", "** SQLite and sent to all VFSes in place of a call to the xSync method", "** when the database connection has [PRAGMA synchronous] set to OFF.)^", "** Some specialized VFSes need this signal in order to operate correctly", "** when [PRAGMA synchronous | PRAGMA synchronous=OFF] is set, but most ", "** VFSes do not need this signal and should silently ignore this opcode.", "** Applications should not call [sqlite3_file_control()] with this", "** opcode as doing so may disrupt the operation of the specialized VFSes", "** that do require it.  ", "**", "** <li>[[SQLITE_FCNTL_WIN32_AV_RETRY]]", "** ^The [SQLITE_FCNTL_WIN32_AV_RETRY] opcode is used to configure automatic", "** retry counts and intervals for certain disk I/O operations for the", "** windows [VFS] in order to provide robustness in the presence of", "** anti-virus programs.  By default, the windows VFS will retry file read,", "** file write, and file delete operations up to 10 times, with a delay", "** of 25 milliseconds before the first retry and with the delay increasing", "** by an additional 25 milliseconds with each subsequent retry.  This", "** opcode allows these two values (10 retries and 25 milliseconds of delay)", "** to be adjusted.  The values are changed for all database connections", "** within the same process.  The argument is a pointer to an array of two", "** integers where the first integer i the new retry count and the second", "** integer is the delay.  If either integer is negative, then the setting", "** is not changed but instead the prior value of that setting is written", "** into the array entry, allowing the current retry settings to be", "** interrogated.  The zDbName parameter is ignored.", "**", "** <li>[[SQLITE_FCNTL_PERSIST_WAL]]", "** ^The [SQLITE_FCNTL_PERSIST_WAL] opcode is used to set or query the", "** persistent [WAL | Write Ahead Log] setting.  By default, the auxiliary", "** write ahead log and shared memory files used for transaction control", "** are automatically deleted when the latest connection to the database", "** closes.  Setting persistent WAL mode causes those files to persist after", "** close.  Persisting the files is useful when other processes that do not", "** have write permission on the directory containing the database file want", "** to read the database file, as the WAL and shared memory files must exist", "** in order for the database to be readable.  The fourth parameter to", "** [sqlite3_file_control()] for this opcode should be a pointer to an integer.", "** That integer is 0 to disable persistent WAL mode or 1 to enable persistent", "** WAL mode.  If the integer is -1, then it is overwritten with the current", "** WAL persistence setting.", "**", "** <li>[[SQLITE_FCNTL_POWERSAFE_OVERWRITE]]", "** ^The [SQLITE_FCNTL_POWERSAFE_OVERWRITE] opcode is used to set or query the", '** persistent "powersafe-overwrite" or "PSOW" setting.  The PSOW setting', "** determines the [SQLITE_IOCAP_POWERSAFE_OVERWRITE] bit of the", "** xDeviceCharacteristics methods. The fourth parameter to", "** [sqlite3_file_control()] for this opcode should be a pointer to an integer.", "** That integer is 0 to disable zero-damage mode or 1 to enable zero-damage", "** mode.  If the integer is -1, then it is overwritten with the current", "** zero-damage mode setting.", "**", "** <li>[[SQLITE_FCNTL_OVERWRITE]]", "** ^The [SQLITE_FCNTL_OVERWRITE] opcode is invoked by SQLite after opening", "** a write transaction to indicate that, unless it is rolled back for some", "** reason, the entire database file will be overwritten by the current ", "** transaction. This is used by VACUUM operations.", "**", "** <li>[[SQLITE_FCNTL_VFSNAME]]", "** ^The [SQLITE_FCNTL_VFSNAME] opcode can be used to obtain the names of", "** all [VFSes] in the VFS stack.  The names are of all VFS shims and the", "** final bottom-level VFS are written into memory obtained from ", "** [sqlite3_malloc()] and the result is stored in the char* variable", "** that the fourth parameter of [sqlite3_file_control()] points to.", "** The caller is responsible for freeing the memory when done.  As with", "** all file-control actions, there is no guarantee that this will actually", "** do anything.  Callers should initialize the char* variable to a NULL", "** pointer in case this file-control is not implemented.  This file-control", "** is intended for diagnostic use only.", "**", "** <li>[[SQLITE_FCNTL_PRAGMA]]", "** ^Whenever a [PRAGMA] statement is parsed, an [SQLITE_FCNTL_PRAGMA] ", "** file control is sent to the open [sqlite3_file] object corresponding", "** to the database file to which the pragma statement refers. ^The argument", "** to the [SQLITE_FCNTL_PRAGMA] file control is an array of", "** pointers to strings (char**) in which the second element of the array", "** is the name of the pragma and the third element is the argument to the", "** pragma or NULL if the pragma has no argument.  ^The handler for an", "** [SQLITE_FCNTL_PRAGMA] file control can optionally make the first element", "** of the char** argument point to a string obtained from [sqlite3_mprintf()]", "** or the equivalent and that string will become the result of the pragma or", "** the error message if the pragma fails. ^If the", "** [SQLITE_FCNTL_PRAGMA] file control returns [SQLITE_NOTFOUND], then normal ", "** [PRAGMA] processing continues.  ^If the [SQLITE_FCNTL_PRAGMA]", "** file control returns [SQLITE_OK], then the parser assumes that the", "** VFS has handled the PRAGMA itself and the parser generates a no-op", "** prepared statement.  ^If the [SQLITE_FCNTL_PRAGMA] file control returns", "** any result code other than [SQLITE_OK] or [SQLITE_NOTFOUND], that means", "** that the VFS encountered an error while handling the [PRAGMA] and the", "** compilation of the PRAGMA fails with an error.  ^The [SQLITE_FCNTL_PRAGMA]", "** file control occurs at the beginning of pragma statement analysis and so", "** it is able to override built-in [PRAGMA] statements.", "** </ul>", "*/", "#define SQLITE_FCNTL_LOCKSTATE               1", "#define SQLITE_FCNTL_GET_LOCKPROXYFILE       2", "#define SQLITE_FCNTL_SET_LOCKPROXYFILE       3", "#define SQLITE_FCNTL_LAST_ERRNO              4", "#define SQLITE_FCNTL_SIZE_HINT               5", "#define SQLITE_FCNTL_CHUNK_SIZE              6", "#define SQLITE_FCNTL_FILE_POINTER            7", "#define SQLITE_FCNTL_SYNC_OMITTED            8", "#define SQLITE_FCNTL_WIN32_AV_RETRY          9", "#define SQLITE_FCNTL_PERSIST_WAL            10", "#define SQLITE_FCNTL_OVERWRITE              11", "#define SQLITE_FCNTL_VFSNAME                12", "#define SQLITE_FCNTL_POWERSAFE_OVERWRITE    13", "#define SQLITE_FCNTL_PRAGMA                 14", "/* deprecated names */", "#define SQLITE_GET_LOCKPROXYFILE      SQLITE_FCNTL_GET_LOCKPROXYFILE", "#define SQLITE_SET_LOCKPROXYFILE      SQLITE_FCNTL_SET_LOCKPROXYFILE", "#define SQLITE_LAST_ERRNO             SQLITE_FCNTL_LAST_ERRNO", "", "/*", "** CAPI3REF: Mutex Handle", "**", "** The mutex module within SQLite defines [sqlite3_mutex] to be an", "** abstract type for a mutex object.  The SQLite core never looks", "** at the internal representation of an [sqlite3_mutex].  It only", "** deals with pointers to the [sqlite3_mutex] object.", "**", "** Mutexes are created using [sqlite3_mutex_alloc()].", "*/", "typedef struct sqlite3_mutex sqlite3_mutex;", "", "/*", "** CAPI3REF: OS Interface Object", "**", "** An instance of the sqlite3_vfs object defines the interface between", '** the SQLite core and the underlying operating system.  The "vfs"', '** in the name of the object stands for "virtual file system".  See', "** the [VFS | VFS documentation] for further information.", "**", "** The value of the iVersion field is initially 1 but may be larger in", "** future versions of SQLite.  Additional fields may be appended to this", "** object when the iVersion value is increased.  Note that the structure", "** of the sqlite3_vfs object changes in the transaction between", "** SQLite version 3.5.9 and 3.6.0 and yet the iVersion field was not", "** modified.", "**", "** The szOsFile field is the size of the subclassed [sqlite3_file]", "** structure used by this VFS.  mxPathname is the maximum length of", "** a pathname in this VFS.", "**", "** Registered sqlite3_vfs objects are kept on a linked list formed by", "** the pNext pointer.  The [sqlite3_vfs_register()]", "** and [sqlite3_vfs_unregister()] interfaces manage this list", "** in a thread-safe way.  The [sqlite3_vfs_find()] interface", "** searches the list.  Neither the application code nor the VFS", "** implementation should use the pNext pointer.", "**", "** The pNext field is the only field in the sqlite3_vfs", "** structure that SQLite will ever modify.  SQLite will only access", "** or modify this field while holding a particular static mutex.", "** The application should never modify anything within the sqlite3_vfs", "** object once the object has been registered.", "**", "** The zName field holds the name of the VFS module.  The name must", "** be unique across all VFS modules.", "**", "** [[sqlite3_vfs.xOpen]]", "** ^SQLite guarantees that the zFilename parameter to xOpen", "** is either a NULL pointer or string obtained", "** from xFullPathname() with an optional suffix added.", "** ^If a suffix is added to the zFilename parameter, it will", '** consist of a single "-" character followed by no more than', '** 11 alphanumeric and/or "-" characters.', "** ^SQLite further guarantees that", "** the string will be valid and unchanged until xClose() is", "** called. Because of the previous sentence,", "** the [sqlite3_file] can safely store a pointer to the", "** filename if it needs to remember the filename for some reason.", "** If the zFilename parameter to xOpen is a NULL pointer then xOpen", "** must invent its own temporary name for the file.  ^Whenever the ", "** xFilename parameter is NULL it will also be the case that the", "** flags parameter will include [SQLITE_OPEN_DELETEONCLOSE].", "**", "** The flags argument to xOpen() includes all bits set in", "** the flags argument to [sqlite3_open_v2()].  Or if [sqlite3_open()]", "** or [sqlite3_open16()] is used, then flags includes at least", "** [SQLITE_OPEN_READWRITE] | [SQLITE_OPEN_CREATE]. ", "** If xOpen() opens a file read-only then it sets *pOutFlags to", "** include [SQLITE_OPEN_READONLY].  Other bits in *pOutFlags may be set.", "**", "** ^(SQLite will also add one of the following flags to the xOpen()", "** call, depending on the object being opened:", "**", "** <ul>", "** <li>  [SQLITE_OPEN_MAIN_DB]", "** <li>  [SQLITE_OPEN_MAIN_JOURNAL]", "** <li>  [SQLITE_OPEN_TEMP_DB]", "** <li>  [SQLITE_OPEN_TEMP_JOURNAL]", "** <li>  [SQLITE_OPEN_TRANSIENT_DB]", "** <li>  [SQLITE_OPEN_SUBJOURNAL]", "** <li>  [SQLITE_OPEN_MASTER_JOURNAL]", "** <li>  [SQLITE_OPEN_WAL]", "** </ul>)^", "**", "** The file I/O implementation can use the object type flags to", "** change the way it deals with files.  For example, an application", "** that does not care about crash recovery or rollback might make", "** the open of a journal file a no-op.  Writes to this journal would", "** also be no-ops, and any attempt to read the journal would return", "** SQLITE_IOERR.  Or the implementation might recognize that a database", "** file will be doing page-aligned sector reads and writes in a random", "** order and set up its I/O subsystem accordingly.", "**", "** SQLite might also add one of the following flags to the xOpen method:", "**", "** <ul>", "** <li> [SQLITE_OPEN_DELETEONCLOSE]", "** <li> [SQLITE_OPEN_EXCLUSIVE]", "** </ul>", "**", "** The [SQLITE_OPEN_DELETEONCLOSE] flag means the file should be", "** deleted when it is closed.  ^The [SQLITE_OPEN_DELETEONCLOSE]", "** will be set for TEMP databases and their journals, transient", "** databases, and subjournals.", "**", "** ^The [SQLITE_OPEN_EXCLUSIVE] flag is always used in conjunction", "** with the [SQLITE_OPEN_CREATE] flag, which are both directly", "** analogous to the O_EXCL and O_CREAT flags of the POSIX open()", "** API.  The SQLITE_OPEN_EXCLUSIVE flag, when paired with the ", "** SQLITE_OPEN_CREATE, is used to indicate that file should always", "** be created, and that it is an error if it already exists.", "** It is <i>not</i> used to indicate the file should be opened ", "** for exclusive access.", "**", "** ^At least szOsFile bytes of memory are allocated by SQLite", "** to hold the  [sqlite3_file] structure passed as the third", "** argument to xOpen.  The xOpen method does not have to", "** allocate the structure; it should just fill it in.  Note that", "** the xOpen method must set the sqlite3_file.pMethods to either", "** a valid [sqlite3_io_methods] object or to NULL.  xOpen must do", "** this even if the open fails.  SQLite expects that the sqlite3_file.pMethods", "** element will be valid after xOpen returns regardless of the success", "** or failure of the xOpen call.", "**", "** [[sqlite3_vfs.xAccess]]", "** ^The flags argument to xAccess() may be [SQLITE_ACCESS_EXISTS]", "** to test for the existence of a file, or [SQLITE_ACCESS_READWRITE] to", "** test whether a file is readable and writable, or [SQLITE_ACCESS_READ]", "** to test whether a file is at least readable.   The file can be a", "** directory.", "**", "** ^SQLite will always allocate at least mxPathname+1 bytes for the", "** output buffer xFullPathname.  The exact size of the output buffer", "** is also passed as a parameter to both  methods. If the output buffer", "** is not large enough, [SQLITE_CANTOPEN] should be returned. Since this is", "** handled as a fatal error by SQLite, vfs implementations should endeavor", "** to prevent this by setting mxPathname to a sufficiently large value.", "**", "** The xRandomness(), xSleep(), xCurrentTime(), and xCurrentTimeInt64()", "** interfaces are not strictly a part of the filesystem, but they are", "** included in the VFS structure for completeness.", "** The xRandomness() function attempts to return nBytes bytes", "** of good-quality randomness into zOut.  The return value is", "** the actual number of bytes of randomness obtained.", "** The xSleep() method causes the calling thread to sleep for at", "** least the number of microseconds given.  ^The xCurrentTime()", "** method returns a Julian Day Number for the current date and time as", "** a floating point value.", "** ^The xCurrentTimeInt64() method returns, as an integer, the Julian", "** Day Number multiplied by 86400000 (the number of milliseconds in ", "** a 24-hour day).  ", "** ^SQLite will use the xCurrentTimeInt64() method to get the current", "** date and time if that method is available (if iVersion is 2 or ", "** greater and the function pointer is not NULL) and will fall back", "** to xCurrentTime() if xCurrentTimeInt64() is unavailable.", "**", "** ^The xSetSystemCall(), xGetSystemCall(), and xNestSystemCall() interfaces", "** are not used by the SQLite core.  These optional interfaces are provided", "** by some VFSes to facilitate testing of the VFS code. By overriding ", "** system calls with functions under its control, a test program can", "** simulate faults and error conditions that would otherwise be difficult", "** or impossible to induce.  The set of system calls that can be overridden", "** varies from one VFS to another, and from one version of the same VFS to the", "** next.  Applications that use these interfaces must be prepared for any", "** or all of these interfaces to be NULL or for their behavior to change", "** from one release to the next.  Applications must not attempt to access", "** any of these methods if the iVersion of the VFS is less than 3.", "*/", "typedef struct sqlite3_vfs sqlite3_vfs;", "typedef void (*sqlite3_syscall_ptr)(void);", "struct sqlite3_vfs {", "  int iVersion;            /* Structure version number (currently 3) */", "  int szOsFile;            /* Size of subclassed sqlite3_file */", "  int mxPathname;          /* Maximum file pathname length */", "  sqlite3_vfs *pNext;      /* Next registered VFS */", "  const char *zName;       /* Name of this virtual file system */", "  void *pAppData;          /* Pointer to application-specific data */", "  int (*xOpen)(sqlite3_vfs*, const char *zName, sqlite3_file*,", "               int flags, int *pOutFlags);", "  int (*xDelete)(sqlite3_vfs*, const char *zName, int syncDir);", "  int (*xAccess)(sqlite3_vfs*, const char *zName, int flags, int *pResOut);", "  int (*xFullPathname)(sqlite3_vfs*, const char *zName, int nOut, char *zOut);", "  void *(*xDlOpen)(sqlite3_vfs*, const char *zFilename);", "  void (*xDlError)(sqlite3_vfs*, int nByte, char *zErrMsg);", "  void (*(*xDlSym)(sqlite3_vfs*,void*, const char *zSymbol))(void);", "  void (*xDlClose)(sqlite3_vfs*, void*);", "  int (*xRandomness)(sqlite3_vfs*, int nByte, char *zOut);", "  int (*xSleep)(sqlite3_vfs*, int microseconds);", "  int (*xCurrentTime)(sqlite3_vfs*, double*);", "  int (*xGetLastError)(sqlite3_vfs*, int, char *);", "  /*", "  ** The methods above are in version 1 of the sqlite_vfs object", "  ** definition.  Those that follow are added in version 2 or later", "  */", "  int (*xCurrentTimeInt64)(sqlite3_vfs*, sqlite3_int64*);", "  /*", "  ** The methods above are in versions 1 and 2 of the sqlite_vfs object.", "  ** Those below are for version 3 and greater.", "  */", "  int (*xSetSystemCall)(sqlite3_vfs*, const char *zName, sqlite3_syscall_ptr);", "  sqlite3_syscall_ptr (*xGetSystemCall)(sqlite3_vfs*, const char *zName);", "  const char *(*xNextSystemCall)(sqlite3_vfs*, const char *zName);", "  /*", "  ** The methods above are in versions 1 through 3 of the sqlite_vfs object.", "  ** New fields may be appended in figure versions.  The iVersion", "  ** value will increment whenever this happens. ", "  */", "};", "", "/*", "** CAPI3REF: Flags for the xAccess VFS method", "**", "** These integer constants can be used as the third parameter to", "** the xAccess method of an [sqlite3_vfs] object.  They determine", "** what kind of permissions the xAccess method is looking for.", "** With SQLITE_ACCESS_EXISTS, the xAccess method", "** simply checks whether the file exists.", "** With SQLITE_ACCESS_READWRITE, the xAccess method", "** checks whether the named directory is both readable and writable", "** (in other words, if files can be added, removed, and renamed within", "** the directory).", "** The SQLITE_ACCESS_READWRITE constant is currently used only by the", "** [temp_store_directory pragma], though this could change in a future", "** release of SQLite.", "** With SQLITE_ACCESS_READ, the xAccess method", "** checks whether the file is readable.  The SQLITE_ACCESS_READ constant is", "** currently unused, though it might be used in a future release of", "** SQLite.", "*/", "#define SQLITE_ACCESS_EXISTS    0", "#define SQLITE_ACCESS_READWRITE 1   /* Used by PRAGMA temp_store_directory */", "#define SQLITE_ACCESS_READ      2   /* Unused */", "", "/*", "** CAPI3REF: Flags for the xShmLock VFS method", "**", "** These integer constants define the various locking operations", "** allowed by the xShmLock method of [sqlite3_io_methods].  The", "** following are the only legal combinations of flags to the", "** xShmLock method:", "**", "** <ul>", "** <li>  SQLITE_SHM_LOCK | SQLITE_SHM_SHARED", "** <li>  SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVE", "** <li>  SQLITE_SHM_UNLOCK | SQLITE_SHM_SHARED", "** <li>  SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE", "** </ul>", "**", "** When unlocking, the same SHARED or EXCLUSIVE flag must be supplied as", "** was given no the corresponding lock.  ", "**", "** The xShmLock method can transition between unlocked and SHARED or", "** between unlocked and EXCLUSIVE.  It cannot transition between SHARED", "** and EXCLUSIVE.", "*/", "#define SQLITE_SHM_UNLOCK       1", "#define SQLITE_SHM_LOCK         2", "#define SQLITE_SHM_SHARED       4", "#define SQLITE_SHM_EXCLUSIVE    8", "", "/*", "** CAPI3REF: Maximum xShmLock index", "**", "** The xShmLock method on [sqlite3_io_methods] may use values", '** between 0 and this upper bound as its "offset" argument.', "** The SQLite core will never attempt to acquire or release a", "** lock outside of this range", "*/", "#define SQLITE_SHM_NLOCK        8", "", "", "/*", "** CAPI3REF: Initialize The SQLite Library", "**", "** ^The sqlite3_initialize() routine initializes the", "** SQLite library.  ^The sqlite3_shutdown() routine", "** deallocates any resources that were allocated by sqlite3_initialize().", "** These routines are designed to aid in process initialization and", "** shutdown on embedded systems.  Workstation applications using", "** SQLite normally do not need to invoke either of these routines.", "**", '** A call to sqlite3_initialize() is an "effective" call if it is', "** the first time sqlite3_initialize() is invoked during the lifetime of", "** the process, or if it is the first time sqlite3_initialize() is invoked", "** following a call to sqlite3_shutdown().  ^(Only an effective call", "** of sqlite3_initialize() does any initialization.  All other calls", "** are harmless no-ops.)^", "**", '** A call to sqlite3_shutdown() is an "effective" call if it is the first', "** call to sqlite3_shutdown() since the last sqlite3_initialize().  ^(Only", "** an effective call to sqlite3_shutdown() does any deinitialization.", "** All other valid calls to sqlite3_shutdown() are harmless no-ops.)^", "**", "** The sqlite3_initialize() interface is threadsafe, but sqlite3_shutdown()", "** is not.  The sqlite3_shutdown() interface must only be called from a", "** single thread.  All open [database connections] must be closed and all", "** other SQLite resources must be deallocated prior to invoking", "** sqlite3_shutdown().", "**", "** Among other things, ^sqlite3_initialize() will invoke", "** sqlite3_os_init().  Similarly, ^sqlite3_shutdown()", "** will invoke sqlite3_os_end().", "**", "** ^The sqlite3_initialize() routine returns [SQLITE_OK] on success.", "** ^If for some reason, sqlite3_initialize() is unable to initialize", "** the library (perhaps it is unable to allocate a needed resource such", "** as a mutex) it returns an [error code] other than [SQLITE_OK].", "**", "** ^The sqlite3_initialize() routine is called internally by many other", "** SQLite interfaces so that an application usually does not need to", "** invoke sqlite3_initialize() directly.  For example, [sqlite3_open()]", "** calls sqlite3_initialize() so the SQLite library will be automatically", "** initialized when [sqlite3_open()] is called if it has not be initialized", "** already.  ^However, if SQLite is compiled with the [SQLITE_OMIT_AUTOINIT]", "** compile-time option, then the automatic calls to sqlite3_initialize()", "** are omitted and the application must call sqlite3_initialize() directly", "** prior to using any other SQLite interface.  For maximum portability,", "** it is recommended that applications always invoke sqlite3_initialize()", "** directly prior to using any other SQLite interface.  Future releases", "** of SQLite may require this.  In other words, the behavior exhibited", "** when SQLite is compiled with [SQLITE_OMIT_AUTOINIT] might become the", "** default behavior in some future release of SQLite.", "**", "** The sqlite3_os_init() routine does operating-system specific", "** initialization of the SQLite library.  The sqlite3_os_end()", "** routine undoes the effect of sqlite3_os_init().  Typical tasks", "** performed by these routines include allocation or deallocation", "** of static resources, initialization of global variables,", "** setting up a default [sqlite3_vfs] module, or setting up", "** a default configuration using [sqlite3_config()].", "**", "** The application should never invoke either sqlite3_os_init()", "** or sqlite3_os_end() directly.  The application should only invoke", "** sqlite3_initialize() and sqlite3_shutdown().  The sqlite3_os_init()", "** interface is called automatically by sqlite3_initialize() and", "** sqlite3_os_end() is called by sqlite3_shutdown().  Appropriate", "** implementations for sqlite3_os_init() and sqlite3_os_end()", "** are built into SQLite when it is compiled for Unix, Windows, or OS/2.", "** When [custom builds | built for other platforms]", "** (using the [SQLITE_OS_OTHER=1] compile-time", "** option) the application must supply a suitable implementation for", "** sqlite3_os_init() and sqlite3_os_end().  An application-supplied", "** implementation of sqlite3_os_init() or sqlite3_os_end()", "** must return [SQLITE_OK] on success and some other [error code] upon", "** failure.", "*/", "SQLITE_API int sqlite3_initialize(void);", "SQLITE_API int sqlite3_shutdown(void);", "SQLITE_API int sqlite3_os_init(void);", "SQLITE_API int sqlite3_os_end(void);", "", "/*", "** CAPI3REF: Configuring The SQLite Library", "**", "** The sqlite3_config() interface is used to make global configuration", "** changes to SQLite in order to tune SQLite to the specific needs of", "** the application.  The default configuration is recommended for most", "** applications and so this routine is usually not necessary.  It is", "** provided to support rare applications with unusual needs.", "**", "** The sqlite3_config() interface is not threadsafe.  The application", "** must insure that no other SQLite interfaces are invoked by other", "** threads while sqlite3_config() is running.  Furthermore, sqlite3_config()", "** may only be invoked prior to library initialization using", "** [sqlite3_initialize()] or after shutdown by [sqlite3_shutdown()].", "** ^If sqlite3_config() is called after [sqlite3_initialize()] and before", "** [sqlite3_shutdown()] then it will return SQLITE_MISUSE.", "** Note, however, that ^sqlite3_config() can be called as part of the", "** implementation of an application-defined [sqlite3_os_init()].", "**", "** The first argument to sqlite3_config() is an integer", "** [configuration option] that determines", "** what property of SQLite is to be configured.  Subsequent arguments", "** vary depending on the [configuration option]", "** in the first argument.", "**", "** ^When a configuration option is set, sqlite3_config() returns [SQLITE_OK].", "** ^If the option is unknown or SQLite is unable to set the option", "** then this routine returns a non-zero [error code].", "*/", "SQLITE_API int sqlite3_config(int, ...);", "", "/*", "** CAPI3REF: Configure database connections", "**", "** The sqlite3_db_config() interface is used to make configuration", "** changes to a [database connection].  The interface is similar to", "** [sqlite3_config()] except that the changes apply to a single", "** [database connection] (specified in the first argument).", "**", "** The second argument to sqlite3_db_config(D,V,...)  is the", "** [SQLITE_DBCONFIG_LOOKASIDE | configuration verb] - an integer code ", "** that indicates what aspect of the [database connection] is being configured.", "** Subsequent arguments vary depending on the configuration verb.", "**", "** ^Calls to sqlite3_db_config() return SQLITE_OK if and only if", "** the call is considered successful.", "*/", "SQLITE_API int sqlite3_db_config(sqlite3*, int op, ...);", "", "/*", "** CAPI3REF: Memory Allocation Routines", "**", "** An instance of this object defines the interface between SQLite", "** and low-level memory allocation routines.", "**", "** This object is used in only one place in the SQLite interface.", "** A pointer to an instance of this object is the argument to", "** [sqlite3_config()] when the configuration option is", "** [SQLITE_CONFIG_MALLOC] or [SQLITE_CONFIG_GETMALLOC].  ", "** By creating an instance of this object", "** and passing it to [sqlite3_config]([SQLITE_CONFIG_MALLOC])", "** during configuration, an application can specify an alternative", "** memory allocation subsystem for SQLite to use for all of its", "** dynamic memory needs.", "**", "** Note that SQLite comes with several [built-in memory allocators]", "** that are perfectly adequate for the overwhelming majority of applications", "** and that this object is only useful to a tiny minority of applications", "** with specialized memory allocation requirements.  This object is", "** also used during testing of SQLite in order to specify an alternative", "** memory allocator that simulates memory out-of-memory conditions in", "** order to verify that SQLite recovers gracefully from such", "** conditions.", "**", "** The xMalloc, xRealloc, and xFree methods must work like the", "** malloc(), realloc() and free() functions from the standard C library.", "** ^SQLite guarantees that the second argument to", "** xRealloc is always a value returned by a prior call to xRoundup.", "**", "** xSize should return the allocated size of a memory allocation", "** previously obtained from xMalloc or xRealloc.  The allocated size", "** is always at least as big as the requested size but may be larger.", "**", "** The xRoundup method returns what would be the allocated size of", "** a memory allocation given a particular requested size.  Most memory", "** allocators round up memory allocations at least to the next multiple", "** of 8.  Some allocators round up to a larger multiple or to a power of 2.", "** Every memory allocation request coming in through [sqlite3_malloc()]", "** or [sqlite3_realloc()] first calls xRoundup.  If xRoundup returns 0, ", "** that causes the corresponding memory allocation to fail.", "**", "** The xInit method initializes the memory allocator.  (For example,", "** it might allocate any require mutexes or initialize internal data", "** structures.  The xShutdown method is invoked (indirectly) by", "** [sqlite3_shutdown()] and should deallocate any resources acquired", "** by xInit.  The pAppData pointer is used as the only parameter to", "** xInit and xShutdown.", "**", "** SQLite holds the [SQLITE_MUTEX_STATIC_MASTER] mutex when it invokes", "** the xInit method, so the xInit method need not be threadsafe.  The", "** xShutdown method is only called from [sqlite3_shutdown()] so it does", "** not need to be threadsafe either.  For all other methods, SQLite", "** holds the [SQLITE_MUTEX_STATIC_MEM] mutex as long as the", "** [SQLITE_CONFIG_MEMSTATUS] configuration option is turned on (which", "** it is by default) and so the methods are automatically serialized.", "** However, if [SQLITE_CONFIG_MEMSTATUS] is disabled, then the other", "** methods must be threadsafe or else make their own arrangements for", "** serialization.", "**", "** SQLite will never invoke xInit() more than once without an intervening", "** call to xShutdown().", "*/", "typedef struct sqlite3_mem_methods sqlite3_mem_methods;", "struct sqlite3_mem_methods {", "  void *(*xMalloc)(int);         /* Memory allocation function */", "  void (*xFree)(void*);          /* Free a prior allocation */", "  void *(*xRealloc)(void*,int);  /* Resize an allocation */", "  int (*xSize)(void*);           /* Return the size of an allocation */", "  int (*xRoundup)(int);          /* Round up request size to allocation size */", "  int (*xInit)(void*);           /* Initialize the memory allocator */", "  void (*xShutdown)(void*);      /* Deinitialize the memory allocator */", "  void *pAppData;                /* Argument to xInit() and xShutdown() */", "};", "", "/*", "** CAPI3REF: Configuration Options", "** KEYWORDS: {configuration option}", "**", "** These constants are the available integer configuration options that", "** can be passed as the first argument to the [sqlite3_config()] interface.", "**", "** New configuration options may be added in future releases of SQLite.", "** Existing configuration options might be discontinued.  Applications", "** should check the return code from [sqlite3_config()] to make sure that", "** the call worked.  The [sqlite3_config()] interface will return a", "** non-zero [error code] if a discontinued or unsupported configuration option", "** is invoked.", "**", "** <dl>", "** [[SQLITE_CONFIG_SINGLETHREAD]] <dt>SQLITE_CONFIG_SINGLETHREAD</dt>", "** <dd>There are no arguments to this option.  ^This option sets the", "** [threading mode] to Single-thread.  In other words, it disables", "** all mutexing and puts SQLite into a mode where it can only be used", "** by a single thread.   ^If SQLite is compiled with", "** the [SQLITE_THREADSAFE | SQLITE_THREADSAFE=0] compile-time option then", "** it is not possible to change the [threading mode] from its default", "** value of Single-thread and so [sqlite3_config()] will return ", "** [SQLITE_ERROR] if called with the SQLITE_CONFIG_SINGLETHREAD", "** configuration option.</dd>", "**", "** [[SQLITE_CONFIG_MULTITHREAD]] <dt>SQLITE_CONFIG_MULTITHREAD</dt>", "** <dd>There are no arguments to this option.  ^This option sets the", "** [threading mode] to Multi-thread.  In other words, it disables", "** mutexing on [database connection] and [prepared statement] objects.", "** The application is responsible for serializing access to", "** [database connections] and [prepared statements].  But other mutexes", "** are enabled so that SQLite will be safe to use in a multi-threaded", "** environment as long as no two threads attempt to use the same", "** [database connection] at the same time.  ^If SQLite is compiled with", "** the [SQLITE_THREADSAFE | SQLITE_THREADSAFE=0] compile-time option then", "** it is not possible to set the Multi-thread [threading mode] and", "** [sqlite3_config()] will return [SQLITE_ERROR] if called with the", "** SQLITE_CONFIG_MULTITHREAD configuration option.</dd>", "**", "** [[SQLITE_CONFIG_SERIALIZED]] <dt>SQLITE_CONFIG_SERIALIZED</dt>", "** <dd>There are no arguments to this option.  ^This option sets the", "** [threading mode] to Serialized. In other words, this option enables", "** all mutexes including the recursive", "** mutexes on [database connection] and [prepared statement] objects.", "** In this mode (which is the default when SQLite is compiled with", "** [SQLITE_THREADSAFE=1]) the SQLite library will itself serialize access", "** to [database connections] and [prepared statements] so that the", "** application is free to use the same [database connection] or the", "** same [prepared statement] in different threads at the same time.", "** ^If SQLite is compiled with", "** the [SQLITE_THREADSAFE | SQLITE_THREADSAFE=0] compile-time option then", "** it is not possible to set the Serialized [threading mode] and", "** [sqlite3_config()] will return [SQLITE_ERROR] if called with the", "** SQLITE_CONFIG_SERIALIZED configuration option.</dd>", "**", "** [[SQLITE_CONFIG_MALLOC]] <dt>SQLITE_CONFIG_MALLOC</dt>", "** <dd> ^(This option takes a single argument which is a pointer to an", "** instance of the [sqlite3_mem_methods] structure.  The argument specifies", "** alternative low-level memory allocation routines to be used in place of", "** the memory allocation routines built into SQLite.)^ ^SQLite makes", "** its own private copy of the content of the [sqlite3_mem_methods] structure", "** before the [sqlite3_config()] call returns.</dd>", "**", "** [[SQLITE_CONFIG_GETMALLOC]] <dt>SQLITE_CONFIG_GETMALLOC</dt>", "** <dd> ^(This option takes a single argument which is a pointer to an", "** instance of the [sqlite3_mem_methods] structure.  The [sqlite3_mem_methods]", "** structure is filled with the currently defined memory allocation routines.)^", "** This option can be used to overload the default memory allocation", "** routines with a wrapper that simulations memory allocation failure or", "** tracks memory usage, for example. </dd>", "**", "** [[SQLITE_CONFIG_MEMSTATUS]] <dt>SQLITE_CONFIG_MEMSTATUS</dt>", "** <dd> ^This option takes single argument of type int, interpreted as a ", "** boolean, which enables or disables the collection of memory allocation ", "** statistics. ^(When memory allocation statistics are disabled, the ", "** following SQLite interfaces become non-operational:", "**   <ul>", "**   <li> [sqlite3_memory_used()]", "**   <li> [sqlite3_memory_highwater()]", "**   <li> [sqlite3_soft_heap_limit64()]", "**   <li> [sqlite3_status()]", "**   </ul>)^", "** ^Memory allocation statistics are enabled by default unless SQLite is", "** compiled with [SQLITE_DEFAULT_MEMSTATUS]=0 in which case memory", "** allocation statistics are disabled by default.", "** </dd>", "**", "** [[SQLITE_CONFIG_SCRATCH]] <dt>SQLITE_CONFIG_SCRATCH</dt>", "** <dd> ^This option specifies a static memory buffer that SQLite can use for", "** scratch memory.  There are three arguments:  A pointer an 8-byte", "** aligned memory buffer from which the scratch allocations will be", "** drawn, the size of each scratch allocation (sz),", "** and the maximum number of scratch allocations (N).  The sz", "** argument must be a multiple of 16.", "** The first argument must be a pointer to an 8-byte aligned buffer", "** of at least sz*N bytes of memory.", "** ^SQLite will use no more than two scratch buffers per thread.  So", "** N should be set to twice the expected maximum number of threads.", "** ^SQLite will never require a scratch buffer that is more than 6", "** times the database page size. ^If SQLite needs needs additional", "** scratch memory beyond what is provided by this configuration option, then ", "** [sqlite3_malloc()] will be used to obtain the memory needed.</dd>", "**", "** [[SQLITE_CONFIG_PAGECACHE]] <dt>SQLITE_CONFIG_PAGECACHE</dt>", "** <dd> ^This option specifies a static memory buffer that SQLite can use for", "** the database page cache with the default page cache implementation.  ", "** This configuration should not be used if an application-define page", "** cache implementation is loaded using the SQLITE_CONFIG_PCACHE2 option.", "** There are three arguments to this option: A pointer to 8-byte aligned", "** memory, the size of each page buffer (sz), and the number of pages (N).", "** The sz argument should be the size of the largest database page", "** (a power of two between 512 and 32768) plus a little extra for each", "** page header.  ^The page header size is 20 to 40 bytes depending on", "** the host architecture.  ^It is harmless, apart from the wasted memory,", "** to make sz a little too large.  The first", "** argument should point to an allocation of at least sz*N bytes of memory.", "** ^SQLite will use the memory provided by the first argument to satisfy its", "** memory needs for the first N pages that it adds to cache.  ^If additional", "** page cache memory is needed beyond what is provided by this option, then", "** SQLite goes to [sqlite3_malloc()] for the additional storage space.", "** The pointer in the first argument must", "** be aligned to an 8-byte boundary or subsequent behavior of SQLite", "** will be undefined.</dd>", "**", "** [[SQLITE_CONFIG_HEAP]] <dt>SQLITE_CONFIG_HEAP</dt>", "** <dd> ^This option specifies a static memory buffer that SQLite will use", "** for all of its dynamic memory allocation needs beyond those provided", "** for by [SQLITE_CONFIG_SCRATCH] and [SQLITE_CONFIG_PAGECACHE].", "** There are three arguments: An 8-byte aligned pointer to the memory,", "** the number of bytes in the memory buffer, and the minimum allocation size.", "** ^If the first pointer (the memory pointer) is NULL, then SQLite reverts", "** to using its default memory allocator (the system malloc() implementation),", "** undoing any prior invocation of [SQLITE_CONFIG_MALLOC].  ^If the", "** memory pointer is not NULL and either [SQLITE_ENABLE_MEMSYS3] or", "** [SQLITE_ENABLE_MEMSYS5] are defined, then the alternative memory", "** allocator is engaged to handle all of SQLites memory allocation needs.", "** The first pointer (the memory pointer) must be aligned to an 8-byte", "** boundary or subsequent behavior of SQLite will be undefined.", "** The minimum allocation size is capped at 2**12. Reasonable values", "** for the minimum allocation size are 2**5 through 2**8.</dd>", "**", "** [[SQLITE_CONFIG_MUTEX]] <dt>SQLITE_CONFIG_MUTEX</dt>", "** <dd> ^(This option takes a single argument which is a pointer to an", "** instance of the [sqlite3_mutex_methods] structure.  The argument specifies", "** alternative low-level mutex routines to be used in place", "** the mutex routines built into SQLite.)^  ^SQLite makes a copy of the", "** content of the [sqlite3_mutex_methods] structure before the call to", "** [sqlite3_config()] returns. ^If SQLite is compiled with", "** the [SQLITE_THREADSAFE | SQLITE_THREADSAFE=0] compile-time option then", "** the entire mutexing subsystem is omitted from the build and hence calls to", "** [sqlite3_config()] with the SQLITE_CONFIG_MUTEX configuration option will", "** return [SQLITE_ERROR].</dd>", "**", "** [[SQLITE_CONFIG_GETMUTEX]] <dt>SQLITE_CONFIG_GETMUTEX</dt>", "** <dd> ^(This option takes a single argument which is a pointer to an", "** instance of the [sqlite3_mutex_methods] structure.  The", "** [sqlite3_mutex_methods]", "** structure is filled with the currently defined mutex routines.)^", "** This option can be used to overload the default mutex allocation", "** routines with a wrapper used to track mutex usage for performance", "** profiling or testing, for example.   ^If SQLite is compiled with", "** the [SQLITE_THREADSAFE | SQLITE_THREADSAFE=0] compile-time option then", "** the entire mutexing subsystem is omitted from the build and hence calls to", "** [sqlite3_config()] with the SQLITE_CONFIG_GETMUTEX configuration option will", "** return [SQLITE_ERROR].</dd>", "**", "** [[SQLITE_CONFIG_LOOKASIDE]] <dt>SQLITE_CONFIG_LOOKASIDE</dt>", "** <dd> ^(This option takes two arguments that determine the default", "** memory allocation for the lookaside memory allocator on each", "** [database connection].  The first argument is the", "** size of each lookaside buffer slot and the second is the number of", "** slots allocated to each database connection.)^  ^(This option sets the", "** <i>default</i> lookaside size. The [SQLITE_DBCONFIG_LOOKASIDE]", "** verb to [sqlite3_db_config()] can be used to change the lookaside", "** configuration on individual connections.)^ </dd>", "**", "** [[SQLITE_CONFIG_PCACHE2]] <dt>SQLITE_CONFIG_PCACHE2</dt>", "** <dd> ^(This option takes a single argument which is a pointer to", "** an [sqlite3_pcache_methods2] object.  This object specifies the interface", "** to a custom page cache implementation.)^  ^SQLite makes a copy of the", "** object and uses it for page cache memory allocations.</dd>", "**", "** [[SQLITE_CONFIG_GETPCACHE2]] <dt>SQLITE_CONFIG_GETPCACHE2</dt>", "** <dd> ^(This option takes a single argument which is a pointer to an", "** [sqlite3_pcache_methods2] object.  SQLite copies of the current", "** page cache implementation into that object.)^ </dd>", "**", "** [[SQLITE_CONFIG_LOG]] <dt>SQLITE_CONFIG_LOG</dt>", "** <dd> ^The SQLITE_CONFIG_LOG option takes two arguments: a pointer to a", "** function with a call signature of void(*)(void*,int,const char*), ", "** and a pointer to void. ^If the function pointer is not NULL, it is", "** invoked by [sqlite3_log()] to process each logging event.  ^If the", "** function pointer is NULL, the [sqlite3_log()] interface becomes a no-op.", "** ^The void pointer that is the second argument to SQLITE_CONFIG_LOG is", "** passed through as the first parameter to the application-defined logger", "** function whenever that function is invoked.  ^The second parameter to", "** the logger function is a copy of the first parameter to the corresponding", "** [sqlite3_log()] call and is intended to be a [result code] or an", "** [extended result code].  ^The third parameter passed to the logger is", "** log message after formatting via [sqlite3_snprintf()].", "** The SQLite logging interface is not reentrant; the logger function", "** supplied by the application must not invoke any SQLite interface.", "** In a multi-threaded application, the application-defined logger", "** function must be threadsafe. </dd>", "**", "** [[SQLITE_CONFIG_URI]] <dt>SQLITE_CONFIG_URI", "** <dd> This option takes a single argument of type int. If non-zero, then", "** URI handling is globally enabled. If the parameter is zero, then URI handling", "** is globally disabled. If URI handling is globally enabled, all filenames", "** passed to [sqlite3_open()], [sqlite3_open_v2()], [sqlite3_open16()] or", "** specified as part of [ATTACH] commands are interpreted as URIs, regardless", "** of whether or not the [SQLITE_OPEN_URI] flag is set when the database", "** connection is opened. If it is globally disabled, filenames are", "** only interpreted as URIs if the SQLITE_OPEN_URI flag is set when the", "** database connection is opened. By default, URI handling is globally", "** disabled. The default value may be changed by compiling with the", "** [SQLITE_USE_URI] symbol defined.", "**", "** [[SQLITE_CONFIG_PCACHE]] [[SQLITE_CONFIG_GETPCACHE]]", "** <dt>SQLITE_CONFIG_PCACHE and SQLITE_CONFIG_GETPCACHE", "** <dd> These options are obsolete and should not be used by new code.", "** They are retained for backwards compatibility but are now no-ops.", "** </dl>", "*/", "#define SQLITE_CONFIG_SINGLETHREAD  1  /* nil */", "#define SQLITE_CONFIG_MULTITHREAD   2  /* nil */", "#define SQLITE_CONFIG_SERIALIZED    3  /* nil */", "#define SQLITE_CONFIG_MALLOC        4  /* sqlite3_mem_methods* */", "#define SQLITE_CONFIG_GETMALLOC     5  /* sqlite3_mem_methods* */", "#define SQLITE_CONFIG_SCRATCH       6  /* void*, int sz, int N */", "#define SQLITE_CONFIG_PAGECACHE     7  /* void*, int sz, int N */", "#define SQLITE_CONFIG_HEAP          8  /* void*, int nByte, int min */", "#define SQLITE_CONFIG_MEMSTATUS     9  /* boolean */", "#define SQLITE_CONFIG_MUTEX        10  /* sqlite3_mutex_methods* */", "#define SQLITE_CONFIG_GETMUTEX     11  /* sqlite3_mutex_methods* */", "/* previously SQLITE_CONFIG_CHUNKALLOC 12 which is now unused. */ ", "#define SQLITE_CONFIG_LOOKASIDE    13  /* int int */", "#define SQLITE_CONFIG_PCACHE       14  /* no-op */", "#define SQLITE_CONFIG_GETPCACHE    15  /* no-op */", "#define SQLITE_CONFIG_LOG          16  /* xFunc, void* */", "#define SQLITE_CONFIG_URI          17  /* int */", "#define SQLITE_CONFIG_PCACHE2      18  /* sqlite3_pcache_methods2* */", "#define SQLITE_CONFIG_GETPCACHE2   19  /* sqlite3_pcache_methods2* */", "", "/*", "** CAPI3REF: Database Connection Configuration Options", "**", "** These constants are the available integer configuration options that", "** can be passed as the second argument to the [sqlite3_db_config()] interface.", "**", "** New configuration options may be added in future releases of SQLite.", "** Existing configuration options might be discontinued.  Applications", "** should check the return code from [sqlite3_db_config()] to make sure that", "** the call worked.  ^The [sqlite3_db_config()] interface will return a", "** non-zero [error code] if a discontinued or unsupported configuration option", "** is invoked.", "**", "** <dl>", "** <dt>SQLITE_DBCONFIG_LOOKASIDE</dt>", "** <dd> ^This option takes three additional arguments that determine the ", "** [lookaside memory allocator] configuration for the [database connection].", "** ^The first argument (the third parameter to [sqlite3_db_config()] is a", "** pointer to a memory buffer to use for lookaside memory.", "** ^The first argument after the SQLITE_DBCONFIG_LOOKASIDE verb", "** may be NULL in which case SQLite will allocate the", "** lookaside buffer itself using [sqlite3_malloc()]. ^The second argument is the", "** size of each lookaside buffer slot.  ^The third argument is the number of", "** slots.  The size of the buffer in the first argument must be greater than", "** or equal to the product of the second and third arguments.  The buffer", "** must be aligned to an 8-byte boundary.  ^If the second argument to", "** SQLITE_DBCONFIG_LOOKASIDE is not a multiple of 8, it is internally", "** rounded down to the next smaller multiple of 8.  ^(The lookaside memory", "** configuration for a database connection can only be changed when that", "** connection is not currently using lookaside memory, or in other words", '** when the "current value" returned by', "** [sqlite3_db_status](D,[SQLITE_CONFIG_LOOKASIDE],...) is zero.", "** Any attempt to change the lookaside memory configuration when lookaside", "** memory is in use leaves the configuration unchanged and returns ", "** [SQLITE_BUSY].)^</dd>", "**", "** <dt>SQLITE_DBCONFIG_ENABLE_FKEY</dt>", "** <dd> ^This option is used to enable or disable the enforcement of", "** [foreign key constraints].  There should be two additional arguments.", "** The first argument is an integer which is 0 to disable FK enforcement,", "** positive to enable FK enforcement or negative to leave FK enforcement", "** unchanged.  The second parameter is a pointer to an integer into which", "** is written 0 or 1 to indicate whether FK enforcement is off or on", "** following this call.  The second parameter may be a NULL pointer, in", "** which case the FK enforcement setting is not reported back. </dd>", "**", "** <dt>SQLITE_DBCONFIG_ENABLE_TRIGGER</dt>", "** <dd> ^This option is used to enable or disable [CREATE TRIGGER | triggers].", "** There should be two additional arguments.", "** The first argument is an integer which is 0 to disable triggers,", "** positive to enable triggers or negative to leave the setting unchanged.", "** The second parameter is a pointer to an integer into which", "** is written 0 or 1 to indicate whether triggers are disabled or enabled", "** following this call.  The second parameter may be a NULL pointer, in", "** which case the trigger setting is not reported back. </dd>", "**", "** </dl>", "*/", "#define SQLITE_DBCONFIG_LOOKASIDE       1001  /* void* int int */", "#define SQLITE_DBCONFIG_ENABLE_FKEY     1002  /* int int* */", "#define SQLITE_DBCONFIG_ENABLE_TRIGGER  1003  /* int int* */", "", "", "/*", "** CAPI3REF: Enable Or Disable Extended Result Codes", "**", "** ^The sqlite3_extended_result_codes() routine enables or disables the", "** [extended result codes] feature of SQLite. ^The extended result", "** codes are disabled by default for historical compatibility.", "*/", "SQLITE_API int sqlite3_extended_result_codes(sqlite3*, int onoff);", "", "/*", "** CAPI3REF: Last Insert Rowid", "**", "** ^Each entry in an SQLite table has a unique 64-bit signed", '** integer key called the [ROWID | "rowid"]. ^The rowid is always available', "** as an undeclared column named ROWID, OID, or _ROWID_ as long as those", "** names are not also used by explicitly declared columns. ^If", "** the table has a column of type [INTEGER PRIMARY KEY] then that column", "** is another alias for the rowid.", "**", "** ^This routine returns the [rowid] of the most recent", "** successful [INSERT] into the database from the [database connection]", "** in the first argument.  ^As of SQLite version 3.7.7, this routines", "** records the last insert rowid of both ordinary tables and [virtual tables].", "** ^If no successful [INSERT]s", "** have ever occurred on that database connection, zero is returned.", "**", "** ^(If an [INSERT] occurs within a trigger or within a [virtual table]", "** method, then this routine will return the [rowid] of the inserted", "** row as long as the trigger or virtual table method is running.", "** But once the trigger or virtual table method ends, the value returned ", "** by this routine reverts to what it was before the trigger or virtual", "** table method began.)^", "**", "** ^An [INSERT] that fails due to a constraint violation is not a", "** successful [INSERT] and does not change the value returned by this", "** routine.  ^Thus INSERT OR FAIL, INSERT OR IGNORE, INSERT OR ROLLBACK,", "** and INSERT OR ABORT make no changes to the return value of this", "** routine when their insertion fails.  ^(When INSERT OR REPLACE", "** encounters a constraint violation, it does not fail.  The", "** INSERT continues to completion after deleting rows that caused", "** the constraint problem so INSERT OR REPLACE will always change", "** the return value of this interface.)^", "**", "** ^For the purposes of this routine, an [INSERT] is considered to", "** be successful even if it is subsequently rolled back.", "**", "** This function is accessible to SQL statements via the", "** [last_insert_rowid() SQL function].", "**", "** If a separate thread performs a new [INSERT] on the same", "** database connection while the [sqlite3_last_insert_rowid()]", "** function is running and thus changes the last insert [rowid],", "** then the value returned by [sqlite3_last_insert_rowid()] is", "** unpredictable and might not equal either the old or the new", "** last insert [rowid].", "*/", "SQLITE_API sqlite3_int64 sqlite3_last_insert_rowid(sqlite3*);", "", "/*", "** CAPI3REF: Count The Number Of Rows Modified", "**", "** ^This function returns the number of database rows that were changed", "** or inserted or deleted by the most recently completed SQL statement", "** on the [database connection] specified by the first parameter.", "** ^(Only changes that are directly specified by the [INSERT], [UPDATE],", "** or [DELETE] statement are counted.  Auxiliary changes caused by", "** triggers or [foreign key actions] are not counted.)^ Use the", "** [sqlite3_total_changes()] function to find the total number of changes", "** including changes caused by triggers and foreign key actions.", "**", "** ^Changes to a view that are simulated by an [INSTEAD OF trigger]", "** are not counted.  Only real table changes are counted.", "**", '** ^(A "row change" is a change to a single row of a single table', "** caused by an INSERT, DELETE, or UPDATE statement.  Rows that", "** are changed as side effects of [REPLACE] constraint resolution,", "** rollback, ABORT processing, [DROP TABLE], or by any other", "** mechanisms do not count as direct row changes.)^", "**", '** A "trigger context" is a scope of execution that begins and', "** ends with the script of a [CREATE TRIGGER | trigger]. ", "** Most SQL statements are", '** evaluated outside of any trigger.  This is the "top level"', "** trigger context.  If a trigger fires from the top level, a", "** new trigger context is entered for the duration of that one", "** trigger.  Subtriggers create subcontexts for their duration.", "**", "** ^Calling [sqlite3_exec()] or [sqlite3_step()] recursively does", "** not create a new trigger context.", "**", "** ^This function returns the number of direct row changes in the", "** most recent INSERT, UPDATE, or DELETE statement within the same", "** trigger context.", "**", "** ^Thus, when called from the top level, this function returns the", "** number of changes in the most recent INSERT, UPDATE, or DELETE", "** that also occurred at the top level.  ^(Within the body of a trigger,", "** the sqlite3_changes() interface can be called to find the number of", "** changes in the most recently completed INSERT, UPDATE, or DELETE", "** statement within the body of the same trigger.", "** However, the number returned does not include changes", "** caused by subtriggers since those have their own context.)^", "**", "** See also the [sqlite3_total_changes()] interface, the", "** [count_changes pragma], and the [changes() SQL function].", "**", "** If a separate thread makes changes on the same database connection", "** while [sqlite3_changes()] is running then the value returned", "** is unpredictable and not meaningful.", "*/", "SQLITE_API int sqlite3_changes(sqlite3*);", "", "/*", "** CAPI3REF: Total Number Of Rows Modified", "**", "** ^This function returns the number of row changes caused by [INSERT],", "** [UPDATE] or [DELETE] statements since the [database connection] was opened.", "** ^(The count returned by sqlite3_total_changes() includes all changes", "** from all [CREATE TRIGGER | trigger] contexts and changes made by", "** [foreign key actions]. However,", "** the count does not include changes used to implement [REPLACE] constraints,", "** do rollbacks or ABORT processing, or [DROP TABLE] processing.  The", "** count does not include rows of views that fire an [INSTEAD OF trigger],", "** though if the INSTEAD OF trigger makes changes of its own, those changes ", "** are counted.)^", "** ^The sqlite3_total_changes() function counts the changes as soon as", "** the statement that makes them is completed (when the statement handle", "** is passed to [sqlite3_reset()] or [sqlite3_finalize()]).", "**", "** See also the [sqlite3_changes()] interface, the", "** [count_changes pragma], and the [total_changes() SQL function].", "**", "** If a separate thread makes changes on the same database connection", "** while [sqlite3_total_changes()] is running then the value", "** returned is unpredictable and not meaningful.", "*/", "SQLITE_API int sqlite3_total_changes(sqlite3*);", "", "/*", "** CAPI3REF: Interrupt A Long-Running Query", "**", "** ^This function causes any pending database operation to abort and", "** return at its earliest opportunity. This routine is typically", '** called in response to a user action such as pressing "Cancel"', "** or Ctrl-C where the user wants a long query operation to halt", "** immediately.", "**", "** ^It is safe to call this routine from a thread different from the", "** thread that is currently running the database operation.  But it", "** is not safe to call this routine with a [database connection] that", "** is closed or might close before sqlite3_interrupt() returns.", "**", "** ^If an SQL operation is very nearly finished at the time when", "** sqlite3_interrupt() is called, then it might not have an opportunity", "** to be interrupted and might continue to completion.", "**", "** ^An SQL operation that is interrupted will return [SQLITE_INTERRUPT].", "** ^If the interrupted SQL operation is an INSERT, UPDATE, or DELETE", "** that is inside an explicit transaction, then the entire transaction", "** will be rolled back automatically.", "**", "** ^The sqlite3_interrupt(D) call is in effect until all currently running", "** SQL statements on [database connection] D complete.  ^Any new SQL statements", "** that are started after the sqlite3_interrupt() call and before the ", "** running statements reaches zero are interrupted as if they had been", "** running prior to the sqlite3_interrupt() call.  ^New SQL statements", "** that are started after the running statement count reaches zero are", "** not effected by the sqlite3_interrupt().", "** ^A call to sqlite3_interrupt(D) that occurs when there are no running", "** SQL statements is a no-op and has no effect on SQL statements", "** that are started after the sqlite3_interrupt() call returns.", "**", "** If the database connection closes while [sqlite3_interrupt()]", "** is running then bad things will likely happen.", "*/", "SQLITE_API void sqlite3_interrupt(sqlite3*);", "", "/*", "** CAPI3REF: Determine If An SQL Statement Is Complete", "**", "** These routines are useful during command-line input to determine if the", "** currently entered text seems to form a complete SQL statement or", "** if additional input is needed before sending the text into", "** SQLite for parsing.  ^These routines return 1 if the input string", "** appears to be a complete SQL statement.  ^A statement is judged to be", "** complete if it ends with a semicolon token and is not a prefix of a", "** well-formed CREATE TRIGGER statement.  ^Semicolons that are embedded within", "** string literals or quoted identifier names or comments are not", "** independent tokens (they are part of the token in which they are", "** embedded) and thus do not count as a statement terminator.  ^Whitespace", "** and comments that follow the final semicolon are ignored.", "**", "** ^These routines return 0 if the statement is incomplete.  ^If a", "** memory allocation fails, then SQLITE_NOMEM is returned.", "**", "** ^These routines do not parse the SQL statements thus", "** will not detect syntactically incorrect SQL.", "**", "** ^(If SQLite has not been initialized using [sqlite3_initialize()] prior ", "** to invoking sqlite3_complete16() then sqlite3_initialize() is invoked", "** automatically by sqlite3_complete16().  If that initialization fails,", "** then the return value from sqlite3_complete16() will be non-zero", "** regardless of whether or not the input SQL is complete.)^", "**", "** The input to [sqlite3_complete()] must be a zero-terminated", "** UTF-8 string.", "**", "** The input to [sqlite3_complete16()] must be a zero-terminated", "** UTF-16 string in native byte order.", "*/", "SQLITE_API int sqlite3_complete(const char *sql);", "SQLITE_API int sqlite3_complete16(const void *sql);", "", "/*", "** CAPI3REF: Register A Callback To Handle SQLITE_BUSY Errors", "**", "** ^This routine sets a callback function that might be invoked whenever", "** an attempt is made to open a database table that another thread", "** or process has locked.", "**", "** ^If the busy callback is NULL, then [SQLITE_BUSY] or [SQLITE_IOERR_BLOCKED]", "** is returned immediately upon encountering the lock.  ^If the busy callback", "** is not NULL, then the callback might be invoked with two arguments.", "**", "** ^The first argument to the busy handler is a copy of the void* pointer which", "** is the third argument to sqlite3_busy_handler().  ^The second argument to", "** the busy handler callback is the number of times that the busy handler has", "** been invoked for this locking event.  ^If the", "** busy callback returns 0, then no additional attempts are made to", "** access the database and [SQLITE_BUSY] or [SQLITE_IOERR_BLOCKED] is returned.", "** ^If the callback returns non-zero, then another attempt", "** is made to open the database for reading and the cycle repeats.", "**", "** The presence of a busy handler does not guarantee that it will be invoked", "** when there is lock contention. ^If SQLite determines that invoking the busy", "** handler could result in a deadlock, it will go ahead and return [SQLITE_BUSY]", "** or [SQLITE_IOERR_BLOCKED] instead of invoking the busy handler.", "** Consider a scenario where one process is holding a read lock that", "** it is trying to promote to a reserved lock and", "** a second process is holding a reserved lock that it is trying", "** to promote to an exclusive lock.  The first process cannot proceed", "** because it is blocked by the second and the second process cannot", "** proceed because it is blocked by the first.  If both processes", "** invoke the busy handlers, neither will make any progress.  Therefore,", "** SQLite returns [SQLITE_BUSY] for the first process, hoping that this", "** will induce the first process to release its read lock and allow", "** the second process to proceed.", "**", "** ^The default busy callback is NULL.", "**", "** ^The [SQLITE_BUSY] error is converted to [SQLITE_IOERR_BLOCKED]", "** when SQLite is in the middle of a large transaction where all the", "** changes will not fit into the in-memory cache.  SQLite will", "** already hold a RESERVED lock on the database file, but it needs", "** to promote this lock to EXCLUSIVE so that it can spill cache", "** pages into the database file without harm to concurrent", "** readers.  ^If it is unable to promote the lock, then the in-memory", "** cache will be left in an inconsistent state and so the error", "** code is promoted from the relatively benign [SQLITE_BUSY] to", "** the more severe [SQLITE_IOERR_BLOCKED].  ^This error code promotion", "** forces an automatic rollback of the changes.  See the", '** <a href="/cvstrac/wiki?p=CorruptionFollowingBusyError">', "** CorruptionFollowingBusyError</a> wiki page for a discussion of why", "** this is important.", "**", "** ^(There can only be a single busy handler defined for each", "** [database connection].  Setting a new busy handler clears any", "** previously set handler.)^  ^Note that calling [sqlite3_busy_timeout()]", "** will also set or clear the busy handler.", "**", "** The busy callback should not take any actions which modify the", "** database connection that invoked the busy handler.  Any such actions", "** result in undefined behavior.", "** ", "** A busy handler must not close the database connection", "** or [prepared statement] that invoked the busy handler.", "*/", "SQLITE_API int sqlite3_busy_handler(sqlite3*, int(*)(void*,int), void*);", "", "/*", "** CAPI3REF: Set A Busy Timeout", "**", "** ^This routine sets a [sqlite3_busy_handler | busy handler] that sleeps", "** for a specified amount of time when a table is locked.  ^The handler", '** will sleep multiple times until at least "ms" milliseconds of sleeping', '** have accumulated.  ^After at least "ms" milliseconds of sleeping,', "** the handler returns 0 which causes [sqlite3_step()] to return", "** [SQLITE_BUSY] or [SQLITE_IOERR_BLOCKED].", "**", "** ^Calling this routine with an argument less than or equal to zero", "** turns off all busy handlers.", "**", "** ^(There can only be a single busy handler for a particular", "** [database connection] any any given moment.  If another busy handler", "** was defined  (using [sqlite3_busy_handler()]) prior to calling", "** this routine, that other busy handler is cleared.)^", "*/", "SQLITE_API int sqlite3_busy_timeout(sqlite3*, int ms);", "", "/*", "** CAPI3REF: Convenience Routines For Running Queries", "**", "** This is a legacy interface that is preserved for backwards compatibility.", "** Use of this interface is not recommended.", "**", "** Definition: A <b>result table</b> is memory data structure created by the", "** [sqlite3_get_table()] interface.  A result table records the", "** complete query results from one or more queries.", "**", "** The table conceptually has a number of rows and columns.  But", "** these numbers are not part of the result table itself.  These", "** numbers are obtained separately.  Let N be the number of rows", "** and M be the number of columns.", "**", "** A result table is an array of pointers to zero-terminated UTF-8 strings.", "** There are (N+1)*M elements in the array.  The first M pointers point", "** to zero-terminated strings that  contain the names of the columns.", "** The remaining entries all point to query results.  NULL values result", "** in NULL pointers.  All other values are in their UTF-8 zero-terminated", "** string representation as returned by [sqlite3_column_text()].", "**", "** A result table might consist of one or more memory allocations.", "** It is not safe to pass a result table directly to [sqlite3_free()].", "** A result table should be deallocated using [sqlite3_free_table()].", "**", "** ^(As an example of the result table format, suppose a query result", "** is as follows:", "**", "** <blockquote><pre>", "**        Name        | Age", "**        -----------------------", "**        Alice       | 43", "**        Bob         | 28", "**        Cindy       | 21", "** </pre></blockquote>", "**", "** There are two column (M==2) and three rows (N==3).  Thus the", "** result table has 8 entries.  Suppose the result table is stored", "** in an array names azResult.  Then azResult holds this content:", "**", "** <blockquote><pre>", '**        azResult&#91;0] = "Name";', '**        azResult&#91;1] = "Age";', '**        azResult&#91;2] = "Alice";', '**        azResult&#91;3] = "43";', '**        azResult&#91;4] = "Bob";', '**        azResult&#91;5] = "28";', '**        azResult&#91;6] = "Cindy";', '**        azResult&#91;7] = "21";', "** </pre></blockquote>)^", "**", "** ^The sqlite3_get_table() function evaluates one or more", "** semicolon-separated SQL statements in the zero-terminated UTF-8", "** string of its 2nd parameter and returns a result table to the", "** pointer given in its 3rd parameter.", "**", "** After the application has finished with the result from sqlite3_get_table(),", "** it must pass the result table pointer to sqlite3_free_table() in order to", "** release the memory that was malloced.  Because of the way the", "** [sqlite3_malloc()] happens within sqlite3_get_table(), the calling", "** function must not try to call [sqlite3_free()] directly.  Only", "** [sqlite3_free_table()] is able to release the memory properly and safely.", "**", "** The sqlite3_get_table() interface is implemented as a wrapper around", "** [sqlite3_exec()].  The sqlite3_get_table() routine does not have access", "** to any internal data structures of SQLite.  It uses only the public", "** interface defined here.  As a consequence, errors that occur in the", "** wrapper layer outside of the internal [sqlite3_exec()] call are not", "** reflected in subsequent calls to [sqlite3_errcode()] or", "** [sqlite3_errmsg()].", "*/", "SQLITE_API int sqlite3_get_table(", "  sqlite3 *db,          /* An open database */", "  const char *zSql,     /* SQL to be evaluated */", "  char ***pazResult,    /* Results of the query */", "  int *pnRow,           /* Number of result rows written here */", "  int *pnColumn,        /* Number of result columns written here */", "  char **pzErrmsg       /* Error msg written here */", ");", "SQLITE_API void sqlite3_free_table(char **result);", "", "/*", "** CAPI3REF: Formatted String Printing Functions", "**", '** These routines are work-alikes of the "printf()" family of functions', "** from the standard C library.", "**", "** ^The sqlite3_mprintf() and sqlite3_vmprintf() routines write their", "** results into memory obtained from [sqlite3_malloc()].", "** The strings returned by these two routines should be", "** released by [sqlite3_free()].  ^Both routines return a", "** NULL pointer if [sqlite3_malloc()] is unable to allocate enough", "** memory to hold the resulting string.", "**", '** ^(The sqlite3_snprintf() routine is similar to "snprintf()" from', "** the standard C library.  The result is written into the", "** buffer supplied as the second parameter whose size is given by", "** the first parameter. Note that the order of the", "** first two parameters is reversed from snprintf().)^  This is an", "** historical accident that cannot be fixed without breaking", "** backwards compatibility.  ^(Note also that sqlite3_snprintf()", "** returns a pointer to its buffer instead of the number of", "** characters actually written into the buffer.)^  We admit that", "** the number of characters written would be a more useful return", "** value but we cannot change the implementation of sqlite3_snprintf()", "** now without breaking compatibility.", "**", "** ^As long as the buffer size is greater than zero, sqlite3_snprintf()", "** guarantees that the buffer is always zero-terminated.  ^The first", '** parameter "n" is the total size of the buffer, including space for', "** the zero terminator.  So the longest string that can be completely", "** written will be n-1 characters.", "**", "** ^The sqlite3_vsnprintf() routine is a varargs version of sqlite3_snprintf().", "**", "** These routines all implement some additional formatting", "** options that are useful for constructing SQL statements.", "** All of the usual printf() formatting options apply.  In addition, there", '** is are "%q", "%Q", and "%z" options.', "**", "** ^(The %q option works like %s in that it substitutes a nul-terminated", "** string from the argument list.  But %q also doubles every '\\'' character.", "** %q is designed for use inside a string literal.)^  By doubling each '\\''", "** character it escapes that character and allows it to be inserted into", "** the string.", "**", "** For example, assume the string variable zText contains text as follows:", "**", "** <blockquote><pre>", "**  char *zText = \"It's a happy day!\";", "** </pre></blockquote>", "**", "** One can use this text in an SQL statement as follows:", "**", "** <blockquote><pre>", "**  char *zSQL = sqlite3_mprintf(\"INSERT INTO table VALUES('%q')\", zText);", "**  sqlite3_exec(db, zSQL, 0, 0, 0);", "**  sqlite3_free(zSQL);", "** </pre></blockquote>", "**", "** Because the %q format string is used, the '\\'' character in zText", "** is escaped and the SQL generated is as follows:", "**", "** <blockquote><pre>", "**  INSERT INTO table1 VALUES('It''s a happy day!')", "** </pre></blockquote>", "**", "** This is correct.  Had we used %s instead of %q, the generated SQL", "** would have looked like this:", "**", "** <blockquote><pre>", "**  INSERT INTO table1 VALUES('It's a happy day!');", "** </pre></blockquote>", "**", "** This second example is an SQL syntax error.  As a general rule you should", "** always use %q instead of %s when inserting text into a string literal.", "**", "** ^(The %Q option works like %q except it also adds single quotes around", "** the outside of the total string.  Additionally, if the parameter in the", '** argument list is a NULL pointer, %Q substitutes the text "NULL" (without', "** single quotes).)^  So, for example, one could say:", "**", "** <blockquote><pre>", '**  char *zSQL = sqlite3_mprintf("INSERT INTO table VALUES(%Q)", zText);', "**  sqlite3_exec(db, zSQL, 0, 0, 0);", "**  sqlite3_free(zSQL);", "** </pre></blockquote>", "**", "** The code above will render a correct SQL statement in the zSQL", "** variable even if the zText variable is a NULL pointer.", "**", '** ^(The "%z" formatting option works like "%s" but with the', "** addition that after the string has been read and copied into", "** the result, [sqlite3_free()] is called on the input string.)^", "*/", "SQLITE_API char *sqlite3_mprintf(const char*,...);", "SQLITE_API char *sqlite3_vmprintf(const char*, va_list);", "SQLITE_API char *sqlite3_snprintf(int,char*,const char*, ...);", "SQLITE_API char *sqlite3_vsnprintf(int,char*,const char*, va_list);", "", "/*", "** CAPI3REF: Memory Allocation Subsystem", "**", "** The SQLite core uses these three routines for all of its own", '** internal memory allocation needs. "Core" in the previous sentence', "** does not include operating-system specific VFS implementation.  The", "** Windows VFS uses native malloc() and free() for some operations.", "**", "** ^The sqlite3_malloc() routine returns a pointer to a block", "** of memory at least N bytes in length, where N is the parameter.", "** ^If sqlite3_malloc() is unable to obtain sufficient free", "** memory, it returns a NULL pointer.  ^If the parameter N to", "** sqlite3_malloc() is zero or negative then sqlite3_malloc() returns", "** a NULL pointer.", "**", "** ^Calling sqlite3_free() with a pointer previously returned", "** by sqlite3_malloc() or sqlite3_realloc() releases that memory so", "** that it might be reused.  ^The sqlite3_free() routine is", "** a no-op if is called with a NULL pointer.  Passing a NULL pointer", "** to sqlite3_free() is harmless.  After being freed, memory", "** should neither be read nor written.  Even reading previously freed", "** memory might result in a segmentation fault or other severe error.", "** Memory corruption, a segmentation fault, or other severe error", "** might result if sqlite3_free() is called with a non-NULL pointer that", "** was not obtained from sqlite3_malloc() or sqlite3_realloc().", "**", "** ^(The sqlite3_realloc() interface attempts to resize a", "** prior memory allocation to be at least N bytes, where N is the", "** second parameter.  The memory allocation to be resized is the first", "** parameter.)^ ^ If the first parameter to sqlite3_realloc()", "** is a NULL pointer then its behavior is identical to calling", "** sqlite3_malloc(N) where N is the second parameter to sqlite3_realloc().", "** ^If the second parameter to sqlite3_realloc() is zero or", "** negative then the behavior is exactly the same as calling", "** sqlite3_free(P) where P is the first parameter to sqlite3_realloc().", "** ^sqlite3_realloc() returns a pointer to a memory allocation", "** of at least N bytes in size or NULL if sufficient memory is unavailable.", "** ^If M is the size of the prior allocation, then min(N,M) bytes", "** of the prior allocation are copied into the beginning of buffer returned", "** by sqlite3_realloc() and the prior allocation is freed.", "** ^If sqlite3_realloc() returns NULL, then the prior allocation", "** is not freed.", "**", "** ^The memory returned by sqlite3_malloc() and sqlite3_realloc()", "** is always aligned to at least an 8 byte boundary, or to a", "** 4 byte boundary if the [SQLITE_4_BYTE_ALIGNED_MALLOC] compile-time", "** option is used.", "**", "** In SQLite version 3.5.0 and 3.5.1, it was possible to define", "** the SQLITE_OMIT_MEMORY_ALLOCATION which would cause the built-in", "** implementation of these routines to be omitted.  That capability", "** is no longer provided.  Only built-in memory allocators can be used.", "**", "** Prior to SQLite version 3.7.10, the Windows OS interface layer called", "** the system malloc() and free() directly when converting", "** filenames between the UTF-8 encoding used by SQLite", "** and whatever filename encoding is used by the particular Windows", "** installation.  Memory allocation errors were detected, but", "** they were reported back as [SQLITE_CANTOPEN] or", "** [SQLITE_IOERR] rather than [SQLITE_NOMEM].", "**", "** The pointer arguments to [sqlite3_free()] and [sqlite3_realloc()]", "** must be either NULL or else pointers obtained from a prior", "** invocation of [sqlite3_malloc()] or [sqlite3_realloc()] that have", "** not yet been released.", "**", "** The application must not read or write any part of", "** a block of memory after it has been released using", "** [sqlite3_free()] or [sqlite3_realloc()].", "*/", "SQLITE_API void *sqlite3_malloc(int);", "SQLITE_API void *sqlite3_realloc(void*, int);", "SQLITE_API void sqlite3_free(void*);", "", "/*", "** CAPI3REF: Memory Allocator Statistics", "**", "** SQLite provides these two interfaces for reporting on the status", "** of the [sqlite3_malloc()], [sqlite3_free()], and [sqlite3_realloc()]", "** routines, which form the built-in memory allocation subsystem.", "**", "** ^The [sqlite3_memory_used()] routine returns the number of bytes", "** of memory currently outstanding (malloced but not freed).", "** ^The [sqlite3_memory_highwater()] routine returns the maximum", "** value of [sqlite3_memory_used()] since the high-water mark", "** was last reset.  ^The values returned by [sqlite3_memory_used()] and", "** [sqlite3_memory_highwater()] include any overhead", "** added by SQLite in its implementation of [sqlite3_malloc()],", "** but not overhead added by the any underlying system library", "** routines that [sqlite3_malloc()] may call.", "**", "** ^The memory high-water mark is reset to the current value of", "** [sqlite3_memory_used()] if and only if the parameter to", "** [sqlite3_memory_highwater()] is true.  ^The value returned", "** by [sqlite3_memory_highwater(1)] is the high-water mark", "** prior to the reset.", "*/", "SQLITE_API sqlite3_int64 sqlite3_memory_used(void);", "SQLITE_API sqlite3_int64 sqlite3_memory_highwater(int resetFlag);", "", "/*", "** CAPI3REF: Pseudo-Random Number Generator", "**", "** SQLite contains a high-quality pseudo-random number generator (PRNG) used to", "** select random [ROWID | ROWIDs] when inserting new records into a table that", "** already uses the largest possible [ROWID].  The PRNG is also used for", "** the build-in random() and randomblob() SQL functions.  This interface allows", "** applications to access the same PRNG for other purposes.", "**", "** ^A call to this routine stores N bytes of randomness into buffer P.", "**", "** ^The first time this routine is invoked (either internally or by", "** the application) the PRNG is seeded using randomness obtained", "** from the xRandomness method of the default [sqlite3_vfs] object.", "** ^On all subsequent invocations, the pseudo-randomness is generated", "** internally and without recourse to the [sqlite3_vfs] xRandomness", "** method.", "*/", "SQLITE_API void sqlite3_randomness(int N, void *P);", "", "/*", "** CAPI3REF: Compile-Time Authorization Callbacks", "**", "** ^This routine registers an authorizer callback with a particular", "** [database connection], supplied in the first argument.", "** ^The authorizer callback is invoked as SQL statements are being compiled", "** by [sqlite3_prepare()] or its variants [sqlite3_prepare_v2()],", "** [sqlite3_prepare16()] and [sqlite3_prepare16_v2()].  ^At various", "** points during the compilation process, as logic is being created", "** to perform various actions, the authorizer callback is invoked to", "** see if those actions are allowed.  ^The authorizer callback should", "** return [SQLITE_OK] to allow the action, [SQLITE_IGNORE] to disallow the", "** specific action but allow the SQL statement to continue to be", "** compiled, or [SQLITE_DENY] to cause the entire SQL statement to be", "** rejected with an error.  ^If the authorizer callback returns", "** any value other than [SQLITE_IGNORE], [SQLITE_OK], or [SQLITE_DENY]", "** then the [sqlite3_prepare_v2()] or equivalent call that triggered", "** the authorizer will fail with an error message.", "**", "** When the callback returns [SQLITE_OK], that means the operation", "** requested is ok.  ^When the callback returns [SQLITE_DENY], the", "** [sqlite3_prepare_v2()] or equivalent call that triggered the", "** authorizer will fail with an error message explaining that", "** access is denied. ", "**", "** ^The first parameter to the authorizer callback is a copy of the third", "** parameter to the sqlite3_set_authorizer() interface. ^The second parameter", "** to the callback is an integer [SQLITE_COPY | action code] that specifies", "** the particular action to be authorized. ^The third through sixth parameters", "** to the callback are zero-terminated strings that contain additional", "** details about the action to be authorized.", "**", "** ^If the action code is [SQLITE_READ]", "** and the callback returns [SQLITE_IGNORE] then the", "** [prepared statement] statement is constructed to substitute", "** a NULL value in place of the table column that would have", "** been read if [SQLITE_OK] had been returned.  The [SQLITE_IGNORE]", "** return can be used to deny an untrusted user access to individual", "** columns of a table.", "** ^If the action code is [SQLITE_DELETE] and the callback returns", "** [SQLITE_IGNORE] then the [DELETE] operation proceeds but the", "** [truncate optimization] is disabled and all rows are deleted individually.", "**", "** An authorizer is used when [sqlite3_prepare | preparing]", "** SQL statements from an untrusted source, to ensure that the SQL statements", "** do not try to access data they are not allowed to see, or that they do not", "** try to execute malicious statements that damage the database.  For", "** example, an application may allow a user to enter arbitrary", "** SQL queries for evaluation by a database.  But the application does", "** not want the user to be able to make arbitrary changes to the", "** database.  An authorizer could then be put in place while the", "** user-entered SQL is being [sqlite3_prepare | prepared] that", "** disallows everything except [SELECT] statements.", "**", "** Applications that need to process SQL from untrusted sources", "** might also consider lowering resource limits using [sqlite3_limit()]", "** and limiting database size using the [max_page_count] [PRAGMA]", "** in addition to using an authorizer.", "**", "** ^(Only a single authorizer can be in place on a database connection", "** at a time.  Each call to sqlite3_set_authorizer overrides the", "** previous call.)^  ^Disable the authorizer by installing a NULL callback.", "** The authorizer is disabled by default.", "**", "** The authorizer callback must not do anything that will modify", "** the database connection that invoked the authorizer callback.", "** Note that [sqlite3_prepare_v2()] and [sqlite3_step()] both modify their", '** database connections for the meaning of "modify" in this paragraph.', "**", "** ^When [sqlite3_prepare_v2()] is used to prepare a statement, the", "** statement might be re-prepared during [sqlite3_step()] due to a ", "** schema change.  Hence, the application should ensure that the", "** correct authorizer callback remains in place during the [sqlite3_step()].", "**", "** ^Note that the authorizer callback is invoked only during", "** [sqlite3_prepare()] or its variants.  Authorization is not", "** performed during statement evaluation in [sqlite3_step()], unless", "** as stated in the previous paragraph, sqlite3_step() invokes", "** sqlite3_prepare_v2() to reprepare a statement after a schema change.", "*/", "SQLITE_API int sqlite3_set_authorizer(", "  sqlite3*,", "  int (*xAuth)(void*,int,const char*,const char*,const char*,const char*),", "  void *pUserData", ");", "", "/*", "** CAPI3REF: Authorizer Return Codes", "**", "** The [sqlite3_set_authorizer | authorizer callback function] must", "** return either [SQLITE_OK] or one of these two constants in order", "** to signal SQLite whether or not the action is permitted.  See the", "** [sqlite3_set_authorizer | authorizer documentation] for additional", "** information.", "**", "** Note that SQLITE_IGNORE is also used as a [SQLITE_ROLLBACK | return code]", "** from the [sqlite3_vtab_on_conflict()] interface.", "*/", "#define SQLITE_DENY   1   /* Abort the SQL statement with an error */", "#define SQLITE_IGNORE 2   /* Don't allow access, but don't generate an error */", "", "/*", "** CAPI3REF: Authorizer Action Codes", "**", "** The [sqlite3_set_authorizer()] interface registers a callback function", "** that is invoked to authorize certain SQL statement actions.  The", "** second parameter to the callback is an integer code that specifies", "** what action is being authorized.  These are the integer action codes that", "** the authorizer callback may be passed.", "**", "** These action code values signify what kind of operation is to be", "** authorized.  The 3rd and 4th parameters to the authorization", "** callback function will be parameters or NULL depending on which of these", "** codes is used as the second parameter.  ^(The 5th parameter to the", '** authorizer callback is the name of the database ("main", "temp",', "** etc.) if applicable.)^  ^The 6th parameter to the authorizer callback", "** is the name of the inner-most trigger or view that is responsible for", "** the access attempt or NULL if this access attempt is directly from", "** top-level SQL code.", "*/", "/******************************************* 3rd ************ 4th ***********/", "#define SQLITE_CREATE_INDEX          1   /* Index Name      Table Name      */", "#define SQLITE_CREATE_TABLE          2   /* Table Name      NULL            */", "#define SQLITE_CREATE_TEMP_INDEX     3   /* Index Name      Table Name      */", "#define SQLITE_CREATE_TEMP_TABLE     4   /* Table Name      NULL            */", "#define SQLITE_CREATE_TEMP_TRIGGER   5   /* Trigger Name    Table Name      */", "#define SQLITE_CREATE_TEMP_VIEW      6   /* View Name       NULL            */", "#define SQLITE_CREATE_TRIGGER        7   /* Trigger Name    Table Name      */", "#define SQLITE_CREATE_VIEW           8   /* View Name       NULL            */", "#define SQLITE_DELETE                9   /* Table Name      NULL            */", "#define SQLITE_DROP_INDEX           10   /* Index Name      Table Name      */", "#define SQLITE_DROP_TABLE           11   /* Table Name      NULL            */", "#define SQLITE_DROP_TEMP_INDEX      12   /* Index Name      Table Name      */", "#define SQLITE_DROP_TEMP_TABLE      13   /* Table Name      NULL            */", "#define SQLITE_DROP_TEMP_TRIGGER    14   /* Trigger Name    Table Name      */", "#define SQLITE_DROP_TEMP_VIEW       15   /* View Name       NULL            */", "#define SQLITE_DROP_TRIGGER         16   /* Trigger Name    Table Name      */", "#define SQLITE_DROP_VIEW            17   /* View Name       NULL            */", "#define SQLITE_INSERT               18   /* Table Name      NULL            */", "#define SQLITE_PRAGMA               19   /* Pragma Name     1st arg or NULL */", "#define SQLITE_READ                 20   /* Table Name      Column Name     */", "#define SQLITE_SELECT               21   /* NULL            NULL            */", "#define SQLITE_TRANSACTION          22   /* Operation       NULL            */", "#define SQLITE_UPDATE               23   /* Table Name      Column Name     */", "#define SQLITE_ATTACH               24   /* Filename        NULL            */", "#define SQLITE_DETACH               25   /* Database Name   NULL            */", "#define SQLITE_ALTER_TABLE          26   /* Database Name   Table Name      */", "#define SQLITE_REINDEX              27   /* Index Name      NULL            */", "#define SQLITE_ANALYZE              28   /* Table Name      NULL            */", "#define SQLITE_CREATE_VTABLE        29   /* Table Name      Module Name     */", "#define SQLITE_DROP_VTABLE          30   /* Table Name      Module Name     */", "#define SQLITE_FUNCTION             31   /* NULL            Function Name   */", "#define SQLITE_SAVEPOINT            32   /* Operation       Savepoint Name  */", "#define SQLITE_COPY                  0   /* No longer used */", "", "/*", "** CAPI3REF: Tracing And Profiling Functions", "**", "** These routines register callback functions that can be used for", "** tracing and profiling the execution of SQL statements.", "**", "** ^The callback function registered by sqlite3_trace() is invoked at", "** various times when an SQL statement is being run by [sqlite3_step()].", "** ^The sqlite3_trace() callback is invoked with a UTF-8 rendering of the", "** SQL statement text as the statement first begins executing.", "** ^(Additional sqlite3_trace() callbacks might occur", "** as each triggered subprogram is entered.  The callbacks for triggers", "** contain a UTF-8 SQL comment that identifies the trigger.)^", "**", "** ^The callback function registered by sqlite3_profile() is invoked", "** as each SQL statement finishes.  ^The profile callback contains", "** the original statement text and an estimate of wall-clock time", "** of how long that statement took to run.  ^The profile callback", "** time is in units of nanoseconds, however the current implementation", "** is only capable of millisecond resolution so the six least significant", "** digits in the time are meaningless.  Future versions of SQLite", "** might provide greater resolution on the profiler callback.  The", "** sqlite3_profile() function is considered experimental and is", "** subject to change in future versions of SQLite.", "*/", "SQLITE_API void *sqlite3_trace(sqlite3*, void(*xTrace)(void*,const char*), void*);", "SQLITE_API SQLITE_EXPERIMENTAL void *sqlite3_profile(sqlite3*,", "   void(*xProfile)(void*,const char*,sqlite3_uint64), void*);", "", "/*", "** CAPI3REF: Query Progress Callbacks", "**", "** ^The sqlite3_progress_handler(D,N,X,P) interface causes the callback", "** function X to be invoked periodically during long running calls to", "** [sqlite3_exec()], [sqlite3_step()] and [sqlite3_get_table()] for", "** database connection D.  An example use for this", "** interface is to keep a GUI updated during a large query.", "**", "** ^The parameter P is passed through as the only parameter to the ", "** callback function X.  ^The parameter N is the number of ", "** [virtual machine instructions] that are evaluated between successive", "** invocations of the callback X.", "**", "** ^Only a single progress handler may be defined at one time per", "** [database connection]; setting a new progress handler cancels the", "** old one.  ^Setting parameter X to NULL disables the progress handler.", "** ^The progress handler is also disabled by setting N to a value less", "** than 1.", "**", "** ^If the progress callback returns non-zero, the operation is", "** interrupted.  This feature can be used to implement a", '** "Cancel" button on a GUI progress dialog box.', "**", "** The progress handler callback must not do anything that will modify", "** the database connection that invoked the progress handler.", "** Note that [sqlite3_prepare_v2()] and [sqlite3_step()] both modify their", '** database connections for the meaning of "modify" in this paragraph.', "**", "*/", "SQLITE_API void sqlite3_progress_handler(sqlite3*, int, int(*)(void*), void*);", "", "/*", "** CAPI3REF: Opening A New Database Connection", "**", "** ^These routines open an SQLite database file as specified by the ", "** filename argument. ^The filename argument is interpreted as UTF-8 for", "** sqlite3_open() and sqlite3_open_v2() and as UTF-16 in the native byte", "** order for sqlite3_open16(). ^(A [database connection] handle is usually", "** returned in *ppDb, even if an error occurs.  The only exception is that", "** if SQLite is unable to allocate memory to hold the [sqlite3] object,", "** a NULL will be written into *ppDb instead of a pointer to the [sqlite3]", "** object.)^ ^(If the database is opened (and/or created) successfully, then", "** [SQLITE_OK] is returned.  Otherwise an [error code] is returned.)^ ^The", "** [sqlite3_errmsg()] or [sqlite3_errmsg16()] routines can be used to obtain", "** an English language description of the error following a failure of any", "** of the sqlite3_open() routines.", "**", "** ^The default encoding for the database will be UTF-8 if", "** sqlite3_open() or sqlite3_open_v2() is called and", "** UTF-16 in the native byte order if sqlite3_open16() is used.", "**", "** Whether or not an error occurs when it is opened, resources", "** associated with the [database connection] handle should be released by", "** passing it to [sqlite3_close()] when it is no longer required.", "**", "** The sqlite3_open_v2() interface works like sqlite3_open()", "** except that it accepts two additional parameters for additional control", "** over the new database connection.  ^(The flags parameter to", "** sqlite3_open_v2() can take one of", "** the following three values, optionally combined with the ", "** [SQLITE_OPEN_NOMUTEX], [SQLITE_OPEN_FULLMUTEX], [SQLITE_OPEN_SHAREDCACHE],", "** [SQLITE_OPEN_PRIVATECACHE], and/or [SQLITE_OPEN_URI] flags:)^", "**", "** <dl>", "** ^(<dt>[SQLITE_OPEN_READONLY]</dt>", "** <dd>The database is opened in read-only mode.  If the database does not", "** already exist, an error is returned.</dd>)^", "**", "** ^(<dt>[SQLITE_OPEN_READWRITE]</dt>", "** <dd>The database is opened for reading and writing if possible, or reading", "** only if the file is write protected by the operating system.  In either", "** case the database must already exist, otherwise an error is returned.</dd>)^", "**", "** ^(<dt>[SQLITE_OPEN_READWRITE] | [SQLITE_OPEN_CREATE]</dt>", "** <dd>The database is opened for reading and writing, and is created if", "** it does not already exist. This is the behavior that is always used for", "** sqlite3_open() and sqlite3_open16().</dd>)^", "** </dl>", "**", "** If the 3rd parameter to sqlite3_open_v2() is not one of the", "** combinations shown above optionally combined with other", "** [SQLITE_OPEN_READONLY | SQLITE_OPEN_* bits]", "** then the behavior is undefined.", "**", "** ^If the [SQLITE_OPEN_NOMUTEX] flag is set, then the database connection", "** opens in the multi-thread [threading mode] as long as the single-thread", "** mode has not been set at compile-time or start-time.  ^If the", "** [SQLITE_OPEN_FULLMUTEX] flag is set then the database connection opens", "** in the serialized [threading mode] unless single-thread was", "** previously selected at compile-time or start-time.", "** ^The [SQLITE_OPEN_SHAREDCACHE] flag causes the database connection to be", "** eligible to use [shared cache mode], regardless of whether or not shared", "** cache is enabled using [sqlite3_enable_shared_cache()].  ^The", "** [SQLITE_OPEN_PRIVATECACHE] flag causes the database connection to not", "** participate in [shared cache mode] even if it is enabled.", "**", "** ^The fourth parameter to sqlite3_open_v2() is the name of the", "** [sqlite3_vfs] object that defines the operating system interface that", "** the new database connection should use.  ^If the fourth parameter is", "** a NULL pointer then the default [sqlite3_vfs] object is used.", "**", '** ^If the filename is ":memory:", then a private, temporary in-memory database', "** is created for the connection.  ^This in-memory database will vanish when", "** the database connection is closed.  Future versions of SQLite might", '** make use of additional special filenames that begin with the ":" character.', "** It is recommended that when a database filename actually does begin with", '** a ":" character you should prefix the filename with a pathname such as', '** "./" to avoid ambiguity.', "**", "** ^If the filename is an empty string, then a private, temporary", "** on-disk database will be created.  ^This private database will be", "** automatically deleted as soon as the database connection is closed.", "**", "** [[URI filenames in sqlite3_open()]] <h3>URI Filenames</h3>", "**", "** ^If [URI filename] interpretation is enabled, and the filename argument", '** begins with "file:", then the filename is interpreted as a URI. ^URI', "** filename interpretation is enabled if the [SQLITE_OPEN_URI] flag is", "** set in the fourth argument to sqlite3_open_v2(), or if it has", "** been enabled globally using the [SQLITE_CONFIG_URI] option with the", "** [sqlite3_config()] method or by the [SQLITE_USE_URI] compile-time option.", "** As of SQLite version 3.7.7, URI filename interpretation is turned off", "** by default, but future releases of SQLite might enable URI filename", '** interpretation by default.  See "[URI filenames]" for additional', "** information.", "**", "** URI filenames are parsed according to RFC 3986. ^If the URI contains an", "** authority, then it must be either an empty string or the string ", '** "localhost". ^If the authority is not an empty string or "localhost", an ', "** error is returned to the caller. ^The fragment component of a URI, if ", "** present, is ignored.", "**", "** ^SQLite uses the path component of the URI as the name of the disk file", "** which contains the database. ^If the path begins with a '/' character, ", "** then it is interpreted as an absolute path. ^If the path does not begin ", "** with a '/' (meaning that the authority section is omitted from the URI)", "** then the path is interpreted as a relative path. ", "** ^On windows, the first component of an absolute path ", '** is a drive specification (e.g. "C:").', "**", "** [[core URI query parameters]]", "** The query component of a URI may contain parameters that are interpreted", "** either by SQLite itself, or by a [VFS | custom VFS implementation].", "** SQLite interprets the following three query parameters:", "**", "** <ul>", '**   <li> <b>vfs</b>: ^The "vfs" parameter may be used to specify the name of', "**     a VFS object that provides the operating system interface that should", "**     be used to access the database file on disk. ^If this option is set to", "**     an empty string the default VFS object is used. ^Specifying an unknown", "**     VFS is an error. ^If sqlite3_open_v2() is used and the vfs option is", "**     present, then the VFS specified by the option takes precedence over", "**     the value passed as the fourth parameter to sqlite3_open_v2().", "**", '**   <li> <b>mode</b>: ^(The mode parameter may be set to either "ro", "rw",', '**     "rwc", or "memory". Attempting to set it to any other value is', "**     an error)^. ", '**     ^If "ro" is specified, then the database is opened for read-only ', "**     access, just as if the [SQLITE_OPEN_READONLY] flag had been set in the ", "**     third argument to sqlite3_prepare_v2(). ^If the mode option is set to ", '**     "rw", then the database is opened for read-write (but not create) ', "**     access, as if SQLITE_OPEN_READWRITE (but not SQLITE_OPEN_CREATE) had ", '**     been set. ^Value "rwc" is equivalent to setting both ', "**     SQLITE_OPEN_READWRITE and SQLITE_OPEN_CREATE.  ^If the mode option is", '**     set to "memory" then a pure [in-memory database] that never reads', "**     or writes from disk is used. ^It is an error to specify a value for", "**     the mode parameter that is less restrictive than that specified by", "**     the flags passed in the third parameter to sqlite3_open_v2().", "**", '**   <li> <b>cache</b>: ^The cache parameter may be set to either "shared" or', '**     "private". ^Setting it to "shared" is equivalent to setting the', "**     SQLITE_OPEN_SHAREDCACHE bit in the flags argument passed to", '**     sqlite3_open_v2(). ^Setting the cache parameter to "private" is ', "**     equivalent to setting the SQLITE_OPEN_PRIVATECACHE bit.", '**     ^If sqlite3_open_v2() is used and the "cache" parameter is present in', "**     a URI filename, its value overrides any behaviour requested by setting", "**     SQLITE_OPEN_PRIVATECACHE or SQLITE_OPEN_SHAREDCACHE flag.", "** </ul>", "**", "** ^Specifying an unknown parameter in the query component of a URI is not an", "** error.  Future versions of SQLite might understand additional query", '** parameters.  See "[query parameters with special meaning to SQLite]" for', "** additional information.", "**", "** [[URI filename examples]] <h3>URI filename examples</h3>", "**", '** <table border="1" align=center cellpadding=5>', "** <tr><th> URI filenames <th> Results", "** <tr><td> file:data.db <td> ", '**          Open the file "data.db" in the current directory.', "** <tr><td> file:/home/fred/data.db<br>", "**          file:///home/fred/data.db <br> ", "**          file://localhost/home/fred/data.db <br> <td> ", '**          Open the database file "/home/fred/data.db".', "** <tr><td> file://darkstar/home/fred/data.db <td> ", '**          An error. "darkstar" is not a recognized authority.', '** <tr><td style="white-space:nowrap"> ', "**          file:///C:/Documents%20and%20Settings/fred/Desktop/data.db", "**     <td> Windows only: Open the file \"data.db\" on fred's desktop on drive", "**          C:. Note that the %20 escaping in this example is not strictly ", "**          necessary - space characters can be used literally", "**          in URI filenames.", "** <tr><td> file:data.db?mode=ro&cache=private <td> ", '**          Open file "data.db" in the current directory for read-only access.', "**          Regardless of whether or not shared-cache mode is enabled by", "**          default, use a private cache.", "** <tr><td> file:/home/fred/data.db?vfs=unix-nolock <td>", '**          Open file "/home/fred/data.db". Use the special VFS "unix-nolock".', "** <tr><td> file:data.db?mode=readonly <td> ", '**          An error. "readonly" is not a valid option for the "mode" parameter.', "** </table>", "**", "** ^URI hexadecimal escape sequences (%HH) are supported within the path and", "** query components of a URI. A hexadecimal escape sequence consists of a", '** percent sign - "%" - followed by exactly two hexadecimal digits ', "** specifying an octet value. ^Before the path or query components of a", "** URI filename are interpreted, they are encoded using UTF-8 and all ", "** hexadecimal escape sequences replaced by a single byte containing the", "** corresponding octet. If this process generates an invalid UTF-8 encoding,", "** the results are undefined.", "**", "** <b>Note to Windows users:</b>  The encoding used for the filename argument", "** of sqlite3_open() and sqlite3_open_v2() must be UTF-8, not whatever", "** codepage is currently defined.  Filenames containing international", "** characters must be converted to UTF-8 prior to passing them into", "** sqlite3_open() or sqlite3_open_v2().", "*/", "SQLITE_API int sqlite3_open(", "  const char *filename,   /* Database filename (UTF-8) */", "  sqlite3 **ppDb          /* OUT: SQLite db handle */", ");", "SQLITE_API int sqlite3_open16(", "  const void *filename,   /* Database filename (UTF-16) */", "  sqlite3 **ppDb          /* OUT: SQLite db handle */", ");", "SQLITE_API int sqlite3_open_v2(", "  const char *filename,   /* Database filename (UTF-8) */", "  sqlite3 **ppDb,         /* OUT: SQLite db handle */", "  int flags,              /* Flags */", "  const char *zVfs        /* Name of VFS module to use */", ");", "", "/*", "** CAPI3REF: Obtain Values For URI Parameters", "**", "** These are utility routines, useful to VFS implementations, that check", "** to see if a database file was a URI that contained a specific query ", "** parameter, and if so obtains the value of that query parameter.", "**", "** If F is the database filename pointer passed into the xOpen() method of ", "** a VFS implementation when the flags parameter to xOpen() has one or ", "** more of the [SQLITE_OPEN_URI] or [SQLITE_OPEN_MAIN_DB] bits set and", "** P is the name of the query parameter, then", "** sqlite3_uri_parameter(F,P) returns the value of the P", "** parameter if it exists or a NULL pointer if P does not appear as a ", "** query parameter on F.  If P is a query parameter of F", "** has no explicit value, then sqlite3_uri_parameter(F,P) returns", "** a pointer to an empty string.", "**", "** The sqlite3_uri_boolean(F,P,B) routine assumes that P is a boolean", "** parameter and returns true (1) or false (0) according to the value", "** of P.  The sqlite3_uri_boolean(F,P,B) routine returns true (1) if the", '** value of query parameter P is one of "yes", "true", or "on" in any', "** case or if the value begins with a non-zero number.  The ", "** sqlite3_uri_boolean(F,P,B) routines returns false (0) if the value of", '** query parameter P is one of "no", "false", or "off" in any case or', "** if the value begins with a numeric zero.  If P is not a query", "** parameter on F or if the value of P is does not match any of the", "** above, then sqlite3_uri_boolean(F,P,B) returns (B!=0).", "**", "** The sqlite3_uri_int64(F,P,D) routine converts the value of P into a", "** 64-bit signed integer and returns that integer, or D if P does not", "** exist.  If the value of P is something other than an integer, then", "** zero is returned.", "** ", "** If F is a NULL pointer, then sqlite3_uri_parameter(F,P) returns NULL and", "** sqlite3_uri_boolean(F,P,B) returns B.  If F is not a NULL pointer and", "** is not a database file pathname pointer that SQLite passed into the xOpen", "** VFS method, then the behavior of this routine is undefined and probably", "** undesirable.", "*/", "SQLITE_API const char *sqlite3_uri_parameter(const char *zFilename, const char *zParam);", "SQLITE_API int sqlite3_uri_boolean(const char *zFile, const char *zParam, int bDefault);", "SQLITE_API sqlite3_int64 sqlite3_uri_int64(const char*, const char*, sqlite3_int64);", "", "", "/*", "** CAPI3REF: Error Codes And Messages", "**", "** ^The sqlite3_errcode() interface returns the numeric [result code] or", "** [extended result code] for the most recent failed sqlite3_* API call", "** associated with a [database connection]. If a prior API call failed", "** but the most recent API call succeeded, the return value from", "** sqlite3_errcode() is undefined.  ^The sqlite3_extended_errcode()", "** interface is the same except that it always returns the ", "** [extended result code] even when extended result codes are", "** disabled.", "**", "** ^The sqlite3_errmsg() and sqlite3_errmsg16() return English-language", "** text that describes the error, as either UTF-8 or UTF-16 respectively.", "** ^(Memory to hold the error message string is managed internally.", "** The application does not need to worry about freeing the result.", "** However, the error string might be overwritten or deallocated by", "** subsequent calls to other SQLite interface functions.)^", "**", "** When the serialized [threading mode] is in use, it might be the", "** case that a second error occurs on a separate thread in between", "** the time of the first error and the call to these interfaces.", "** When that happens, the second error will be reported since these", "** interfaces always report the most recent result.  To avoid", "** this, each thread can obtain exclusive use of the [database connection] D", "** by invoking [sqlite3_mutex_enter]([sqlite3_db_mutex](D)) before beginning", "** to use D and invoking [sqlite3_mutex_leave]([sqlite3_db_mutex](D)) after", "** all calls to the interfaces listed here are completed.", "**", "** If an interface fails with SQLITE_MISUSE, that means the interface", "** was invoked incorrectly by the application.  In that case, the", "** error code and message may or may not be set.", "*/", "SQLITE_API int sqlite3_errcode(sqlite3 *db);", "SQLITE_API int sqlite3_extended_errcode(sqlite3 *db);", "SQLITE_API const char *sqlite3_errmsg(sqlite3*);", "SQLITE_API const void *sqlite3_errmsg16(sqlite3*);", "", "/*", "** CAPI3REF: SQL Statement Object", "** KEYWORDS: {prepared statement} {prepared statements}", "**", "** An instance of this object represents a single SQL statement.", '** This object is variously known as a "prepared statement" or a', '** "compiled SQL statement" or simply as a "statement".', "**", "** The life of a statement object goes something like this:", "**", "** <ol>", "** <li> Create the object using [sqlite3_prepare_v2()] or a related", "**      function.", "** <li> Bind values to [host parameters] using the sqlite3_bind_*()", "**      interfaces.", "** <li> Run the SQL by calling [sqlite3_step()] one or more times.", "** <li> Reset the statement using [sqlite3_reset()] then go back", "**      to step 2.  Do this zero or more times.", "** <li> Destroy the object using [sqlite3_finalize()].", "** </ol>", "**", "** Refer to documentation on individual methods above for additional", "** information.", "*/", "typedef struct sqlite3_stmt sqlite3_stmt;", "", "/*", "** CAPI3REF: Run-time Limits", "**", "** ^(This interface allows the size of various constructs to be limited", "** on a connection by connection basis.  The first parameter is the", "** [database connection] whose limit is to be set or queried.  The", "** second parameter is one of the [limit categories] that define a", "** class of constructs to be size limited.  The third parameter is the", "** new limit for that construct.)^", "**", "** ^If the new limit is a negative number, the limit is unchanged.", "** ^(For each limit category SQLITE_LIMIT_<i>NAME</i> there is a ", "** [limits | hard upper bound]", "** set at compile-time by a C preprocessor macro called", "** [limits | SQLITE_MAX_<i>NAME</i>].", '** (The "_LIMIT_" in the name is changed to "_MAX_".))^', "** ^Attempts to increase a limit above its hard upper bound are", "** silently truncated to the hard upper bound.", "**", "** ^Regardless of whether or not the limit was changed, the ", "** [sqlite3_limit()] interface returns the prior value of the limit.", "** ^Hence, to find the current value of a limit without changing it,", "** simply invoke this interface with the third parameter set to -1.", "**", "** Run-time limits are intended for use in applications that manage", "** both their own internal database and also databases that are controlled", "** by untrusted external sources.  An example application might be a", "** web browser that has its own databases for storing history and", "** separate databases controlled by JavaScript applications downloaded", "** off the Internet.  The internal databases can be given the", "** large, default limits.  Databases managed by external sources can", "** be given much smaller limits designed to prevent a denial of service", "** attack.  Developers might also want to use the [sqlite3_set_authorizer()]", "** interface to further control untrusted SQL.  The size of the database", "** created by an untrusted script can be contained using the", "** [max_page_count] [PRAGMA].", "**", "** New run-time limit categories may be added in future releases.", "*/", "SQLITE_API int sqlite3_limit(sqlite3*, int id, int newVal);", "", "/*", "** CAPI3REF: Run-Time Limit Categories", "** KEYWORDS: {limit category} {*limit categories}", "**", "** These constants define various performance limits", "** that can be lowered at run-time using [sqlite3_limit()].", "** The synopsis of the meanings of the various limits is shown below.", "** Additional information is available at [limits | Limits in SQLite].", "**", "** <dl>", "** [[SQLITE_LIMIT_LENGTH]] ^(<dt>SQLITE_LIMIT_LENGTH</dt>", "** <dd>The maximum size of any string or BLOB or table row, in bytes.<dd>)^", "**", "** [[SQLITE_LIMIT_SQL_LENGTH]] ^(<dt>SQLITE_LIMIT_SQL_LENGTH</dt>", "** <dd>The maximum length of an SQL statement, in bytes.</dd>)^", "**", "** [[SQLITE_LIMIT_COLUMN]] ^(<dt>SQLITE_LIMIT_COLUMN</dt>", "** <dd>The maximum number of columns in a table definition or in the", "** result set of a [SELECT] or the maximum number of columns in an index", "** or in an ORDER BY or GROUP BY clause.</dd>)^", "**", "** [[SQLITE_LIMIT_EXPR_DEPTH]] ^(<dt>SQLITE_LIMIT_EXPR_DEPTH</dt>", "** <dd>The maximum depth of the parse tree on any expression.</dd>)^", "**", "** [[SQLITE_LIMIT_COMPOUND_SELECT]] ^(<dt>SQLITE_LIMIT_COMPOUND_SELECT</dt>", "** <dd>The maximum number of terms in a compound SELECT statement.</dd>)^", "**", "** [[SQLITE_LIMIT_VDBE_OP]] ^(<dt>SQLITE_LIMIT_VDBE_OP</dt>", "** <dd>The maximum number of instructions in a virtual machine program", "** used to implement an SQL statement.  This limit is not currently", "** enforced, though that might be added in some future release of", "** SQLite.</dd>)^", "**", "** [[SQLITE_LIMIT_FUNCTION_ARG]] ^(<dt>SQLITE_LIMIT_FUNCTION_ARG</dt>", "** <dd>The maximum number of arguments on a function.</dd>)^", "**", "** [[SQLITE_LIMIT_ATTACHED]] ^(<dt>SQLITE_LIMIT_ATTACHED</dt>", "** <dd>The maximum number of [ATTACH | attached databases].)^</dd>", "**", "** [[SQLITE_LIMIT_LIKE_PATTERN_LENGTH]]", "** ^(<dt>SQLITE_LIMIT_LIKE_PATTERN_LENGTH</dt>", "** <dd>The maximum length of the pattern argument to the [LIKE] or", "** [GLOB] operators.</dd>)^", "**", "** [[SQLITE_LIMIT_VARIABLE_NUMBER]]", "** ^(<dt>SQLITE_LIMIT_VARIABLE_NUMBER</dt>", "** <dd>The maximum index number of any [parameter] in an SQL statement.)^", "**", "** [[SQLITE_LIMIT_TRIGGER_DEPTH]] ^(<dt>SQLITE_LIMIT_TRIGGER_DEPTH</dt>", "** <dd>The maximum depth of recursion for triggers.</dd>)^", "** </dl>", "*/", "#define SQLITE_LIMIT_LENGTH                    0", "#define SQLITE_LIMIT_SQL_LENGTH                1", "#define SQLITE_LIMIT_COLUMN                    2", "#define SQLITE_LIMIT_EXPR_DEPTH                3", "#define SQLITE_LIMIT_COMPOUND_SELECT           4", "#define SQLITE_LIMIT_VDBE_OP                   5", "#define SQLITE_LIMIT_FUNCTION_ARG              6", "#define SQLITE_LIMIT_ATTACHED                  7", "#define SQLITE_LIMIT_LIKE_PATTERN_LENGTH       8", "#define SQLITE_LIMIT_VARIABLE_NUMBER           9", "#define SQLITE_LIMIT_TRIGGER_DEPTH            10", "", "/*", "** CAPI3REF: Compiling An SQL Statement", "** KEYWORDS: {SQL statement compiler}", "**", "** To execute an SQL query, it must first be compiled into a byte-code", "** program using one of these routines.", "**", '** The first argument, "db", is a [database connection] obtained from a', "** prior successful call to [sqlite3_open()], [sqlite3_open_v2()] or", "** [sqlite3_open16()].  The database connection must not have been closed.", "**", '** The second argument, "zSql", is the statement to be compiled, encoded', "** as either UTF-8 or UTF-16.  The sqlite3_prepare() and sqlite3_prepare_v2()", "** interfaces use UTF-8, and sqlite3_prepare16() and sqlite3_prepare16_v2()", "** use UTF-16.", "**", "** ^If the nByte argument is less than zero, then zSql is read up to the", "** first zero terminator. ^If nByte is non-negative, then it is the maximum", "** number of  bytes read from zSql.  ^When nByte is non-negative, the", "** zSql string ends at either the first '\\000' or '\\u0000' character or", "** the nByte-th byte, whichever comes first. If the caller knows", "** that the supplied string is nul-terminated, then there is a small", "** performance advantage to be gained by passing an nByte parameter that", "** is equal to the number of bytes in the input string <i>including</i>", "** the nul-terminator bytes as this saves SQLite from having to", "** make a copy of the input string.", "**", "** ^If pzTail is not NULL then *pzTail is made to point to the first byte", "** past the end of the first SQL statement in zSql.  These routines only", "** compile the first statement in zSql, so *pzTail is left pointing to", "** what remains uncompiled.", "**", "** ^*ppStmt is left pointing to a compiled [prepared statement] that can be", "** executed using [sqlite3_step()].  ^If there is an error, *ppStmt is set", "** to NULL.  ^If the input text contains no SQL (if the input is an empty", "** string or a comment) then *ppStmt is set to NULL.", "** The calling procedure is responsible for deleting the compiled", "** SQL statement using [sqlite3_finalize()] after it has finished with it.", "** ppStmt may not be NULL.", "**", "** ^On success, the sqlite3_prepare() family of routines return [SQLITE_OK];", "** otherwise an [error code] is returned.", "**", "** The sqlite3_prepare_v2() and sqlite3_prepare16_v2() interfaces are", "** recommended for all new programs. The two older interfaces are retained", "** for backwards compatibility, but their use is discouraged.", '** ^In the "v2" interfaces, the prepared statement', "** that is returned (the [sqlite3_stmt] object) contains a copy of the", "** original SQL text. This causes the [sqlite3_step()] interface to", "** behave differently in three ways:", "**", "** <ol>", "** <li>", "** ^If the database schema changes, instead of returning [SQLITE_SCHEMA] as it", "** always used to do, [sqlite3_step()] will automatically recompile the SQL", "** statement and try to run it again.", "** </li>", "**", "** <li>", "** ^When an error occurs, [sqlite3_step()] will return one of the detailed", "** [error codes] or [extended error codes].  ^The legacy behavior was that", "** [sqlite3_step()] would only return a generic [SQLITE_ERROR] result code", "** and the application would have to make a second call to [sqlite3_reset()]", '** in order to find the underlying cause of the problem. With the "v2" prepare', "** interfaces, the underlying reason for the error is returned immediately.", "** </li>", "**", "** <li>", "** ^If the specific value bound to [parameter | host parameter] in the ", "** WHERE clause might influence the choice of query plan for a statement,", "** then the statement will be automatically recompiled, as if there had been ", "** a schema change, on the first  [sqlite3_step()] call following any change", "** to the [sqlite3_bind_text | bindings] of that [parameter]. ", "** ^The specific value of WHERE-clause [parameter] might influence the ", "** choice of query plan if the parameter is the left-hand side of a [LIKE]", "** or [GLOB] operator or if the parameter is compared to an indexed column", "** and the [SQLITE_ENABLE_STAT3] compile-time option is enabled.", "** the ", "** </li>", "** </ol>", "*/", "SQLITE_API int sqlite3_prepare(", "  sqlite3 *db,            /* Database handle */", "  const char *zSql,       /* SQL statement, UTF-8 encoded */", "  int nByte,              /* Maximum length of zSql in bytes. */", "  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */", "  const char **pzTail     /* OUT: Pointer to unused portion of zSql */", ");", "SQLITE_API int sqlite3_prepare_v2(", "  sqlite3 *db,            /* Database handle */", "  const char *zSql,       /* SQL statement, UTF-8 encoded */", "  int nByte,              /* Maximum length of zSql in bytes. */", "  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */", "  const char **pzTail     /* OUT: Pointer to unused portion of zSql */", ");", "SQLITE_API int sqlite3_prepare16(", "  sqlite3 *db,            /* Database handle */", "  const void *zSql,       /* SQL statement, UTF-16 encoded */", "  int nByte,              /* Maximum length of zSql in bytes. */", "  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */", "  const void **pzTail     /* OUT: Pointer to unused portion of zSql */", ");", "SQLITE_API int sqlite3_prepare16_v2(", "  sqlite3 *db,            /* Database handle */", "  const void *zSql,       /* SQL statement, UTF-16 encoded */", "  int nByte,              /* Maximum length of zSql in bytes. */", "  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */", "  const void **pzTail     /* OUT: Pointer to unused portion of zSql */", ");", "", "/*", "** CAPI3REF: Retrieving Statement SQL", "**", "** ^This interface can be used to retrieve a saved copy of the original", "** SQL text used to create a [prepared statement] if that statement was", "** compiled using either [sqlite3_prepare_v2()] or [sqlite3_prepare16_v2()].", "*/", "SQLITE_API const char *sqlite3_sql(sqlite3_stmt *pStmt);", "", "/*", "** CAPI3REF: Determine If An SQL Statement Writes The Database", "**", "** ^The sqlite3_stmt_readonly(X) interface returns true (non-zero) if", "** and only if the [prepared statement] X makes no direct changes to", "** the content of the database file.", "**", "** Note that [application-defined SQL functions] or", "** [virtual tables] might change the database indirectly as a side effect.  ", '** ^(For example, if an application defines a function "eval()" that ', "** calls [sqlite3_exec()], then the following SQL statement would", "** change the database file through side-effects:", "**", "** <blockquote><pre>", "**    SELECT eval('DELETE FROM t1') FROM t2;", "** </pre></blockquote>", "**", "** But because the [SELECT] statement does not change the database file", "** directly, sqlite3_stmt_readonly() would still return true.)^", "**", "** ^Transaction control statements such as [BEGIN], [COMMIT], [ROLLBACK],", "** [SAVEPOINT], and [RELEASE] cause sqlite3_stmt_readonly() to return true,", "** since the statements themselves do not actually modify the database but", "** rather they control the timing of when other statements modify the ", "** database.  ^The [ATTACH] and [DETACH] statements also cause", "** sqlite3_stmt_readonly() to return true since, while those statements", "** change the configuration of a database connection, they do not make ", "** changes to the content of the database files on disk.", "*/", "SQLITE_API int sqlite3_stmt_readonly(sqlite3_stmt *pStmt);", "", "/*", "** CAPI3REF: Determine If A Prepared Statement Has Been Reset", "**", "** ^The sqlite3_stmt_busy(S) interface returns true (non-zero) if the", "** [prepared statement] S has been stepped at least once using ", "** [sqlite3_step(S)] but has not run to completion and/or has not ", "** been reset using [sqlite3_reset(S)].  ^The sqlite3_stmt_busy(S)", "** interface returns false if S is a NULL pointer.  If S is not a ", "** NULL pointer and is not a pointer to a valid [prepared statement]", "** object, then the behavior is undefined and probably undesirable.", "**", "** This interface can be used in combination [sqlite3_next_stmt()]", "** to locate all prepared statements associated with a database ", "** connection that are in need of being reset.  This can be used,", "** for example, in diagnostic routines to search for prepared ", "** statements that are holding a transaction open.", "*/", "SQLITE_API int sqlite3_stmt_busy(sqlite3_stmt*);", "", "/*", "** CAPI3REF: Dynamically Typed Value Object", "** KEYWORDS: {protected sqlite3_value} {unprotected sqlite3_value}", "**", "** SQLite uses the sqlite3_value object to represent all values", "** that can be stored in a database table. SQLite uses dynamic typing", "** for the values it stores.  ^Values stored in sqlite3_value objects", "** can be integers, floating point values, strings, BLOBs, or NULL.", "**", '** An sqlite3_value object may be either "protected" or "unprotected".', "** Some interfaces require a protected sqlite3_value.  Other interfaces", "** will accept either a protected or an unprotected sqlite3_value.", "** Every interface that accepts sqlite3_value arguments specifies", "** whether or not it requires a protected sqlite3_value.", "**", '** The terms "protected" and "unprotected" refer to whether or not', "** a mutex is held.  An internal mutex is held for a protected", "** sqlite3_value object but no mutex is held for an unprotected", "** sqlite3_value object.  If SQLite is compiled to be single-threaded", "** (with [SQLITE_THREADSAFE=0] and with [sqlite3_threadsafe()] returning 0)", "** or if SQLite is run in one of reduced mutex modes ", "** [SQLITE_CONFIG_SINGLETHREAD] or [SQLITE_CONFIG_MULTITHREAD]", "** then there is no distinction between protected and unprotected", "** sqlite3_value objects and they can be used interchangeably.  However,", "** for maximum code portability it is recommended that applications", "** still make the distinction between protected and unprotected", "** sqlite3_value objects even when not strictly required.", "**", "** ^The sqlite3_value objects that are passed as parameters into the", "** implementation of [application-defined SQL functions] are protected.", "** ^The sqlite3_value object returned by", "** [sqlite3_column_value()] is unprotected.", "** Unprotected sqlite3_value objects may only be used with", "** [sqlite3_result_value()] and [sqlite3_bind_value()].", "** The [sqlite3_value_blob | sqlite3_value_type()] family of", "** interfaces require protected sqlite3_value objects.", "*/", "typedef struct Mem sqlite3_value;", "", "/*", "** CAPI3REF: SQL Function Context Object", "**", "** The context in which an SQL function executes is stored in an", "** sqlite3_context object.  ^A pointer to an sqlite3_context object", "** is always first parameter to [application-defined SQL functions].", "** The application-defined SQL function implementation will pass this", "** pointer through into calls to [sqlite3_result_int | sqlite3_result()],", "** [sqlite3_aggregate_context()], [sqlite3_user_data()],", "** [sqlite3_context_db_handle()], [sqlite3_get_auxdata()],", "** and/or [sqlite3_set_auxdata()].", "*/", "typedef struct sqlite3_context sqlite3_context;", "", "/*", "** CAPI3REF: Binding Values To Prepared Statements", "** KEYWORDS: {host parameter} {host parameters} {host parameter name}", "** KEYWORDS: {SQL parameter} {SQL parameters} {parameter binding}", "**", "** ^(In the SQL statement text input to [sqlite3_prepare_v2()] and its variants,", "** literals may be replaced by a [parameter] that matches one of following", "** templates:", "**", "** <ul>", "** <li>  ?", "** <li>  ?NNN", "** <li>  :VVV", "** <li>  @VVV", "** <li>  $VVV", "** </ul>", "**", "** In the templates above, NNN represents an integer literal,", "** and VVV represents an alphanumeric identifier.)^  ^The values of these", '** parameters (also called "host parameter names" or "SQL parameters")', "** can be set using the sqlite3_bind_*() routines defined here.", "**", "** ^The first argument to the sqlite3_bind_*() routines is always", "** a pointer to the [sqlite3_stmt] object returned from", "** [sqlite3_prepare_v2()] or its variants.", "**", "** ^The second argument is the index of the SQL parameter to be set.", "** ^The leftmost SQL parameter has an index of 1.  ^When the same named", "** SQL parameter is used more than once, second and subsequent", "** occurrences have the same index as the first occurrence.", "** ^The index for named parameters can be looked up using the", "** [sqlite3_bind_parameter_index()] API if desired.  ^The index", '** for "?NNN" parameters is the value of NNN.', "** ^The NNN value must be between 1 and the [sqlite3_limit()]", "** parameter [SQLITE_LIMIT_VARIABLE_NUMBER] (default value: 999).", "**", "** ^The third argument is the value to bind to the parameter.", "**", "** ^(In those routines that have a fourth argument, its value is the", "** number of bytes in the parameter.  To be clear: the value is the", "** number of <u>bytes</u> in the value, not the number of characters.)^", "** ^If the fourth parameter is negative, the length of the string is", "** the number of bytes up to the first zero terminator.", "** If a non-negative fourth parameter is provided to sqlite3_bind_text()", "** or sqlite3_bind_text16() then that parameter must be the byte offset", "** where the NUL terminator would occur assuming the string were NUL", "** terminated.  If any NUL characters occur at byte offsets less than ", "** the value of the fourth parameter then the resulting string value will", "** contain embedded NULs.  The result of expressions involving strings", "** with embedded NULs is undefined.", "**", "** ^The fifth argument to sqlite3_bind_blob(), sqlite3_bind_text(), and", "** sqlite3_bind_text16() is a destructor used to dispose of the BLOB or", "** string after SQLite has finished with it.  ^The destructor is called", "** to dispose of the BLOB or string even if the call to sqlite3_bind_blob(),", "** sqlite3_bind_text(), or sqlite3_bind_text16() fails.  ", "** ^If the fifth argument is", "** the special value [SQLITE_STATIC], then SQLite assumes that the", "** information is in static, unmanaged space and does not need to be freed.", "** ^If the fifth argument has the value [SQLITE_TRANSIENT], then", "** SQLite makes its own private copy of the data immediately, before", "** the sqlite3_bind_*() routine returns.", "**", "** ^The sqlite3_bind_zeroblob() routine binds a BLOB of length N that", "** is filled with zeroes.  ^A zeroblob uses a fixed amount of memory", "** (just an integer to hold its size) while it is being processed.", "** Zeroblobs are intended to serve as placeholders for BLOBs whose", "** content is later written using", "** [sqlite3_blob_open | incremental BLOB I/O] routines.", "** ^A negative value for the zeroblob results in a zero-length BLOB.", "**", "** ^If any of the sqlite3_bind_*() routines are called with a NULL pointer", "** for the [prepared statement] or with a prepared statement for which", "** [sqlite3_step()] has been called more recently than [sqlite3_reset()],", "** then the call will return [SQLITE_MISUSE].  If any sqlite3_bind_()", "** routine is passed a [prepared statement] that has been finalized, the", "** result is undefined and probably harmful.", "**", "** ^Bindings are not cleared by the [sqlite3_reset()] routine.", "** ^Unbound parameters are interpreted as NULL.", "**", "** ^The sqlite3_bind_* routines return [SQLITE_OK] on success or an", "** [error code] if anything goes wrong.", "** ^[SQLITE_RANGE] is returned if the parameter", "** index is out of range.  ^[SQLITE_NOMEM] is returned if malloc() fails.", "**", "** See also: [sqlite3_bind_parameter_count()],", "** [sqlite3_bind_parameter_name()], and [sqlite3_bind_parameter_index()].", "*/", "SQLITE_API int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));", "SQLITE_API int sqlite3_bind_double(sqlite3_stmt*, int, double);", "SQLITE_API int sqlite3_bind_int(sqlite3_stmt*, int, int);", "SQLITE_API int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite3_int64);", "SQLITE_API int sqlite3_bind_null(sqlite3_stmt*, int);", "SQLITE_API int sqlite3_bind_text(sqlite3_stmt*, int, const char*, int n, void(*)(void*));", "SQLITE_API int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)(void*));", "SQLITE_API int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);", "SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);", "", "/*", "** CAPI3REF: Number Of SQL Parameters", "**", "** ^This routine can be used to find the number of [SQL parameters]", "** in a [prepared statement].  SQL parameters are tokens of the", '** form "?", "?NNN", ":AAA", "$AAA", or "@AAA" that serve as', "** placeholders for values that are [sqlite3_bind_blob | bound]", "** to the parameters at a later time.", "**", "** ^(This routine actually returns the index of the largest (rightmost)", "** parameter. For all forms except ?NNN, this will correspond to the", "** number of unique parameters.  If parameters of the ?NNN form are used,", "** there may be gaps in the list.)^", "**", "** See also: [sqlite3_bind_blob|sqlite3_bind()],", "** [sqlite3_bind_parameter_name()], and", "** [sqlite3_bind_parameter_index()].", "*/", "SQLITE_API int sqlite3_bind_parameter_count(sqlite3_stmt*);", "", "/*", "** CAPI3REF: Name Of A Host Parameter", "**", "** ^The sqlite3_bind_parameter_name(P,N) interface returns", "** the name of the N-th [SQL parameter] in the [prepared statement] P.", '** ^(SQL parameters of the form "?NNN" or ":AAA" or "@AAA" or "$AAA"', '** have a name which is the string "?NNN" or ":AAA" or "@AAA" or "$AAA"', "** respectively.", '** In other words, the initial ":" or "$" or "@" or "?"', "** is included as part of the name.)^", '** ^Parameters of the form "?" without a following integer have no name', '** and are referred to as "nameless" or "anonymous parameters".', "**", "** ^The first host parameter has an index of 1, not 0.", "**", "** ^If the value N is out of range or if the N-th parameter is", "** nameless, then NULL is returned.  ^The returned string is", "** always in UTF-8 encoding even if the named parameter was", "** originally specified as UTF-16 in [sqlite3_prepare16()] or", "** [sqlite3_prepare16_v2()].", "**", "** See also: [sqlite3_bind_blob|sqlite3_bind()],", "** [sqlite3_bind_parameter_count()], and", "** [sqlite3_bind_parameter_index()].", "*/", "SQLITE_API const char *sqlite3_bind_parameter_name(sqlite3_stmt*, int);", "", "/*", "** CAPI3REF: Index Of A Parameter With A Given Name", "**", "** ^Return the index of an SQL parameter given its name.  ^The", "** index value returned is suitable for use as the second", "** parameter to [sqlite3_bind_blob|sqlite3_bind()].  ^A zero", "** is returned if no matching parameter is found.  ^The parameter", "** name must be given in UTF-8 even if the original statement", "** was prepared from UTF-16 text using [sqlite3_prepare16_v2()].", "**", "** See also: [sqlite3_bind_blob|sqlite3_bind()],", "** [sqlite3_bind_parameter_count()], and", "** [sqlite3_bind_parameter_index()].", "*/", "SQLITE_API int sqlite3_bind_parameter_index(sqlite3_stmt*, const char *zName);", "", "/*", "** CAPI3REF: Reset All Bindings On A Prepared Statement", "**", "** ^Contrary to the intuition of many, [sqlite3_reset()] does not reset", "** the [sqlite3_bind_blob | bindings] on a [prepared statement].", "** ^Use this routine to reset all host parameters to NULL.", "*/", "SQLITE_API int sqlite3_clear_bindings(sqlite3_stmt*);", "", "/*", "** CAPI3REF: Number Of Columns In A Result Set", "**", "** ^Return the number of columns in the result set returned by the", "** [prepared statement]. ^This routine returns 0 if pStmt is an SQL", "** statement that does not return data (for example an [UPDATE]).", "**", "** See also: [sqlite3_data_count()]", "*/", "SQLITE_API int sqlite3_column_count(sqlite3_stmt *pStmt);", "", "/*", "** CAPI3REF: Column Names In A Result Set", "**", "** ^These routines return the name assigned to a particular column", "** in the result set of a [SELECT] statement.  ^The sqlite3_column_name()", "** interface returns a pointer to a zero-terminated UTF-8 string", "** and sqlite3_column_name16() returns a pointer to a zero-terminated", "** UTF-16 string.  ^The first parameter is the [prepared statement]", "** that implements the [SELECT] statement. ^The second parameter is the", "** column number.  ^The leftmost column is number 0.", "**", "** ^The returned string pointer is valid until either the [prepared statement]", "** is destroyed by [sqlite3_finalize()] or until the statement is automatically", "** reprepared by the first call to [sqlite3_step()] for a particular run", "** or until the next call to", "** sqlite3_column_name() or sqlite3_column_name16() on the same column.", "**", "** ^If sqlite3_malloc() fails during the processing of either routine", "** (for example during a conversion from UTF-8 to UTF-16) then a", "** NULL pointer is returned.", "**", '** ^The name of a result column is the value of the "AS" clause for', "** that column, if there is an AS clause.  If there is no AS clause", "** then the name of the column is unspecified and may change from", "** one release of SQLite to the next.", "*/", "SQLITE_API const char *sqlite3_column_name(sqlite3_stmt*, int N);", "SQLITE_API const void *sqlite3_column_name16(sqlite3_stmt*, int N);", "", "/*", "** CAPI3REF: Source Of Data In A Query Result", "**", "** ^These routines provide a means to determine the database, table, and", "** table column that is the origin of a particular result column in", "** [SELECT] statement.", "** ^The name of the database or table or column can be returned as", "** either a UTF-8 or UTF-16 string.  ^The _database_ routines return", "** the database name, the _table_ routines return the table name, and", "** the origin_ routines return the column name.", "** ^The returned string is valid until the [prepared statement] is destroyed", "** using [sqlite3_finalize()] or until the statement is automatically", "** reprepared by the first call to [sqlite3_step()] for a particular run", "** or until the same information is requested", "** again in a different encoding.", "**", "** ^The names returned are the original un-aliased names of the", "** database, table, and column.", "**", "** ^The first argument to these interfaces is a [prepared statement].", "** ^These functions return information about the Nth result column returned by", "** the statement, where N is the second function argument.", "** ^The left-most column is column 0 for these routines.", "**", "** ^If the Nth column returned by the statement is an expression or", "** subquery and is not a column value, then all of these functions return", "** NULL.  ^These routine might also return NULL if a memory allocation error", "** occurs.  ^Otherwise, they return the name of the attached database, table,", "** or column that query result column was extracted from.", "**", '** ^As with all other SQLite APIs, those whose names end with "16" return', "** UTF-16 encoded strings and the other functions return UTF-8.", "**", "** ^These APIs are only available if the library was compiled with the", "** [SQLITE_ENABLE_COLUMN_METADATA] C-preprocessor symbol.", "**", "** If two or more threads call one or more of these routines against the same", "** prepared statement and column at the same time then the results are", "** undefined.", "**", "** If two or more threads call one or more", "** [sqlite3_column_database_name | column metadata interfaces]", "** for the same [prepared statement] and result column", "** at the same time then the results are undefined.", "*/", "SQLITE_API const char *sqlite3_column_database_name(sqlite3_stmt*,int);", "SQLITE_API const void *sqlite3_column_database_name16(sqlite3_stmt*,int);", "SQLITE_API const char *sqlite3_column_table_name(sqlite3_stmt*,int);", "SQLITE_API const void *sqlite3_column_table_name16(sqlite3_stmt*,int);", "SQLITE_API const char *sqlite3_column_origin_name(sqlite3_stmt*,int);", "SQLITE_API const void *sqlite3_column_origin_name16(sqlite3_stmt*,int);", "", "/*", "** CAPI3REF: Declared Datatype Of A Query Result", "**", "** ^(The first parameter is a [prepared statement].", "** If this statement is a [SELECT] statement and the Nth column of the", "** returned result set of that [SELECT] is a table column (not an", "** expression or subquery) then the declared type of the table", "** column is returned.)^  ^If the Nth column of the result set is an", "** expression or subquery, then a NULL pointer is returned.", "** ^The returned string is always UTF-8 encoded.", "**", "** ^(For example, given the database schema:", "**", "** CREATE TABLE t1(c1 VARIANT);", "**", "** and the following statement to be compiled:", "**", "** SELECT c1 + 1, c1 FROM t1;", "**", '** this routine would return the string "VARIANT" for the second result', "** column (i==1), and a NULL pointer for the first result column (i==0).)^", "**", "** ^SQLite uses dynamic run-time typing.  ^So just because a column", "** is declared to contain a particular type does not mean that the", "** data stored in that column is of the declared type.  SQLite is", "** strongly typed, but the typing is dynamic not static.  ^Type", "** is associated with individual values, not with the containers", "** used to hold those values.", "*/", "SQLITE_API const char *sqlite3_column_decltype(sqlite3_stmt*,int);", "SQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt*,int);", "", "/*", "** CAPI3REF: Evaluate An SQL Statement", "**", "** After a [prepared statement] has been prepared using either", "** [sqlite3_prepare_v2()] or [sqlite3_prepare16_v2()] or one of the legacy", "** interfaces [sqlite3_prepare()] or [sqlite3_prepare16()], this function", "** must be called one or more times to evaluate the statement.", "**", "** The details of the behavior of the sqlite3_step() interface depend", '** on whether the statement was prepared using the newer "v2" interface', "** [sqlite3_prepare_v2()] and [sqlite3_prepare16_v2()] or the older legacy", "** interface [sqlite3_prepare()] and [sqlite3_prepare16()].  The use of the", '** new "v2" interface is recommended for new applications but the legacy', "** interface will continue to be supported.", "**", "** ^In the legacy interface, the return value will be either [SQLITE_BUSY],", "** [SQLITE_DONE], [SQLITE_ROW], [SQLITE_ERROR], or [SQLITE_MISUSE].", '** ^With the "v2" interface, any of the other [result codes] or', "** [extended result codes] might be returned as well.", "**", "** ^[SQLITE_BUSY] means that the database engine was unable to acquire the", "** database locks it needs to do its job.  ^If the statement is a [COMMIT]", "** or occurs outside of an explicit transaction, then you can retry the", "** statement.  If the statement is not a [COMMIT] and occurs within an", "** explicit transaction then you should rollback the transaction before", "** continuing.", "**", "** ^[SQLITE_DONE] means that the statement has finished executing", "** successfully.  sqlite3_step() should not be called again on this virtual", "** machine without first calling [sqlite3_reset()] to reset the virtual", "** machine back to its initial state.", "**", "** ^If the SQL statement being executed returns any data, then [SQLITE_ROW]", "** is returned each time a new row of data is ready for processing by the", "** caller. The values may be accessed using the [column access functions].", "** sqlite3_step() is called again to retrieve the next row of data.", "**", "** ^[SQLITE_ERROR] means that a run-time error (such as a constraint", "** violation) has occurred.  sqlite3_step() should not be called again on", "** the VM. More information may be found by calling [sqlite3_errmsg()].", "** ^With the legacy interface, a more specific error code (for example,", "** [SQLITE_INTERRUPT], [SQLITE_SCHEMA], [SQLITE_CORRUPT], and so forth)", "** can be obtained by calling [sqlite3_reset()] on the", '** [prepared statement].  ^In the "v2" interface,', "** the more specific error code is returned directly by sqlite3_step().", "**", "** [SQLITE_MISUSE] means that the this routine was called inappropriately.", "** Perhaps it was called on a [prepared statement] that has", "** already been [sqlite3_finalize | finalized] or on one that had", "** previously returned [SQLITE_ERROR] or [SQLITE_DONE].  Or it could", "** be the case that the same database connection is being used by two or", "** more threads at the same moment in time.", "**", "** For all versions of SQLite up to and including 3.6.23.1, a call to", "** [sqlite3_reset()] was required after sqlite3_step() returned anything", "** other than [SQLITE_ROW] before any subsequent invocation of", "** sqlite3_step().  Failure to reset the prepared statement using ", "** [sqlite3_reset()] would result in an [SQLITE_MISUSE] return from", "** sqlite3_step().  But after version 3.6.23.1, sqlite3_step() began", "** calling [sqlite3_reset()] automatically in this circumstance rather", "** than returning [SQLITE_MISUSE].  This is not considered a compatibility", "** break because any application that ever receives an SQLITE_MISUSE error", "** is broken by definition.  The [SQLITE_OMIT_AUTORESET] compile-time option", "** can be used to restore the legacy behavior.", "**", "** <b>Goofy Interface Alert:</b> In the legacy interface, the sqlite3_step()", "** API always returns a generic error code, [SQLITE_ERROR], following any", "** error other than [SQLITE_BUSY] and [SQLITE_MISUSE].  You must call", "** [sqlite3_reset()] or [sqlite3_finalize()] in order to find one of the", "** specific [error codes] that better describes the error.", "** We admit that this is a goofy design.  The problem has been fixed", '** with the "v2" interface.  If you prepare all of your SQL statements', "** using either [sqlite3_prepare_v2()] or [sqlite3_prepare16_v2()] instead", "** of the legacy [sqlite3_prepare()] and [sqlite3_prepare16()] interfaces,", "** then the more specific [error codes] are returned directly", '** by sqlite3_step().  The use of the "v2" interface is recommended.', "*/", "SQLITE_API int sqlite3_step(sqlite3_stmt*);", "", "/*", "** CAPI3REF: Number of columns in a result set", "**", "** ^The sqlite3_data_count(P) interface returns the number of columns in the", "** current row of the result set of [prepared statement] P.", "** ^If prepared statement P does not have results ready to return", "** (via calls to the [sqlite3_column_int | sqlite3_column_*()] of", "** interfaces) then sqlite3_data_count(P) returns 0.", "** ^The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer.", "** ^The sqlite3_data_count(P) routine returns 0 if the previous call to", "** [sqlite3_step](P) returned [SQLITE_DONE].  ^The sqlite3_data_count(P)", "** will return non-zero if previous call to [sqlite3_step](P) returned", "** [SQLITE_ROW], except in the case of the [PRAGMA incremental_vacuum]", "** where it always returns zero since each step of that multi-step", "** pragma returns 0 columns of data.", "**", "** See also: [sqlite3_column_count()]", "*/", "SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt);", "", "/*", "** CAPI3REF: Fundamental Datatypes", "** KEYWORDS: SQLITE_TEXT", "**", "** ^(Every value in SQLite has one of five fundamental datatypes:", "**", "** <ul>", "** <li> 64-bit signed integer", "** <li> 64-bit IEEE floating point number", "** <li> string", "** <li> BLOB", "** <li> NULL", "** </ul>)^", "**", "** These constants are codes for each of those types.", "**", "** Note that the SQLITE_TEXT constant was also used in SQLite version 2", "** for a completely different meaning.  Software that links against both", "** SQLite version 2 and SQLite version 3 should use SQLITE3_TEXT, not", "** SQLITE_TEXT.", "*/", "#define SQLITE_INTEGER  1", "#define SQLITE_FLOAT    2", "#define SQLITE_BLOB     4", "#define SQLITE_NULL     5", "#ifdef SQLITE_TEXT", "# undef SQLITE_TEXT", "#else", "# define SQLITE_TEXT     3", "#endif", "#define SQLITE3_TEXT     3", "", "/*", "** CAPI3REF: Result Values From A Query", "** KEYWORDS: {column access functions}", "**", '** These routines form the "result set" interface.', "**", "** ^These routines return information about a single column of the current", "** result row of a query.  ^In every case the first argument is a pointer", "** to the [prepared statement] that is being evaluated (the [sqlite3_stmt*]", "** that was returned from [sqlite3_prepare_v2()] or one of its variants)", "** and the second argument is the index of the column for which information", "** should be returned. ^The leftmost column of the result set has the index 0.", "** ^The number of columns in the result can be determined using", "** [sqlite3_column_count()].", "**", "** If the SQL statement does not currently point to a valid row, or if the", "** column index is out of range, the result is undefined.", "** These routines may only be called when the most recent call to", "** [sqlite3_step()] has returned [SQLITE_ROW] and neither", "** [sqlite3_reset()] nor [sqlite3_finalize()] have been called subsequently.", "** If any of these routines are called after [sqlite3_reset()] or", "** [sqlite3_finalize()] or after [sqlite3_step()] has returned", "** something other than [SQLITE_ROW], the results are undefined.", "** If [sqlite3_step()] or [sqlite3_reset()] or [sqlite3_finalize()]", "** are called from a different thread while any of these routines", "** are pending, then the results are undefined.", "**", "** ^The sqlite3_column_type() routine returns the", "** [SQLITE_INTEGER | datatype code] for the initial data type", "** of the result column.  ^The returned value is one of [SQLITE_INTEGER],", "** [SQLITE_FLOAT], [SQLITE_TEXT], [SQLITE_BLOB], or [SQLITE_NULL].  The value", "** returned by sqlite3_column_type() is only meaningful if no type", "** conversions have occurred as described below.  After a type conversion,", "** the value returned by sqlite3_column_type() is undefined.  Future", "** versions of SQLite may change the behavior of sqlite3_column_type()", "** following a type conversion.", "**", "** ^If the result is a BLOB or UTF-8 string then the sqlite3_column_bytes()", "** routine returns the number of bytes in that BLOB or string.", "** ^If the result is a UTF-16 string, then sqlite3_column_bytes() converts", "** the string to UTF-8 and then returns the number of bytes.", "** ^If the result is a numeric value then sqlite3_column_bytes() uses", "** [sqlite3_snprintf()] to convert that value to a UTF-8 string and returns", "** the number of bytes in that string.", "** ^If the result is NULL, then sqlite3_column_bytes() returns zero.", "**", "** ^If the result is a BLOB or UTF-16 string then the sqlite3_column_bytes16()", "** routine returns the number of bytes in that BLOB or string.", "** ^If the result is a UTF-8 string, then sqlite3_column_bytes16() converts", "** the string to UTF-16 and then returns the number of bytes.", "** ^If the result is a numeric value then sqlite3_column_bytes16() uses", "** [sqlite3_snprintf()] to convert that value to a UTF-16 string and returns", "** the number of bytes in that string.", "** ^If the result is NULL, then sqlite3_column_bytes16() returns zero.", "**", "** ^The values returned by [sqlite3_column_bytes()] and ", "** [sqlite3_column_bytes16()] do not include the zero terminators at the end", "** of the string.  ^For clarity: the values returned by", "** [sqlite3_column_bytes()] and [sqlite3_column_bytes16()] are the number of", "** bytes in the string, not the number of characters.", "**", "** ^Strings returned by sqlite3_column_text() and sqlite3_column_text16(),", "** even empty strings, are always zero-terminated.  ^The return", "** value from sqlite3_column_blob() for a zero-length BLOB is a NULL pointer.", "**", "** ^The object returned by [sqlite3_column_value()] is an", "** [unprotected sqlite3_value] object.  An unprotected sqlite3_value object", "** may only be used with [sqlite3_bind_value()] and [sqlite3_result_value()].", "** If the [unprotected sqlite3_value] object returned by", "** [sqlite3_column_value()] is used in any other way, including calls", "** to routines like [sqlite3_value_int()], [sqlite3_value_text()],", "** or [sqlite3_value_bytes()], then the behavior is undefined.", "**", "** These routines attempt to convert the value where appropriate.  ^For", "** example, if the internal representation is FLOAT and a text result", "** is requested, [sqlite3_snprintf()] is used internally to perform the", "** conversion automatically.  ^(The following table details the conversions", "** that are applied:", "**", "** <blockquote>", '** <table border="1">', "** <tr><th> Internal<br>Type <th> Requested<br>Type <th>  Conversion", "**", "** <tr><td>  NULL    <td> INTEGER   <td> Result is 0", "** <tr><td>  NULL    <td>  FLOAT    <td> Result is 0.0", "** <tr><td>  NULL    <td>   TEXT    <td> Result is NULL pointer", "** <tr><td>  NULL    <td>   BLOB    <td> Result is NULL pointer", "** <tr><td> INTEGER  <td>  FLOAT    <td> Convert from integer to float", "** <tr><td> INTEGER  <td>   TEXT    <td> ASCII rendering of the integer", "** <tr><td> INTEGER  <td>   BLOB    <td> Same as INTEGER->TEXT", "** <tr><td>  FLOAT   <td> INTEGER   <td> Convert from float to integer", "** <tr><td>  FLOAT   <td>   TEXT    <td> ASCII rendering of the float", "** <tr><td>  FLOAT   <td>   BLOB    <td> Same as FLOAT->TEXT", "** <tr><td>  TEXT    <td> INTEGER   <td> Use atoi()", "** <tr><td>  TEXT    <td>  FLOAT    <td> Use atof()", "** <tr><td>  TEXT    <td>   BLOB    <td> No change", "** <tr><td>  BLOB    <td> INTEGER   <td> Convert to TEXT then use atoi()", "** <tr><td>  BLOB    <td>  FLOAT    <td> Convert to TEXT then use atof()", "** <tr><td>  BLOB    <td>   TEXT    <td> Add a zero terminator if needed", "** </table>", "** </blockquote>)^", "**", "** The table above makes reference to standard C library functions atoi()", "** and atof().  SQLite does not really use these functions.  It has its", "** own equivalent internal routines.  The atoi() and atof() names are", "** used in the table for brevity and because they are familiar to most", "** C programmers.", "**", "** Note that when type conversions occur, pointers returned by prior", "** calls to sqlite3_column_blob(), sqlite3_column_text(), and/or", "** sqlite3_column_text16() may be invalidated.", "** Type conversions and pointer invalidations might occur", "** in the following cases:", "**", "** <ul>", "** <li> The initial content is a BLOB and sqlite3_column_text() or", "**      sqlite3_column_text16() is called.  A zero-terminator might", "**      need to be added to the string.</li>", "** <li> The initial content is UTF-8 text and sqlite3_column_bytes16() or", "**      sqlite3_column_text16() is called.  The content must be converted", "**      to UTF-16.</li>", "** <li> The initial content is UTF-16 text and sqlite3_column_bytes() or", "**      sqlite3_column_text() is called.  The content must be converted", "**      to UTF-8.</li>", "** </ul>", "**", "** ^Conversions between UTF-16be and UTF-16le are always done in place and do", "** not invalidate a prior pointer, though of course the content of the buffer", "** that the prior pointer references will have been modified.  Other kinds", "** of conversion are done in place when it is possible, but sometimes they", "** are not possible and in those cases prior pointers are invalidated.", "**", "** The safest and easiest to remember policy is to invoke these routines", "** in one of the following ways:", "**", "** <ul>", "**  <li>sqlite3_column_text() followed by sqlite3_column_bytes()</li>", "**  <li>sqlite3_column_blob() followed by sqlite3_column_bytes()</li>", "**  <li>sqlite3_column_text16() followed by sqlite3_column_bytes16()</li>", "** </ul>", "**", "** In other words, you should call sqlite3_column_text(),", "** sqlite3_column_blob(), or sqlite3_column_text16() first to force the result", "** into the desired format, then invoke sqlite3_column_bytes() or", "** sqlite3_column_bytes16() to find the size of the result.  Do not mix calls", "** to sqlite3_column_text() or sqlite3_column_blob() with calls to", "** sqlite3_column_bytes16(), and do not mix calls to sqlite3_column_text16()", "** with calls to sqlite3_column_bytes().", "**", "** ^The pointers returned are valid until a type conversion occurs as", "** described above, or until [sqlite3_step()] or [sqlite3_reset()] or", "** [sqlite3_finalize()] is called.  ^The memory space used to hold strings", "** and BLOBs is freed automatically.  Do <b>not</b> pass the pointers returned", "** [sqlite3_column_blob()], [sqlite3_column_text()], etc. into", "** [sqlite3_free()].", "**", "** ^(If a memory allocation error occurs during the evaluation of any", "** of these routines, a default value is returned.  The default value", "** is either the integer 0, the floating point number 0.0, or a NULL", "** pointer.  Subsequent calls to [sqlite3_errcode()] will return", "** [SQLITE_NOMEM].)^", "*/", "SQLITE_API const void *sqlite3_column_blob(sqlite3_stmt*, int iCol);", "SQLITE_API int sqlite3_column_bytes(sqlite3_stmt*, int iCol);", "SQLITE_API int sqlite3_column_bytes16(sqlite3_stmt*, int iCol);", "SQLITE_API double sqlite3_column_double(sqlite3_stmt*, int iCol);", "SQLITE_API int sqlite3_column_int(sqlite3_stmt*, int iCol);", "SQLITE_API sqlite3_int64 sqlite3_column_int64(sqlite3_stmt*, int iCol);", "SQLITE_API const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);", "SQLITE_API const void *sqlite3_column_text16(sqlite3_stmt*, int iCol);", "SQLITE_API int sqlite3_column_type(sqlite3_stmt*, int iCol);", "SQLITE_API sqlite3_value *sqlite3_column_value(sqlite3_stmt*, int iCol);", "", "/*", "** CAPI3REF: Destroy A Prepared Statement Object", "**", "** ^The sqlite3_finalize() function is called to delete a [prepared statement].", "** ^If the most recent evaluation of the statement encountered no errors", "** or if the statement is never been evaluated, then sqlite3_finalize() returns", "** SQLITE_OK.  ^If the most recent evaluation of statement S failed, then", "** sqlite3_finalize(S) returns the appropriate [error code] or", "** [extended error code].", "**", "** ^The sqlite3_finalize(S) routine can be called at any point during", "** the life cycle of [prepared statement] S:", "** before statement S is ever evaluated, after", "** one or more calls to [sqlite3_reset()], or after any call", "** to [sqlite3_step()] regardless of whether or not the statement has", "** completed execution.", "**", "** ^Invoking sqlite3_finalize() on a NULL pointer is a harmless no-op.", "**", "** The application must finalize every [prepared statement] in order to avoid", "** resource leaks.  It is a grievous error for the application to try to use", "** a prepared statement after it has been finalized.  Any use of a prepared", "** statement after it has been finalized can result in undefined and", "** undesirable behavior such as segfaults and heap corruption.", "*/", "SQLITE_API int sqlite3_finalize(sqlite3_stmt *pStmt);", "", "/*", "** CAPI3REF: Reset A Prepared Statement Object", "**", "** The sqlite3_reset() function is called to reset a [prepared statement]", "** object back to its initial state, ready to be re-executed.", "** ^Any SQL statement variables that had values bound to them using", "** the [sqlite3_bind_blob | sqlite3_bind_*() API] retain their values.", "** Use [sqlite3_clear_bindings()] to reset the bindings.", "**", "** ^The [sqlite3_reset(S)] interface resets the [prepared statement] S", "** back to the beginning of its program.", "**", "** ^If the most recent call to [sqlite3_step(S)] for the", "** [prepared statement] S returned [SQLITE_ROW] or [SQLITE_DONE],", "** or if [sqlite3_step(S)] has never before been called on S,", "** then [sqlite3_reset(S)] returns [SQLITE_OK].", "**", "** ^If the most recent call to [sqlite3_step(S)] for the", "** [prepared statement] S indicated an error, then", "** [sqlite3_reset(S)] returns an appropriate [error code].", "**", "** ^The [sqlite3_reset(S)] interface does not change the values", "** of any [sqlite3_bind_blob|bindings] on the [prepared statement] S.", "*/", "SQLITE_API int sqlite3_reset(sqlite3_stmt *pStmt);", "", "/*", "** CAPI3REF: Create Or Redefine SQL Functions", "** KEYWORDS: {function creation routines}", "** KEYWORDS: {application-defined SQL function}", "** KEYWORDS: {application-defined SQL functions}", "**", '** ^These functions (collectively known as "function creation routines")', "** are used to add SQL functions or aggregates or to redefine the behavior", "** of existing SQL functions or aggregates.  The only differences between", "** these routines are the text encoding expected for", "** the second parameter (the name of the function being created)", "** and the presence or absence of a destructor callback for", "** the application data pointer.", "**", "** ^The first parameter is the [database connection] to which the SQL", "** function is to be added.  ^If an application uses more than one database", "** connection then application-defined SQL functions must be added", "** to each database connection separately.", "**", "** ^The second parameter is the name of the SQL function to be created or", "** redefined.  ^The length of the name is limited to 255 bytes in a UTF-8", "** representation, exclusive of the zero-terminator.  ^Note that the name", "** length limit is in UTF-8 bytes, not characters nor UTF-16 bytes.  ", "** ^Any attempt to create a function with a longer name", "** will result in [SQLITE_MISUSE] being returned.", "**", "** ^The third parameter (nArg)", "** is the number of arguments that the SQL function or", "** aggregate takes. ^If this parameter is -1, then the SQL function or", "** aggregate may take any number of arguments between 0 and the limit", "** set by [sqlite3_limit]([SQLITE_LIMIT_FUNCTION_ARG]).  If the third", "** parameter is less than -1 or greater than 127 then the behavior is", "** undefined.", "**", "** ^The fourth parameter, eTextRep, specifies what", "** [SQLITE_UTF8 | text encoding] this SQL function prefers for", "** its parameters.  Every SQL function implementation must be able to work", "** with UTF-8, UTF-16le, or UTF-16be.  But some implementations may be", "** more efficient with one encoding than another.  ^An application may", "** invoke sqlite3_create_function() or sqlite3_create_function16() multiple", "** times with the same function but with different values of eTextRep.", "** ^When multiple implementations of the same function are available, SQLite", "** will pick the one that involves the least amount of data conversion.", "** If there is only a single implementation which does not care what text", "** encoding is used, then the fourth argument should be [SQLITE_ANY].", "**", "** ^(The fifth parameter is an arbitrary pointer.  The implementation of the", "** function can gain access to this pointer using [sqlite3_user_data()].)^", "**", "** ^The sixth, seventh and eighth parameters, xFunc, xStep and xFinal, are", "** pointers to C-language functions that implement the SQL function or", "** aggregate. ^A scalar SQL function requires an implementation of the xFunc", "** callback only; NULL pointers must be passed as the xStep and xFinal", "** parameters. ^An aggregate SQL function requires an implementation of xStep", "** and xFinal and NULL pointer must be passed for xFunc. ^To delete an existing", "** SQL function or aggregate, pass NULL pointers for all three function", "** callbacks.", "**", "** ^(If the ninth parameter to sqlite3_create_function_v2() is not NULL,", "** then it is destructor for the application data pointer. ", "** The destructor is invoked when the function is deleted, either by being", "** overloaded or when the database connection closes.)^", "** ^The destructor is also invoked if the call to", "** sqlite3_create_function_v2() fails.", "** ^When the destructor callback of the tenth parameter is invoked, it", "** is passed a single argument which is a copy of the application data ", "** pointer which was the fifth parameter to sqlite3_create_function_v2().", "**", "** ^It is permitted to register multiple implementations of the same", "** functions with the same name but with either differing numbers of", "** arguments or differing preferred text encodings.  ^SQLite will use", "** the implementation that most closely matches the way in which the", "** SQL function is used.  ^A function implementation with a non-negative", "** nArg parameter is a better match than a function implementation with", "** a negative nArg.  ^A function where the preferred text encoding", "** matches the database encoding is a better", "** match than a function where the encoding is different.  ", "** ^A function where the encoding difference is between UTF16le and UTF16be", "** is a closer match than a function where the encoding difference is", "** between UTF8 and UTF16.", "**", "** ^Built-in functions may be overloaded by new application-defined functions.", "**", "** ^An application-defined function is permitted to call other", "** SQLite interfaces.  However, such calls must not", "** close the database connection nor finalize or reset the prepared", "** statement in which the function is running.", "*/", "SQLITE_API int sqlite3_create_function(", "  sqlite3 *db,", "  const char *zFunctionName,", "  int nArg,", "  int eTextRep,", "  void *pApp,", "  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),", "  void (*xStep)(sqlite3_context*,int,sqlite3_value**),", "  void (*xFinal)(sqlite3_context*)", ");", "SQLITE_API int sqlite3_create_function16(", "  sqlite3 *db,", "  const void *zFunctionName,", "  int nArg,", "  int eTextRep,", "  void *pApp,", "  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),", "  void (*xStep)(sqlite3_context*,int,sqlite3_value**),", "  void (*xFinal)(sqlite3_context*)", ");", "SQLITE_API int sqlite3_create_function_v2(", "  sqlite3 *db,", "  const char *zFunctionName,", "  int nArg,", "  int eTextRep,", "  void *pApp,", "  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),", "  void (*xStep)(sqlite3_context*,int,sqlite3_value**),", "  void (*xFinal)(sqlite3_context*),", "  void(*xDestroy)(void*)", ");", "", "/*", "** CAPI3REF: Text Encodings", "**", "** These constant define integer codes that represent the various", "** text encodings supported by SQLite.", "*/", "#define SQLITE_UTF8           1", "#define SQLITE_UTF16LE        2", "#define SQLITE_UTF16BE        3", "#define SQLITE_UTF16          4    /* Use native byte order */", "#define SQLITE_ANY            5    /* sqlite3_create_function only */", "#define SQLITE_UTF16_ALIGNED  8    /* sqlite3_create_collation only */", "", "/*", "** CAPI3REF: Deprecated Functions", "** DEPRECATED", "**", "** These functions are [deprecated].  In order to maintain", "** backwards compatibility with older code, these functions continue ", "** to be supported.  However, new applications should avoid", "** the use of these functions.  To help encourage people to avoid", "** using these functions, we are not going to tell you what they do.", "*/", "#ifndef SQLITE_OMIT_DEPRECATED", "SQLITE_API SQLITE_DEPRECATED int sqlite3_aggregate_count(sqlite3_context*);", "SQLITE_API SQLITE_DEPRECATED int sqlite3_expired(sqlite3_stmt*);", "SQLITE_API SQLITE_DEPRECATED int sqlite3_transfer_bindings(sqlite3_stmt*, sqlite3_stmt*);", "SQLITE_API SQLITE_DEPRECATED int sqlite3_global_recover(void);", "SQLITE_API SQLITE_DEPRECATED void sqlite3_thread_cleanup(void);", "SQLITE_API SQLITE_DEPRECATED int sqlite3_memory_alarm(void(*)(void*,sqlite3_int64,int),void*,sqlite3_int64);", "#endif", "", "/*", "** CAPI3REF: Obtaining SQL Function Parameter Values", "**", "** The C-language implementation of SQL functions and aggregates uses", "** this set of interface routines to access the parameter values on", "** the function or aggregate.", "**", "** The xFunc (for scalar functions) or xStep (for aggregates) parameters", "** to [sqlite3_create_function()] and [sqlite3_create_function16()]", "** define callbacks that implement the SQL functions and aggregates.", "** The 3rd parameter to these callbacks is an array of pointers to", "** [protected sqlite3_value] objects.  There is one [sqlite3_value] object for", "** each parameter to the SQL function.  These routines are used to", "** extract values from the [sqlite3_value] objects.", "**", "** These routines work only with [protected sqlite3_value] objects.", "** Any attempt to use these routines on an [unprotected sqlite3_value]", "** object results in undefined behavior.", "**", "** ^These routines work just like the corresponding [column access functions]", "** except that  these routines take a single [protected sqlite3_value] object", "** pointer instead of a [sqlite3_stmt*] pointer and an integer column number.", "**", "** ^The sqlite3_value_text16() interface extracts a UTF-16 string", "** in the native byte-order of the host machine.  ^The", "** sqlite3_value_text16be() and sqlite3_value_text16le() interfaces", "** extract UTF-16 strings as big-endian and little-endian respectively.", "**", "** ^(The sqlite3_value_numeric_type() interface attempts to apply", "** numeric affinity to the value.  This means that an attempt is", "** made to convert the value to an integer or floating point.  If", "** such a conversion is possible without loss of information (in other", "** words, if the value is a string that looks like a number)", "** then the conversion is performed.  Otherwise no conversion occurs.", "** The [SQLITE_INTEGER | datatype] after conversion is returned.)^", "**", "** Please pay particular attention to the fact that the pointer returned", "** from [sqlite3_value_blob()], [sqlite3_value_text()], or", "** [sqlite3_value_text16()] can be invalidated by a subsequent call to", "** [sqlite3_value_bytes()], [sqlite3_value_bytes16()], [sqlite3_value_text()],", "** or [sqlite3_value_text16()].", "**", "** These routines must be called from the same thread as", "** the SQL function that supplied the [sqlite3_value*] parameters.", "*/", "SQLITE_API const void *sqlite3_value_blob(sqlite3_value*);", "SQLITE_API int sqlite3_value_bytes(sqlite3_value*);", "SQLITE_API int sqlite3_value_bytes16(sqlite3_value*);", "SQLITE_API double sqlite3_value_double(sqlite3_value*);", "SQLITE_API int sqlite3_value_int(sqlite3_value*);", "SQLITE_API sqlite3_int64 sqlite3_value_int64(sqlite3_value*);", "SQLITE_API const unsigned char *sqlite3_value_text(sqlite3_value*);", "SQLITE_API const void *sqlite3_value_text16(sqlite3_value*);", "SQLITE_API const void *sqlite3_value_text16le(sqlite3_value*);", "SQLITE_API const void *sqlite3_value_text16be(sqlite3_value*);", "SQLITE_API int sqlite3_value_type(sqlite3_value*);", "SQLITE_API int sqlite3_value_numeric_type(sqlite3_value*);", "", "/*", "** CAPI3REF: Obtain Aggregate Function Context", "**", "** Implementations of aggregate SQL functions use this", "** routine to allocate memory for storing their state.", "**", "** ^The first time the sqlite3_aggregate_context(C,N) routine is called ", "** for a particular aggregate function, SQLite", "** allocates N of memory, zeroes out that memory, and returns a pointer", "** to the new memory. ^On second and subsequent calls to", "** sqlite3_aggregate_context() for the same aggregate function instance,", "** the same buffer is returned.  Sqlite3_aggregate_context() is normally", "** called once for each invocation of the xStep callback and then one", "** last time when the xFinal callback is invoked.  ^(When no rows match", "** an aggregate query, the xStep() callback of the aggregate function", "** implementation is never called and xFinal() is called exactly once.", "** In those cases, sqlite3_aggregate_context() might be called for the", "** first time from within xFinal().)^", "**", "** ^The sqlite3_aggregate_context(C,N) routine returns a NULL pointer if N is", "** less than or equal to zero or if a memory allocate error occurs.", "**", "** ^(The amount of space allocated by sqlite3_aggregate_context(C,N) is", "** determined by the N parameter on first successful call.  Changing the", "** value of N in subsequent call to sqlite3_aggregate_context() within", "** the same aggregate function instance will not resize the memory", "** allocation.)^", "**", "** ^SQLite automatically frees the memory allocated by ", "** sqlite3_aggregate_context() when the aggregate query concludes.", "**", "** The first parameter must be a copy of the", "** [sqlite3_context | SQL function context] that is the first parameter", "** to the xStep or xFinal callback routine that implements the aggregate", "** function.", "**", "** This routine must be called from the same thread in which", "** the aggregate SQL function is running.", "*/", "SQLITE_API void *sqlite3_aggregate_context(sqlite3_context*, int nBytes);", "", "/*", "** CAPI3REF: User Data For Functions", "**", "** ^The sqlite3_user_data() interface returns a copy of", "** the pointer that was the pUserData parameter (the 5th parameter)", "** of the [sqlite3_create_function()]", "** and [sqlite3_create_function16()] routines that originally", "** registered the application defined function.", "**", "** This routine must be called from the same thread in which", "** the application-defined function is running.", "*/", "SQLITE_API void *sqlite3_user_data(sqlite3_context*);", "", "/*", "** CAPI3REF: Database Connection For Functions", "**", "** ^The sqlite3_context_db_handle() interface returns a copy of", "** the pointer to the [database connection] (the 1st parameter)", "** of the [sqlite3_create_function()]", "** and [sqlite3_create_function16()] routines that originally", "** registered the application defined function.", "*/", "SQLITE_API sqlite3 *sqlite3_context_db_handle(sqlite3_context*);", "", "/*", "** CAPI3REF: Function Auxiliary Data", "**", "** The following two functions may be used by scalar SQL functions to", "** associate metadata with argument values. If the same value is passed to", "** multiple invocations of the same SQL function during query execution, under", "** some circumstances the associated metadata may be preserved. This may", "** be used, for example, to add a regular-expression matching scalar", "** function. The compiled version of the regular expression is stored as", "** metadata associated with the SQL value passed as the regular expression", "** pattern.  The compiled regular expression can be reused on multiple", "** invocations of the same function so that the original pattern string", "** does not need to be recompiled on each invocation.", "**", "** ^The sqlite3_get_auxdata() interface returns a pointer to the metadata", "** associated by the sqlite3_set_auxdata() function with the Nth argument", "** value to the application-defined function. ^If no metadata has been ever", "** been set for the Nth argument of the function, or if the corresponding", "** function parameter has changed since the meta-data was set,", "** then sqlite3_get_auxdata() returns a NULL pointer.", "**", "** ^The sqlite3_set_auxdata() interface saves the metadata", "** pointed to by its 3rd parameter as the metadata for the N-th", "** argument of the application-defined function.  Subsequent", "** calls to sqlite3_get_auxdata() might return this data, if it has", "** not been destroyed.", "** ^If it is not NULL, SQLite will invoke the destructor", "** function given by the 4th parameter to sqlite3_set_auxdata() on", "** the metadata when the corresponding function parameter changes", "** or when the SQL statement completes, whichever comes first.", "**", "** SQLite is free to call the destructor and drop metadata on any", "** parameter of any function at any time.  ^The only guarantee is that", "** the destructor will be called before the metadata is dropped.", "**", "** ^(In practice, metadata is preserved between function calls for", "** expressions that are constant at compile time. This includes literal", "** values and [parameters].)^", "**", "** These routines must be called from the same thread in which", "** the SQL function is running.", "*/", "SQLITE_API void *sqlite3_get_auxdata(sqlite3_context*, int N);", "SQLITE_API void sqlite3_set_auxdata(sqlite3_context*, int N, void*, void (*)(void*));", "", "", "/*", "** CAPI3REF: Constants Defining Special Destructor Behavior", "**", "** These are special values for the destructor that is passed in as the", "** final argument to routines like [sqlite3_result_blob()].  ^If the destructor", "** argument is SQLITE_STATIC, it means that the content pointer is constant", "** and will never change.  It does not need to be destroyed.  ^The", "** SQLITE_TRANSIENT value means that the content will likely change in", "** the near future and that SQLite should make its own private copy of", "** the content before returning.", "**", "** The typedef is necessary to work around problems in certain", "** C++ compilers.  See ticket #2191.", "*/", "typedef void (*sqlite3_destructor_type)(void*);", "#define SQLITE_STATIC      ((sqlite3_destructor_type)0)", "#define SQLITE_TRANSIENT   ((sqlite3_destructor_type)-1)", "", "/*", "** CAPI3REF: Setting The Result Of An SQL Function", "**", "** These routines are used by the xFunc or xFinal callbacks that", "** implement SQL functions and aggregates.  See", "** [sqlite3_create_function()] and [sqlite3_create_function16()]", "** for additional information.", "**", "** These functions work very much like the [parameter binding] family of", "** functions used to bind values to host parameters in prepared statements.", "** Refer to the [SQL parameter] documentation for additional information.", "**", "** ^The sqlite3_result_blob() interface sets the result from", "** an application-defined function to be the BLOB whose content is pointed", "** to by the second parameter and which is N bytes long where N is the", "** third parameter.", "**", "** ^The sqlite3_result_zeroblob() interfaces set the result of", "** the application-defined function to be a BLOB containing all zero", "** bytes and N bytes in size, where N is the value of the 2nd parameter.", "**", "** ^The sqlite3_result_double() interface sets the result from", "** an application-defined function to be a floating point value specified", "** by its 2nd argument.", "**", "** ^The sqlite3_result_error() and sqlite3_result_error16() functions", "** cause the implemented SQL function to throw an exception.", "** ^SQLite uses the string pointed to by the", "** 2nd parameter of sqlite3_result_error() or sqlite3_result_error16()", "** as the text of an error message.  ^SQLite interprets the error", "** message string from sqlite3_result_error() as UTF-8. ^SQLite", "** interprets the string from sqlite3_result_error16() as UTF-16 in native", "** byte order.  ^If the third parameter to sqlite3_result_error()", "** or sqlite3_result_error16() is negative then SQLite takes as the error", "** message all text up through the first zero character.", "** ^If the third parameter to sqlite3_result_error() or", "** sqlite3_result_error16() is non-negative then SQLite takes that many", "** bytes (not characters) from the 2nd parameter as the error message.", "** ^The sqlite3_result_error() and sqlite3_result_error16()", "** routines make a private copy of the error message text before", "** they return.  Hence, the calling function can deallocate or", "** modify the text after they return without harm.", "** ^The sqlite3_result_error_code() function changes the error code", "** returned by SQLite as a result of an error in a function.  ^By default,", "** the error code is SQLITE_ERROR.  ^A subsequent call to sqlite3_result_error()", "** or sqlite3_result_error16() resets the error code to SQLITE_ERROR.", "**", "** ^The sqlite3_result_toobig() interface causes SQLite to throw an error", "** indicating that a string or BLOB is too long to represent.", "**", "** ^The sqlite3_result_nomem() interface causes SQLite to throw an error", "** indicating that a memory allocation failed.", "**", "** ^The sqlite3_result_int() interface sets the return value", "** of the application-defined function to be the 32-bit signed integer", "** value given in the 2nd argument.", "** ^The sqlite3_result_int64() interface sets the return value", "** of the application-defined function to be the 64-bit signed integer", "** value given in the 2nd argument.", "**", "** ^The sqlite3_result_null() interface sets the return value", "** of the application-defined function to be NULL.", "**", "** ^The sqlite3_result_text(), sqlite3_result_text16(),", "** sqlite3_result_text16le(), and sqlite3_result_text16be() interfaces", "** set the return value of the application-defined function to be", "** a text string which is represented as UTF-8, UTF-16 native byte order,", "** UTF-16 little endian, or UTF-16 big endian, respectively.", "** ^SQLite takes the text result from the application from", "** the 2nd parameter of the sqlite3_result_text* interfaces.", "** ^If the 3rd parameter to the sqlite3_result_text* interfaces", "** is negative, then SQLite takes result text from the 2nd parameter", "** through the first zero character.", "** ^If the 3rd parameter to the sqlite3_result_text* interfaces", "** is non-negative, then as many bytes (not characters) of the text", "** pointed to by the 2nd parameter are taken as the application-defined", "** function result.  If the 3rd parameter is non-negative, then it", "** must be the byte offset into the string where the NUL terminator would", "** appear if the string where NUL terminated.  If any NUL characters occur", "** in the string at a byte offset that is less than the value of the 3rd", "** parameter, then the resulting string will contain embedded NULs and the", "** result of expressions operating on strings with embedded NULs is undefined.", "** ^If the 4th parameter to the sqlite3_result_text* interfaces", "** or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that", "** function as the destructor on the text or BLOB result when it has", "** finished using that result.", "** ^If the 4th parameter to the sqlite3_result_text* interfaces or to", "** sqlite3_result_blob is the special constant SQLITE_STATIC, then SQLite", "** assumes that the text or BLOB result is in constant space and does not", "** copy the content of the parameter nor call a destructor on the content", "** when it has finished using that result.", "** ^If the 4th parameter to the sqlite3_result_text* interfaces", "** or sqlite3_result_blob is the special constant SQLITE_TRANSIENT", "** then SQLite makes a copy of the result into space obtained from", "** from [sqlite3_malloc()] before it returns.", "**", "** ^The sqlite3_result_value() interface sets the result of", "** the application-defined function to be a copy the", "** [unprotected sqlite3_value] object specified by the 2nd parameter.  ^The", "** sqlite3_result_value() interface makes a copy of the [sqlite3_value]", "** so that the [sqlite3_value] specified in the parameter may change or", "** be deallocated after sqlite3_result_value() returns without harm.", "** ^A [protected sqlite3_value] object may always be used where an", "** [unprotected sqlite3_value] object is required, so either", "** kind of [sqlite3_value] object can be used with this interface.", "**", "** If these routines are called from within the different thread", "** than the one containing the application-defined function that received", "** the [sqlite3_context] pointer, the results are undefined.", "*/", "SQLITE_API void sqlite3_result_blob(sqlite3_context*, const void*, int, void(*)(void*));", "SQLITE_API void sqlite3_result_double(sqlite3_context*, double);", "SQLITE_API void sqlite3_result_error(sqlite3_context*, const char*, int);", "SQLITE_API void sqlite3_result_error16(sqlite3_context*, const void*, int);", "SQLITE_API void sqlite3_result_error_toobig(sqlite3_context*);", "SQLITE_API void sqlite3_result_error_nomem(sqlite3_context*);", "SQLITE_API void sqlite3_result_error_code(sqlite3_context*, int);", "SQLITE_API void sqlite3_result_int(sqlite3_context*, int);", "SQLITE_API void sqlite3_result_int64(sqlite3_context*, sqlite3_int64);", "SQLITE_API void sqlite3_result_null(sqlite3_context*);", "SQLITE_API void sqlite3_result_text(sqlite3_context*, const char*, int, void(*)(void*));", "SQLITE_API void sqlite3_result_text16(sqlite3_context*, const void*, int, void(*)(void*));", "SQLITE_API void sqlite3_result_text16le(sqlite3_context*, const void*, int,void(*)(void*));", "SQLITE_API void sqlite3_result_text16be(sqlite3_context*, const void*, int,void(*)(void*));", "SQLITE_API void sqlite3_result_value(sqlite3_context*, sqlite3_value*);", "SQLITE_API void sqlite3_result_zeroblob(sqlite3_context*, int n);", "", "/*", "** CAPI3REF: Define New Collating Sequences", "**", "** ^These functions add, remove, or modify a [collation] associated", "** with the [database connection] specified as the first argument.", "**", "** ^The name of the collation is a UTF-8 string", "** for sqlite3_create_collation() and sqlite3_create_collation_v2()", "** and a UTF-16 string in native byte order for sqlite3_create_collation16().", "** ^Collation names that compare equal according to [sqlite3_strnicmp()] are", "** considered to be the same name.", "**", "** ^(The third argument (eTextRep) must be one of the constants:", "** <ul>", "** <li> [SQLITE_UTF8],", "** <li> [SQLITE_UTF16LE],", "** <li> [SQLITE_UTF16BE],", "** <li> [SQLITE_UTF16], or", "** <li> [SQLITE_UTF16_ALIGNED].", "** </ul>)^", "** ^The eTextRep argument determines the encoding of strings passed", "** to the collating function callback, xCallback.", "** ^The [SQLITE_UTF16] and [SQLITE_UTF16_ALIGNED] values for eTextRep", "** force strings to be UTF16 with native byte order.", "** ^The [SQLITE_UTF16_ALIGNED] value for eTextRep forces strings to begin", "** on an even byte address.", "**", "** ^The fourth argument, pArg, is an application data pointer that is passed", "** through as the first argument to the collating function callback.", "**", "** ^The fifth argument, xCallback, is a pointer to the collating function.", "** ^Multiple collating functions can be registered using the same name but", "** with different eTextRep parameters and SQLite will use whichever", "** function requires the least amount of data transformation.", "** ^If the xCallback argument is NULL then the collating function is", "** deleted.  ^When all collating functions having the same name are deleted,", "** that collation is no longer usable.", "**", "** ^The collating function callback is invoked with a copy of the pArg ", "** application data pointer and with two strings in the encoding specified", "** by the eTextRep argument.  The collating function must return an", "** integer that is negative, zero, or positive", "** if the first string is less than, equal to, or greater than the second,", "** respectively.  A collating function must always return the same answer", "** given the same inputs.  If two or more collating functions are registered", "** to the same collation name (using different eTextRep values) then all", "** must give an equivalent answer when invoked with equivalent strings.", "** The collating function must obey the following properties for all", "** strings A, B, and C:", "**", "** <ol>", "** <li> If A==B then B==A.", "** <li> If A==B and B==C then A==C.", "** <li> If A&lt;B THEN B&gt;A.", "** <li> If A&lt;B and B&lt;C then A&lt;C.", "** </ol>", "**", "** If a collating function fails any of the above constraints and that", "** collating function is  registered and used, then the behavior of SQLite", "** is undefined.", "**", "** ^The sqlite3_create_collation_v2() works like sqlite3_create_collation()", "** with the addition that the xDestroy callback is invoked on pArg when", "** the collating function is deleted.", "** ^Collating functions are deleted when they are overridden by later", "** calls to the collation creation functions or when the", "** [database connection] is closed using [sqlite3_close()].", "**", "** ^The xDestroy callback is <u>not</u> called if the ", "** sqlite3_create_collation_v2() function fails.  Applications that invoke", "** sqlite3_create_collation_v2() with a non-NULL xDestroy argument should ", "** check the return code and dispose of the application data pointer", "** themselves rather than expecting SQLite to deal with it for them.", "** This is different from every other SQLite interface.  The inconsistency ", "** is unfortunate but cannot be changed without breaking backwards ", "** compatibility.", "**", "** See also:  [sqlite3_collation_needed()] and [sqlite3_collation_needed16()].", "*/", "SQLITE_API int sqlite3_create_collation(", "  sqlite3*, ", "  const char *zName, ", "  int eTextRep, ", "  void *pArg,", "  int(*xCompare)(void*,int,const void*,int,const void*)", ");", "SQLITE_API int sqlite3_create_collation_v2(", "  sqlite3*, ", "  const char *zName, ", "  int eTextRep, ", "  void *pArg,", "  int(*xCompare)(void*,int,const void*,int,const void*),", "  void(*xDestroy)(void*)", ");", "SQLITE_API int sqlite3_create_collation16(", "  sqlite3*, ", "  const void *zName,", "  int eTextRep, ", "  void *pArg,", "  int(*xCompare)(void*,int,const void*,int,const void*)", ");", "", "/*", "** CAPI3REF: Collation Needed Callbacks", "**", "** ^To avoid having to register all collation sequences before a database", "** can be used, a single callback function may be registered with the", "** [database connection] to be invoked whenever an undefined collation", "** sequence is required.", "**", "** ^If the function is registered using the sqlite3_collation_needed() API,", "** then it is passed the names of undefined collation sequences as strings", "** encoded in UTF-8. ^If sqlite3_collation_needed16() is used,", "** the names are passed as UTF-16 in machine native byte order.", "** ^A call to either function replaces the existing collation-needed callback.", "**", "** ^(When the callback is invoked, the first argument passed is a copy", "** of the second argument to sqlite3_collation_needed() or", "** sqlite3_collation_needed16().  The second argument is the database", "** connection.  The third argument is one of [SQLITE_UTF8], [SQLITE_UTF16BE],", "** or [SQLITE_UTF16LE], indicating the most desirable form of the collation", "** sequence function required.  The fourth parameter is the name of the", "** required collation sequence.)^", "**", "** The callback function should register the desired collation using", "** [sqlite3_create_collation()], [sqlite3_create_collation16()], or", "** [sqlite3_create_collation_v2()].", "*/", "SQLITE_API int sqlite3_collation_needed(", "  sqlite3*, ", "  void*, ", "  void(*)(void*,sqlite3*,int eTextRep,const char*)", ");", "SQLITE_API int sqlite3_collation_needed16(", "  sqlite3*, ", "  void*,", "  void(*)(void*,sqlite3*,int eTextRep,const void*)", ");", "", "#ifdef SQLITE_HAS_CODEC", "/*", "** Specify the key for an encrypted database.  This routine should be", "** called right after sqlite3_open().", "**", "** The code to implement this API is not available in the public release", "** of SQLite.", "*/", "SQLITE_API int sqlite3_key(", "  sqlite3 *db,                   /* Database to be rekeyed */", "  const void *pKey, int nKey     /* The key */", ");", "", "/*", "** Change the key on an open database.  If the current database is not", "** encrypted, this routine will encrypt it.  If pNew==0 or nNew==0, the", "** database is decrypted.", "**", "** The code to implement this API is not available in the public release", "** of SQLite.", "*/", "SQLITE_API int sqlite3_rekey(", "  sqlite3 *db,                   /* Database to be rekeyed */", "  const void *pKey, int nKey     /* The new key */", ");", "", "/*", "** Specify the activation key for a SEE database.  Unless ", "** activated, none of the SEE routines will work.", "*/", "SQLITE_API void sqlite3_activate_see(", "  const char *zPassPhrase        /* Activation phrase */", ");", "#endif", "", "#ifdef SQLITE_ENABLE_CEROD", "/*", "** Specify the activation key for a CEROD database.  Unless ", "** activated, none of the CEROD routines will work.", "*/", "SQLITE_API void sqlite3_activate_cerod(", "  const char *zPassPhrase        /* Activation phrase */", ");", "#endif", "", "/*", "** CAPI3REF: Suspend Execution For A Short Time", "**", "** The sqlite3_sleep() function causes the current thread to suspend execution", "** for at least a number of milliseconds specified in its parameter.", "**", "** If the operating system does not support sleep requests with", "** millisecond time resolution, then the time will be rounded up to", "** the nearest second. The number of milliseconds of sleep actually", "** requested from the operating system is returned.", "**", "** ^SQLite implements this interface by calling the xSleep()", "** method of the default [sqlite3_vfs] object.  If the xSleep() method", "** of the default VFS is not implemented correctly, or not implemented at", "** all, then the behavior of sqlite3_sleep() may deviate from the description", "** in the previous paragraphs.", "*/", "SQLITE_API int sqlite3_sleep(int);", "", "/*", "** CAPI3REF: Name Of The Folder Holding Temporary Files", "**", "** ^(If this global variable is made to point to a string which is", "** the name of a folder (a.k.a. directory), then all temporary files", "** created by SQLite when using a built-in [sqlite3_vfs | VFS]", "** will be placed in that directory.)^  ^If this variable", "** is a NULL pointer, then SQLite performs a search for an appropriate", "** temporary file directory.", "**", "** It is not safe to read or modify this variable in more than one", "** thread at a time.  It is not safe to read or modify this variable", "** if a [database connection] is being used at the same time in a separate", "** thread.", "** It is intended that this variable be set once", "** as part of process initialization and before any SQLite interface", "** routines have been called and that this variable remain unchanged", "** thereafter.", "**", "** ^The [temp_store_directory pragma] may modify this variable and cause", "** it to point to memory obtained from [sqlite3_malloc].  ^Furthermore,", "** the [temp_store_directory pragma] always assumes that any string", "** that this variable points to is held in memory obtained from ", "** [sqlite3_malloc] and the pragma may attempt to free that memory", "** using [sqlite3_free].", "** Hence, if this variable is modified directly, either it should be", "** made NULL or made to point to memory obtained from [sqlite3_malloc]", "** or else the use of the [temp_store_directory pragma] should be avoided.", "*/", "SQLITE_API SQLITE_EXTERN char *sqlite3_temp_directory;", "", "/*", "** CAPI3REF: Name Of The Folder Holding Database Files", "**", "** ^(If this global variable is made to point to a string which is", "** the name of a folder (a.k.a. directory), then all database files", "** specified with a relative pathname and created or accessed by", "** SQLite when using a built-in windows [sqlite3_vfs | VFS] will be assumed", "** to be relative to that directory.)^ ^If this variable is a NULL", "** pointer, then SQLite assumes that all database files specified", "** with a relative pathname are relative to the current directory", "** for the process.  Only the windows VFS makes use of this global", "** variable; it is ignored by the unix VFS.", "**", "** Changing the value of this variable while a database connection is", "** open can result in a corrupt database.", "**", "** It is not safe to read or modify this variable in more than one", "** thread at a time.  It is not safe to read or modify this variable", "** if a [database connection] is being used at the same time in a separate", "** thread.", "** It is intended that this variable be set once", "** as part of process initialization and before any SQLite interface", "** routines have been called and that this variable remain unchanged", "** thereafter.", "**", "** ^The [data_store_directory pragma] may modify this variable and cause", "** it to point to memory obtained from [sqlite3_malloc].  ^Furthermore,", "** the [data_store_directory pragma] always assumes that any string", "** that this variable points to is held in memory obtained from ", "** [sqlite3_malloc] and the pragma may attempt to free that memory", "** using [sqlite3_free].", "** Hence, if this variable is modified directly, either it should be", "** made NULL or made to point to memory obtained from [sqlite3_malloc]", "** or else the use of the [data_store_directory pragma] should be avoided.", "*/", "SQLITE_API SQLITE_EXTERN char *sqlite3_data_directory;", "", "/*", "** CAPI3REF: Test For Auto-Commit Mode", "** KEYWORDS: {autocommit mode}", "**", "** ^The sqlite3_get_autocommit() interface returns non-zero or", "** zero if the given database connection is or is not in autocommit mode,", "** respectively.  ^Autocommit mode is on by default.", "** ^Autocommit mode is disabled by a [BEGIN] statement.", "** ^Autocommit mode is re-enabled by a [COMMIT] or [ROLLBACK].", "**", "** If certain kinds of errors occur on a statement within a multi-statement", "** transaction (errors including [SQLITE_FULL], [SQLITE_IOERR],", "** [SQLITE_NOMEM], [SQLITE_BUSY], and [SQLITE_INTERRUPT]) then the", "** transaction might be rolled back automatically.  The only way to", "** find out whether SQLite automatically rolled back the transaction after", "** an error is to use this function.", "**", "** If another thread changes the autocommit status of the database", "** connection while this routine is running, then the return value", "** is undefined.", "*/", "SQLITE_API int sqlite3_get_autocommit(sqlite3*);", "", "/*", "** CAPI3REF: Find The Database Handle Of A Prepared Statement", "**", "** ^The sqlite3_db_handle interface returns the [database connection] handle", "** to which a [prepared statement] belongs.  ^The [database connection]", "** returned by sqlite3_db_handle is the same [database connection]", "** that was the first argument", "** to the [sqlite3_prepare_v2()] call (or its variants) that was used to", "** create the statement in the first place.", "*/", "SQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt*);", "", "/*", "** CAPI3REF: Return The Filename For A Database Connection", "**", "** ^The sqlite3_db_filename(D,N) interface returns a pointer to a filename", "** associated with database N of connection D.  ^The main database file", '** has the name "main".  If there is no attached database N on the database', "** connection D, or if database N is a temporary or in-memory database, then", "** a NULL pointer is returned.", "**", "** ^The filename returned by this function is the output of the", "** xFullPathname method of the [VFS].  ^In other words, the filename", "** will be an absolute pathname, even if the filename used", "** to open the database originally was a URI or relative pathname.", "*/", "SQLITE_API const char *sqlite3_db_filename(sqlite3 *db, const char *zDbName);", "", "/*", "** CAPI3REF: Determine if a database is read-only", "**", "** ^The sqlite3_db_readonly(D,N) interface returns 1 if the database N", "** of connection D is read-only, 0 if it is read/write, or -1 if N is not", "** the name of a database on connection D.", "*/", "SQLITE_API int sqlite3_db_readonly(sqlite3 *db, const char *zDbName);", "", "/*", "** CAPI3REF: Find the next prepared statement", "**", "** ^This interface returns a pointer to the next [prepared statement] after", "** pStmt associated with the [database connection] pDb.  ^If pStmt is NULL", "** then this interface returns a pointer to the first prepared statement", "** associated with the database connection pDb.  ^If no prepared statement", "** satisfies the conditions of this routine, it returns NULL.", "**", "** The [database connection] pointer D in a call to", "** [sqlite3_next_stmt(D,S)] must refer to an open database", "** connection and in particular must not be a NULL pointer.", "*/", "SQLITE_API sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt);", "", "/*", "** CAPI3REF: Commit And Rollback Notification Callbacks", "**", "** ^The sqlite3_commit_hook() interface registers a callback", "** function to be invoked whenever a transaction is [COMMIT | committed].", "** ^Any callback set by a previous call to sqlite3_commit_hook()", "** for the same database connection is overridden.", "** ^The sqlite3_rollback_hook() interface registers a callback", "** function to be invoked whenever a transaction is [ROLLBACK | rolled back].", "** ^Any callback set by a previous call to sqlite3_rollback_hook()", "** for the same database connection is overridden.", "** ^The pArg argument is passed through to the callback.", "** ^If the callback on a commit hook function returns non-zero,", "** then the commit is converted into a rollback.", "**", "** ^The sqlite3_commit_hook(D,C,P) and sqlite3_rollback_hook(D,C,P) functions", "** return the P argument from the previous call of the same function", "** on the same [database connection] D, or NULL for", "** the first call for each function on D.", "**", "** The commit and rollback hook callbacks are not reentrant.", "** The callback implementation must not do anything that will modify", "** the database connection that invoked the callback.  Any actions", "** to modify the database connection must be deferred until after the", "** completion of the [sqlite3_step()] call that triggered the commit", "** or rollback hook in the first place.", "** Note that running any other SQL statements, including SELECT statements,", "** or merely calling [sqlite3_prepare_v2()] and [sqlite3_step()] will modify", '** the database connections for the meaning of "modify" in this paragraph.', "**", "** ^Registering a NULL function disables the callback.", "**", "** ^When the commit hook callback routine returns zero, the [COMMIT]", "** operation is allowed to continue normally.  ^If the commit hook", "** returns non-zero, then the [COMMIT] is converted into a [ROLLBACK].", "** ^The rollback hook is invoked on a rollback that results from a commit", "** hook returning non-zero, just as it would be with any other rollback.", "**", "** ^For the purposes of this API, a transaction is said to have been", '** rolled back if an explicit "ROLLBACK" statement is executed, or', "** an error or constraint causes an implicit rollback to occur.", "** ^The rollback callback is not invoked if a transaction is", "** automatically rolled back because the database connection is closed.", "**", "** See also the [sqlite3_update_hook()] interface.", "*/", "SQLITE_API void *sqlite3_commit_hook(sqlite3*, int(*)(void*), void*);", "SQLITE_API void *sqlite3_rollback_hook(sqlite3*, void(*)(void *), void*);", "", "/*", "** CAPI3REF: Data Change Notification Callbacks", "**", "** ^The sqlite3_update_hook() interface registers a callback function", "** with the [database connection] identified by the first argument", "** to be invoked whenever a row is updated, inserted or deleted.", "** ^Any callback set by a previous call to this function", "** for the same database connection is overridden.", "**", "** ^The second argument is a pointer to the function to invoke when a", "** row is updated, inserted or deleted.", "** ^The first argument to the callback is a copy of the third argument", "** to sqlite3_update_hook().", "** ^The second callback argument is one of [SQLITE_INSERT], [SQLITE_DELETE],", "** or [SQLITE_UPDATE], depending on the operation that caused the callback", "** to be invoked.", "** ^The third and fourth arguments to the callback contain pointers to the", "** database and table name containing the affected row.", "** ^The final callback parameter is the [rowid] of the row.", "** ^In the case of an update, this is the [rowid] after the update takes place.", "**", "** ^(The update hook is not invoked when internal system tables are", "** modified (i.e. sqlite_master and sqlite_sequence).)^", "**", "** ^In the current implementation, the update hook", "** is not invoked when duplication rows are deleted because of an", "** [ON CONFLICT | ON CONFLICT REPLACE] clause.  ^Nor is the update hook", "** invoked when rows are deleted using the [truncate optimization].", "** The exceptions defined in this paragraph might change in a future", "** release of SQLite.", "**", "** The update hook implementation must not do anything that will modify", "** the database connection that invoked the update hook.  Any actions", "** to modify the database connection must be deferred until after the", "** completion of the [sqlite3_step()] call that triggered the update hook.", "** Note that [sqlite3_prepare_v2()] and [sqlite3_step()] both modify their", '** database connections for the meaning of "modify" in this paragraph.', "**", "** ^The sqlite3_update_hook(D,C,P) function", "** returns the P argument from the previous call", "** on the same [database connection] D, or NULL for", "** the first call on D.", "**", "** See also the [sqlite3_commit_hook()] and [sqlite3_rollback_hook()]", "** interfaces.", "*/", "SQLITE_API void *sqlite3_update_hook(", "  sqlite3*, ", "  void(*)(void *,int ,char const *,char const *,sqlite3_int64),", "  void*", ");", "", "/*", "** CAPI3REF: Enable Or Disable Shared Pager Cache", "**", "** ^(This routine enables or disables the sharing of the database cache", "** and schema data structures between [database connection | connections]", "** to the same database. Sharing is enabled if the argument is true", "** and disabled if the argument is false.)^", "**", "** ^Cache sharing is enabled and disabled for an entire process.", "** This is a change as of SQLite version 3.5.0. In prior versions of SQLite,", "** sharing was enabled or disabled for each thread separately.", "**", "** ^(The cache sharing mode set by this interface effects all subsequent", "** calls to [sqlite3_open()], [sqlite3_open_v2()], and [sqlite3_open16()].", "** Existing database connections continue use the sharing mode", "** that was in effect at the time they were opened.)^", "**", "** ^(This routine returns [SQLITE_OK] if shared cache was enabled or disabled", "** successfully.  An [error code] is returned otherwise.)^", "**", "** ^Shared cache is disabled by default. But this might change in", "** future releases of SQLite.  Applications that care about shared", "** cache setting should set it explicitly.", "**", "** ^Note: This method is deprecated on MacOS X 10.7 and iOS version 5.0", "** and will always return SQLITE_MISUSE, instead of calling this function", "** shared cache mode should be enabled per-database connection via ", "** sqlite3_open_v2 with SQLITE_OPEN_SHAREDCACHE instead.", "**", "** See Also:  [SQLite Shared-Cache Mode]", "*/", "SQLITE_API int sqlite3_enable_shared_cache(int) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_7, __IPHONE_2_0, __IPHONE_5_0);", "", "/*", "** CAPI3REF: Attempt To Free Heap Memory", "**", "** ^The sqlite3_release_memory() interface attempts to free N bytes", "** of heap memory by deallocating non-essential memory allocations", "** held by the database library.   Memory used to cache database", "** pages to improve performance is an example of non-essential memory.", "** ^sqlite3_release_memory() returns the number of bytes actually freed,", "** which might be more or less than the amount requested.", "** ^The sqlite3_release_memory() routine is a no-op returning zero", "** if SQLite is not compiled with [SQLITE_ENABLE_MEMORY_MANAGEMENT].", "**", "** See also: [sqlite3_db_release_memory()]", "*/", "SQLITE_API int sqlite3_release_memory(int);", "", "/*", "** CAPI3REF: Free Memory Used By A Database Connection", "**", "** ^The sqlite3_db_release_memory(D) interface attempts to free as much heap", "** memory as possible from database connection D. Unlike the", "** [sqlite3_release_memory()] interface, this interface is effect even", "** when then [SQLITE_ENABLE_MEMORY_MANAGEMENT] compile-time option is", "** omitted.", "**", "** See also: [sqlite3_release_memory()]", "*/", "SQLITE_API int sqlite3_db_release_memory(sqlite3*);", "", "/*", "** CAPI3REF: Impose A Limit On Heap Size", "**", "** ^The sqlite3_soft_heap_limit64() interface sets and/or queries the", "** soft limit on the amount of heap memory that may be allocated by SQLite.", "** ^SQLite strives to keep heap memory utilization below the soft heap", "** limit by reducing the number of pages held in the page cache", "** as heap memory usages approaches the limit.", '** ^The soft heap limit is "soft" because even though SQLite strives to stay', "** below the limit, it will exceed the limit rather than generate", "** an [SQLITE_NOMEM] error.  In other words, the soft heap limit ", "** is advisory only.", "**", "** ^The return value from sqlite3_soft_heap_limit64() is the size of", "** the soft heap limit prior to the call, or negative in the case of an", "** error.  ^If the argument N is negative", "** then no change is made to the soft heap limit.  Hence, the current", "** size of the soft heap limit can be determined by invoking", "** sqlite3_soft_heap_limit64() with a negative argument.", "**", "** ^If the argument N is zero then the soft heap limit is disabled.", "**", "** ^(The soft heap limit is not enforced in the current implementation", "** if one or more of following conditions are true:", "**", "** <ul>", "** <li> The soft heap limit is set to zero.", "** <li> Memory accounting is disabled using a combination of the", "**      [sqlite3_config]([SQLITE_CONFIG_MEMSTATUS],...) start-time option and", "**      the [SQLITE_DEFAULT_MEMSTATUS] compile-time option.", "** <li> An alternative page cache implementation is specified using", "**      [sqlite3_config]([SQLITE_CONFIG_PCACHE2],...).", "** <li> The page cache allocates from its own memory pool supplied", "**      by [sqlite3_config]([SQLITE_CONFIG_PAGECACHE],...) rather than", "**      from the heap.", "** </ul>)^", "**", "** Beginning with SQLite version 3.7.3, the soft heap limit is enforced", "** regardless of whether or not the [SQLITE_ENABLE_MEMORY_MANAGEMENT]", "** compile-time option is invoked.  With [SQLITE_ENABLE_MEMORY_MANAGEMENT],", "** the soft heap limit is enforced on every memory allocation.  Without", "** [SQLITE_ENABLE_MEMORY_MANAGEMENT], the soft heap limit is only enforced", "** when memory is allocated by the page cache.  Testing suggests that because", "** the page cache is the predominate memory user in SQLite, most", "** applications will achieve adequate soft heap limit enforcement without", "** the use of [SQLITE_ENABLE_MEMORY_MANAGEMENT].", "**", "** The circumstances under which SQLite will enforce the soft heap limit may", "** changes in future releases of SQLite.", "*/", "SQLITE_API sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 N);", "", "/*", "** CAPI3REF: Deprecated Soft Heap Limit Interface", "** DEPRECATED", "**", "** This is a deprecated version of the [sqlite3_soft_heap_limit64()]", "** interface.  This routine is provided for historical compatibility", "** only.  All new applications should use the", "** [sqlite3_soft_heap_limit64()] interface rather than this one.", "*/", "SQLITE_API SQLITE_DEPRECATED void sqlite3_soft_heap_limit(int N);", "", "", "/*", "** CAPI3REF: Extract Metadata About A Column Of A Table", "**", "** ^This routine returns metadata about a specific column of a specific", "** database table accessible using the [database connection] handle", "** passed as the first function argument.", "**", "** ^The column is identified by the second, third and fourth parameters to", "** this function. ^The second parameter is either the name of the database", '** (i.e. "main", "temp", or an attached database) containing the specified', "** table or NULL. ^If it is NULL, then all attached databases are searched", "** for the table using the same algorithm used by the database engine to", "** resolve unqualified table references.", "**", "** ^The third and fourth parameters to this function are the table and column", "** name of the desired column, respectively. Neither of these parameters", "** may be NULL.", "**", "** ^Metadata is returned by writing to the memory locations passed as the 5th", "** and subsequent parameters to this function. ^Any of these arguments may be", "** NULL, in which case the corresponding element of metadata is omitted.", "**", "** ^(<blockquote>", '** <table border="1">', "** <tr><th> Parameter <th> Output<br>Type <th>  Description", "**", "** <tr><td> 5th <td> const char* <td> Data type", "** <tr><td> 6th <td> const char* <td> Name of default collation sequence", "** <tr><td> 7th <td> int         <td> True if column has a NOT NULL constraint", "** <tr><td> 8th <td> int         <td> True if column is part of the PRIMARY KEY", "** <tr><td> 9th <td> int         <td> True if column is [AUTOINCREMENT]", "** </table>", "** </blockquote>)^", "**", "** ^The memory pointed to by the character pointers returned for the", "** declaration type and collation sequence is valid only until the next", "** call to any SQLite API function.", "**", "** ^If the specified table is actually a view, an [error code] is returned.", "**", '** ^If the specified column is "rowid", "oid" or "_rowid_" and an', "** [INTEGER PRIMARY KEY] column has been explicitly declared, then the output", "** parameters are set for the explicitly declared column. ^(If there is no", "** explicitly declared [INTEGER PRIMARY KEY] column, then the output", "** parameters are set as follows:", "**", "** <pre>", '**     data type: "INTEGER"', '**     collation sequence: "BINARY"', "**     not null: 0", "**     primary key: 1", "**     auto increment: 0", "** </pre>)^", "**", "** ^(This function may load one or more schemas from database files. If an", "** error occurs during this process, or if the requested table or column", "** cannot be found, an [error code] is returned and an error message left", "** in the [database connection] (to be retrieved using sqlite3_errmsg()).)^", "**", "** ^This API is only available if the library was compiled with the", "** [SQLITE_ENABLE_COLUMN_METADATA] C-preprocessor symbol defined.", "*/", "SQLITE_API int sqlite3_table_column_metadata(", "  sqlite3 *db,                /* Connection handle */", "  const char *zDbName,        /* Database name or NULL */", "  const char *zTableName,     /* Table name */", "  const char *zColumnName,    /* Column name */", "  char const **pzDataType,    /* OUTPUT: Declared data type */", "  char const **pzCollSeq,     /* OUTPUT: Collation sequence name */", "  int *pNotNull,              /* OUTPUT: True if NOT NULL constraint exists */", "  int *pPrimaryKey,           /* OUTPUT: True if column part of PK */", "  int *pAutoinc               /* OUTPUT: True if column is auto-increment */", ");", "", "/*", "** CAPI3REF: Load An Extension", "**", "** ^This interface loads an SQLite extension library from the named file.", "**", "** ^The sqlite3_load_extension() interface attempts to load an", "** SQLite extension library contained in the file zFile.", "**", "** ^The entry point is zProc.", "** ^zProc may be 0, in which case the name of the entry point", '** defaults to "sqlite3_extension_init".', "** ^The sqlite3_load_extension() interface returns", "** [SQLITE_OK] on success and [SQLITE_ERROR] if something goes wrong.", "** ^If an error occurs and pzErrMsg is not 0, then the", "** [sqlite3_load_extension()] interface shall attempt to", "** fill *pzErrMsg with error message text stored in memory", "** obtained from [sqlite3_malloc()]. The calling function", "** should free this memory by calling [sqlite3_free()].", "**", "** ^Extension loading must be enabled using", "** [sqlite3_enable_load_extension()] prior to calling this API,", "** otherwise an error will be returned.", "**", "** See also the [load_extension() SQL function].", "*/", "SQLITE_API int sqlite3_load_extension(", "  sqlite3 *db,          /* Load the extension into this database connection */", "  const char *zFile,    /* Name of the shared library containing extension */", "  const char *zProc,    /* Entry point.  Derived from zFile if 0 */", "  char **pzErrMsg       /* Put error message here if not 0 */", ");", "", "/*", "** CAPI3REF: Enable Or Disable Extension Loading", "**", "** ^So as not to open security holes in older applications that are", "** unprepared to deal with extension loading, and as a means of disabling", "** extension loading while evaluating user-entered SQL, the following API", "** is provided to turn the [sqlite3_load_extension()] mechanism on and off.", "**", "** ^Extension loading is off by default. See ticket #1863.", "** ^Call the sqlite3_enable_load_extension() routine with onoff==1", "** to turn extension loading on and call it with onoff==0 to turn", "** it back off again.", "*/", "SQLITE_API int sqlite3_enable_load_extension(sqlite3 *db, int onoff);", "", "/*", "** CAPI3REF: Automatically Load Statically Linked Extensions", "**", "** ^This interface causes the xEntryPoint() function to be invoked for", "** each new [database connection] that is created.  The idea here is that", "** xEntryPoint() is the entry point for a statically linked SQLite extension", "** that is to be automatically loaded into all new database connections.", "**", "** ^(Even though the function prototype shows that xEntryPoint() takes", "** no arguments and returns void, SQLite invokes xEntryPoint() with three", "** arguments and expects and integer result as if the signature of the", "** entry point where as follows:", "**", "** <blockquote><pre>", "** &nbsp;  int xEntryPoint(", "** &nbsp;    sqlite3 *db,", "** &nbsp;    const char **pzErrMsg,", "** &nbsp;    const struct sqlite3_api_routines *pThunk", "** &nbsp;  );", "** </pre></blockquote>)^", "**", "** If the xEntryPoint routine encounters an error, it should make *pzErrMsg", "** point to an appropriate error message (obtained from [sqlite3_mprintf()])", "** and return an appropriate [error code].  ^SQLite ensures that *pzErrMsg", "** is NULL before calling the xEntryPoint().  ^SQLite will invoke", "** [sqlite3_free()] on *pzErrMsg after xEntryPoint() returns.  ^If any", "** xEntryPoint() returns an error, the [sqlite3_open()], [sqlite3_open16()],", "** or [sqlite3_open_v2()] call that provoked the xEntryPoint() will fail.", "**", "** ^Calling sqlite3_auto_extension(X) with an entry point X that is already", "** on the list of automatic extensions is a harmless no-op. ^No entry point", "** will be called more than once for each database connection that is opened.", "**", "** See also: [sqlite3_reset_auto_extension()].", "*/", "SQLITE_API int sqlite3_auto_extension(void (*xEntryPoint)(void));", "", "/*", "** CAPI3REF: Reset Automatic Extension Loading", "**", "** ^This interface disables all automatic extensions previously", "** registered using [sqlite3_auto_extension()].", "*/", "SQLITE_API void sqlite3_reset_auto_extension(void);", "", "/*", "** The interface to the virtual-table mechanism is currently considered", "** to be experimental.  The interface might change in incompatible ways.", "** If this is a problem for you, do not use the interface at this time.", "**", "** When the virtual-table mechanism stabilizes, we will declare the", "** interface fixed, support it indefinitely, and remove this comment.", "*/", "", "/*", "** Structures used by the virtual table interface", "*/", "typedef struct sqlite3_vtab sqlite3_vtab;", "typedef struct sqlite3_index_info sqlite3_index_info;", "typedef struct sqlite3_vtab_cursor sqlite3_vtab_cursor;", "typedef struct sqlite3_module sqlite3_module;", "", "/*", "** CAPI3REF: Virtual Table Object", "** KEYWORDS: sqlite3_module {virtual table module}", "**", '** This structure, sometimes called a "virtual table module", ', "** defines the implementation of a [virtual tables].  ", "** This structure consists mostly of methods for the module.", "**", "** ^A virtual table module is created by filling in a persistent", "** instance of this structure and passing a pointer to that instance", "** to [sqlite3_create_module()] or [sqlite3_create_module_v2()].", "** ^The registration remains valid until it is replaced by a different", "** module or until the [database connection] closes.  The content", "** of this structure must not change while it is registered with", "** any database connection.", "*/", "struct sqlite3_module {", "  int iVersion;", "  int (*xCreate)(sqlite3*, void *pAux,", "               int argc, const char *const*argv,", "               sqlite3_vtab **ppVTab, char**);", "  int (*xConnect)(sqlite3*, void *pAux,", "               int argc, const char *const*argv,", "               sqlite3_vtab **ppVTab, char**);", "  int (*xBestIndex)(sqlite3_vtab *pVTab, sqlite3_index_info*);", "  int (*xDisconnect)(sqlite3_vtab *pVTab);", "  int (*xDestroy)(sqlite3_vtab *pVTab);", "  int (*xOpen)(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor);", "  int (*xClose)(sqlite3_vtab_cursor*);", "  int (*xFilter)(sqlite3_vtab_cursor*, int idxNum, const char *idxStr,", "                int argc, sqlite3_value **argv);", "  int (*xNext)(sqlite3_vtab_cursor*);", "  int (*xEof)(sqlite3_vtab_cursor*);", "  int (*xColumn)(sqlite3_vtab_cursor*, sqlite3_context*, int);", "  int (*xRowid)(sqlite3_vtab_cursor*, sqlite3_int64 *pRowid);", "  int (*xUpdate)(sqlite3_vtab *, int, sqlite3_value **, sqlite3_int64 *);", "  int (*xBegin)(sqlite3_vtab *pVTab);", "  int (*xSync)(sqlite3_vtab *pVTab);", "  int (*xCommit)(sqlite3_vtab *pVTab);", "  int (*xRollback)(sqlite3_vtab *pVTab);", "  int (*xFindFunction)(sqlite3_vtab *pVtab, int nArg, const char *zName,", "                       void (**pxFunc)(sqlite3_context*,int,sqlite3_value**),", "                       void **ppArg);", "  int (*xRename)(sqlite3_vtab *pVtab, const char *zNew);", "  /* The methods above are in version 1 of the sqlite_module object. Those ", "  ** below are for version 2 and greater. */", "  int (*xSavepoint)(sqlite3_vtab *pVTab, int);", "  int (*xRelease)(sqlite3_vtab *pVTab, int);", "  int (*xRollbackTo)(sqlite3_vtab *pVTab, int);", "};", "", "/*", "** CAPI3REF: Virtual Table Indexing Information", "** KEYWORDS: sqlite3_index_info", "**", "** The sqlite3_index_info structure and its substructures is used as part", "** of the [virtual table] interface to", "** pass information into and receive the reply from the [xBestIndex]", "** method of a [virtual table module].  The fields under **Inputs** are the", "** inputs to xBestIndex and are read-only.  xBestIndex inserts its", "** results into the **Outputs** fields.", "**", "** ^(The aConstraint[] array records WHERE clause constraints of the form:", "**", "** <blockquote>column OP expr</blockquote>", "**", "** where OP is =, &lt;, &lt;=, &gt;, or &gt;=.)^  ^(The particular operator is", "** stored in aConstraint[].op using one of the", "** [SQLITE_INDEX_CONSTRAINT_EQ | SQLITE_INDEX_CONSTRAINT_ values].)^", "** ^(The index of the column is stored in", "** aConstraint[].iColumn.)^  ^(aConstraint[].usable is TRUE if the", "** expr on the right-hand side can be evaluated (and thus the constraint", "** is usable) and false if it cannot.)^", "**", '** ^The optimizer automatically inverts terms of the form "expr OP column"', "** and makes other simplifications to the WHERE clause in an attempt to", "** get as many WHERE clause terms into the form shown above as possible.", "** ^The aConstraint[] array only reports WHERE clause terms that are", "** relevant to the particular virtual table being queried.", "**", "** ^Information about the ORDER BY clause is stored in aOrderBy[].", "** ^Each term of aOrderBy records a column of the ORDER BY clause.", "**", "** The [xBestIndex] method must fill aConstraintUsage[] with information", "** about what parameters to pass to xFilter.  ^If argvIndex>0 then", "** the right-hand side of the corresponding aConstraint[] is evaluated", "** and becomes the argvIndex-th entry in argv.  ^(If aConstraintUsage[].omit", "** is true, then the constraint is assumed to be fully handled by the", "** virtual table and is not checked again by SQLite.)^", "**", "** ^The idxNum and idxPtr values are recorded and passed into the", "** [xFilter] method.", "** ^[sqlite3_free()] is used to free idxPtr if and only if", "** needToFreeIdxPtr is true.", "**", "** ^The orderByConsumed means that output from [xFilter]/[xNext] will occur in", "** the correct order to satisfy the ORDER BY clause so that no separate", "** sorting step is required.", "**", "** ^The estimatedCost value is an estimate of the cost of doing the", "** particular lookup.  A full scan of a table with N entries should have", "** a cost of N.  A binary search of a table of N entries should have a", "** cost of approximately log(N).", "*/", "struct sqlite3_index_info {", "  /* Inputs */", "  int nConstraint;           /* Number of entries in aConstraint */", "  struct sqlite3_index_constraint {", "     int iColumn;              /* Column on left-hand side of constraint */", "     unsigned char op;         /* Constraint operator */", "     unsigned char usable;     /* True if this constraint is usable */", "     int iTermOffset;          /* Used internally - xBestIndex should ignore */", "  } *aConstraint;            /* Table of WHERE clause constraints */", "  int nOrderBy;              /* Number of terms in the ORDER BY clause */", "  struct sqlite3_index_orderby {", "     int iColumn;              /* Column number */", "     unsigned char desc;       /* True for DESC.  False for ASC. */", "  } *aOrderBy;               /* The ORDER BY clause */", "  /* Outputs */", "  struct sqlite3_index_constraint_usage {", "    int argvIndex;           /* if >0, constraint is part of argv to xFilter */", "    unsigned char omit;      /* Do not code a test for this constraint */", "  } *aConstraintUsage;", "  int idxNum;                /* Number used to identify the index */", "  char *idxStr;              /* String, possibly obtained from sqlite3_malloc */", "  int needToFreeIdxStr;      /* Free idxStr using sqlite3_free() if true */", "  int orderByConsumed;       /* True if output is already ordered */", "  double estimatedCost;      /* Estimated cost of using this index */", "};", "", "/*", "** CAPI3REF: Virtual Table Constraint Operator Codes", "**", "** These macros defined the allowed values for the", "** [sqlite3_index_info].aConstraint[].op field.  Each value represents", "** an operator that is part of a constraint term in the wHERE clause of", "** a query that uses a [virtual table].", "*/", "#define SQLITE_INDEX_CONSTRAINT_EQ    2", "#define SQLITE_INDEX_CONSTRAINT_GT    4", "#define SQLITE_INDEX_CONSTRAINT_LE    8", "#define SQLITE_INDEX_CONSTRAINT_LT    16", "#define SQLITE_INDEX_CONSTRAINT_GE    32", "#define SQLITE_INDEX_CONSTRAINT_MATCH 64", "", "/*", "** CAPI3REF: Register A Virtual Table Implementation", "**", "** ^These routines are used to register a new [virtual table module] name.", "** ^Module names must be registered before", "** creating a new [virtual table] using the module and before using a", "** preexisting [virtual table] for the module.", "**", "** ^The module name is registered on the [database connection] specified", "** by the first parameter.  ^The name of the module is given by the ", "** second parameter.  ^The third parameter is a pointer to", "** the implementation of the [virtual table module].   ^The fourth", "** parameter is an arbitrary client data pointer that is passed through", "** into the [xCreate] and [xConnect] methods of the virtual table module", "** when a new virtual table is be being created or reinitialized.", "**", "** ^The sqlite3_create_module_v2() interface has a fifth parameter which", "** is a pointer to a destructor for the pClientData.  ^SQLite will", "** invoke the destructor function (if it is not NULL) when SQLite", "** no longer needs the pClientData pointer.  ^The destructor will also", "** be invoked if the call to sqlite3_create_module_v2() fails.", "** ^The sqlite3_create_module()", "** interface is equivalent to sqlite3_create_module_v2() with a NULL", "** destructor.", "*/", "SQLITE_API int sqlite3_create_module(", "  sqlite3 *db,               /* SQLite connection to register module with */", "  const char *zName,         /* Name of the module */", "  const sqlite3_module *p,   /* Methods for the module */", "  void *pClientData          /* Client data for xCreate/xConnect */", ");", "SQLITE_API int sqlite3_create_module_v2(", "  sqlite3 *db,               /* SQLite connection to register module with */", "  const char *zName,         /* Name of the module */", "  const sqlite3_module *p,   /* Methods for the module */", "  void *pClientData,         /* Client data for xCreate/xConnect */", "  void(*xDestroy)(void*)     /* Module destructor function */", ");", "", "/*", "** CAPI3REF: Virtual Table Instance Object", "** KEYWORDS: sqlite3_vtab", "**", "** Every [virtual table module] implementation uses a subclass", "** of this object to describe a particular instance", "** of the [virtual table].  Each subclass will", "** be tailored to the specific needs of the module implementation.", "** The purpose of this superclass is to define certain fields that are", "** common to all module implementations.", "**", "** ^Virtual tables methods can set an error message by assigning a", "** string obtained from [sqlite3_mprintf()] to zErrMsg.  The method should", "** take care that any prior string is freed by a call to [sqlite3_free()]", "** prior to assigning a new string to zErrMsg.  ^After the error message", "** is delivered up to the client application, the string will be automatically", "** freed by sqlite3_free() and the zErrMsg field will be zeroed.", "*/", "struct sqlite3_vtab {", "  const sqlite3_module *pModule;  /* The module for this virtual table */", "  int nRef;                       /* NO LONGER USED */", "  char *zErrMsg;                  /* Error message from sqlite3_mprintf() */", "  /* Virtual table implementations will typically add additional fields */", "};", "", "/*", "** CAPI3REF: Virtual Table Cursor Object", "** KEYWORDS: sqlite3_vtab_cursor {virtual table cursor}", "**", "** Every [virtual table module] implementation uses a subclass of the", "** following structure to describe cursors that point into the", "** [virtual table] and are used", "** to loop through the virtual table.  Cursors are created using the", "** [sqlite3_module.xOpen | xOpen] method of the module and are destroyed", "** by the [sqlite3_module.xClose | xClose] method.  Cursors are used", "** by the [xFilter], [xNext], [xEof], [xColumn], and [xRowid] methods", "** of the module.  Each module implementation will define", "** the content of a cursor structure to suit its own needs.", "**", "** This superclass exists in order to define fields of the cursor that", "** are common to all implementations.", "*/", "struct sqlite3_vtab_cursor {", "  sqlite3_vtab *pVtab;      /* Virtual table of this cursor */", "  /* Virtual table implementations will typically add additional fields */", "};", "", "/*", "** CAPI3REF: Declare The Schema Of A Virtual Table", "**", "** ^The [xCreate] and [xConnect] methods of a", "** [virtual table module] call this interface", "** to declare the format (the names and datatypes of the columns) of", "** the virtual tables they implement.", "*/", "SQLITE_API int sqlite3_declare_vtab(sqlite3*, const char *zSQL);", "", "/*", "** CAPI3REF: Overload A Function For A Virtual Table", "**", "** ^(Virtual tables can provide alternative implementations of functions", "** using the [xFindFunction] method of the [virtual table module].  ", "** But global versions of those functions", "** must exist in order to be overloaded.)^", "**", "** ^(This API makes sure a global version of a function with a particular", "** name and number of parameters exists.  If no such function exists", "** before this API is called, a new function is created.)^  ^The implementation", "** of the new function always causes an exception to be thrown.  So", "** the new function is not good for anything by itself.  Its only", "** purpose is to be a placeholder function that can be overloaded", "** by a [virtual table].", "*/", "SQLITE_API int sqlite3_overload_function(sqlite3*, const char *zFuncName, int nArg);", "", "/*", "** The interface to the virtual-table mechanism defined above (back up", "** to a comment remarkably similar to this one) is currently considered", "** to be experimental.  The interface might change in incompatible ways.", "** If this is a problem for you, do not use the interface at this time.", "**", "** When the virtual-table mechanism stabilizes, we will declare the", "** interface fixed, support it indefinitely, and remove this comment.", "*/", "", "/*", "** CAPI3REF: A Handle To An Open BLOB", "** KEYWORDS: {BLOB handle} {BLOB handles}", "**", "** An instance of this object represents an open BLOB on which", "** [sqlite3_blob_open | incremental BLOB I/O] can be performed.", "** ^Objects of this type are created by [sqlite3_blob_open()]", "** and destroyed by [sqlite3_blob_close()].", "** ^The [sqlite3_blob_read()] and [sqlite3_blob_write()] interfaces", "** can be used to read or write small subsections of the BLOB.", "** ^The [sqlite3_blob_bytes()] interface returns the size of the BLOB in bytes.", "*/", "typedef struct sqlite3_blob sqlite3_blob;", "", "/*", "** CAPI3REF: Open A BLOB For Incremental I/O", "**", "** ^(This interfaces opens a [BLOB handle | handle] to the BLOB located", "** in row iRow, column zColumn, table zTable in database zDb;", "** in other words, the same BLOB that would be selected by:", "**", "** <pre>", "**     SELECT zColumn FROM zDb.zTable WHERE [rowid] = iRow;", "** </pre>)^", "**", "** ^If the flags parameter is non-zero, then the BLOB is opened for read", "** and write access. ^If it is zero, the BLOB is opened for read access.", "** ^It is not possible to open a column that is part of an index or primary ", "** key for writing. ^If [foreign key constraints] are enabled, it is ", "** not possible to open a column that is part of a [child key] for writing.", "**", "** ^Note that the database name is not the filename that contains", "** the database but rather the symbolic name of the database that", "** appears after the AS keyword when the database is connected using [ATTACH].", '** ^For the main database file, the database name is "main".', '** ^For TEMP tables, the database name is "temp".', "**", "** ^(On success, [SQLITE_OK] is returned and the new [BLOB handle] is written", "** to *ppBlob. Otherwise an [error code] is returned and *ppBlob is set", "** to be a null pointer.)^", "** ^This function sets the [database connection] error code and message", "** accessible via [sqlite3_errcode()] and [sqlite3_errmsg()] and related", "** functions. ^Note that the *ppBlob variable is always initialized in a", "** way that makes it safe to invoke [sqlite3_blob_close()] on *ppBlob", "** regardless of the success or failure of this routine.", "**", "** ^(If the row that a BLOB handle points to is modified by an", "** [UPDATE], [DELETE], or by [ON CONFLICT] side-effects", '** then the BLOB handle is marked as "expired".', "** This is true if any column of the row is changed, even a column", "** other than the one the BLOB handle is open on.)^", "** ^Calls to [sqlite3_blob_read()] and [sqlite3_blob_write()] for", "** an expired BLOB handle fail with a return code of [SQLITE_ABORT].", "** ^(Changes written into a BLOB prior to the BLOB expiring are not", "** rolled back by the expiration of the BLOB.  Such changes will eventually", "** commit if the transaction continues to completion.)^", "**", "** ^Use the [sqlite3_blob_bytes()] interface to determine the size of", "** the opened blob.  ^The size of a blob may not be changed by this", "** interface.  Use the [UPDATE] SQL command to change the size of a", "** blob.", "**", "** ^The [sqlite3_bind_zeroblob()] and [sqlite3_result_zeroblob()] interfaces", "** and the built-in [zeroblob] SQL function can be used, if desired,", "** to create an empty, zero-filled blob in which to read or write using", "** this interface.", "**", "** To avoid a resource leak, every open [BLOB handle] should eventually", "** be released by a call to [sqlite3_blob_close()].", "*/", "SQLITE_API int sqlite3_blob_open(", "  sqlite3*,", "  const char *zDb,", "  const char *zTable,", "  const char *zColumn,", "  sqlite3_int64 iRow,", "  int flags,", "  sqlite3_blob **ppBlob", ");", "", "/*", "** CAPI3REF: Move a BLOB Handle to a New Row", "**", "** ^This function is used to move an existing blob handle so that it points", "** to a different row of the same database table. ^The new row is identified", "** by the rowid value passed as the second argument. Only the row can be", "** changed. ^The database, table and column on which the blob handle is open", "** remain the same. Moving an existing blob handle to a new row can be", "** faster than closing the existing handle and opening a new one.", "**", "** ^(The new row must meet the same criteria as for [sqlite3_blob_open()] -", "** it must exist and there must be either a blob or text value stored in", "** the nominated column.)^ ^If the new row is not present in the table, or if", "** it does not contain a blob or text value, or if another error occurs, an", "** SQLite error code is returned and the blob handle is considered aborted.", "** ^All subsequent calls to [sqlite3_blob_read()], [sqlite3_blob_write()] or", "** [sqlite3_blob_reopen()] on an aborted blob handle immediately return", "** SQLITE_ABORT. ^Calling [sqlite3_blob_bytes()] on an aborted blob handle", "** always returns zero.", "**", "** ^This function sets the database handle error code and message.", "*/", "SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_blob_reopen(sqlite3_blob *, sqlite3_int64);", "", "/*", "** CAPI3REF: Close A BLOB Handle", "**", "** ^Closes an open [BLOB handle].", "**", "** ^Closing a BLOB shall cause the current transaction to commit", "** if there are no other BLOBs, no pending prepared statements, and the", "** database connection is in [autocommit mode].", "** ^If any writes were made to the BLOB, they might be held in cache", "** until the close operation if they will fit.", "**", "** ^(Closing the BLOB often forces the changes", "** out to disk and so if any I/O errors occur, they will likely occur", "** at the time when the BLOB is closed.  Any errors that occur during", "** closing are reported as a non-zero return value.)^", "**", "** ^(The BLOB is closed unconditionally.  Even if this routine returns", "** an error code, the BLOB is still closed.)^", "**", "** ^Calling this routine with a null pointer (such as would be returned", "** by a failed call to [sqlite3_blob_open()]) is a harmless no-op.", "*/", "SQLITE_API int sqlite3_blob_close(sqlite3_blob *);", "", "/*", "** CAPI3REF: Return The Size Of An Open BLOB", "**", "** ^Returns the size in bytes of the BLOB accessible via the ", "** successfully opened [BLOB handle] in its only argument.  ^The", "** incremental blob I/O routines can only read or overwriting existing", "** blob content; they cannot change the size of a blob.", "**", "** This routine only works on a [BLOB handle] which has been created", "** by a prior successful call to [sqlite3_blob_open()] and which has not", "** been closed by [sqlite3_blob_close()].  Passing any other pointer in", "** to this routine results in undefined and probably undesirable behavior.", "*/", "SQLITE_API int sqlite3_blob_bytes(sqlite3_blob *);", "", "/*", "** CAPI3REF: Read Data From A BLOB Incrementally", "**", "** ^(This function is used to read data from an open [BLOB handle] into a", "** caller-supplied buffer. N bytes of data are copied into buffer Z", "** from the open BLOB, starting at offset iOffset.)^", "**", "** ^If offset iOffset is less than N bytes from the end of the BLOB,", "** [SQLITE_ERROR] is returned and no data is read.  ^If N or iOffset is", "** less than zero, [SQLITE_ERROR] is returned and no data is read.", "** ^The size of the blob (and hence the maximum value of N+iOffset)", "** can be determined using the [sqlite3_blob_bytes()] interface.", "**", "** ^An attempt to read from an expired [BLOB handle] fails with an", "** error code of [SQLITE_ABORT].", "**", "** ^(On success, sqlite3_blob_read() returns SQLITE_OK.", "** Otherwise, an [error code] or an [extended error code] is returned.)^", "**", "** This routine only works on a [BLOB handle] which has been created", "** by a prior successful call to [sqlite3_blob_open()] and which has not", "** been closed by [sqlite3_blob_close()].  Passing any other pointer in", "** to this routine results in undefined and probably undesirable behavior.", "**", "** See also: [sqlite3_blob_write()].", "*/", "SQLITE_API int sqlite3_blob_read(sqlite3_blob *, void *Z, int N, int iOffset);", "", "/*", "** CAPI3REF: Write Data Into A BLOB Incrementally", "**", "** ^This function is used to write data into an open [BLOB handle] from a", "** caller-supplied buffer. ^N bytes of data are copied from the buffer Z", "** into the open BLOB, starting at offset iOffset.", "**", "** ^If the [BLOB handle] passed as the first argument was not opened for", "** writing (the flags parameter to [sqlite3_blob_open()] was zero),", "** this function returns [SQLITE_READONLY].", "**", "** ^This function may only modify the contents of the BLOB; it is", "** not possible to increase the size of a BLOB using this API.", "** ^If offset iOffset is less than N bytes from the end of the BLOB,", "** [SQLITE_ERROR] is returned and no data is written.  ^If N is", "** less than zero [SQLITE_ERROR] is returned and no data is written.", "** The size of the BLOB (and hence the maximum value of N+iOffset)", "** can be determined using the [sqlite3_blob_bytes()] interface.", "**", "** ^An attempt to write to an expired [BLOB handle] fails with an", "** error code of [SQLITE_ABORT].  ^Writes to the BLOB that occurred", "** before the [BLOB handle] expired are not rolled back by the", "** expiration of the handle, though of course those changes might", "** have been overwritten by the statement that expired the BLOB handle", "** or by other independent statements.", "**", "** ^(On success, sqlite3_blob_write() returns SQLITE_OK.", "** Otherwise, an  [error code] or an [extended error code] is returned.)^", "**", "** This routine only works on a [BLOB handle] which has been created", "** by a prior successful call to [sqlite3_blob_open()] and which has not", "** been closed by [sqlite3_blob_close()].  Passing any other pointer in", "** to this routine results in undefined and probably undesirable behavior.", "**", "** See also: [sqlite3_blob_read()].", "*/", "SQLITE_API int sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOffset);", "", "/*", "** CAPI3REF: Virtual File System Objects", "**", "** A virtual filesystem (VFS) is an [sqlite3_vfs] object", "** that SQLite uses to interact", "** with the underlying operating system.  Most SQLite builds come with a", "** single default VFS that is appropriate for the host computer.", "** New VFSes can be registered and existing VFSes can be unregistered.", "** The following interfaces are provided.", "**", "** ^The sqlite3_vfs_find() interface returns a pointer to a VFS given its name.", "** ^Names are case sensitive.", "** ^Names are zero-terminated UTF-8 strings.", "** ^If there is no match, a NULL pointer is returned.", "** ^If zVfsName is NULL then the default VFS is returned.", "**", "** ^New VFSes are registered with sqlite3_vfs_register().", "** ^Each new VFS becomes the default VFS if the makeDflt flag is set.", "** ^The same VFS can be registered multiple times without injury.", "** ^To make an existing VFS into the default VFS, register it again", "** with the makeDflt flag set.  If two different VFSes with the", "** same name are registered, the behavior is undefined.  If a", "** VFS is registered with a name that is NULL or an empty string,", "** then the behavior is undefined.", "**", "** ^Unregister a VFS with the sqlite3_vfs_unregister() interface.", "** ^(If the default VFS is unregistered, another VFS is chosen as", "** the default.  The choice for the new VFS is arbitrary.)^", "*/", "SQLITE_API sqlite3_vfs *sqlite3_vfs_find(const char *zVfsName);", "SQLITE_API int sqlite3_vfs_register(sqlite3_vfs*, int makeDflt);", "SQLITE_API int sqlite3_vfs_unregister(sqlite3_vfs*);", "", "/*", "** CAPI3REF: Mutexes", "**", "** The SQLite core uses these routines for thread", "** synchronization. Though they are intended for internal", "** use by SQLite, code that links against SQLite is", "** permitted to use any of these routines.", "**", "** The SQLite source code contains multiple implementations", "** of these mutex routines.  An appropriate implementation", "** is selected automatically at compile-time.  ^(The following", "** implementations are available in the SQLite core:", "**", "** <ul>", "** <li>   SQLITE_MUTEX_OS2", "** <li>   SQLITE_MUTEX_PTHREADS", "** <li>   SQLITE_MUTEX_W32", "** <li>   SQLITE_MUTEX_NOOP", "** </ul>)^", "**", "** ^The SQLITE_MUTEX_NOOP implementation is a set of routines", "** that does no real locking and is appropriate for use in", "** a single-threaded application.  ^The SQLITE_MUTEX_OS2,", "** SQLITE_MUTEX_PTHREADS, and SQLITE_MUTEX_W32 implementations", "** are appropriate for use on OS/2, Unix, and Windows.", "**", "** ^(If SQLite is compiled with the SQLITE_MUTEX_APPDEF preprocessor", '** macro defined (with "-DSQLITE_MUTEX_APPDEF=1"), then no mutex', "** implementation is included with the library. In this case the", "** application must supply a custom mutex implementation using the", "** [SQLITE_CONFIG_MUTEX] option of the sqlite3_config() function", "** before calling sqlite3_initialize() or any other public sqlite3_", "** function that calls sqlite3_initialize().)^", "**", "** ^The sqlite3_mutex_alloc() routine allocates a new", "** mutex and returns a pointer to it. ^If it returns NULL", "** that means that a mutex could not be allocated.  ^SQLite", "** will unwind its stack and return an error.  ^(The argument", "** to sqlite3_mutex_alloc() is one of these integer constants:", "**", "** <ul>", "** <li>  SQLITE_MUTEX_FAST", "** <li>  SQLITE_MUTEX_RECURSIVE", "** <li>  SQLITE_MUTEX_STATIC_MASTER", "** <li>  SQLITE_MUTEX_STATIC_MEM", "** <li>  SQLITE_MUTEX_STATIC_MEM2", "** <li>  SQLITE_MUTEX_STATIC_PRNG", "** <li>  SQLITE_MUTEX_STATIC_LRU", "** <li>  SQLITE_MUTEX_STATIC_LRU2", "** </ul>)^", "**", "** ^The first two constants (SQLITE_MUTEX_FAST and SQLITE_MUTEX_RECURSIVE)", "** cause sqlite3_mutex_alloc() to create", "** a new mutex.  ^The new mutex is recursive when SQLITE_MUTEX_RECURSIVE", "** is used but not necessarily so when SQLITE_MUTEX_FAST is used.", "** The mutex implementation does not need to make a distinction", "** between SQLITE_MUTEX_RECURSIVE and SQLITE_MUTEX_FAST if it does", "** not want to.  ^SQLite will only request a recursive mutex in", "** cases where it really needs one.  ^If a faster non-recursive mutex", "** implementation is available on the host platform, the mutex subsystem", "** might return such a mutex in response to SQLITE_MUTEX_FAST.", "**", "** ^The other allowed parameters to sqlite3_mutex_alloc() (anything other", "** than SQLITE_MUTEX_FAST and SQLITE_MUTEX_RECURSIVE) each return", "** a pointer to a static preexisting mutex.  ^Six static mutexes are", "** used by the current version of SQLite.  Future versions of SQLite", "** may add additional static mutexes.  Static mutexes are for internal", "** use by SQLite only.  Applications that use SQLite mutexes should", "** use only the dynamic mutexes returned by SQLITE_MUTEX_FAST or", "** SQLITE_MUTEX_RECURSIVE.", "**", "** ^Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FAST", "** or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc()", "** returns a different mutex on every call.  ^But for the static", "** mutex types, the same mutex is returned on every call that has", "** the same type number.", "**", "** ^The sqlite3_mutex_free() routine deallocates a previously", "** allocated dynamic mutex.  ^SQLite is careful to deallocate every", "** dynamic mutex that it allocates.  The dynamic mutexes must not be in", "** use when they are deallocated.  Attempting to deallocate a static", "** mutex results in undefined behavior.  ^SQLite never deallocates", "** a static mutex.", "**", "** ^The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt", "** to enter a mutex.  ^If another thread is already within the mutex,", "** sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return", "** SQLITE_BUSY.  ^The sqlite3_mutex_try() interface returns [SQLITE_OK]", "** upon successful entry.  ^(Mutexes created using", "** SQLITE_MUTEX_RECURSIVE can be entered multiple times by the same thread.", "** In such cases the,", "** mutex must be exited an equal number of times before another thread", "** can enter.)^  ^(If the same thread tries to enter any other", "** kind of mutex more than once, the behavior is undefined.", "** SQLite will never exhibit", "** such behavior in its own use of mutexes.)^", "**", "** ^(Some systems (for example, Windows 95) do not support the operation", "** implemented by sqlite3_mutex_try().  On those systems, sqlite3_mutex_try()", "** will always return SQLITE_BUSY.  The SQLite core only ever uses", "** sqlite3_mutex_try() as an optimization so this is acceptable behavior.)^", "**", "** ^The sqlite3_mutex_leave() routine exits a mutex that was", "** previously entered by the same thread.   ^(The behavior", "** is undefined if the mutex is not currently entered by the", "** calling thread or is not currently allocated.  SQLite will", "** never do either.)^", "**", "** ^If the argument to sqlite3_mutex_enter(), sqlite3_mutex_try(), or", "** sqlite3_mutex_leave() is a NULL pointer, then all three routines", "** behave as no-ops.", "**", "** See also: [sqlite3_mutex_held()] and [sqlite3_mutex_notheld()].", "*/", "SQLITE_API sqlite3_mutex *sqlite3_mutex_alloc(int);", "SQLITE_API void sqlite3_mutex_free(sqlite3_mutex*);", "SQLITE_API void sqlite3_mutex_enter(sqlite3_mutex*);", "SQLITE_API int sqlite3_mutex_try(sqlite3_mutex*);", "SQLITE_API void sqlite3_mutex_leave(sqlite3_mutex*);", "", "/*", "** CAPI3REF: Mutex Methods Object", "**", "** An instance of this structure defines the low-level routines", "** used to allocate and use mutexes.", "**", "** Usually, the default mutex implementations provided by SQLite are", "** sufficient, however the user has the option of substituting a custom", "** implementation for specialized deployments or systems for which SQLite", "** does not provide a suitable implementation. In this case, the user", "** creates and populates an instance of this structure to pass", "** to sqlite3_config() along with the [SQLITE_CONFIG_MUTEX] option.", "** Additionally, an instance of this structure can be used as an", "** output variable when querying the system for the current mutex", "** implementation, using the [SQLITE_CONFIG_GETMUTEX] option.", "**", "** ^The xMutexInit method defined by this structure is invoked as", "** part of system initialization by the sqlite3_initialize() function.", "** ^The xMutexInit routine is called by SQLite exactly once for each", "** effective call to [sqlite3_initialize()].", "**", "** ^The xMutexEnd method defined by this structure is invoked as", "** part of system shutdown by the sqlite3_shutdown() function. The", "** implementation of this method is expected to release all outstanding", "** resources obtained by the mutex methods implementation, especially", "** those obtained by the xMutexInit method.  ^The xMutexEnd()", "** interface is invoked exactly once for each call to [sqlite3_shutdown()].", "**", "** ^(The remaining seven methods defined by this structure (xMutexAlloc,", "** xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld and", "** xMutexNotheld) implement the following interfaces (respectively):", "**", "** <ul>", "**   <li>  [sqlite3_mutex_alloc()] </li>", "**   <li>  [sqlite3_mutex_free()] </li>", "**   <li>  [sqlite3_mutex_enter()] </li>", "**   <li>  [sqlite3_mutex_try()] </li>", "**   <li>  [sqlite3_mutex_leave()] </li>", "**   <li>  [sqlite3_mutex_held()] </li>", "**   <li>  [sqlite3_mutex_notheld()] </li>", "** </ul>)^", "**", "** The only difference is that the public sqlite3_XXX functions enumerated", "** above silently ignore any invocations that pass a NULL pointer instead", "** of a valid mutex handle. The implementations of the methods defined", "** by this structure are not required to handle this case, the results", "** of passing a NULL pointer instead of a valid mutex handle are undefined", "** (i.e. it is acceptable to provide an implementation that segfaults if", "** it is passed a NULL pointer).", "**", "** The xMutexInit() method must be threadsafe.  ^It must be harmless to", "** invoke xMutexInit() multiple times within the same process and without", "** intervening calls to xMutexEnd().  Second and subsequent calls to", "** xMutexInit() must be no-ops.", "**", "** ^xMutexInit() must not use SQLite memory allocation ([sqlite3_malloc()]", "** and its associates).  ^Similarly, xMutexAlloc() must not use SQLite memory", "** allocation for a static mutex.  ^However xMutexAlloc() may use SQLite", "** memory allocation for a fast or recursive mutex.", "**", "** ^SQLite will invoke the xMutexEnd() method when [sqlite3_shutdown()] is", "** called, but only if the prior call to xMutexInit returned SQLITE_OK.", "** If xMutexInit fails in any way, it is expected to clean up after itself", "** prior to returning.", "*/", "typedef struct sqlite3_mutex_methods sqlite3_mutex_methods;", "struct sqlite3_mutex_methods {", "  int (*xMutexInit)(void);", "  int (*xMutexEnd)(void);", "  sqlite3_mutex *(*xMutexAlloc)(int);", "  void (*xMutexFree)(sqlite3_mutex *);", "  void (*xMutexEnter)(sqlite3_mutex *);", "  int (*xMutexTry)(sqlite3_mutex *);", "  void (*xMutexLeave)(sqlite3_mutex *);", "  int (*xMutexHeld)(sqlite3_mutex *);", "  int (*xMutexNotheld)(sqlite3_mutex *);", "};", "", "/*", "** CAPI3REF: Mutex Verification Routines", "**", "** The sqlite3_mutex_held() and sqlite3_mutex_notheld() routines", "** are intended for use inside assert() statements.  ^The SQLite core", "** never uses these routines except inside an assert() and applications", "** are advised to follow the lead of the core.  ^The SQLite core only", "** provides implementations for these routines when it is compiled", "** with the SQLITE_DEBUG flag.  ^External mutex implementations", "** are only required to provide these routines if SQLITE_DEBUG is", "** defined and if NDEBUG is not defined.", "**", "** ^These routines should return true if the mutex in their argument", "** is held or not held, respectively, by the calling thread.", "**", "** ^The implementation is not required to provide versions of these", "** routines that actually work. If the implementation does not provide working", "** versions of these routines, it should at least provide stubs that always", "** return true so that one does not get spurious assertion failures.", "**", "** ^If the argument to sqlite3_mutex_held() is a NULL pointer then", "** the routine should return 1.   This seems counter-intuitive since", "** clearly the mutex cannot be held if it does not exist.  But", "** the reason the mutex does not exist is because the build is not", "** using mutexes.  And we do not want the assert() containing the", "** call to sqlite3_mutex_held() to fail, so a non-zero return is", "** the appropriate thing to do.  ^The sqlite3_mutex_notheld()", "** interface should also return 1 when given a NULL pointer.", "*/", "#ifndef NDEBUG", "SQLITE_API int sqlite3_mutex_held(sqlite3_mutex*);", "SQLITE_API int sqlite3_mutex_notheld(sqlite3_mutex*);", "#endif", "", "/*", "** CAPI3REF: Mutex Types", "**", "** The [sqlite3_mutex_alloc()] interface takes a single argument", "** which is one of these integer constants.", "**", "** The set of static mutexes may change from one SQLite release to the", "** next.  Applications that override the built-in mutex logic must be", "** prepared to accommodate additional static mutexes.", "*/", "#define SQLITE_MUTEX_FAST             0", "#define SQLITE_MUTEX_RECURSIVE        1", "#define SQLITE_MUTEX_STATIC_MASTER    2", "#define SQLITE_MUTEX_STATIC_MEM       3  /* sqlite3_malloc() */", "#define SQLITE_MUTEX_STATIC_MEM2      4  /* NOT USED */", "#define SQLITE_MUTEX_STATIC_OPEN      4  /* sqlite3BtreeOpen() */", "#define SQLITE_MUTEX_STATIC_PRNG      5  /* sqlite3_random() */", "#define SQLITE_MUTEX_STATIC_LRU       6  /* lru page list */", "#define SQLITE_MUTEX_STATIC_LRU2      7  /* NOT USED */", "#define SQLITE_MUTEX_STATIC_PMEM      7  /* sqlite3PageMalloc() */", "", "/*", "** CAPI3REF: Retrieve the mutex for a database connection", "**", "** ^This interface returns a pointer the [sqlite3_mutex] object that ", "** serializes access to the [database connection] given in the argument", "** when the [threading mode] is Serialized.", "** ^If the [threading mode] is Single-thread or Multi-thread then this", "** routine returns a NULL pointer.", "*/", "SQLITE_API sqlite3_mutex *sqlite3_db_mutex(sqlite3*);", "", "/*", "** CAPI3REF: Low-Level Control Of Database Files", "**", "** ^The [sqlite3_file_control()] interface makes a direct call to the", "** xFileControl method for the [sqlite3_io_methods] object associated", "** with a particular database identified by the second argument. ^The", '** name of the database is "main" for the main database or "temp" for the', "** TEMP database, or the name that appears after the AS keyword for", "** databases that are added using the [ATTACH] SQL command.", '** ^A NULL pointer can be used in place of "main" to refer to the', "** main database file.", "** ^The third and fourth parameters to this routine", "** are passed directly through to the second and third parameters of", "** the xFileControl method.  ^The return value of the xFileControl", "** method becomes the return value of this routine.", "**", "** ^The SQLITE_FCNTL_FILE_POINTER value for the op parameter causes", "** a pointer to the underlying [sqlite3_file] object to be written into", "** the space pointed to by the 4th parameter.  ^The SQLITE_FCNTL_FILE_POINTER", "** case is a short-circuit path which does not actually invoke the", "** underlying sqlite3_io_methods.xFileControl method.", "**", "** ^If the second parameter (zDbName) does not match the name of any", "** open database file, then SQLITE_ERROR is returned.  ^This error", "** code is not remembered and will not be recalled by [sqlite3_errcode()]", "** or [sqlite3_errmsg()].  The underlying xFileControl method might", "** also return SQLITE_ERROR.  There is no way to distinguish between", "** an incorrect zDbName and an SQLITE_ERROR return from the underlying", "** xFileControl method.", "**", "** See also: [SQLITE_FCNTL_LOCKSTATE]", "*/", "SQLITE_API int sqlite3_file_control(sqlite3*, const char *zDbName, int op, void*);", "", "/*", "** CAPI3REF: Testing Interface", "**", "** ^The sqlite3_test_control() interface is used to read out internal", "** state of SQLite and to inject faults into SQLite for testing", "** purposes.  ^The first parameter is an operation code that determines", "** the number, meaning, and operation of all subsequent parameters.", "**", "** This interface is not for use by applications.  It exists solely", "** for verifying the correct operation of the SQLite library.  Depending", "** on how the SQLite library is compiled, this interface might not exist.", "**", "** The details of the operation codes, their meanings, the parameters", "** they take, and what they do are all subject to change without notice.", "** Unlike most of the SQLite API, this function is not guaranteed to", "** operate consistently from one release to the next.", "*/", "SQLITE_API int sqlite3_test_control(int op, ...);", "", "/*", "** CAPI3REF: Testing Interface Operation Codes", "**", "** These constants are the valid operation code parameters used", "** as the first argument to [sqlite3_test_control()].", "**", "** These parameters and their meanings are subject to change", "** without notice.  These values are for testing purposes only.", "** Applications should not use any of these parameters or the", "** [sqlite3_test_control()] interface.", "*/", "#define SQLITE_TESTCTRL_FIRST                    5", "#define SQLITE_TESTCTRL_PRNG_SAVE                5", "#define SQLITE_TESTCTRL_PRNG_RESTORE             6", "#define SQLITE_TESTCTRL_PRNG_RESET               7", "#define SQLITE_TESTCTRL_BITVEC_TEST              8", "#define SQLITE_TESTCTRL_FAULT_INSTALL            9", "#define SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS     10", "#define SQLITE_TESTCTRL_PENDING_BYTE            11", "#define SQLITE_TESTCTRL_ASSERT                  12", "#define SQLITE_TESTCTRL_ALWAYS                  13", "#define SQLITE_TESTCTRL_RESERVE                 14", "#define SQLITE_TESTCTRL_OPTIMIZATIONS           15", "#define SQLITE_TESTCTRL_ISKEYWORD               16", "#define SQLITE_TESTCTRL_SCRATCHMALLOC           17", "#define SQLITE_TESTCTRL_LOCALTIME_FAULT         18", "#define SQLITE_TESTCTRL_EXPLAIN_STMT            19", "#define SQLITE_TESTCTRL_LAST                    19", "", "/*", "** CAPI3REF: SQLite Runtime Status", "**", "** ^This interface is used to retrieve runtime status information", "** about the performance of SQLite, and optionally to reset various", "** highwater marks.  ^The first argument is an integer code for", "** the specific parameter to measure.  ^(Recognized integer codes", "** are of the form [status parameters | SQLITE_STATUS_...].)^", "** ^The current value of the parameter is returned into *pCurrent.", "** ^The highest recorded value is returned in *pHighwater.  ^If the", "** resetFlag is true, then the highest record value is reset after", "** *pHighwater is written.  ^(Some parameters do not record the highest", "** value.  For those parameters", "** nothing is written into *pHighwater and the resetFlag is ignored.)^", "** ^(Other parameters record only the highwater mark and not the current", "** value.  For these latter parameters nothing is written into *pCurrent.)^", "**", "** ^The sqlite3_status() routine returns SQLITE_OK on success and a", "** non-zero [error code] on failure.", "**", "** This routine is threadsafe but is not atomic.  This routine can be", "** called while other threads are running the same or different SQLite", "** interfaces.  However the values returned in *pCurrent and", "** *pHighwater reflect the status of SQLite at different points in time", "** and it is possible that another thread might change the parameter", "** in between the times when *pCurrent and *pHighwater are written.", "**", "** See also: [sqlite3_db_status()]", "*/", "SQLITE_API int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag);", "", "", "/*", "** CAPI3REF: Status Parameters", "** KEYWORDS: {status parameters}", "**", "** These integer constants designate various run-time status parameters", "** that can be returned by [sqlite3_status()].", "**", "** <dl>", "** [[SQLITE_STATUS_MEMORY_USED]] ^(<dt>SQLITE_STATUS_MEMORY_USED</dt>", "** <dd>This parameter is the current amount of memory checked out", "** using [sqlite3_malloc()], either directly or indirectly.  The", "** figure includes calls made to [sqlite3_malloc()] by the application", "** and internal memory usage by the SQLite library.  Scratch memory", "** controlled by [SQLITE_CONFIG_SCRATCH] and auxiliary page-cache", "** memory controlled by [SQLITE_CONFIG_PAGECACHE] is not included in", "** this parameter.  The amount returned is the sum of the allocation", "** sizes as reported by the xSize method in [sqlite3_mem_methods].</dd>)^", "**", "** [[SQLITE_STATUS_MALLOC_SIZE]] ^(<dt>SQLITE_STATUS_MALLOC_SIZE</dt>", "** <dd>This parameter records the largest memory allocation request", "** handed to [sqlite3_malloc()] or [sqlite3_realloc()] (or their", "** internal equivalents).  Only the value returned in the", "** *pHighwater parameter to [sqlite3_status()] is of interest.  ", "** The value written into the *pCurrent parameter is undefined.</dd>)^", "**", "** [[SQLITE_STATUS_MALLOC_COUNT]] ^(<dt>SQLITE_STATUS_MALLOC_COUNT</dt>", "** <dd>This parameter records the number of separate memory allocations", "** currently checked out.</dd>)^", "**", "** [[SQLITE_STATUS_PAGECACHE_USED]] ^(<dt>SQLITE_STATUS_PAGECACHE_USED</dt>", "** <dd>This parameter returns the number of pages used out of the", "** [pagecache memory allocator] that was configured using ", "** [SQLITE_CONFIG_PAGECACHE].  The", "** value returned is in pages, not in bytes.</dd>)^", "**", "** [[SQLITE_STATUS_PAGECACHE_OVERFLOW]] ", "** ^(<dt>SQLITE_STATUS_PAGECACHE_OVERFLOW</dt>", "** <dd>This parameter returns the number of bytes of page cache", "** allocation which could not be satisfied by the [SQLITE_CONFIG_PAGECACHE]", "** buffer and where forced to overflow to [sqlite3_malloc()].  The", "** returned value includes allocations that overflowed because they", '** where too large (they were larger than the "sz" parameter to', "** [SQLITE_CONFIG_PAGECACHE]) and allocations that overflowed because", "** no space was left in the page cache.</dd>)^", "**", "** [[SQLITE_STATUS_PAGECACHE_SIZE]] ^(<dt>SQLITE_STATUS_PAGECACHE_SIZE</dt>", "** <dd>This parameter records the largest memory allocation request", "** handed to [pagecache memory allocator].  Only the value returned in the", "** *pHighwater parameter to [sqlite3_status()] is of interest.  ", "** The value written into the *pCurrent parameter is undefined.</dd>)^", "**", "** [[SQLITE_STATUS_SCRATCH_USED]] ^(<dt>SQLITE_STATUS_SCRATCH_USED</dt>", "** <dd>This parameter returns the number of allocations used out of the", "** [scratch memory allocator] configured using", "** [SQLITE_CONFIG_SCRATCH].  The value returned is in allocations, not", "** in bytes.  Since a single thread may only have one scratch allocation", "** outstanding at time, this parameter also reports the number of threads", "** using scratch memory at the same time.</dd>)^", "**", "** [[SQLITE_STATUS_SCRATCH_OVERFLOW]] ^(<dt>SQLITE_STATUS_SCRATCH_OVERFLOW</dt>", "** <dd>This parameter returns the number of bytes of scratch memory", "** allocation which could not be satisfied by the [SQLITE_CONFIG_SCRATCH]", "** buffer and where forced to overflow to [sqlite3_malloc()].  The values", "** returned include overflows because the requested allocation was too", "** larger (that is, because the requested allocation was larger than the", '** "sz" parameter to [SQLITE_CONFIG_SCRATCH]) and because no scratch buffer', "** slots were available.", "** </dd>)^", "**", "** [[SQLITE_STATUS_SCRATCH_SIZE]] ^(<dt>SQLITE_STATUS_SCRATCH_SIZE</dt>", "** <dd>This parameter records the largest memory allocation request", "** handed to [scratch memory allocator].  Only the value returned in the", "** *pHighwater parameter to [sqlite3_status()] is of interest.  ", "** The value written into the *pCurrent parameter is undefined.</dd>)^", "**", "** [[SQLITE_STATUS_PARSER_STACK]] ^(<dt>SQLITE_STATUS_PARSER_STACK</dt>", "** <dd>This parameter records the deepest parser stack.  It is only", "** meaningful if SQLite is compiled with [YYTRACKMAXSTACKDEPTH].</dd>)^", "** </dl>", "**", "** New status parameters may be added from time to time.", "*/", "#define SQLITE_STATUS_MEMORY_USED          0", "#define SQLITE_STATUS_PAGECACHE_USED       1", "#define SQLITE_STATUS_PAGECACHE_OVERFLOW   2", "#define SQLITE_STATUS_SCRATCH_USED         3", "#define SQLITE_STATUS_SCRATCH_OVERFLOW     4", "#define SQLITE_STATUS_MALLOC_SIZE          5", "#define SQLITE_STATUS_PARSER_STACK         6", "#define SQLITE_STATUS_PAGECACHE_SIZE       7", "#define SQLITE_STATUS_SCRATCH_SIZE         8", "#define SQLITE_STATUS_MALLOC_COUNT         9", "", "/*", "** CAPI3REF: Database Connection Status", "**", "** ^This interface is used to retrieve runtime status information ", "** about a single [database connection].  ^The first argument is the", "** database connection object to be interrogated.  ^The second argument", "** is an integer constant, taken from the set of", "** [SQLITE_DBSTATUS options], that", "** determines the parameter to interrogate.  The set of ", "** [SQLITE_DBSTATUS options] is likely", "** to grow in future releases of SQLite.", "**", "** ^The current value of the requested parameter is written into *pCur", "** and the highest instantaneous value is written into *pHiwtr.  ^If", "** the resetFlg is true, then the highest instantaneous value is", "** reset back down to the current value.", "**", "** ^The sqlite3_db_status() routine returns SQLITE_OK on success and a", "** non-zero [error code] on failure.", "**", "** See also: [sqlite3_status()] and [sqlite3_stmt_status()].", "*/", "SQLITE_API int sqlite3_db_status(sqlite3*, int op, int *pCur, int *pHiwtr, int resetFlg);", "", "/*", "** CAPI3REF: Status Parameters for database connections", "** KEYWORDS: {SQLITE_DBSTATUS options}", "**", '** These constants are the available integer "verbs" that can be passed as', "** the second argument to the [sqlite3_db_status()] interface.", "**", "** New verbs may be added in future releases of SQLite. Existing verbs", "** might be discontinued. Applications should check the return code from", "** [sqlite3_db_status()] to make sure that the call worked.", "** The [sqlite3_db_status()] interface will return a non-zero error code", "** if a discontinued or unsupported verb is invoked.", "**", "** <dl>", "** [[SQLITE_DBSTATUS_LOOKASIDE_USED]] ^(<dt>SQLITE_DBSTATUS_LOOKASIDE_USED</dt>", "** <dd>This parameter returns the number of lookaside memory slots currently", "** checked out.</dd>)^", "**", "** [[SQLITE_DBSTATUS_LOOKASIDE_HIT]] ^(<dt>SQLITE_DBSTATUS_LOOKASIDE_HIT</dt>", "** <dd>This parameter returns the number malloc attempts that were ", "** satisfied using lookaside memory. Only the high-water value is meaningful;", "** the current value is always zero.)^", "**", "** [[SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE]]", "** ^(<dt>SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE</dt>", "** <dd>This parameter returns the number malloc attempts that might have", "** been satisfied using lookaside memory but failed due to the amount of", "** memory requested being larger than the lookaside slot size.", "** Only the high-water value is meaningful;", "** the current value is always zero.)^", "**", "** [[SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL]]", "** ^(<dt>SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL</dt>", "** <dd>This parameter returns the number malloc attempts that might have", "** been satisfied using lookaside memory but failed due to all lookaside", "** memory already being in use.", "** Only the high-water value is meaningful;", "** the current value is always zero.)^", "**", "** [[SQLITE_DBSTATUS_CACHE_USED]] ^(<dt>SQLITE_DBSTATUS_CACHE_USED</dt>", "** <dd>This parameter returns the approximate number of of bytes of heap", "** memory used by all pager caches associated with the database connection.)^", "** ^The highwater mark associated with SQLITE_DBSTATUS_CACHE_USED is always 0.", "**", "** [[SQLITE_DBSTATUS_SCHEMA_USED]] ^(<dt>SQLITE_DBSTATUS_SCHEMA_USED</dt>", "** <dd>This parameter returns the approximate number of of bytes of heap", "** memory used to store the schema for all databases associated", "** with the connection - main, temp, and any [ATTACH]-ed databases.)^ ", "** ^The full amount of memory used by the schemas is reported, even if the", "** schema memory is shared with other database connections due to", "** [shared cache mode] being enabled.", "** ^The highwater mark associated with SQLITE_DBSTATUS_SCHEMA_USED is always 0.", "**", "** [[SQLITE_DBSTATUS_STMT_USED]] ^(<dt>SQLITE_DBSTATUS_STMT_USED</dt>", "** <dd>This parameter returns the approximate number of of bytes of heap", "** and lookaside memory used by all prepared statements associated with", "** the database connection.)^", "** ^The highwater mark associated with SQLITE_DBSTATUS_STMT_USED is always 0.", "** </dd>", "**", "** [[SQLITE_DBSTATUS_CACHE_HIT]] ^(<dt>SQLITE_DBSTATUS_CACHE_HIT</dt>", "** <dd>This parameter returns the number of pager cache hits that have", "** occurred.)^ ^The highwater mark associated with SQLITE_DBSTATUS_CACHE_HIT ", "** is always 0.", "** </dd>", "**", "** [[SQLITE_DBSTATUS_CACHE_MISS]] ^(<dt>SQLITE_DBSTATUS_CACHE_MISS</dt>", "** <dd>This parameter returns the number of pager cache misses that have", "** occurred.)^ ^The highwater mark associated with SQLITE_DBSTATUS_CACHE_MISS ", "** is always 0.", "** </dd>", "**", "** [[SQLITE_DBSTATUS_CACHE_WRITE]] ^(<dt>SQLITE_DBSTATUS_CACHE_WRITE</dt>", "** <dd>This parameter returns the number of dirty cache entries that have", "** been written to disk. Specifically, the number of pages written to the", "** wal file in wal mode databases, or the number of pages written to the", "** database file in rollback mode databases. Any pages written as part of", "** transaction rollback or database recovery operations are not included.", "** If an IO or other error occurs while writing a page to disk, the effect", "** on subsequent SQLITE_DBSTATUS_CACHE_WRITE requests is undefined.)^ ^The", "** highwater mark associated with SQLITE_DBSTATUS_CACHE_WRITE is always 0.", "** </dd>", "** </dl>", "*/", "#define SQLITE_DBSTATUS_LOOKASIDE_USED       0", "#define SQLITE_DBSTATUS_CACHE_USED           1", "#define SQLITE_DBSTATUS_SCHEMA_USED          2", "#define SQLITE_DBSTATUS_STMT_USED            3", "#define SQLITE_DBSTATUS_LOOKASIDE_HIT        4", "#define SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE  5", "#define SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL  6", "#define SQLITE_DBSTATUS_CACHE_HIT            7", "#define SQLITE_DBSTATUS_CACHE_MISS           8", "#define SQLITE_DBSTATUS_CACHE_WRITE          9", "#define SQLITE_DBSTATUS_MAX                  9   /* Largest defined DBSTATUS */", "", "", "/*", "** CAPI3REF: Prepared Statement Status", "**", "** ^(Each prepared statement maintains various", "** [SQLITE_STMTSTATUS counters] that measure the number", "** of times it has performed specific operations.)^  These counters can", "** be used to monitor the performance characteristics of the prepared", "** statements.  For example, if the number of table steps greatly exceeds", "** the number of table searches or result rows, that would tend to indicate", "** that the prepared statement is using a full table scan rather than", "** an index.  ", "**", "** ^(This interface is used to retrieve and reset counter values from", "** a [prepared statement].  The first argument is the prepared statement", "** object to be interrogated.  The second argument", "** is an integer code for a specific [SQLITE_STMTSTATUS counter]", "** to be interrogated.)^", "** ^The current value of the requested counter is returned.", "** ^If the resetFlg is true, then the counter is reset to zero after this", "** interface call returns.", "**", "** See also: [sqlite3_status()] and [sqlite3_db_status()].", "*/", "SQLITE_API int sqlite3_stmt_status(sqlite3_stmt*, int op,int resetFlg);", "", "/*", "** CAPI3REF: Status Parameters for prepared statements", "** KEYWORDS: {SQLITE_STMTSTATUS counter} {SQLITE_STMTSTATUS counters}", "**", "** These preprocessor macros define integer codes that name counter", "** values associated with the [sqlite3_stmt_status()] interface.", "** The meanings of the various counters are as follows:", "**", "** <dl>", "** [[SQLITE_STMTSTATUS_FULLSCAN_STEP]] <dt>SQLITE_STMTSTATUS_FULLSCAN_STEP</dt>", "** <dd>^This is the number of times that SQLite has stepped forward in", "** a table as part of a full table scan.  Large numbers for this counter", "** may indicate opportunities for performance improvement through ", "** careful use of indices.</dd>", "**", "** [[SQLITE_STMTSTATUS_SORT]] <dt>SQLITE_STMTSTATUS_SORT</dt>", "** <dd>^This is the number of sort operations that have occurred.", "** A non-zero value in this counter may indicate an opportunity to", "** improvement performance through careful use of indices.</dd>", "**", "** [[SQLITE_STMTSTATUS_AUTOINDEX]] <dt>SQLITE_STMTSTATUS_AUTOINDEX</dt>", "** <dd>^This is the number of rows inserted into transient indices that", "** were created automatically in order to help joins run faster.", "** A non-zero value in this counter may indicate an opportunity to", "** improvement performance by adding permanent indices that do not", "** need to be reinitialized each time the statement is run.</dd>", "** </dl>", "*/", "#define SQLITE_STMTSTATUS_FULLSCAN_STEP     1", "#define SQLITE_STMTSTATUS_SORT              2", "#define SQLITE_STMTSTATUS_AUTOINDEX         3", "", "/*", "** CAPI3REF: Custom Page Cache Object", "**", "** The sqlite3_pcache type is opaque.  It is implemented by", "** the pluggable module.  The SQLite core has no knowledge of", "** its size or internal structure and never deals with the", "** sqlite3_pcache object except by holding and passing pointers", "** to the object.", "**", "** See [sqlite3_pcache_methods2] for additional information.", "*/", "typedef struct sqlite3_pcache sqlite3_pcache;", "", "/*", "** CAPI3REF: Custom Page Cache Object", "**", "** The sqlite3_pcache_page object represents a single page in the", "** page cache.  The page cache will allocate instances of this", "** object.  Various methods of the page cache use pointers to instances", "** of this object as parameters or as their return value.", "**", "** See [sqlite3_pcache_methods2] for additional information.", "*/", "typedef struct sqlite3_pcache_page sqlite3_pcache_page;", "struct sqlite3_pcache_page {", "  void *pBuf;        /* The content of the page */", "  void *pExtra;      /* Extra information associated with the page */", "};", "", "/*", "** CAPI3REF: Application Defined Page Cache.", "** KEYWORDS: {page cache}", "**", "** ^(The [sqlite3_config]([SQLITE_CONFIG_PCACHE2], ...) interface can", "** register an alternative page cache implementation by passing in an ", "** instance of the sqlite3_pcache_methods2 structure.)^", "** In many applications, most of the heap memory allocated by ", "** SQLite is used for the page cache.", "** By implementing a ", "** custom page cache using this API, an application can better control", "** the amount of memory consumed by SQLite, the way in which ", "** that memory is allocated and released, and the policies used to ", "** determine exactly which parts of a database file are cached and for ", "** how long.", "**", "** The alternative page cache mechanism is an", "** extreme measure that is only needed by the most demanding applications.", "** The built-in page cache is recommended for most uses.", "**", "** ^(The contents of the sqlite3_pcache_methods2 structure are copied to an", "** internal buffer by SQLite within the call to [sqlite3_config].  Hence", "** the application may discard the parameter after the call to", "** [sqlite3_config()] returns.)^", "**", "** [[the xInit() page cache method]]", "** ^(The xInit() method is called once for each effective ", "** call to [sqlite3_initialize()])^", "** (usually only once during the lifetime of the process). ^(The xInit()", "** method is passed a copy of the sqlite3_pcache_methods2.pArg value.)^", "** The intent of the xInit() method is to set up global data structures ", "** required by the custom page cache implementation. ", "** ^(If the xInit() method is NULL, then the ", "** built-in default page cache is used instead of the application defined", "** page cache.)^", "**", "** [[the xShutdown() page cache method]]", "** ^The xShutdown() method is called by [sqlite3_shutdown()].", "** It can be used to clean up ", "** any outstanding resources before process shutdown, if required.", "** ^The xShutdown() method may be NULL.", "**", "** ^SQLite automatically serializes calls to the xInit method,", "** so the xInit method need not be threadsafe.  ^The", "** xShutdown method is only called from [sqlite3_shutdown()] so it does", "** not need to be threadsafe either.  All other methods must be threadsafe", "** in multithreaded applications.", "**", "** ^SQLite will never invoke xInit() more than once without an intervening", "** call to xShutdown().", "**", "** [[the xCreate() page cache methods]]", "** ^SQLite invokes the xCreate() method to construct a new cache instance.", "** SQLite will typically create one cache instance for each open database file,", "** though this is not guaranteed. ^The", "** first parameter, szPage, is the size in bytes of the pages that must", "** be allocated by the cache.  ^szPage will always a power of two.  ^The", "** second parameter szExtra is a number of bytes of extra storage ", "** associated with each page cache entry.  ^The szExtra parameter will", "** a number less than 250.  SQLite will use the", "** extra szExtra bytes on each page to store metadata about the underlying", "** database page on disk.  The value passed into szExtra depends", "** on the SQLite version, the target platform, and how SQLite was compiled.", "** ^The third argument to xCreate(), bPurgeable, is true if the cache being", "** created will be used to cache database pages of a file stored on disk, or", "** false if it is used for an in-memory database. The cache implementation", "** does not have to do anything special based with the value of bPurgeable;", "** it is purely advisory.  ^On a cache where bPurgeable is false, SQLite will", "** never invoke xUnpin() except to deliberately delete a page.", "** ^In other words, calls to xUnpin() on a cache with bPurgeable set to", '** false will always have the "discard" flag set to true.  ', "** ^Hence, a cache created with bPurgeable false will", "** never contain any unpinned pages.", "**", "** [[the xCachesize() page cache method]]", "** ^(The xCachesize() method may be called at any time by SQLite to set the", "** suggested maximum cache-size (number of pages stored by) the cache", "** instance passed as the first argument. This is the value configured using", '** the SQLite "[PRAGMA cache_size]" command.)^  As with the bPurgeable', "** parameter, the implementation is not required to do anything with this", "** value; it is advisory only.", "**", "** [[the xPagecount() page cache methods]]", "** The xPagecount() method must return the number of pages currently", "** stored in the cache, both pinned and unpinned.", "** ", "** [[the xFetch() page cache methods]]", "** The xFetch() method locates a page in the cache and returns a pointer to ", "** an sqlite3_pcache_page object associated with that page, or a NULL pointer.", "** The pBuf element of the returned sqlite3_pcache_page object will be a", "** pointer to a buffer of szPage bytes used to store the content of a ", "** single database page.  The pExtra element of sqlite3_pcache_page will be", "** a pointer to the szExtra bytes of extra storage that SQLite has requested", "** for each entry in the page cache.", "**", "** The page to be fetched is determined by the key. ^The minimum key value", "** is 1.  After it has been retrieved using xFetch, the page is considered", '** to be "pinned".', "**", "** If the requested page is already in the page cache, then the page cache", "** implementation must return a pointer to the page buffer with its content", "** intact.  If the requested page is not already in the cache, then the", "** cache implementation should use the value of the createFlag", "** parameter to help it determined what action to take:", "**", "** <table border=1 width=85% align=center>", "** <tr><th> createFlag <th> Behaviour when page is not already in cache", "** <tr><td> 0 <td> Do not allocate a new page.  Return NULL.", "** <tr><td> 1 <td> Allocate a new page if it easy and convenient to do so.", "**                 Otherwise return NULL.", "** <tr><td> 2 <td> Make every effort to allocate a new page.  Only return", "**                 NULL if allocating a new page is effectively impossible.", "** </table>", "**", "** ^(SQLite will normally invoke xFetch() with a createFlag of 0 or 1.  SQLite", "** will only use a createFlag of 2 after a prior call with a createFlag of 1", "** failed.)^  In between the to xFetch() calls, SQLite may", "** attempt to unpin one or more cache pages by spilling the content of", "** pinned pages to disk and synching the operating system disk cache.", "**", "** [[the xUnpin() page cache method]]", "** ^xUnpin() is called by SQLite with a pointer to a currently pinned page", "** as its second argument.  If the third parameter, discard, is non-zero,", "** then the page must be evicted from the cache.", "** ^If the discard parameter is", "** zero, then the page may be discarded or retained at the discretion of", "** page cache implementation. ^The page cache implementation", "** may choose to evict unpinned pages at any time.", "**", "** The cache must not perform any reference counting. A single ", "** call to xUnpin() unpins the page regardless of the number of prior calls ", "** to xFetch().", "**", "** [[the xRekey() page cache methods]]", "** The xRekey() method is used to change the key value associated with the", "** page passed as the second argument. If the cache", "** previously contains an entry associated with newKey, it must be", "** discarded. ^Any prior cache entry associated with newKey is guaranteed not", "** to be pinned.", "**", "** When SQLite calls the xTruncate() method, the cache must discard all", "** existing cache entries with page numbers (keys) greater than or equal", "** to the value of the iLimit parameter passed to xTruncate(). If any", "** of these pages are pinned, they are implicitly unpinned, meaning that", "** they can be safely discarded.", "**", "** [[the xDestroy() page cache method]]", "** ^The xDestroy() method is used to delete a cache allocated by xCreate().", "** All resources associated with the specified cache should be freed. ^After", "** calling the xDestroy() method, SQLite considers the [sqlite3_pcache*]", "** handle invalid, and will not use it with any other sqlite3_pcache_methods2", "** functions.", "**", "** [[the xShrink() page cache method]]", "** ^SQLite invokes the xShrink() method when it wants the page cache to", "** free up as much of heap memory as possible.  The page cache implementation", "** is not obligated to free any memory, but well-behaved implementations should", "** do their best.", "*/", "typedef struct sqlite3_pcache_methods2 sqlite3_pcache_methods2;", "struct sqlite3_pcache_methods2 {", "  int iVersion;", "  void *pArg;", "  int (*xInit)(void*);", "  void (*xShutdown)(void*);", "  sqlite3_pcache *(*xCreate)(int szPage, int szExtra, int bPurgeable);", "  void (*xCachesize)(sqlite3_pcache*, int nCachesize);", "  int (*xPagecount)(sqlite3_pcache*);", "  sqlite3_pcache_page *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag);", "  void (*xUnpin)(sqlite3_pcache*, sqlite3_pcache_page*, int discard);", "  void (*xRekey)(sqlite3_pcache*, sqlite3_pcache_page*, ", "      unsigned oldKey, unsigned newKey);", "  void (*xTruncate)(sqlite3_pcache*, unsigned iLimit);", "  void (*xDestroy)(sqlite3_pcache*);", "  void (*xShrink)(sqlite3_pcache*);", "};", "", "/*", "** This is the obsolete pcache_methods object that has now been replaced", "** by sqlite3_pcache_methods2.  This object is not used by SQLite.  It is", "** retained in the header file for backwards compatibility only.", "*/", "typedef struct sqlite3_pcache_methods sqlite3_pcache_methods;", "struct sqlite3_pcache_methods {", "  void *pArg;", "  int (*xInit)(void*);", "  void (*xShutdown)(void*);", "  sqlite3_pcache *(*xCreate)(int szPage, int bPurgeable);", "  void (*xCachesize)(sqlite3_pcache*, int nCachesize);", "  int (*xPagecount)(sqlite3_pcache*);", "  void *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag);", "  void (*xUnpin)(sqlite3_pcache*, void*, int discard);", "  void (*xRekey)(sqlite3_pcache*, void*, unsigned oldKey, unsigned newKey);", "  void (*xTruncate)(sqlite3_pcache*, unsigned iLimit);", "  void (*xDestroy)(sqlite3_pcache*);", "};", "", "", "/*", "** CAPI3REF: Online Backup Object", "**", "** The sqlite3_backup object records state information about an ongoing", "** online backup operation.  ^The sqlite3_backup object is created by", "** a call to [sqlite3_backup_init()] and is destroyed by a call to", "** [sqlite3_backup_finish()].", "**", "** See Also: [Using the SQLite Online Backup API]", "*/", "typedef struct sqlite3_backup sqlite3_backup;", "", "/*", "** CAPI3REF: Online Backup API.", "**", "** The backup API copies the content of one database into another.", "** It is useful either for creating backups of databases or", "** for copying in-memory databases to or from persistent files. ", "**", "** See Also: [Using the SQLite Online Backup API]", "**", "** ^SQLite holds a write transaction open on the destination database file", "** for the duration of the backup operation.", "** ^The source database is read-locked only while it is being read;", "** it is not locked continuously for the entire backup operation.", "** ^Thus, the backup may be performed on a live source database without", "** preventing other database connections from", "** reading or writing to the source database while the backup is underway.", "** ", "** ^(To perform a backup operation: ", "**   <ol>", "**     <li><b>sqlite3_backup_init()</b> is called once to initialize the", "**         backup, ", "**     <li><b>sqlite3_backup_step()</b> is called one or more times to transfer ", "**         the data between the two databases, and finally", "**     <li><b>sqlite3_backup_finish()</b> is called to release all resources ", "**         associated with the backup operation. ", "**   </ol>)^", "** There should be exactly one call to sqlite3_backup_finish() for each", "** successful call to sqlite3_backup_init().", "**", "** [[sqlite3_backup_init()]] <b>sqlite3_backup_init()</b>", "**", "** ^The D and N arguments to sqlite3_backup_init(D,N,S,M) are the ", "** [database connection] associated with the destination database ", "** and the database name, respectively.", '** ^The database name is "main" for the main database, "temp" for the', "** temporary database, or the name specified after the AS keyword in", "** an [ATTACH] statement for an attached database.", "** ^The S and M arguments passed to ", "** sqlite3_backup_init(D,N,S,M) identify the [database connection]", "** and database name of the source database, respectively.", "** ^The source and destination [database connections] (parameters S and D)", "** must be different or else sqlite3_backup_init(D,N,S,M) will fail with", "** an error.", "**", "** ^If an error occurs within sqlite3_backup_init(D,N,S,M), then NULL is", "** returned and an error code and error message are stored in the", "** destination [database connection] D.", "** ^The error code and message for the failed call to sqlite3_backup_init()", "** can be retrieved using the [sqlite3_errcode()], [sqlite3_errmsg()], and/or", "** [sqlite3_errmsg16()] functions.", "** ^A successful call to sqlite3_backup_init() returns a pointer to an", "** [sqlite3_backup] object.", "** ^The [sqlite3_backup] object may be used with the sqlite3_backup_step() and", "** sqlite3_backup_finish() functions to perform the specified backup ", "** operation.", "**", "** [[sqlite3_backup_step()]] <b>sqlite3_backup_step()</b>", "**", "** ^Function sqlite3_backup_step(B,N) will copy up to N pages between ", "** the source and destination databases specified by [sqlite3_backup] object B.", "** ^If N is negative, all remaining source pages are copied. ", "** ^If sqlite3_backup_step(B,N) successfully copies N pages and there", "** are still more pages to be copied, then the function returns [SQLITE_OK].", "** ^If sqlite3_backup_step(B,N) successfully finishes copying all pages", "** from source to destination, then it returns [SQLITE_DONE].", "** ^If an error occurs while running sqlite3_backup_step(B,N),", "** then an [error code] is returned. ^As well as [SQLITE_OK] and", "** [SQLITE_DONE], a call to sqlite3_backup_step() may return [SQLITE_READONLY],", "** [SQLITE_NOMEM], [SQLITE_BUSY], [SQLITE_LOCKED], or an", "** [SQLITE_IOERR_ACCESS | SQLITE_IOERR_XXX] extended error code.", "**", "** ^(The sqlite3_backup_step() might return [SQLITE_READONLY] if", "** <ol>", "** <li> the destination database was opened read-only, or", "** <li> the destination database is using write-ahead-log journaling", "** and the destination and source page sizes differ, or", "** <li> the destination database is an in-memory database and the", "** destination and source page sizes differ.", "** </ol>)^", "**", "** ^If sqlite3_backup_step() cannot obtain a required file-system lock, then", "** the [sqlite3_busy_handler | busy-handler function]", "** is invoked (if one is specified). ^If the ", "** busy-handler returns non-zero before the lock is available, then ", "** [SQLITE_BUSY] is returned to the caller. ^In this case the call to", "** sqlite3_backup_step() can be retried later. ^If the source", "** [database connection]", "** is being used to write to the source database when sqlite3_backup_step()", "** is called, then [SQLITE_LOCKED] is returned immediately. ^Again, in this", "** case the call to sqlite3_backup_step() can be retried later on. ^(If", "** [SQLITE_IOERR_ACCESS | SQLITE_IOERR_XXX], [SQLITE_NOMEM], or", "** [SQLITE_READONLY] is returned, then ", "** there is no point in retrying the call to sqlite3_backup_step(). These ", "** errors are considered fatal.)^  The application must accept ", "** that the backup operation has failed and pass the backup operation handle ", "** to the sqlite3_backup_finish() to release associated resources.", "**", "** ^The first call to sqlite3_backup_step() obtains an exclusive lock", "** on the destination file. ^The exclusive lock is not released until either ", "** sqlite3_backup_finish() is called or the backup operation is complete ", "** and sqlite3_backup_step() returns [SQLITE_DONE].  ^Every call to", "** sqlite3_backup_step() obtains a [shared lock] on the source database that", "** lasts for the duration of the sqlite3_backup_step() call.", "** ^Because the source database is not locked between calls to", "** sqlite3_backup_step(), the source database may be modified mid-way", "** through the backup process.  ^If the source database is modified by an", "** external process or via a database connection other than the one being", "** used by the backup operation, then the backup will be automatically", "** restarted by the next call to sqlite3_backup_step(). ^If the source ", "** database is modified by the using the same database connection as is used", "** by the backup operation, then the backup database is automatically", "** updated at the same time.", "**", "** [[sqlite3_backup_finish()]] <b>sqlite3_backup_finish()</b>", "**", "** When sqlite3_backup_step() has returned [SQLITE_DONE], or when the ", "** application wishes to abandon the backup operation, the application", "** should destroy the [sqlite3_backup] by passing it to sqlite3_backup_finish().", "** ^The sqlite3_backup_finish() interfaces releases all", "** resources associated with the [sqlite3_backup] object. ", "** ^If sqlite3_backup_step() has not yet returned [SQLITE_DONE], then any", "** active write-transaction on the destination database is rolled back.", "** The [sqlite3_backup] object is invalid", "** and may not be used following a call to sqlite3_backup_finish().", "**", "** ^The value returned by sqlite3_backup_finish is [SQLITE_OK] if no", "** sqlite3_backup_step() errors occurred, regardless or whether or not", "** sqlite3_backup_step() completed.", "** ^If an out-of-memory condition or IO error occurred during any prior", "** sqlite3_backup_step() call on the same [sqlite3_backup] object, then", "** sqlite3_backup_finish() returns the corresponding [error code].", "**", "** ^A return of [SQLITE_BUSY] or [SQLITE_LOCKED] from sqlite3_backup_step()", "** is not a permanent error and does not affect the return value of", "** sqlite3_backup_finish().", "**", "** [[sqlite3_backup__remaining()]] [[sqlite3_backup_pagecount()]]", "** <b>sqlite3_backup_remaining() and sqlite3_backup_pagecount()</b>", "**", "** ^Each call to sqlite3_backup_step() sets two values inside", "** the [sqlite3_backup] object: the number of pages still to be backed", "** up and the total number of pages in the source database file.", "** The sqlite3_backup_remaining() and sqlite3_backup_pagecount() interfaces", "** retrieve these two values, respectively.", "**", "** ^The values returned by these functions are only updated by", "** sqlite3_backup_step(). ^If the source database is modified during a backup", "** operation, then the values are not updated to account for any extra", "** pages that need to be updated or the size of the source database file", "** changing.", "**", "** <b>Concurrent Usage of Database Handles</b>", "**", "** ^The source [database connection] may be used by the application for other", "** purposes while a backup operation is underway or being initialized.", "** ^If SQLite is compiled and configured to support threadsafe database", "** connections, then the source database connection may be used concurrently", "** from within other threads.", "**", "** However, the application must guarantee that the destination ", "** [database connection] is not passed to any other API (by any thread) after ", "** sqlite3_backup_init() is called and before the corresponding call to", "** sqlite3_backup_finish().  SQLite does not currently check to see", "** if the application incorrectly accesses the destination [database connection]", "** and so no error code is reported, but the operations may malfunction", "** nevertheless.  Use of the destination database connection while a", "** backup is in progress might also also cause a mutex deadlock.", "**", "** If running in [shared cache mode], the application must", "** guarantee that the shared cache used by the destination database", "** is not accessed while the backup is running. In practice this means", "** that the application must guarantee that the disk file being ", "** backed up to is not accessed by any connection within the process,", "** not just the specific connection that was passed to sqlite3_backup_init().", "**", "** The [sqlite3_backup] object itself is partially threadsafe. Multiple ", "** threads may safely make multiple concurrent calls to sqlite3_backup_step().", "** However, the sqlite3_backup_remaining() and sqlite3_backup_pagecount()", "** APIs are not strictly speaking threadsafe. If they are invoked at the", "** same time as another thread is invoking sqlite3_backup_step() it is", "** possible that they return invalid values.", "*/", "SQLITE_API sqlite3_backup *sqlite3_backup_init(", "  sqlite3 *pDest,                        /* Destination database handle */", "  const char *zDestName,                 /* Destination database name */", "  sqlite3 *pSource,                      /* Source database handle */", "  const char *zSourceName                /* Source database name */", ");", "SQLITE_API int sqlite3_backup_step(sqlite3_backup *p, int nPage);", "SQLITE_API int sqlite3_backup_finish(sqlite3_backup *p);", "SQLITE_API int sqlite3_backup_remaining(sqlite3_backup *p);", "SQLITE_API int sqlite3_backup_pagecount(sqlite3_backup *p);", "", "/*", "** CAPI3REF: Unlock Notification", "**", "** ^When running in shared-cache mode, a database operation may fail with", "** an [SQLITE_LOCKED] error if the required locks on the shared-cache or", "** individual tables within the shared-cache cannot be obtained. See", "** [SQLite Shared-Cache Mode] for a description of shared-cache locking. ", "** ^This API may be used to register a callback that SQLite will invoke ", "** when the connection currently holding the required lock relinquishes it.", "** ^This API is only available if the library was compiled with the", "** [SQLITE_ENABLE_UNLOCK_NOTIFY] C-preprocessor symbol defined.", "**", "** See Also: [Using the SQLite Unlock Notification Feature].", "**", "** ^Shared-cache locks are released when a database connection concludes", "** its current transaction, either by committing it or rolling it back. ", "**", "** ^When a connection (known as the blocked connection) fails to obtain a", "** shared-cache lock and SQLITE_LOCKED is returned to the caller, the", "** identity of the database connection (the blocking connection) that", "** has locked the required resource is stored internally. ^After an ", "** application receives an SQLITE_LOCKED error, it may call the", "** sqlite3_unlock_notify() method with the blocked connection handle as ", "** the first argument to register for a callback that will be invoked", "** when the blocking connections current transaction is concluded. ^The", "** callback is invoked from within the [sqlite3_step] or [sqlite3_close]", "** call that concludes the blocking connections transaction.", "**", "** ^(If sqlite3_unlock_notify() is called in a multi-threaded application,", "** there is a chance that the blocking connection will have already", "** concluded its transaction by the time sqlite3_unlock_notify() is invoked.", "** If this happens, then the specified callback is invoked immediately,", "** from within the call to sqlite3_unlock_notify().)^", "**", "** ^If the blocked connection is attempting to obtain a write-lock on a", "** shared-cache table, and more than one other connection currently holds", "** a read-lock on the same table, then SQLite arbitrarily selects one of ", "** the other connections to use as the blocking connection.", "**", "** ^(There may be at most one unlock-notify callback registered by a ", "** blocked connection. If sqlite3_unlock_notify() is called when the", "** blocked connection already has a registered unlock-notify callback,", "** then the new callback replaces the old.)^ ^If sqlite3_unlock_notify() is", "** called with a NULL pointer as its second argument, then any existing", "** unlock-notify callback is canceled. ^The blocked connections ", "** unlock-notify callback may also be canceled by closing the blocked", "** connection using [sqlite3_close()].", "**", "** The unlock-notify callback is not reentrant. If an application invokes", "** any sqlite3_xxx API functions from within an unlock-notify callback, a", "** crash or deadlock may be the result.", "**", "** ^Unless deadlock is detected (see below), sqlite3_unlock_notify() always", "** returns SQLITE_OK.", "**", "** <b>Callback Invocation Details</b>", "**", "** When an unlock-notify callback is registered, the application provides a ", "** single void* pointer that is passed to the callback when it is invoked.", "** However, the signature of the callback function allows SQLite to pass", "** it an array of void* context pointers. The first argument passed to", "** an unlock-notify callback is a pointer to an array of void* pointers,", "** and the second is the number of entries in the array.", "**", "** When a blocking connections transaction is concluded, there may be", "** more than one blocked connection that has registered for an unlock-notify", "** callback. ^If two or more such blocked connections have specified the", "** same callback function, then instead of invoking the callback function", "** multiple times, it is invoked once with the set of void* context pointers", "** specified by the blocked connections bundled together into an array.", "** This gives the application an opportunity to prioritize any actions ", "** related to the set of unblocked database connections.", "**", "** <b>Deadlock Detection</b>", "**", "** Assuming that after registering for an unlock-notify callback a ", "** database waits for the callback to be issued before taking any further", "** action (a reasonable assumption), then using this API may cause the", "** application to deadlock. For example, if connection X is waiting for", "** connection Y's transaction to be concluded, and similarly connection", "** Y is waiting on connection X's transaction, then neither connection", "** will proceed and the system may remain deadlocked indefinitely.", "**", "** To avoid this scenario, the sqlite3_unlock_notify() performs deadlock", "** detection. ^If a given call to sqlite3_unlock_notify() would put the", "** system in a deadlocked state, then SQLITE_LOCKED is returned and no", "** unlock-notify callback is registered. The system is said to be in", "** a deadlocked state if connection A has registered for an unlock-notify", "** callback on the conclusion of connection B's transaction, and connection", "** B has itself registered for an unlock-notify callback when connection", "** A's transaction is concluded. ^Indirect deadlock is also detected, so", "** the system is also considered to be deadlocked if connection B has", "** registered for an unlock-notify callback on the conclusion of connection", "** C's transaction, where connection C is waiting on connection A. ^Any", "** number of levels of indirection are allowed.", "**", '** <b>The "DROP TABLE" Exception</b>', "**", "** When a call to [sqlite3_step()] returns SQLITE_LOCKED, it is almost ", "** always appropriate to call sqlite3_unlock_notify(). There is however,", '** one exception. When executing a "DROP TABLE" or "DROP INDEX" statement,', "** SQLite checks if there are any currently executing SELECT statements", "** that belong to the same connection. If there are, SQLITE_LOCKED is", '** returned. In this case there is no "blocking connection", so invoking', "** sqlite3_unlock_notify() results in the unlock-notify callback being", '** invoked immediately. If the application then re-attempts the "DROP TABLE"', '** or "DROP INDEX" query, an infinite loop might be the result.', "**", "** One way around this problem is to check the extended error code returned", "** by an sqlite3_step() call. ^(If there is a blocking connection, then the", "** extended error code is set to SQLITE_LOCKED_SHAREDCACHE. Otherwise, in", '** the special "DROP TABLE/INDEX" case, the extended error code is just ', "** SQLITE_LOCKED.)^", "*/", "SQLITE_API int sqlite3_unlock_notify(", "  sqlite3 *pBlocked,                          /* Waiting connection */", "  void (*xNotify)(void **apArg, int nArg),    /* Callback function to invoke */", "  void *pNotifyArg                            /* Argument to pass to xNotify */", ");", "", "", "/*", "** CAPI3REF: String Comparison", "**", "** ^The [sqlite3_stricmp()] and [sqlite3_strnicmp()] APIs allow applications", "** and extensions to compare the contents of two buffers containing UTF-8", '** strings in a case-independent fashion, using the same definition of "case', '** independence" that SQLite uses internally when comparing identifiers.', "*/", "SQLITE_API int sqlite3_stricmp(const char *, const char *);", "SQLITE_API int sqlite3_strnicmp(const char *, const char *, int);", "", "/*", "** CAPI3REF: Error Logging Interface", "**", "** ^The [sqlite3_log()] interface writes a message into the error log", "** established by the [SQLITE_CONFIG_LOG] option to [sqlite3_config()].", "** ^If logging is enabled, the zFormat string and subsequent arguments are", "** used with [sqlite3_snprintf()] to generate the final output string.", "**", "** The sqlite3_log() interface is intended for use by extensions such as", "** virtual tables, collating functions, and SQL functions.  While there is", "** nothing to prevent an application from calling sqlite3_log(), doing so", "** is considered bad form.", "**", "** The zFormat string must not be NULL.", "**", "** To avoid deadlocks and other threading problems, the sqlite3_log() routine", "** will not use dynamically allocated memory.  The log message is stored in", "** a fixed-length buffer on the stack.  If the log message is longer than", "** a few hundred characters, it will be truncated to the length of the", "** buffer.", "*/", "SQLITE_API void sqlite3_log(int iErrCode, const char *zFormat, ...);", "", "/*", "** CAPI3REF: Write-Ahead Log Commit Hook", "**", "** ^The [sqlite3_wal_hook()] function is used to register a callback that", "** will be invoked each time a database connection commits data to a", "** [write-ahead log] (i.e. whenever a transaction is committed in", "** [journal_mode | journal_mode=WAL mode]). ", "**", "** ^The callback is invoked by SQLite after the commit has taken place and ", "** the associated write-lock on the database released, so the implementation ", "** may read, write or [checkpoint] the database as required.", "**", "** ^The first parameter passed to the callback function when it is invoked", "** is a copy of the third parameter passed to sqlite3_wal_hook() when", "** registering the callback. ^The second is a copy of the database handle.", "** ^The third parameter is the name of the database that was written to -", '** either "main" or the name of an [ATTACH]-ed database. ^The fourth parameter', "** is the number of pages currently in the write-ahead log file,", "** including those that were just committed.", "**", "** The callback function should normally return [SQLITE_OK].  ^If an error", "** code is returned, that error will propagate back up through the", "** SQLite code base to cause the statement that provoked the callback", "** to report an error, though the commit will have still occurred. If the", "** callback returns [SQLITE_ROW] or [SQLITE_DONE], or if it returns a value", "** that does not correspond to any valid SQLite error code, the results", "** are undefined.", "**", "** A single database handle may have at most a single write-ahead log callback ", "** registered at one time. ^Calling [sqlite3_wal_hook()] replaces any", "** previously registered write-ahead log callback. ^Note that the", "** [sqlite3_wal_autocheckpoint()] interface and the", "** [wal_autocheckpoint pragma] both invoke [sqlite3_wal_hook()] and will", "** those overwrite any prior [sqlite3_wal_hook()] settings.", "*/", "SQLITE_API void *sqlite3_wal_hook(", "  sqlite3*, ", "  int(*)(void *,sqlite3*,const char*,int),", "  void*", ");", "", "/*", "** CAPI3REF: Configure an auto-checkpoint", "**", "** ^The [sqlite3_wal_autocheckpoint(D,N)] is a wrapper around", "** [sqlite3_wal_hook()] that causes any database on [database connection] D", "** to automatically [checkpoint]", "** after committing a transaction if there are N or", "** more frames in the [write-ahead log] file.  ^Passing zero or ", "** a negative value as the nFrame parameter disables automatic", "** checkpoints entirely.", "**", "** ^The callback registered by this function replaces any existing callback", "** registered using [sqlite3_wal_hook()].  ^Likewise, registering a callback", "** using [sqlite3_wal_hook()] disables the automatic checkpoint mechanism", "** configured by this function.", "**", "** ^The [wal_autocheckpoint pragma] can be used to invoke this interface", "** from SQL.", "**", "** ^Every new [database connection] defaults to having the auto-checkpoint", "** enabled with a threshold of 1000 or [SQLITE_DEFAULT_WAL_AUTOCHECKPOINT]", "** pages.  The use of this interface", "** is only necessary if the default setting is found to be suboptimal", "** for a particular application.", "*/", "SQLITE_API int sqlite3_wal_autocheckpoint(sqlite3 *db, int N);", "", "/*", "** CAPI3REF: Checkpoint a database", "**", "** ^The [sqlite3_wal_checkpoint(D,X)] interface causes database named X", "** on [database connection] D to be [checkpointed].  ^If X is NULL or an", "** empty string, then a checkpoint is run on all databases of", "** connection D.  ^If the database connection D is not in", "** [WAL | write-ahead log mode] then this interface is a harmless no-op.", "**", "** ^The [wal_checkpoint pragma] can be used to invoke this interface", "** from SQL.  ^The [sqlite3_wal_autocheckpoint()] interface and the", "** [wal_autocheckpoint pragma] can be used to cause this interface to be", "** run whenever the WAL reaches a certain size threshold.", "**", "** See also: [sqlite3_wal_checkpoint_v2()]", "*/", "SQLITE_API int sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb);", "", "/*", "** CAPI3REF: Checkpoint a database", "**", "** Run a checkpoint operation on WAL database zDb attached to database ", "** handle db. The specific operation is determined by the value of the ", "** eMode parameter:", "**", "** <dl>", "** <dt>SQLITE_CHECKPOINT_PASSIVE<dd>", "**   Checkpoint as many frames as possible without waiting for any database ", "**   readers or writers to finish. Sync the db file if all frames in the log", "**   are checkpointed. This mode is the same as calling ", "**   sqlite3_wal_checkpoint(). The busy-handler callback is never invoked.", "**", "** <dt>SQLITE_CHECKPOINT_FULL<dd>", "**   This mode blocks (calls the busy-handler callback) until there is no", "**   database writer and all readers are reading from the most recent database", "**   snapshot. It then checkpoints all frames in the log file and syncs the", "**   database file. This call blocks database writers while it is running,", "**   but not database readers.", "**", "** <dt>SQLITE_CHECKPOINT_RESTART<dd>", "**   This mode works the same way as SQLITE_CHECKPOINT_FULL, except after ", "**   checkpointing the log file it blocks (calls the busy-handler callback)", "**   until all readers are reading from the database file only. This ensures ", "**   that the next client to write to the database file restarts the log file ", "**   from the beginning. This call blocks database writers while it is running,", "**   but not database readers.", "** </dl>", "**", "** If pnLog is not NULL, then *pnLog is set to the total number of frames in", "** the log file before returning. If pnCkpt is not NULL, then *pnCkpt is set to", "** the total number of checkpointed frames (including any that were already", "** checkpointed when this function is called). *pnLog and *pnCkpt may be", "** populated even if sqlite3_wal_checkpoint_v2() returns other than SQLITE_OK.", "** If no values are available because of an error, they are both set to -1", "** before returning to communicate this to the caller.", "**", '** All calls obtain an exclusive "checkpoint" lock on the database file. If', "** any other process is running a checkpoint operation at the same time, the ", "** lock cannot be obtained and SQLITE_BUSY is returned. Even if there is a ", "** busy-handler configured, it will not be invoked in this case.", "**", "** The SQLITE_CHECKPOINT_FULL and RESTART modes also obtain the exclusive ", '** "writer" lock on the database file. If the writer lock cannot be obtained', "** immediately, and a busy-handler is configured, it is invoked and the writer", "** lock retried until either the busy-handler returns 0 or the lock is", "** successfully obtained. The busy-handler is also invoked while waiting for", "** database readers as described above. If the busy-handler returns 0 before", "** the writer lock is obtained or while waiting for database readers, the", "** checkpoint operation proceeds from that point in the same way as ", "** SQLITE_CHECKPOINT_PASSIVE - checkpointing as many frames as possible ", "** without blocking any further. SQLITE_BUSY is returned in this case.", "**", "** If parameter zDb is NULL or points to a zero length string, then the", "** specified operation is attempted on all WAL databases. In this case the", "** values written to output parameters *pnLog and *pnCkpt are undefined. If ", "** an SQLITE_BUSY error is encountered when processing one or more of the ", "** attached WAL databases, the operation is still attempted on any remaining ", "** attached databases and SQLITE_BUSY is returned to the caller. If any other ", "** error occurs while processing an attached database, processing is abandoned ", "** and the error code returned to the caller immediately. If no error ", "** (SQLITE_BUSY or otherwise) is encountered while processing the attached ", "** databases, SQLITE_OK is returned.", "**", "** If database zDb is the name of an attached database that is not in WAL", "** mode, SQLITE_OK is returned and both *pnLog and *pnCkpt set to -1. If", "** zDb is not NULL (or a zero length string) and is not the name of any", "** attached database, SQLITE_ERROR is returned to the caller.", "*/", "SQLITE_API int sqlite3_wal_checkpoint_v2(", "  sqlite3 *db,                    /* Database handle */", "  const char *zDb,                /* Name of attached database (or NULL) */", "  int eMode,                      /* SQLITE_CHECKPOINT_* value */", "  int *pnLog,                     /* OUT: Size of WAL log in frames */", "  int *pnCkpt                     /* OUT: Total number of frames checkpointed */", ");", "", "/*", "** CAPI3REF: Checkpoint operation parameters", "**", "** These constants can be used as the 3rd parameter to", "** [sqlite3_wal_checkpoint_v2()].  See the [sqlite3_wal_checkpoint_v2()]", "** documentation for additional information about the meaning and use of", "** each of these values.", "*/", "#define SQLITE_CHECKPOINT_PASSIVE 0", "#define SQLITE_CHECKPOINT_FULL    1", "#define SQLITE_CHECKPOINT_RESTART 2", "", "/*", "** CAPI3REF: Virtual Table Interface Configuration", "**", "** This function may be called by either the [xConnect] or [xCreate] method", "** of a [virtual table] implementation to configure", "** various facets of the virtual table interface.", "**", "** If this interface is invoked outside the context of an xConnect or", "** xCreate virtual table method then the behavior is undefined.", "**", "** At present, there is only one option that may be configured using", "** this function. (See [SQLITE_VTAB_CONSTRAINT_SUPPORT].)  Further options", "** may be added in the future.", "*/", "SQLITE_API int sqlite3_vtab_config(sqlite3*, int op, ...);", "", "/*", "** CAPI3REF: Virtual Table Configuration Options", "**", "** These macros define the various options to the", "** [sqlite3_vtab_config()] interface that [virtual table] implementations", "** can use to customize and optimize their behavior.", "**", "** <dl>", "** <dt>SQLITE_VTAB_CONSTRAINT_SUPPORT", "** <dd>Calls of the form", "** [sqlite3_vtab_config](db,SQLITE_VTAB_CONSTRAINT_SUPPORT,X) are supported,", "** where X is an integer.  If X is zero, then the [virtual table] whose", "** [xCreate] or [xConnect] method invoked [sqlite3_vtab_config()] does not", "** support constraints.  In this configuration (which is the default) if", "** a call to the [xUpdate] method returns [SQLITE_CONSTRAINT], then the entire", "** statement is rolled back as if [ON CONFLICT | OR ABORT] had been", "** specified as part of the users SQL statement, regardless of the actual", "** ON CONFLICT mode specified.", "**", "** If X is non-zero, then the virtual table implementation guarantees", "** that if [xUpdate] returns [SQLITE_CONSTRAINT], it will do so before", "** any modifications to internal or persistent data structures have been made.", "** If the [ON CONFLICT] mode is ABORT, FAIL, IGNORE or ROLLBACK, SQLite ", "** is able to roll back a statement or database transaction, and abandon", "** or continue processing the current SQL statement as appropriate. ", "** If the ON CONFLICT mode is REPLACE and the [xUpdate] method returns", "** [SQLITE_CONSTRAINT], SQLite handles this as if the ON CONFLICT mode", "** had been ABORT.", "**", "** Virtual table implementations that are required to handle OR REPLACE", "** must do so within the [xUpdate] method. If a call to the ", "** [sqlite3_vtab_on_conflict()] function indicates that the current ON ", "** CONFLICT policy is REPLACE, the virtual table implementation should ", "** silently replace the appropriate rows within the xUpdate callback and", "** return SQLITE_OK. Or, if this is not possible, it may return", "** SQLITE_CONSTRAINT, in which case SQLite falls back to OR ABORT ", "** constraint handling.", "** </dl>", "*/", "#define SQLITE_VTAB_CONSTRAINT_SUPPORT 1", "", "/*", "** CAPI3REF: Determine The Virtual Table Conflict Policy", "**", "** This function may only be called from within a call to the [xUpdate] method", "** of a [virtual table] implementation for an INSERT or UPDATE operation. ^The", "** value returned is one of [SQLITE_ROLLBACK], [SQLITE_IGNORE], [SQLITE_FAIL],", "** [SQLITE_ABORT], or [SQLITE_REPLACE], according to the [ON CONFLICT] mode", "** of the SQL statement that triggered the call to the [xUpdate] method of the", "** [virtual table].", "*/", "SQLITE_API int sqlite3_vtab_on_conflict(sqlite3 *);", "", "/*", "** CAPI3REF: Conflict resolution modes", "**", "** These constants are returned by [sqlite3_vtab_on_conflict()] to", "** inform a [virtual table] implementation what the [ON CONFLICT] mode", "** is for the SQL statement being evaluated.", "**", "** Note that the [SQLITE_IGNORE] constant is also used as a potential", "** return value from the [sqlite3_set_authorizer()] callback and that", "** [SQLITE_ABORT] is also a [result code].", "*/", "#define SQLITE_ROLLBACK 1", "/* #define SQLITE_IGNORE 2 // Also used by sqlite3_authorizer() callback */", "#define SQLITE_FAIL     3", "/* #define SQLITE_ABORT 4  // Also an error code */", "#define SQLITE_REPLACE  5", "", "", "", "/*", "** Undo the hack that converts floating point types to integer for", "** builds on processors without floating point support.", "*/", "#ifdef SQLITE_OMIT_FLOATING_POINT", "# undef double", "#endif", "", "#ifdef __cplusplus", "}  /* End of the 'extern \"C\"' block */", "#endif", "#endif", "", "/*", "** 2010 August 30", "**", "** The author disclaims copyright to this source code.  In place of", "** a legal notice, here is a blessing:", "**", "**    May you do good and not evil.", "**    May you find forgiveness for yourself and forgive others.", "**    May you share freely, never taking more than you give.", "**", "*************************************************************************", "*/", "", "#ifndef _SQLITE3RTREE_H_", "#define _SQLITE3RTREE_H_", "", "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "", "typedef struct sqlite3_rtree_geometry sqlite3_rtree_geometry;", "", "/*", "** Register a geometry callback named zGeom that can be used as part of an", "** R-Tree geometry query as follows:", "**", "**   SELECT ... FROM <rtree> WHERE <rtree col> MATCH $zGeom(... params ...)", "*/", "SQLITE_API int sqlite3_rtree_geometry_callback(", "  sqlite3 *db,", "  const char *zGeom,", "#ifdef SQLITE_RTREE_INT_ONLY", "  int (*xGeom)(sqlite3_rtree_geometry*, int n, sqlite3_int64 *a, int *pRes),", "#else", "  int (*xGeom)(sqlite3_rtree_geometry*, int n, double *a, int *pRes),", "#endif", "  void *pContext", ");", "", "", "/*", "** A pointer to a structure of the following type is passed as the first", "** argument to callbacks registered using rtree_geometry_callback().", "*/", "struct sqlite3_rtree_geometry {", "  void *pContext;                 /* Copy of pContext passed to s_r_g_c() */", "  int nParam;                     /* Size of array aParam[] */", "  double *aParam;                 /* Parameters passed to SQL geom function */", "  void *pUser;                    /* Callback implementation user data */", "  void (*xDelUser)(void *);       /* Called by SQLite to clean up pUser */", "};", "", "", "#ifdef __cplusplus", "}  /* end of the 'extern \"C\"' block */", "#endif", "", "#endif  /* ifndef _SQLITE3RTREE_H_ */", "" },
    ["sqlite3ext.h"] = { "/*", "** 2006 June 7", "**", "** The author disclaims copyright to this source code.  In place of", "** a legal notice, here is a blessing:", "**", "**    May you do good and not evil.", "**    May you find forgiveness for yourself and forgive others.", "**    May you share freely, never taking more than you give.", "**", "*************************************************************************", "** This header file defines the SQLite interface for use by", "** shared libraries that want to be imported as extensions into", "** an SQLite instance.  Shared libraries that intend to be loaded", "** as extensions by SQLite should #include this file instead of ", "** sqlite3.h.", "*/", "#ifndef _SQLITE3EXT_H_", "#define _SQLITE3EXT_H_", '#include "sqlite3.h"', "", "typedef struct sqlite3_api_routines sqlite3_api_routines;", "", "/*", "** The following structure holds pointers to all of the SQLite API", "** routines.", "**", "** WARNING:  In order to maintain backwards compatibility, add new", "** interfaces to the end of this structure only.  If you insert new", "** interfaces in the middle of this structure, then older different", "** versions of SQLite will not be able to load each others' shared", "** libraries!", "*/", "struct sqlite3_api_routines {", "  void * (*aggregate_context)(sqlite3_context*,int nBytes);", "  int  (*aggregate_count)(sqlite3_context*);", "  int  (*bind_blob)(sqlite3_stmt*,int,const void*,int n,void(*)(void*));", "  int  (*bind_double)(sqlite3_stmt*,int,double);", "  int  (*bind_int)(sqlite3_stmt*,int,int);", "  int  (*bind_int64)(sqlite3_stmt*,int,sqlite_int64);", "  int  (*bind_null)(sqlite3_stmt*,int);", "  int  (*bind_parameter_count)(sqlite3_stmt*);", "  int  (*bind_parameter_index)(sqlite3_stmt*,const char*zName);", "  const char * (*bind_parameter_name)(sqlite3_stmt*,int);", "  int  (*bind_text)(sqlite3_stmt*,int,const char*,int n,void(*)(void*));", "  int  (*bind_text16)(sqlite3_stmt*,int,const void*,int,void(*)(void*));", "  int  (*bind_value)(sqlite3_stmt*,int,const sqlite3_value*);", "  int  (*busy_handler)(sqlite3*,int(*)(void*,int),void*);", "  int  (*busy_timeout)(sqlite3*,int ms);", "  int  (*changes)(sqlite3*);", "  int  (*close)(sqlite3*);", "  int  (*collation_needed)(sqlite3*,void*,void(*)(void*,sqlite3*,", "                           int eTextRep,const char*));", "  int  (*collation_needed16)(sqlite3*,void*,void(*)(void*,sqlite3*,", "                             int eTextRep,const void*));", "  const void * (*column_blob)(sqlite3_stmt*,int iCol);", "  int  (*column_bytes)(sqlite3_stmt*,int iCol);", "  int  (*column_bytes16)(sqlite3_stmt*,int iCol);", "  int  (*column_count)(sqlite3_stmt*pStmt);", "  const char * (*column_database_name)(sqlite3_stmt*,int);", "  const void * (*column_database_name16)(sqlite3_stmt*,int);", "  const char * (*column_decltype)(sqlite3_stmt*,int i);", "  const void * (*column_decltype16)(sqlite3_stmt*,int);", "  double  (*column_double)(sqlite3_stmt*,int iCol);", "  int  (*column_int)(sqlite3_stmt*,int iCol);", "  sqlite_int64  (*column_int64)(sqlite3_stmt*,int iCol);", "  const char * (*column_name)(sqlite3_stmt*,int);", "  const void * (*column_name16)(sqlite3_stmt*,int);", "  const char * (*column_origin_name)(sqlite3_stmt*,int);", "  const void * (*column_origin_name16)(sqlite3_stmt*,int);", "  const char * (*column_table_name)(sqlite3_stmt*,int);", "  const void * (*column_table_name16)(sqlite3_stmt*,int);", "  const unsigned char * (*column_text)(sqlite3_stmt*,int iCol);", "  const void * (*column_text16)(sqlite3_stmt*,int iCol);", "  int  (*column_type)(sqlite3_stmt*,int iCol);", "  sqlite3_value* (*column_value)(sqlite3_stmt*,int iCol);", "  void * (*commit_hook)(sqlite3*,int(*)(void*),void*);", "  int  (*complete)(const char*sql);", "  int  (*complete16)(const void*sql);", "  int  (*create_collation)(sqlite3*,const char*,int,void*,", "                           int(*)(void*,int,const void*,int,const void*));", "  int  (*create_collation16)(sqlite3*,const void*,int,void*,", "                             int(*)(void*,int,const void*,int,const void*));", "  int  (*create_function)(sqlite3*,const char*,int,int,void*,", "                          void (*xFunc)(sqlite3_context*,int,sqlite3_value**),", "                          void (*xStep)(sqlite3_context*,int,sqlite3_value**),", "                          void (*xFinal)(sqlite3_context*));", "  int  (*create_function16)(sqlite3*,const void*,int,int,void*,", "                            void (*xFunc)(sqlite3_context*,int,sqlite3_value**),", "                            void (*xStep)(sqlite3_context*,int,sqlite3_value**),", "                            void (*xFinal)(sqlite3_context*));", "  int (*create_module)(sqlite3*,const char*,const sqlite3_module*,void*);", "  int  (*data_count)(sqlite3_stmt*pStmt);", "  sqlite3 * (*db_handle)(sqlite3_stmt*);", "  int (*declare_vtab)(sqlite3*,const char*);", "  int  (*enable_shared_cache)(int);", "  int  (*errcode)(sqlite3*db);", "  const char * (*errmsg)(sqlite3*);", "  const void * (*errmsg16)(sqlite3*);", "  int  (*exec)(sqlite3*,const char*,sqlite3_callback,void*,char**);", "  int  (*expired)(sqlite3_stmt*);", "  int  (*finalize)(sqlite3_stmt*pStmt);", "  void  (*free)(void*);", "  void  (*free_table)(char**result);", "  int  (*get_autocommit)(sqlite3*);", "  void * (*get_auxdata)(sqlite3_context*,int);", "  int  (*get_table)(sqlite3*,const char*,char***,int*,int*,char**);", "  int  (*global_recover)(void);", "  void  (*interruptx)(sqlite3*);", "  sqlite_int64  (*last_insert_rowid)(sqlite3*);", "  const char * (*libversion)(void);", "  int  (*libversion_number)(void);", "  void *(*malloc)(int);", "  char * (*mprintf)(const char*,...);", "  int  (*open)(const char*,sqlite3**);", "  int  (*open16)(const void*,sqlite3**);", "  int  (*prepare)(sqlite3*,const char*,int,sqlite3_stmt**,const char**);", "  int  (*prepare16)(sqlite3*,const void*,int,sqlite3_stmt**,const void**);", "  void * (*profile)(sqlite3*,void(*)(void*,const char*,sqlite_uint64),void*);", "  void  (*progress_handler)(sqlite3*,int,int(*)(void*),void*);", "  void *(*realloc)(void*,int);", "  int  (*reset)(sqlite3_stmt*pStmt);", "  void  (*result_blob)(sqlite3_context*,const void*,int,void(*)(void*));", "  void  (*result_double)(sqlite3_context*,double);", "  void  (*result_error)(sqlite3_context*,const char*,int);", "  void  (*result_error16)(sqlite3_context*,const void*,int);", "  void  (*result_int)(sqlite3_context*,int);", "  void  (*result_int64)(sqlite3_context*,sqlite_int64);", "  void  (*result_null)(sqlite3_context*);", "  void  (*result_text)(sqlite3_context*,const char*,int,void(*)(void*));", "  void  (*result_text16)(sqlite3_context*,const void*,int,void(*)(void*));", "  void  (*result_text16be)(sqlite3_context*,const void*,int,void(*)(void*));", "  void  (*result_text16le)(sqlite3_context*,const void*,int,void(*)(void*));", "  void  (*result_value)(sqlite3_context*,sqlite3_value*);", "  void * (*rollback_hook)(sqlite3*,void(*)(void*),void*);", "  int  (*set_authorizer)(sqlite3*,int(*)(void*,int,const char*,const char*,", "                         const char*,const char*),void*);", "  void  (*set_auxdata)(sqlite3_context*,int,void*,void (*)(void*));", "  char * (*snprintf)(int,char*,const char*,...);", "  int  (*step)(sqlite3_stmt*);", "  int  (*table_column_metadata)(sqlite3*,const char*,const char*,const char*,", "                                char const**,char const**,int*,int*,int*);", "  void  (*thread_cleanup)(void);", "  int  (*total_changes)(sqlite3*);", "  void * (*trace)(sqlite3*,void(*xTrace)(void*,const char*),void*);", "  int  (*transfer_bindings)(sqlite3_stmt*,sqlite3_stmt*);", "  void * (*update_hook)(sqlite3*,void(*)(void*,int ,char const*,char const*,", "                                         sqlite_int64),void*);", "  void * (*user_data)(sqlite3_context*);", "  const void * (*value_blob)(sqlite3_value*);", "  int  (*value_bytes)(sqlite3_value*);", "  int  (*value_bytes16)(sqlite3_value*);", "  double  (*value_double)(sqlite3_value*);", "  int  (*value_int)(sqlite3_value*);", "  sqlite_int64  (*value_int64)(sqlite3_value*);", "  int  (*value_numeric_type)(sqlite3_value*);", "  const unsigned char * (*value_text)(sqlite3_value*);", "  const void * (*value_text16)(sqlite3_value*);", "  const void * (*value_text16be)(sqlite3_value*);", "  const void * (*value_text16le)(sqlite3_value*);", "  int  (*value_type)(sqlite3_value*);", "  char *(*vmprintf)(const char*,va_list);", "  /* Added ??? */", "  int (*overload_function)(sqlite3*, const char *zFuncName, int nArg);", "  /* Added by 3.3.13 */", "  int (*prepare_v2)(sqlite3*,const char*,int,sqlite3_stmt**,const char**);", "  int (*prepare16_v2)(sqlite3*,const void*,int,sqlite3_stmt**,const void**);", "  int (*clear_bindings)(sqlite3_stmt*);", "  /* Added by 3.4.1 */", "  int (*create_module_v2)(sqlite3*,const char*,const sqlite3_module*,void*,", "                          void (*xDestroy)(void *));", "  /* Added by 3.5.0 */", "  int (*bind_zeroblob)(sqlite3_stmt*,int,int);", "  int (*blob_bytes)(sqlite3_blob*);", "  int (*blob_close)(sqlite3_blob*);", "  int (*blob_open)(sqlite3*,const char*,const char*,const char*,sqlite3_int64,", "                   int,sqlite3_blob**);", "  int (*blob_read)(sqlite3_blob*,void*,int,int);", "  int (*blob_write)(sqlite3_blob*,const void*,int,int);", "  int (*create_collation_v2)(sqlite3*,const char*,int,void*,", "                             int(*)(void*,int,const void*,int,const void*),", "                             void(*)(void*));", "  int (*file_control)(sqlite3*,const char*,int,void*);", "  sqlite3_int64 (*memory_highwater)(int);", "  sqlite3_int64 (*memory_used)(void);", "  sqlite3_mutex *(*mutex_alloc)(int);", "  void (*mutex_enter)(sqlite3_mutex*);", "  void (*mutex_free)(sqlite3_mutex*);", "  void (*mutex_leave)(sqlite3_mutex*);", "  int (*mutex_try)(sqlite3_mutex*);", "  int (*open_v2)(const char*,sqlite3**,int,const char*);", "  int (*release_memory)(int);", "  void (*result_error_nomem)(sqlite3_context*);", "  void (*result_error_toobig)(sqlite3_context*);", "  int (*sleep)(int);", "  void (*soft_heap_limit)(int);", "  sqlite3_vfs *(*vfs_find)(const char*);", "  int (*vfs_register)(sqlite3_vfs*,int);", "  int (*vfs_unregister)(sqlite3_vfs*);", "  int (*xthreadsafe)(void);", "  void (*result_zeroblob)(sqlite3_context*,int);", "  void (*result_error_code)(sqlite3_context*,int);", "  int (*test_control)(int, ...);", "  void (*randomness)(int,void*);", "  sqlite3 *(*context_db_handle)(sqlite3_context*);", "  int (*extended_result_codes)(sqlite3*,int);", "  int (*limit)(sqlite3*,int,int);", "  sqlite3_stmt *(*next_stmt)(sqlite3*,sqlite3_stmt*);", "  const char *(*sql)(sqlite3_stmt*);", "  int (*status)(int,int*,int*,int);", "  int (*backup_finish)(sqlite3_backup*);", "  sqlite3_backup *(*backup_init)(sqlite3*,const char*,sqlite3*,const char*);", "  int (*backup_pagecount)(sqlite3_backup*);", "  int (*backup_remaining)(sqlite3_backup*);", "  int (*backup_step)(sqlite3_backup*,int);", "  const char *(*compileoption_get)(int);", "  int (*compileoption_used)(const char*);", "  int (*create_function_v2)(sqlite3*,const char*,int,int,void*,", "                            void (*xFunc)(sqlite3_context*,int,sqlite3_value**),", "                            void (*xStep)(sqlite3_context*,int,sqlite3_value**),", "                            void (*xFinal)(sqlite3_context*),", "                            void(*xDestroy)(void*));", "  int (*db_config)(sqlite3*,int,...);", "  sqlite3_mutex *(*db_mutex)(sqlite3*);", "  int (*db_status)(sqlite3*,int,int*,int*,int);", "  int (*extended_errcode)(sqlite3*);", "  void (*log)(int,const char*,...);", "  sqlite3_int64 (*soft_heap_limit64)(sqlite3_int64);", "  const char *(*sourceid)(void);", "  int (*stmt_status)(sqlite3_stmt*,int,int);", "  int (*strnicmp)(const char*,const char*,int);", "  int (*unlock_notify)(sqlite3*,void(*)(void**,int),void*);", "  int (*wal_autocheckpoint)(sqlite3*,int);", "  int (*wal_checkpoint)(sqlite3*,const char*);", "  void *(*wal_hook)(sqlite3*,int(*)(void*,sqlite3*,const char*,int),void*);", "  int (*blob_reopen)(sqlite3_blob*,sqlite3_int64);", "  int (*vtab_config)(sqlite3*,int op,...);", "  int (*vtab_on_conflict)(sqlite3*);", "};", "", "/*", "** The following macros redefine the API routines so that they are", "** redirected throught the global sqlite3_api structure.", "**", "** This header file is also used by the loadext.c source file", "** (part of the main SQLite library - not an extension) so that", "** it can get access to the sqlite3_api_routines structure", "** definition.  But the main library does not want to redefine", "** the API.  So the redefinition macros are only valid if the", "** SQLITE_CORE macros is undefined.", "*/", "#ifndef SQLITE_CORE", "#define sqlite3_aggregate_context      sqlite3_api->aggregate_context", "#ifndef SQLITE_OMIT_DEPRECATED", "#define sqlite3_aggregate_count        sqlite3_api->aggregate_count", "#endif", "#define sqlite3_bind_blob              sqlite3_api->bind_blob", "#define sqlite3_bind_double            sqlite3_api->bind_double", "#define sqlite3_bind_int               sqlite3_api->bind_int", "#define sqlite3_bind_int64             sqlite3_api->bind_int64", "#define sqlite3_bind_null              sqlite3_api->bind_null", "#define sqlite3_bind_parameter_count   sqlite3_api->bind_parameter_count", "#define sqlite3_bind_parameter_index   sqlite3_api->bind_parameter_index", "#define sqlite3_bind_parameter_name    sqlite3_api->bind_parameter_name", "#define sqlite3_bind_text              sqlite3_api->bind_text", "#define sqlite3_bind_text16            sqlite3_api->bind_text16", "#define sqlite3_bind_value             sqlite3_api->bind_value", "#define sqlite3_busy_handler           sqlite3_api->busy_handler", "#define sqlite3_busy_timeout           sqlite3_api->busy_timeout", "#define sqlite3_changes                sqlite3_api->changes", "#define sqlite3_close                  sqlite3_api->close", "#define sqlite3_collation_needed       sqlite3_api->collation_needed", "#define sqlite3_collation_needed16     sqlite3_api->collation_needed16", "#define sqlite3_column_blob            sqlite3_api->column_blob", "#define sqlite3_column_bytes           sqlite3_api->column_bytes", "#define sqlite3_column_bytes16         sqlite3_api->column_bytes16", "#define sqlite3_column_count           sqlite3_api->column_count", "#define sqlite3_column_database_name   sqlite3_api->column_database_name", "#define sqlite3_column_database_name16 sqlite3_api->column_database_name16", "#define sqlite3_column_decltype        sqlite3_api->column_decltype", "#define sqlite3_column_decltype16      sqlite3_api->column_decltype16", "#define sqlite3_column_double          sqlite3_api->column_double", "#define sqlite3_column_int             sqlite3_api->column_int", "#define sqlite3_column_int64           sqlite3_api->column_int64", "#define sqlite3_column_name            sqlite3_api->column_name", "#define sqlite3_column_name16          sqlite3_api->column_name16", "#define sqlite3_column_origin_name     sqlite3_api->column_origin_name", "#define sqlite3_column_origin_name16   sqlite3_api->column_origin_name16", "#define sqlite3_column_table_name      sqlite3_api->column_table_name", "#define sqlite3_column_table_name16    sqlite3_api->column_table_name16", "#define sqlite3_column_text            sqlite3_api->column_text", "#define sqlite3_column_text16          sqlite3_api->column_text16", "#define sqlite3_column_type            sqlite3_api->column_type", "#define sqlite3_column_value           sqlite3_api->column_value", "#define sqlite3_commit_hook            sqlite3_api->commit_hook", "#define sqlite3_complete               sqlite3_api->complete", "#define sqlite3_complete16             sqlite3_api->complete16", "#define sqlite3_create_collation       sqlite3_api->create_collation", "#define sqlite3_create_collation16     sqlite3_api->create_collation16", "#define sqlite3_create_function        sqlite3_api->create_function", "#define sqlite3_create_function16      sqlite3_api->create_function16", "#define sqlite3_create_module          sqlite3_api->create_module", "#define sqlite3_create_module_v2       sqlite3_api->create_module_v2", "#define sqlite3_data_count             sqlite3_api->data_count", "#define sqlite3_db_handle              sqlite3_api->db_handle", "#define sqlite3_declare_vtab           sqlite3_api->declare_vtab", "#define sqlite3_enable_shared_cache    sqlite3_api->enable_shared_cache", "#define sqlite3_errcode                sqlite3_api->errcode", "#define sqlite3_errmsg                 sqlite3_api->errmsg", "#define sqlite3_errmsg16               sqlite3_api->errmsg16", "#define sqlite3_exec                   sqlite3_api->exec", "#ifndef SQLITE_OMIT_DEPRECATED", "#define sqlite3_expired                sqlite3_api->expired", "#endif", "#define sqlite3_finalize               sqlite3_api->finalize", "#define sqlite3_free                   sqlite3_api->free", "#define sqlite3_free_table             sqlite3_api->free_table", "#define sqlite3_get_autocommit         sqlite3_api->get_autocommit", "#define sqlite3_get_auxdata            sqlite3_api->get_auxdata", "#define sqlite3_get_table              sqlite3_api->get_table", "#ifndef SQLITE_OMIT_DEPRECATED", "#define sqlite3_global_recover         sqlite3_api->global_recover", "#endif", "#define sqlite3_interrupt              sqlite3_api->interruptx", "#define sqlite3_last_insert_rowid      sqlite3_api->last_insert_rowid", "#define sqlite3_libversion             sqlite3_api->libversion", "#define sqlite3_libversion_number      sqlite3_api->libversion_number", "#define sqlite3_malloc                 sqlite3_api->malloc", "#define sqlite3_mprintf                sqlite3_api->mprintf", "#define sqlite3_open                   sqlite3_api->open", "#define sqlite3_open16                 sqlite3_api->open16", "#define sqlite3_prepare                sqlite3_api->prepare", "#define sqlite3_prepare16              sqlite3_api->prepare16", "#define sqlite3_prepare_v2             sqlite3_api->prepare_v2", "#define sqlite3_prepare16_v2           sqlite3_api->prepare16_v2", "#define sqlite3_profile                sqlite3_api->profile", "#define sqlite3_progress_handler       sqlite3_api->progress_handler", "#define sqlite3_realloc                sqlite3_api->realloc", "#define sqlite3_reset                  sqlite3_api->reset", "#define sqlite3_result_blob            sqlite3_api->result_blob", "#define sqlite3_result_double          sqlite3_api->result_double", "#define sqlite3_result_error           sqlite3_api->result_error", "#define sqlite3_result_error16         sqlite3_api->result_error16", "#define sqlite3_result_int             sqlite3_api->result_int", "#define sqlite3_result_int64           sqlite3_api->result_int64", "#define sqlite3_result_null            sqlite3_api->result_null", "#define sqlite3_result_text            sqlite3_api->result_text", "#define sqlite3_result_text16          sqlite3_api->result_text16", "#define sqlite3_result_text16be        sqlite3_api->result_text16be", "#define sqlite3_result_text16le        sqlite3_api->result_text16le", "#define sqlite3_result_value           sqlite3_api->result_value", "#define sqlite3_rollback_hook          sqlite3_api->rollback_hook", "#define sqlite3_set_authorizer         sqlite3_api->set_authorizer", "#define sqlite3_set_auxdata            sqlite3_api->set_auxdata", "#define sqlite3_snprintf               sqlite3_api->snprintf", "#define sqlite3_step                   sqlite3_api->step", "#define sqlite3_table_column_metadata  sqlite3_api->table_column_metadata", "#define sqlite3_thread_cleanup         sqlite3_api->thread_cleanup", "#define sqlite3_total_changes          sqlite3_api->total_changes", "#define sqlite3_trace                  sqlite3_api->trace", "#ifndef SQLITE_OMIT_DEPRECATED", "#define sqlite3_transfer_bindings      sqlite3_api->transfer_bindings", "#endif", "#define sqlite3_update_hook            sqlite3_api->update_hook", "#define sqlite3_user_data              sqlite3_api->user_data", "#define sqlite3_value_blob             sqlite3_api->value_blob", "#define sqlite3_value_bytes            sqlite3_api->value_bytes", "#define sqlite3_value_bytes16          sqlite3_api->value_bytes16", "#define sqlite3_value_double           sqlite3_api->value_double", "#define sqlite3_value_int              sqlite3_api->value_int", "#define sqlite3_value_int64            sqlite3_api->value_int64", "#define sqlite3_value_numeric_type     sqlite3_api->value_numeric_type", "#define sqlite3_value_text             sqlite3_api->value_text", "#define sqlite3_value_text16           sqlite3_api->value_text16", "#define sqlite3_value_text16be         sqlite3_api->value_text16be", "#define sqlite3_value_text16le         sqlite3_api->value_text16le", "#define sqlite3_value_type             sqlite3_api->value_type", "#define sqlite3_vmprintf               sqlite3_api->vmprintf", "#define sqlite3_overload_function      sqlite3_api->overload_function", "#define sqlite3_prepare_v2             sqlite3_api->prepare_v2", "#define sqlite3_prepare16_v2           sqlite3_api->prepare16_v2", "#define sqlite3_clear_bindings         sqlite3_api->clear_bindings", "#define sqlite3_bind_zeroblob          sqlite3_api->bind_zeroblob", "#define sqlite3_blob_bytes             sqlite3_api->blob_bytes", "#define sqlite3_blob_close             sqlite3_api->blob_close", "#define sqlite3_blob_open              sqlite3_api->blob_open", "#define sqlite3_blob_read              sqlite3_api->blob_read", "#define sqlite3_blob_write             sqlite3_api->blob_write", "#define sqlite3_create_collation_v2    sqlite3_api->create_collation_v2", "#define sqlite3_file_control           sqlite3_api->file_control", "#define sqlite3_memory_highwater       sqlite3_api->memory_highwater", "#define sqlite3_memory_used            sqlite3_api->memory_used", "#define sqlite3_mutex_alloc            sqlite3_api->mutex_alloc", "#define sqlite3_mutex_enter            sqlite3_api->mutex_enter", "#define sqlite3_mutex_free             sqlite3_api->mutex_free", "#define sqlite3_mutex_leave            sqlite3_api->mutex_leave", "#define sqlite3_mutex_try              sqlite3_api->mutex_try", "#define sqlite3_open_v2                sqlite3_api->open_v2", "#define sqlite3_release_memory         sqlite3_api->release_memory", "#define sqlite3_result_error_nomem     sqlite3_api->result_error_nomem", "#define sqlite3_result_error_toobig    sqlite3_api->result_error_toobig", "#define sqlite3_sleep                  sqlite3_api->sleep", "#define sqlite3_soft_heap_limit        sqlite3_api->soft_heap_limit", "#define sqlite3_vfs_find               sqlite3_api->vfs_find", "#define sqlite3_vfs_register           sqlite3_api->vfs_register", "#define sqlite3_vfs_unregister         sqlite3_api->vfs_unregister", "#define sqlite3_threadsafe             sqlite3_api->xthreadsafe", "#define sqlite3_result_zeroblob        sqlite3_api->result_zeroblob", "#define sqlite3_result_error_code      sqlite3_api->result_error_code", "#define sqlite3_test_control           sqlite3_api->test_control", "#define sqlite3_randomness             sqlite3_api->randomness", "#define sqlite3_context_db_handle      sqlite3_api->context_db_handle", "#define sqlite3_extended_result_codes  sqlite3_api->extended_result_codes", "#define sqlite3_limit                  sqlite3_api->limit", "#define sqlite3_next_stmt              sqlite3_api->next_stmt", "#define sqlite3_sql                    sqlite3_api->sql", "#define sqlite3_status                 sqlite3_api->status", "#define sqlite3_backup_finish          sqlite3_api->backup_finish", "#define sqlite3_backup_init            sqlite3_api->backup_init", "#define sqlite3_backup_pagecount       sqlite3_api->backup_pagecount", "#define sqlite3_backup_remaining       sqlite3_api->backup_remaining", "#define sqlite3_backup_step            sqlite3_api->backup_step", "#define sqlite3_compileoption_get      sqlite3_api->compileoption_get", "#define sqlite3_compileoption_used     sqlite3_api->compileoption_used", "#define sqlite3_create_function_v2     sqlite3_api->create_function_v2", "#define sqlite3_db_config              sqlite3_api->db_config", "#define sqlite3_db_mutex               sqlite3_api->db_mutex", "#define sqlite3_db_status              sqlite3_api->db_status", "#define sqlite3_extended_errcode       sqlite3_api->extended_errcode", "#define sqlite3_log                    sqlite3_api->log", "#define sqlite3_soft_heap_limit64      sqlite3_api->soft_heap_limit64", "#define sqlite3_sourceid               sqlite3_api->sourceid", "#define sqlite3_stmt_status            sqlite3_api->stmt_status", "#define sqlite3_strnicmp               sqlite3_api->strnicmp", "#define sqlite3_unlock_notify          sqlite3_api->unlock_notify", "#define sqlite3_wal_autocheckpoint     sqlite3_api->wal_autocheckpoint", "#define sqlite3_wal_checkpoint         sqlite3_api->wal_checkpoint", "#define sqlite3_wal_hook               sqlite3_api->wal_hook", "#define sqlite3_blob_reopen            sqlite3_api->blob_reopen", "#define sqlite3_vtab_config            sqlite3_api->vtab_config", "#define sqlite3_vtab_on_conflict       sqlite3_api->vtab_on_conflict", "#endif /* SQLITE_CORE */", "", "#define SQLITE_EXTENSION_INIT1     const sqlite3_api_routines *sqlite3_api = 0;", "#define SQLITE_EXTENSION_INIT2(v)  sqlite3_api = v;", "", "#endif /* _SQLITE3EXT_H_ */" },
    ["stab.h"] = { "/*-", " * Copyright (c) 1991, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)stab.h\t8.1 (Berkeley) 6/2/93", " */", "", "/*", " * The following are symbols used by various debuggers and by the Pascal", " * compiler.  Each of them must have one (or more) of the bits defined by", " * the N_STAB mask set.", " */", "", "#define\tN_GSYM\t\t0x20\t/* global symbol */", "#define\tN_FNAME\t\t0x22\t/* F77 function name */", "#define\tN_FUN\t\t0x24\t/* procedure name */", "#define\tN_STSYM\t\t0x26\t/* data segment variable */", "#define\tN_LCSYM\t\t0x28\t/* bss segment variable */", "#define\tN_MAIN\t\t0x2a\t/* main function name */", "#define\tN_PC\t\t0x30\t/* global Pascal symbol */", "#define\tN_RSYM\t\t0x40\t/* register variable */", "#define\tN_SLINE\t\t0x44\t/* text segment line number */", "#define\tN_DSLINE\t0x46\t/* data segment line number */", "#define\tN_BSLINE\t0x48\t/* bss segment line number */", "#define\tN_SSYM\t\t0x60\t/* structure/union element */", "#define\tN_SO\t\t0x64\t/* main source file name */", "#define\tN_LSYM\t\t0x80\t/* stack variable */", "#define\tN_BINCL\t\t0x82\t/* include file beginning */", "#define\tN_SOL\t\t0x84\t/* included source file name */", "#define\tN_PSYM\t\t0xa0\t/* parameter variable */", "#define\tN_EINCL\t\t0xa2\t/* include file end */", "#define\tN_ENTRY\t\t0xa4\t/* alternate entry point */", "#define\tN_LBRAC\t\t0xc0\t/* left bracket */", "#define\tN_EXCL\t\t0xc2\t/* deleted include file */", "#define\tN_RBRAC\t\t0xe0\t/* right bracket */", "#define\tN_BCOMM\t\t0xe2\t/* begin common */", "#define\tN_ECOMM\t\t0xe4\t/* end common */", "#define\tN_ECOML\t\t0xe8\t/* end common (local name) */", "#define\tN_LENG\t\t0xfe\t/* length of preceding entry */" },
    ["standards.h"] = { "/*", " * Copyright (c) 1999, 2010 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/*", " * Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved", " */", "", "#ifndef _STANDARDS_H", "#define _STANDARDS_H", "", "#include <sys/cdefs.h>", "", '#warning "The use of <standards.h> is deprecated, and it will be removed in a future release."', "", "#endif /* _STANDARDS_H */" },
    ["stdbool.h"] = { "/*", " * Copyright (c) 2000 Jeroen Ruigrok van der Werven <asmodai@FreeBSD.org>", " * All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " *", " * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " * $FreeBSD: src/include/stdbool.h,v 1.6 2002/08/16 07:33:14 alfred Exp $", " */", "", "#ifndef _STDBOOL_H_", "#define\t_STDBOOL_H_\t", "", "#define\t__bool_true_false_are_defined\t1", "", "#ifndef __cplusplus", "", "#define\tbool\t_Bool", "#if __STDC_VERSION__ < 199901L && __GNUC__ < 3", "typedef\tint\t_Bool;", "#endif", "", "#define\tfalse\t0", "#define\ttrue\t1", "", "#endif /* !__cplusplus */", "", "#endif /* !_STDBOOL_H_ */" },
    ["stddef.h"] = { "/*", " * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/*\t$OpenBSD: stddef.h,v 1.2 1997/09/21 10:45:52 niklas Exp $\t*/", "/*\t$NetBSD: stddef.h,v 1.4 1994/10/26 00:56:26 cgd Exp $\t*/", "", "/*-", " * Copyright (c) 1990 The Regents of the University of California.", " * All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)stddef.h\t5.5 (Berkeley) 4/3/91", " */", "", "#if !defined(__STDDEF_H__)", "", "#if !defined(__need_wchar_t) && !defined(__need_size_t) \\", "    && !defined(__need_ptrdiff_t) && !defined(__need_NULL) \\", "    && !defined(__need_wint_t) && !defined(__need_rsize_t)", "#define __STDDEF_H__", "#endif /* none of __need_* defined */", "", "#include <_types.h>", "", "#if defined(__STDDEF_H__) || defined(__need_ptrdiff_t)", "#include <sys/_types/_ptrdiff_t.h>", "#endif /* __STDDEF_H__ || __need_ptrdiff_t */", "", "#if defined(__STDDEF_H__) || defined(__need_size_t)", "/* DO NOT REMOVE THIS COMMENT: fixincludes needs to see:", " * _GCC_SIZE_T */", "#include <sys/_types/_size_t.h>", "#endif /* __STDDEF_H__ || __need_size_t */", "", "#if (defined(__STDDEF_H__) && defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1) || defined(__need_rsize_t)", "#include <sys/_types/_rsize_t.h>", "#endif /* (__STDDEF_H__ && __STDC_WANT_LIB_EXT1__ >= 1) || __need_rsize_t */", "", "#if defined(__STDDEF_H__) || defined(__need_wchar_t)", "#include <sys/_types/_wchar_t.h>", "#endif /* __STDDEF_H__ || __need_wchar_t */", "", "#if (defined(__STDDEF_H__) && !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))) \\", "    || defined(__need_wint_t)", "#include <sys/_types/_wint_t.h>", "#endif /* __STDDEF_H__ && !_ANSI_SOURCE && (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) || __need_wchar_t */", "", "#if defined(__STDDEF_H__) || defined(__need_NULL)", "#include <sys/_types/_null.h>", "#endif /* __STDDEF_H__ || __need_NULL */", "", "#ifdef __STDDEF_H__", "#if defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 5 || __GNUC__ > 3)", "#ifndef __offsetof\t/* Deprecated: for source compatibility only */", "#define __offsetof(type, field) __builtin_offsetof(type, field)", "#endif", "#define offsetof(type, field) __builtin_offsetof(type, field)", "#else /* ! (gcc >= 3.5) */", "#ifndef __offsetof\t/* Deprecated: for source compatibility only */", "#define __offsetof(type, field) ((size_t)(&((type *)0)->field))", "#endif", "#define offsetof(type, field) ((size_t)(&((type *)0)->field))", "#endif /* (gcc >= 3.5) */", "#endif /* __STDDEF_H__ */", "", "#endif /* __STDDEF_H__ */", "", "#undef __need_ptrdiff_t", "#undef __need_size_t", "#undef __need_wchar_t", "#undef __need_wint_t", "#undef __need_NULL" },
    ["stdint.h"] = { "/*", " * Copyright (c) 2000-2010 Apple Inc.", " * All rights reserved.", " */", "", "#ifndef _STDINT_H_", "#define _STDINT_H_", "", "#if __LP64__", "#define __WORDSIZE 64", "#else", "#define __WORDSIZE 32", "#endif", "", "/* from ISO/IEC 988:1999 spec */", "", "/* 7.18.1.1 Exact-width integer types */", "#include <sys/_types/_int8_t.h>", "#include <sys/_types/_int16_t.h>", "#include <sys/_types/_int32_t.h>", "#include <sys/_types/_int64_t.h>", "", "#include <_types/_uint8_t.h>", "#include <_types/_uint16_t.h>", "#include <_types/_uint32_t.h>", "#include <_types/_uint64_t.h>", "", "/* 7.18.1.2 Minimum-width integer types */", "typedef int8_t           int_least8_t;", "typedef int16_t         int_least16_t;", "typedef int32_t         int_least32_t;", "typedef int64_t         int_least64_t;", "typedef uint8_t         uint_least8_t;", "typedef uint16_t       uint_least16_t;", "typedef uint32_t       uint_least32_t;", "typedef uint64_t       uint_least64_t;", "", "", "/* 7.18.1.3 Fastest-width integer types */", "typedef int8_t            int_fast8_t;", "typedef int16_t          int_fast16_t;", "typedef int32_t          int_fast32_t;", "typedef int64_t          int_fast64_t;", "typedef uint8_t          uint_fast8_t;", "typedef uint16_t        uint_fast16_t;", "typedef uint32_t        uint_fast32_t;", "typedef uint64_t        uint_fast64_t;", "", "", "/* 7.18.1.4 Integer types capable of holding object pointers */", "", "#include <sys/_types.h>", "#include <sys/_types/_intptr_t.h>", "#include <sys/_types/_uintptr_t.h>", "", "", "/* 7.18.1.5 Greatest-width integer types */", "#include <_types/_intmax_t.h>", "#include <_types/_uintmax_t.h>", "", "/* 7.18.2 Limits of specified-width integer types:", " *   These #defines specify the minimum and maximum limits", " *   of each of the types declared above.", " */", "", "", "/* 7.18.2.1 Limits of exact-width integer types */", "#define INT8_MAX         127", "#define INT16_MAX        32767", "#define INT32_MAX        2147483647", "#define INT64_MAX        9223372036854775807LL", "", "#define INT8_MIN          -128", "#define INT16_MIN         -32768", "   /*", '      Note:  the literal "most negative int" cannot be written in C --', "      the rules in the standard (section 6.4.4.1 in C99) will give it", "      an unsigned type, so INT32_MIN (and the most negative member of", "      any larger signed type) must be written via a constant expression.", "   */", "#define INT32_MIN        (-INT32_MAX-1)", "#define INT64_MIN        (-INT64_MAX-1)", "", "#define UINT8_MAX         255", "#define UINT16_MAX        65535", "#define UINT32_MAX        4294967295U", "#define UINT64_MAX        18446744073709551615ULL", "", "/* 7.18.2.2 Limits of minimum-width integer types */", "#define INT_LEAST8_MIN    INT8_MIN", "#define INT_LEAST16_MIN   INT16_MIN", "#define INT_LEAST32_MIN   INT32_MIN", "#define INT_LEAST64_MIN   INT64_MIN", "", "#define INT_LEAST8_MAX    INT8_MAX", "#define INT_LEAST16_MAX   INT16_MAX", "#define INT_LEAST32_MAX   INT32_MAX", "#define INT_LEAST64_MAX   INT64_MAX", "", "#define UINT_LEAST8_MAX   UINT8_MAX", "#define UINT_LEAST16_MAX  UINT16_MAX", "#define UINT_LEAST32_MAX  UINT32_MAX", "#define UINT_LEAST64_MAX  UINT64_MAX", "", "/* 7.18.2.3 Limits of fastest minimum-width integer types */", "#define INT_FAST8_MIN     INT8_MIN", "#define INT_FAST16_MIN    INT16_MIN", "#define INT_FAST32_MIN    INT32_MIN", "#define INT_FAST64_MIN    INT64_MIN", "", "#define INT_FAST8_MAX     INT8_MAX", "#define INT_FAST16_MAX    INT16_MAX", "#define INT_FAST32_MAX    INT32_MAX", "#define INT_FAST64_MAX    INT64_MAX", "", "#define UINT_FAST8_MAX    UINT8_MAX", "#define UINT_FAST16_MAX   UINT16_MAX", "#define UINT_FAST32_MAX   UINT32_MAX", "#define UINT_FAST64_MAX   UINT64_MAX", "", "/* 7.18.2.4 Limits of integer types capable of holding object pointers */", "", "#if __WORDSIZE == 64", "#define INTPTR_MIN\t  INT64_MIN", "#define INTPTR_MAX\t  INT64_MAX", "#else", "#define INTPTR_MIN        INT32_MIN", "#define INTPTR_MAX        INT32_MAX", "#endif", "", "#if __WORDSIZE == 64", "#define UINTPTR_MAX\t  UINT64_MAX", "#else", "#define UINTPTR_MAX       UINT32_MAX", "#endif", "", "/* 7.18.2.5 Limits of greatest-width integer types */", "#define INTMAX_MIN        INT64_MIN", "#define INTMAX_MAX        INT64_MAX", "", "#define UINTMAX_MAX       UINT64_MAX", "", '/* 7.18.3 "Other" */', "#if __WORDSIZE == 64", "#define PTRDIFF_MIN\t  INT64_MIN", "#define PTRDIFF_MAX\t  INT64_MAX", "#else", "#define PTRDIFF_MIN       INT32_MIN", "#define PTRDIFF_MAX       INT32_MAX", "#endif", "", "/* We have no sig_atomic_t yet, so no SIG_ATOMIC_{MIN,MAX}.", "   Should end up being {-127,127} or {0,255} ... or bigger.", "   My bet would be on one of {U}INT32_{MIN,MAX}. */", "", "#if __WORDSIZE == 64", "#define SIZE_MAX\t  UINT64_MAX", "#else", "#define SIZE_MAX          UINT32_MAX", "#endif", "", "#if defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1", "#define RSIZE_MAX         (SIZE_MAX >> 1)", "#endif", "", "#ifndef WCHAR_MAX", "#  ifdef __WCHAR_MAX__", "#    define WCHAR_MAX     __WCHAR_MAX__", "#  else", "#    define WCHAR_MAX     0x7fffffff", "#  endif", "#endif", "", "/* WCHAR_MIN should be 0 if wchar_t is an unsigned type and", "   (-WCHAR_MAX-1) if wchar_t is a signed type.  Unfortunately,", "   it turns out that -fshort-wchar changes the signedness of", "   the type. */", "#ifndef WCHAR_MIN", "#  if WCHAR_MAX == 0xffff", "#    define WCHAR_MIN       0", "#  else", "#    define WCHAR_MIN       (-WCHAR_MAX-1)", "#  endif", "#endif", "", "#define WINT_MIN\t  INT32_MIN", "#define WINT_MAX\t  INT32_MAX", "", "#define SIG_ATOMIC_MIN\t  INT32_MIN", "#define SIG_ATOMIC_MAX\t  INT32_MAX", "", "/* 7.18.4 Macros for integer constants */", "#define INT8_C(v)    (v)", "#define INT16_C(v)   (v)", "#define INT32_C(v)   (v)", "#define INT64_C(v)   (v ## LL)", "", "#define UINT8_C(v)   (v ## U)", "#define UINT16_C(v)  (v ## U)", "#define UINT32_C(v)  (v ## U)", "#define UINT64_C(v)  (v ## ULL)", "", "#ifdef __LP64__", "#define INTMAX_C(v)  (v ## L)", "#define UINTMAX_C(v) (v ## UL)", "#else", "#define INTMAX_C(v)  (v ## LL)", "#define UINTMAX_C(v) (v ## ULL)", "#endif", "", "#endif /* _STDINT_H_ */" },
    ["stdio.h"] = { "/*", " * Copyright (c) 2000, 2005, 2007, 2009, 2010 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " *", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " *", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " *", " * @APPLE_LICENSE_HEADER_END@", " */", "/*-", " * Copyright (c) 1990, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * This code is derived from software contributed to Berkeley by", " * Chris Torek.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)stdio.h\t8.5 (Berkeley) 4/29/95", " */", "", "#ifndef\t_STDIO_H_", "#define\t_STDIO_H_", "", "#include <sys/cdefs.h>", "#include <Availability.h>", "", "#include <_types.h>", "", "/* DO NOT REMOVE THIS COMMENT: fixincludes needs to see:", " * __gnuc_va_list and include <stdarg.h> */", "#include <sys/_types/_va_list.h>", "#include <sys/_types/_size_t.h>", "#include <sys/_types/_null.h>", "", "typedef __darwin_off_t\t\tfpos_t;", "", "#define\t_FSTDIO\t\t\t/* Define for new stdio with functions. */", "", "/*", " * NB: to fit things in six character monocase externals, the stdio", " * code uses the prefix `__s' for stdio objects, typically followed", " * by a three-character attempt at a mnemonic.", " */", "", "/* stdio buffers */", "struct __sbuf {", "\tunsigned char\t*_base;", "\tint\t\t_size;", "};", "", "/* hold a buncha junk that would grow the ABI */", "struct __sFILEX;", "", "/*", " * stdio state variables.", " *", " * The following always hold:", " *", " *\tif (_flags&(__SLBF|__SWR)) == (__SLBF|__SWR),", " *\t\t_lbfsize is -_bf._size, else _lbfsize is 0", " *\tif _flags&__SRD, _w is 0", " *\tif _flags&__SWR, _r is 0", " *", " * This ensures that the getc and putc macros (or inline functions) never", " * try to write or read from a file that is in `read' or `write' mode.", " * (Moreover, they can, and do, automatically switch from read mode to", ' * write mode, and back, on "r+" and "w+" files.)', " *", " * _lbfsize is used only to make the inline line-buffered output stream", " * code as compact as possible.", " *", " * _ub, _up, and _ur are used when ungetc() pushes back more characters", " * than fit in the current _bf, or when ungetc() pushes back a character", " * that does not match the previous one in _bf.  When this happens,", " * _ub._base becomes non-nil (i.e., a stream has ungetc() data iff", " * _ub._base!=NULL) and _up and _ur save the current values of _p and _r.", " *", " * NB: see WARNING above before changing the layout of this structure!", " */", "typedef\tstruct __sFILE {", "\tunsigned char *_p;\t/* current position in (some) buffer */", "\tint\t_r;\t\t/* read space left for getc() */", "\tint\t_w;\t\t/* write space left for putc() */", "\tshort\t_flags;\t\t/* flags, below; this FILE is free if 0 */", "\tshort\t_file;\t\t/* fileno, if Unix descriptor, else -1 */", "\tstruct\t__sbuf _bf;\t/* the buffer (at least 1 byte, if !NULL) */", "\tint\t_lbfsize;\t/* 0 or -_bf._size, for inline putc */", "", "\t/* operations */", "\tvoid\t*_cookie;\t/* cookie passed to io functions */", "\tint\t(*_close)(void *);", "\tint\t(*_read) (void *, char *, int);", "\tfpos_t\t(*_seek) (void *, fpos_t, int);", "\tint\t(*_write)(void *, const char *, int);", "", "\t/* separate buffer for long sequences of ungetc() */", "\tstruct\t__sbuf _ub;\t/* ungetc buffer */", "\tstruct __sFILEX *_extra; /* additions to FILE to not break ABI */", "\tint\t_ur;\t\t/* saved _r when _r is counting ungetc data */", "", "\t/* tricks to meet minimum requirements even when malloc() fails */", "\tunsigned char _ubuf[3];\t/* guarantee an ungetc() buffer */", "\tunsigned char _nbuf[1];\t/* guarantee a getc() buffer */", "", "\t/* separate buffer for fgetln() when line crosses buffer boundary */", "\tstruct\t__sbuf _lb;\t/* buffer for fgetln() */", "", "\t/* Unix stdio files get aligned to block boundaries on fseek() */", "\tint\t_blksize;\t/* stat.st_blksize (may be != _bf._size) */", "\tfpos_t\t_offset;\t/* current lseek offset (see WARNING) */", "} FILE;", "", "__BEGIN_DECLS", "extern FILE *__stdinp;", "extern FILE *__stdoutp;", "extern FILE *__stderrp;", "__END_DECLS", "", "#define\t__SLBF\t0x0001\t\t/* line buffered */", "#define\t__SNBF\t0x0002\t\t/* unbuffered */", "#define\t__SRD\t0x0004\t\t/* OK to read */", "#define\t__SWR\t0x0008\t\t/* OK to write */", "\t/* RD and WR are never simultaneously asserted */", "#define\t__SRW\t0x0010\t\t/* open for reading & writing */", "#define\t__SEOF\t0x0020\t\t/* found EOF */", "#define\t__SERR\t0x0040\t\t/* found error */", "#define\t__SMBF\t0x0080\t\t/* _buf is from malloc */", "#define\t__SAPP\t0x0100\t\t/* fdopen()ed in append mode */", "#define\t__SSTR\t0x0200\t\t/* this is an sprintf/snprintf string */", "#define\t__SOPT\t0x0400\t\t/* do fseek() optimisation */", "#define\t__SNPT\t0x0800\t\t/* do not do fseek() optimisation */", "#define\t__SOFF\t0x1000\t\t/* set iff _offset is in fact correct */", "#define\t__SMOD\t0x2000\t\t/* true => fgetln modified _p text */", "#define __SALC  0x4000\t\t/* allocate string space dynamically */", "#define __SIGN  0x8000\t\t/* ignore this file in _fwalk */", "", "/*", " * The following three definitions are for ANSI C, which took them", " * from System V, which brilliantly took internal interface macros and", " * made them official arguments to setvbuf(), without renaming them.", " * Hence, these ugly _IOxxx names are *supposed* to appear in user code.", " *", " * Although numbered as their counterparts above, the implementation", " * does not rely on this.", " */", "#define\t_IOFBF\t0\t\t/* setvbuf should set fully buffered */", "#define\t_IOLBF\t1\t\t/* setvbuf should set line buffered */", "#define\t_IONBF\t2\t\t/* setvbuf should set unbuffered */", "", "#define\tBUFSIZ\t1024\t\t/* size of buffer used by setbuf */", "#define\tEOF\t(-1)", "", "\t\t\t\t/* must be == _POSIX_STREAM_MAX <limits.h> */", "#define\tFOPEN_MAX\t20\t/* must be <= OPEN_MAX <sys/syslimits.h> */", "#define\tFILENAME_MAX\t1024\t/* must be <= PATH_MAX <sys/syslimits.h> */", "", "/* System V/ANSI C; this is the wrong way to do this, do *not* use these. */", "#ifndef _ANSI_SOURCE", '#define\tP_tmpdir\t"/var/tmp/"', "#endif", "#define\tL_tmpnam\t1024\t/* XXX must be == PATH_MAX */", "#define\tTMP_MAX\t\t308915776", "", "#ifndef SEEK_SET", "#define\tSEEK_SET\t0\t/* set file offset to offset */", "#endif", "#ifndef SEEK_CUR", "#define\tSEEK_CUR\t1\t/* set file offset to current plus offset */", "#endif", "#ifndef SEEK_END", "#define\tSEEK_END\t2\t/* set file offset to EOF plus offset */", "#endif", "", "#define\tstdin\t__stdinp", "#define\tstdout\t__stdoutp", "#define\tstderr\t__stderrp", "", "#ifdef _DARWIN_UNLIMITED_STREAMS", "#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_2", '#error "_DARWIN_UNLIMITED_STREAMS specified, but -miphoneos-version-min version does not support it."', "#elif defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_6", '#error "_DARWIN_UNLIMITED_STREAMS specified, but -mmacosx-version-min version does not support it."', "#endif", "#endif", "", "/* ANSI-C */", "", "__BEGIN_DECLS", "void\t clearerr(FILE *);", "int\t fclose(FILE *);", "int\t feof(FILE *);", "int\t ferror(FILE *);", "int\t fflush(FILE *);", "int\t fgetc(FILE *);", "int\t fgetpos(FILE * __restrict, fpos_t *);", "char\t*fgets(char * __restrict, int, FILE *);", "#if defined(_DARWIN_UNLIMITED_STREAMS) || defined(_DARWIN_C_SOURCE)", "FILE\t*fopen(const char * __restrict, const char * __restrict) __DARWIN_ALIAS_STARTING(__MAC_10_6, __IPHONE_3_2, __DARWIN_EXTSN(fopen));", "#else /* !_DARWIN_UNLIMITED_STREAMS && !_DARWIN_C_SOURCE */", "FILE\t*fopen(const char * __restrict, const char * __restrict) __DARWIN_ALIAS_STARTING(__MAC_10_6, __IPHONE_2_0, __DARWIN_ALIAS(fopen));", "#endif /* (DARWIN_UNLIMITED_STREAMS || _DARWIN_C_SOURCE) */", "int\t fprintf(FILE * __restrict, const char * __restrict, ...) __printflike(2, 3);", "int\t fputc(int, FILE *);", "int\t fputs(const char * __restrict, FILE * __restrict) __DARWIN_ALIAS(fputs);", "size_t\t fread(void * __restrict, size_t, size_t, FILE * __restrict);", "FILE\t*freopen(const char * __restrict, const char * __restrict,", "                 FILE * __restrict) __DARWIN_ALIAS(freopen);", "int\t fscanf(FILE * __restrict, const char * __restrict, ...) __scanflike(2, 3);", "int\t fseek(FILE *, long, int);", "int\t fsetpos(FILE *, const fpos_t *);", "long\t ftell(FILE *);", "size_t\t fwrite(const void * __restrict, size_t, size_t, FILE * __restrict) __DARWIN_ALIAS(fwrite);", "int\t getc(FILE *);", "int\t getchar(void);", "char\t*gets(char *);", "void\t perror(const char *);", "int\t printf(const char * __restrict, ...) __printflike(1, 2);", "int\t putc(int, FILE *);", "int\t putchar(int);", "int\t puts(const char *);", "int\t remove(const char *);", "int\t rename (const char *, const char *);", "void\t rewind(FILE *);", "int\t scanf(const char * __restrict, ...) __scanflike(1, 2);", "void\t setbuf(FILE * __restrict, char * __restrict);", "int\t setvbuf(FILE * __restrict, char * __restrict, int, size_t);", "int\t sprintf(char * __restrict, const char * __restrict, ...) __printflike(2, 3);", "int\t sscanf(const char * __restrict, const char * __restrict, ...) __scanflike(2, 3);", "FILE\t*tmpfile(void);", "", "#if !defined(_POSIX_C_SOURCE)", '__deprecated_msg("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tmpnam(3), it is highly recommended that you use mkstemp(3) instead.")', "#endif", "char\t*tmpnam(char *);", "int\t ungetc(int, FILE *);", "int\t vfprintf(FILE * __restrict, const char * __restrict, va_list) __printflike(2, 0);", "int\t vprintf(const char * __restrict, va_list) __printflike(1, 0);", "int\t vsprintf(char * __restrict, const char * __restrict, va_list) __printflike(2, 0);", "__END_DECLS", "", "", "", "/* Additional functionality provided by:", " * POSIX.1-1988", " */", "", "#if __DARWIN_C_LEVEL >= 198808L", "#define\tL_ctermid\t1024\t/* size for ctermid(); PATH_MAX */", "", "__BEGIN_DECLS", "#ifndef __CTERMID_DEFINED", "/* Multiply defined in stdio.h and unistd.h by SUS */", "#define __CTERMID_DEFINED 1", "char\t*ctermid(char *);", "#endif", "", "#if defined(_DARWIN_UNLIMITED_STREAMS) || defined(_DARWIN_C_SOURCE)", "FILE\t*fdopen(int, const char *) __DARWIN_ALIAS_STARTING(__MAC_10_6, __IPHONE_3_2, __DARWIN_EXTSN(fdopen));", "#else /* !_DARWIN_UNLIMITED_STREAMS && !_DARWIN_C_SOURCE */", "FILE\t*fdopen(int, const char *) __DARWIN_ALIAS_STARTING(__MAC_10_6, __IPHONE_2_0, __DARWIN_ALIAS(fdopen));", "#endif /* (DARWIN_UNLIMITED_STREAMS || _DARWIN_C_SOURCE) */", "int\t fileno(FILE *);", "__END_DECLS", "#endif /* __DARWIN_C_LEVEL >= 198808L */", "", "", "/* Additional functionality provided by:", " * POSIX.2-1992 C Language Binding Option", " */", "", "#if __DARWIN_C_LEVEL >= 199209L", "__BEGIN_DECLS", "int\t pclose(FILE *);", "#if defined(_DARWIN_UNLIMITED_STREAMS) || defined(_DARWIN_C_SOURCE)", "FILE\t*popen(const char *, const char *) __DARWIN_ALIAS_STARTING(__MAC_10_6, __IPHONE_3_2, __DARWIN_EXTSN(popen));", "#else /* !_DARWIN_UNLIMITED_STREAMS && !_DARWIN_C_SOURCE */", "FILE\t*popen(const char *, const char *) __DARWIN_ALIAS_STARTING(__MAC_10_6, __IPHONE_2_0, __DARWIN_ALIAS(popen));", "#endif /* (DARWIN_UNLIMITED_STREAMS || _DARWIN_C_SOURCE) */", "__END_DECLS", "#endif /* __DARWIN_C_LEVEL >= 199209L */", "", "", "", "", "/* Additional functionality provided by:", " * POSIX.1c-1995,", " * POSIX.1i-1995,", " * and the omnibus ISO/IEC 9945-1: 1996", " */", "", "#if __DARWIN_C_LEVEL >= 199506L", "", "/* Functions internal to the implementation. */", "__BEGIN_DECLS", "int\t__srget(FILE *);", "int\t__svfscanf(FILE *, const char *, va_list) __scanflike(2, 0);", "int\t__swbuf(int, FILE *);", "__END_DECLS", "", "/*", " * The __sfoo macros are here so that we can", " * define function versions in the C library.", " */", "#define\t__sgetc(p) (--(p)->_r < 0 ? __srget(p) : (int)(*(p)->_p++))", "#if defined(__GNUC__) && defined(__STDC__)", "__header_always_inline int __sputc(int _c, FILE *_p) {", "\tif (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\\n'))", "\t\treturn (*_p->_p++ = _c);", "\telse", "\t\treturn (__swbuf(_c, _p));", "}", "#else", "/*", " * This has been tuned to generate reasonable code on the vax using pcc.", " */", "#define\t__sputc(c, p) \\", "\t(--(p)->_w < 0 ? \\", "\t\t(p)->_w >= (p)->_lbfsize ? \\", "\t\t\t(*(p)->_p = (c)), *(p)->_p != '\\n' ? \\", "\t\t\t\t(int)*(p)->_p++ : \\", "\t\t\t\t__swbuf('\\n', p) : \\", "\t\t\t__swbuf((int)(c), p) : \\", "\t\t(*(p)->_p = (c), (int)*(p)->_p++))", "#endif", "", "#define\t__sfeof(p)\t(((p)->_flags & __SEOF) != 0)", "#define\t__sferror(p)\t(((p)->_flags & __SERR) != 0)", "#define\t__sclearerr(p)\t((void)((p)->_flags &= ~(__SERR|__SEOF)))", "#define\t__sfileno(p)\t((p)->_file)", "", "__BEGIN_DECLS", "void\t flockfile(FILE *);", "int\t ftrylockfile(FILE *);", "void\t funlockfile(FILE *);", "int\t getc_unlocked(FILE *);", "int\t getchar_unlocked(void);", "int\t putc_unlocked(int, FILE *);", "int\t putchar_unlocked(int);", "", "/* Removed in Issue 6 */", "#if !defined(_POSIX_C_SOURCE) || _POSIX_C_SOURCE < 200112L", "int\t getw(FILE *);", "int\t putw(int, FILE *);", "#endif", "", "#if !defined(_POSIX_C_SOURCE)", '__deprecated_msg("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tempnam(3), it is highly recommended that you use mkstemp(3) instead.")', "#endif", "char\t*tempnam(const char *, const char *) __DARWIN_ALIAS(tempnam);", "__END_DECLS", "", "#ifndef lint", "#define\tgetc_unlocked(fp)\t__sgetc(fp)", "#define putc_unlocked(x, fp)\t__sputc(x, fp)", "#endif /* lint */", "", "#define\tgetchar_unlocked()\tgetc_unlocked(stdin)", "#define\tputchar_unlocked(x)\tputc_unlocked(x, stdout)", "#endif /* __DARWIN_C_LEVEL >= 199506L */", "", "", "", "/* Additional functionality provided by:", " * POSIX.1-2001", " * ISO C99", " */", "", "#if __DARWIN_C_LEVEL >= 200112L", "#include <sys/_types/_off_t.h>", "", "__BEGIN_DECLS", "int\t fseeko(FILE *, off_t, int);", "off_t\t ftello(FILE *);", "__END_DECLS", "#endif /* __DARWIN_C_LEVEL >= 200112L */", "", "#if __DARWIN_C_LEVEL >= 200112L || defined(_C99_SOURCE) || defined(__cplusplus)", "__BEGIN_DECLS", "int\t snprintf(char * __restrict, size_t, const char * __restrict, ...) __printflike(3, 4);", "int\t vfscanf(FILE * __restrict, const char * __restrict, va_list) __scanflike(2, 0);", "int\t vscanf(const char * __restrict, va_list) __scanflike(1, 0);", "int\t vsnprintf(char * __restrict, size_t, const char * __restrict, va_list) __printflike(3, 0);", "int\t vsscanf(const char * __restrict, const char * __restrict, va_list) __scanflike(2, 0);", "__END_DECLS", "#endif /* __DARWIN_C_LEVEL >= 200112L || defined(_C99_SOURCE) || defined(__cplusplus) */", "", "", "", "/* Additional functionality provided by:", " * POSIX.1-2008", " */", "", "#if __DARWIN_C_LEVEL >= 200809L", "#include <sys/_types/_ssize_t.h>", "", "__BEGIN_DECLS", "int\tdprintf(int, const char * __restrict, ...) __printflike(2, 3) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);", "int\tvdprintf(int, const char * __restrict, va_list) __printflike(2, 0) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);", "ssize_t getdelim(char ** __restrict, size_t * __restrict, int, FILE * __restrict) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);", "ssize_t getline(char ** __restrict, size_t * __restrict, FILE * __restrict) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);", "__END_DECLS", "#endif /* __DARWIN_C_LEVEL >= 200809L */", "", "", "", "/* Darwin extensions */", "", "#if __DARWIN_C_LEVEL >= __DARWIN_C_FULL", "__BEGIN_DECLS", "extern __const int sys_nerr;\t\t/* perror(3) external variables */", "extern __const char *__const sys_errlist[];", "", "int\t asprintf(char ** __restrict, const char * __restrict, ...) __printflike(2, 3);", "char\t*ctermid_r(char *);", "char\t*fgetln(FILE *, size_t *);", "__const char *fmtcheck(const char *, const char *);", "int\t fpurge(FILE *);", "void\t setbuffer(FILE *, char *, int);", "int\t setlinebuf(FILE *);", "int\t vasprintf(char ** __restrict, const char * __restrict, va_list) __printflike(2, 0);", "FILE\t*zopen(const char *, const char *, int);", "", "", "/*", " * Stdio function-access interface.", " */", "FILE\t*funopen(const void *,", "                 int (*)(void *, char *, int),", "                 int (*)(void *, const char *, int),", "                 fpos_t (*)(void *, fpos_t, int),", "                 int (*)(void *));", "__END_DECLS", "#define\tfropen(cookie, fn) funopen(cookie, fn, 0, 0, 0)", "#define\tfwopen(cookie, fn) funopen(cookie, 0, fn, 0, 0)", "", "#define\tfeof_unlocked(p)\t__sfeof(p)", "#define\tferror_unlocked(p)\t__sferror(p)", "#define\tclearerr_unlocked(p)\t__sclearerr(p)", "#define\tfileno_unlocked(p)\t__sfileno(p)", "", "#endif /* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */", "", "", "#ifdef _USE_EXTENDED_LOCALES_", "#include <xlocale/_stdio.h>", "#endif /* _USE_EXTENDED_LOCALES_ */", "", "#if defined (__GNUC__) && _FORTIFY_SOURCE > 0 && !defined (__cplusplus)", "/* Security checking functions.  */", "#include <secure/_stdio.h>", "#endif", "", "#endif /* _STDIO_H_ */" },
    ["stdlib.h"] = { "/*", " * Copyright (c) 2000, 2002 - 2008 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/*-", " * Copyright (c) 1990, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)stdlib.h\t8.5 (Berkeley) 5/19/95", " */", "", "#ifndef _STDLIB_H_", "#define _STDLIB_H_", "", "#include <Availability.h>", "", "#include <_types.h>", "#if !defined(_ANSI_SOURCE)", "#include <sys/wait.h>", "#if (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))", "#include <alloca.h>", "#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */", "#endif /* !_ANSI_SOURCE */", "", "/* DO NOT REMOVE THIS COMMENT: fixincludes needs to see:", " * _GCC_SIZE_T */", "#include <sys/_types/_size_t.h>", "", "#if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))", "#include <sys/_types/_ct_rune_t.h>", "#include <sys/_types/_rune_t.h>", "#endif\t/* !_ANSI_SOURCE && (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */", "", "#include <sys/_types/_wchar_t.h>", "", "typedef struct {", "\tint quot;\t\t/* quotient */", "\tint rem;\t\t/* remainder */", "} div_t;", "", "typedef struct {", "\tlong quot;\t\t/* quotient */", "\tlong rem;\t\t/* remainder */", "} ldiv_t;", "", "#if !__DARWIN_NO_LONG_LONG", "typedef struct {", "\tlong long quot;", "\tlong long rem;", "} lldiv_t;", "#endif /* !__DARWIN_NO_LONG_LONG */", "", "#include <sys/_types/_null.h>", "", "#define\tEXIT_FAILURE\t1", "#define\tEXIT_SUCCESS\t0", "", "#define\tRAND_MAX\t0x7fffffff", "", "#ifdef _USE_EXTENDED_LOCALES_", "#include <_xlocale.h>", "#endif /* _USE_EXTENDED_LOCALES_ */", "", "#ifndef MB_CUR_MAX", "#ifdef _USE_EXTENDED_LOCALES_", "#define\tMB_CUR_MAX\t(___mb_cur_max())", "#ifndef MB_CUR_MAX_L", "#define\tMB_CUR_MAX_L(x)\t(___mb_cur_max_l(x))", "#endif /* !MB_CUR_MAX_L */", "#else /* !_USE_EXTENDED_LOCALES_ */", "extern int __mb_cur_max;", "#define\tMB_CUR_MAX\t__mb_cur_max", "#endif /* _USE_EXTENDED_LOCALES_ */", "#endif /* MB_CUR_MAX */", "", "#if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)) \\", "    && defined(_USE_EXTENDED_LOCALES_) && !defined(MB_CUR_MAX_L)", "#define\tMB_CUR_MAX_L(x)\t(___mb_cur_max_l(x))", "#endif", "", "__BEGIN_DECLS", "void\t abort(void) __dead2;", "int\t abs(int) __pure2;", "int\t atexit(void (*)(void));", "double\t atof(const char *);", "int\t atoi(const char *);", "long\t atol(const char *);", "#if !__DARWIN_NO_LONG_LONG", "long long", "\t atoll(const char *);", "#endif /* !__DARWIN_NO_LONG_LONG */", "void\t*bsearch(const void *, const void *, size_t,", "\t    size_t, int (*)(const void *, const void *));", "void\t*calloc(size_t, size_t);", "div_t\t div(int, int) __pure2;", "void\t exit(int) __dead2;", "void\t free(void *);", "char\t*getenv(const char *);", "long\t labs(long) __pure2;", "ldiv_t\t ldiv(long, long) __pure2;", "#if !__DARWIN_NO_LONG_LONG", "long long", "\t llabs(long long);", "lldiv_t\t lldiv(long long, long long);", "#endif /* !__DARWIN_NO_LONG_LONG */", "void\t*malloc(size_t);", "int\t mblen(const char *, size_t);", "size_t\t mbstowcs(wchar_t * __restrict , const char * __restrict, size_t);", "int\t mbtowc(wchar_t * __restrict, const char * __restrict, size_t);", "int \t posix_memalign(void **, size_t, size_t) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_0);", "void\t qsort(void *, size_t, size_t,", "\t    int (*)(const void *, const void *));", "int\t rand(void);", "void\t*realloc(void *, size_t);", "void\t srand(unsigned);", "double\t strtod(const char *, char **) __DARWIN_ALIAS(strtod);", "float\t strtof(const char *, char **) __DARWIN_ALIAS(strtof);", "long\t strtol(const char *, char **, int);", "long double", "\t strtold(const char *, char **);", "#if !__DARWIN_NO_LONG_LONG", "long long ", "\t strtoll(const char *, char **, int);", "#endif /* !__DARWIN_NO_LONG_LONG */", "unsigned long", "\t strtoul(const char *, char **, int);", "#if !__DARWIN_NO_LONG_LONG", "unsigned long long", "\t strtoull(const char *, char **, int);", "#endif /* !__DARWIN_NO_LONG_LONG */", "int\t system(const char *) __DARWIN_ALIAS_C(system);", "size_t\t wcstombs(char * __restrict, const wchar_t * __restrict, size_t);", "int\t wctomb(char *, wchar_t);", "", "#ifndef _ANSI_SOURCE", "void\t_Exit(int) __dead2;", "long\t a64l(const char *);", "double\t drand48(void);", "char\t*ecvt(double, int, int *__restrict, int *__restrict); /* LEGACY */", "double\t erand48(unsigned short[3]); ", "char\t*fcvt(double, int, int *__restrict, int *__restrict); /* LEGACY */", "char\t*gcvt(double, int, char *); /* LEGACY */", "int\t getsubopt(char **, char * const *, char **);", "int\t grantpt(int);", "#if __DARWIN_UNIX03", "char\t*initstate(unsigned, char *, size_t); /* no  __DARWIN_ALIAS needed */", "#else /* !__DARWIN_UNIX03 */", "char\t*initstate(unsigned long, char *, long);", "#endif /* __DARWIN_UNIX03 */", "long\t jrand48(unsigned short[3]);", "char\t*l64a(long);", "void\t lcong48(unsigned short[7]);", "long\t lrand48(void);", "char\t*mktemp(char *);", "int\t mkstemp(char *);", "long\t mrand48(void); ", "long\t nrand48(unsigned short[3]);", "int\t posix_openpt(int);", "char\t*ptsname(int);", "int\t putenv(char *) __DARWIN_ALIAS(putenv);", "long\t random(void);", "int\t rand_r(unsigned *);", "#if (__DARWIN_UNIX03 && !defined(_POSIX_C_SOURCE)) || defined(_DARWIN_C_SOURCE) || defined(_DARWIN_BETTER_REALPATH)", "char\t*realpath(const char * __restrict, char * __restrict) __DARWIN_EXTSN(realpath);", "#else /* (!__DARWIN_UNIX03 || _POSIX_C_SOURCE) && !_DARWIN_C_SOURCE && !_DARWIN_BETTER_REALPATH */", "char\t*realpath(const char * __restrict, char * __restrict) __DARWIN_ALIAS(realpath);", "#endif /* (__DARWIN_UNIX03 && _POSIX_C_SOURCE) || _DARWIN_C_SOURCE || _DARWIN_BETTER_REALPATH */", "unsigned short", "\t*seed48(unsigned short[3]);", "int\t setenv(const char *, const char *, int) __DARWIN_ALIAS(setenv);", "#if __DARWIN_UNIX03", "void\t setkey(const char *) __DARWIN_ALIAS(setkey);", "#else /* !__DARWIN_UNIX03 */", "int\t setkey(const char *);", "#endif /* __DARWIN_UNIX03 */", "char\t*setstate(const char *);", "void\t srand48(long);", "#if __DARWIN_UNIX03", "void\t srandom(unsigned);", "#else /* !__DARWIN_UNIX03 */", "void\t srandom(unsigned long);", "#endif /* __DARWIN_UNIX03 */", "int\t unlockpt(int);", "#if __DARWIN_UNIX03", "int\t unsetenv(const char *) __DARWIN_ALIAS(unsetenv);", "#else /* !__DARWIN_UNIX03 */", "void\t unsetenv(const char *);", "#endif /* __DARWIN_UNIX03 */", "#endif\t/* !_ANSI_SOURCE */", "", "#if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))", "#include <machine/types.h>", "", "#include <sys/_types/_dev_t.h>", "#include <sys/_types/_mode_t.h>", "", "u_int32_t\tarc4random(void);", "void\t arc4random_addrandom(unsigned char * /*dat*/, int /*datlen*/);", "void\t arc4random_buf(void * /*buf*/, size_t /*nbytes*/) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);", "void\t arc4random_stir(void);", "u_int32_t", "\t arc4random_uniform(u_int32_t /*upper_bound*/) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);", "#ifdef __BLOCKS__", "int\t atexit_b(void (^)(void)) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);", "void\t*bsearch_b(const void *, const void *, size_t,", "\t    size_t, int (^)(const void *, const void *)) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);", "#endif /* __BLOCKS__ */", "", "\t /* getcap(3) functions */", "char\t*cgetcap(char *, const char *, int);", "int\t cgetclose(void);", "int\t cgetent(char **, char **, const char *);", "int\t cgetfirst(char **, char **);", "int\t cgetmatch(const char *, const char *);", "int\t cgetnext(char **, char **);", "int\t cgetnum(char *, const char *, long *);", "int\t cgetset(const char *);", "int\t cgetstr(char *, const char *, char **);", "int\t cgetustr(char *, const char *, char **);", "", "int\t daemon(int, int) __DARWIN_1050(daemon) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_5, __IPHONE_2_0, __IPHONE_2_0);", "char\t*devname(dev_t, mode_t);", "char\t*devname_r(dev_t, mode_t, char *buf, int len);", "char\t*getbsize(int *, long *);", "int\t getloadavg(double [], int);", "const char", "\t*getprogname(void);", "", "int\t heapsort(void *, size_t, size_t,", "\t    int (*)(const void *, const void *));", "#ifdef __BLOCKS__", "int\t heapsort_b(void *, size_t, size_t,", "\t    int (^)(const void *, const void *)) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);", "#endif /* __BLOCKS__ */", "int\t mergesort(void *, size_t, size_t,", "\t    int (*)(const void *, const void *));", "#ifdef __BLOCKS__", "int\t mergesort_b(void *, size_t, size_t,", "\t    int (^)(const void *, const void *)) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);", "#endif /* __BLOCKS__ */", "void\t psort(void *, size_t, size_t,", "\t    int (*)(const void *, const void *)) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);", "#ifdef __BLOCKS__", "void\t psort_b(void *, size_t, size_t,", "\t    int (^)(const void *, const void *)) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);", "#endif /* __BLOCKS__ */", "void\t psort_r(void *, size_t, size_t, void *,", "\t    int (*)(void *, const void *, const void *))  __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);", "#ifdef __BLOCKS__", "void\t qsort_b(void *, size_t, size_t,", "\t    int (^)(const void *, const void *)) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);", "#endif /* __BLOCKS__ */", "void\t qsort_r(void *, size_t, size_t, void *,", "\t    int (*)(void *, const void *, const void *));", "int\t radixsort(const unsigned char **, int, const unsigned char *,", "\t    unsigned);", "void\t setprogname(const char *);", "int\t sradixsort(const unsigned char **, int, const unsigned char *,", "\t    unsigned);", "void\t sranddev(void);", "void\t srandomdev(void);", "void\t*reallocf(void *, size_t);", "#if !__DARWIN_NO_LONG_LONG", "long long", "\t strtoq(const char *, char **, int);", "unsigned long long", "\t strtouq(const char *, char **, int);", "#endif /* !__DARWIN_NO_LONG_LONG */", "extern char *suboptarg;\t\t/* getsubopt(3) external variable */", "void\t*valloc(size_t);", "#endif\t/* !_ANSI_SOURCE && !_POSIX_SOURCE */", "", "/* Poison the following routines if -fshort-wchar is set */", "#if !defined(__cplusplus) && defined(__WCHAR_MAX__) && __WCHAR_MAX__ <= 0xffffU", "#pragma GCC poison mbstowcs mbtowc wcstombs wctomb", "#endif", "__END_DECLS", "", "#ifdef _USE_EXTENDED_LOCALES_", "#include <xlocale/_stdlib.h>", "#endif /* _USE_EXTENDED_LOCALES_ */", "", "#endif /* _STDLIB_H_ */" },
    ["strhash.h"] = { "#ifndef _STRHASH_H_INCLUDE", "#define _STRHASH_H_INCLUDE", "", "/* $FreeBSD: /repoman/r/ncvs/src/include/strhash.h,v 1.3 1999/08/28 04:59:30 peter Exp $ */", "", "/*", " *", " *                      Copyright 1990", " *               Terry Jones & Jordan Hubbard", " *", " *\t\t  PCS Computer Systeme, GmbH.", " *\t             Munich, West Germany", " *", " *", " *  All rights reserved.", " *", " *  This is unsupported software and is subject to change without notice.", " *  the author makes no representations about the suitability of this software", ' *  for any purpose. It is supplied "as is" without express or implied', " *  warranty.", " *", " *  Permission to use, copy, modify, and distribute this software and its", " *  documentation for any purpose and without fee is hereby granted, provided", " *  that the above copyright notice appear in all copies and that both that", " *  copyright notice and this permission notice appear in supporting", " *  documentation, and that the name of the author not be used in", " *  advertising or publicity pertaining to distribution of the software", " *  without specific, written prior permission.", " *", " */", "", "/*", " * This is the definition file for hash.c. The plunderer from down-under", " * did the code, I just helped define the spec. That's why his name gets", " * to go first.", " */", "", "#define HASH_SZ 97", "", "typedef struct _node {", "    char *key;", "    void *data;", "    struct _node *next;", "} hash_node;", "", "typedef struct {", "    int size;", "    hash_node **buckets;", "} hash_table;", "", "#include <sys/cdefs.h>", "", "__BEGIN_DECLS", "hash_table *hash_create(int size);", "void\thash_destroy(hash_table *table, char *key,", "\t\t     void (*nukefunc)(char *k, void *d));", "void\t*hash_search(hash_table *table, char *key, void *datum,", "\t\t     void (*replace_func)(void *d));", "void\thash_traverse(hash_table *table,", "\t\t      int (*func)(char *k, void *d, void *arg), void *arg);", "void\thash_purge(hash_table *table, void (*purge_func)(char *k, void *d));", "", "#ifdef HASH_STATS", "extern void hash_stats();", "#endif", "__END_DECLS", "", "#endif /* _STRHASH_H_INCLUDE */" },
    ["string.h"] = { "/*", " * Copyright (c) 2000, 2007, 2010 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " *", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " *", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " *", " * @APPLE_LICENSE_HEADER_END@", " */", "/*-", " * Copyright (c) 1990, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)string.h\t8.1 (Berkeley) 6/2/93", " */", "", "#ifndef _STRING_H_", "#define\t_STRING_H_", "", "#include <_types.h>", "#include <sys/cdefs.h>", "#include <Availability.h>", "#include <sys/_types/_size_t.h>", "#include <sys/_types/_null.h>", "", "/* ANSI-C */", "", "__BEGIN_DECLS", "void\t*memchr(const void *, int, size_t);", "int\t memcmp(const void *, const void *, size_t);", "void\t*memcpy(void *, const void *, size_t);", "void\t*memmove(void *, const void *, size_t);", "void\t*memset(void *, int, size_t);", "char\t*strcat(char *, const char *);", "char\t*strchr(const char *, int);", "int\t strcmp(const char *, const char *);", "int\t strcoll(const char *, const char *);", "char\t*strcpy(char *, const char *);", "size_t\t strcspn(const char *, const char *);", "char\t*strerror(int) __DARWIN_ALIAS(strerror);", "size_t\t strlen(const char *);", "char\t*strncat(char *, const char *, size_t);", "int\t strncmp(const char *, const char *, size_t);", "char\t*strncpy(char *, const char *, size_t);", "char\t*strpbrk(const char *, const char *);", "char\t*strrchr(const char *, int);", "size_t\t strspn(const char *, const char *);", "char\t*strstr(const char *, const char *);", "char\t*strtok(char *, const char *);", "size_t\t strxfrm(char *, const char *, size_t);", "__END_DECLS", "", "", "", "/* Additional functionality provided by:", " * POSIX.1c-1995,", " * POSIX.1i-1995,", " * and the omnibus ISO/IEC 9945-1: 1996", " */", "", "#if __DARWIN_C_LEVEL >= 199506L", "__BEGIN_DECLS", "char\t*strtok_r(char *, const char *, char **);", "__END_DECLS", "#endif /* __DARWIN_C_LEVEL >= 199506L */", "", "", "", "/* Additional functionality provided by:", " * POSIX.1-2001", " */", "", "#if __DARWIN_C_LEVEL >= 200112L", "__BEGIN_DECLS", "int\t strerror_r(int, char *, size_t);", "char\t*strdup(const char *);", "void\t*memccpy(void *, const void *, int, size_t);", "__END_DECLS", "#endif /* __DARWIN_C_LEVEL >= 200112L */", "", "", "", "/* Additional functionality provided by:", " * POSIX.1-2008", " */", "", "#if __DARWIN_C_LEVEL >= 200809L", "__BEGIN_DECLS", "char\t*stpcpy(char *, const char *);", "char    *stpncpy(char *, const char *, size_t) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);", "char\t*strndup(const char *, size_t) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);", "size_t   strnlen(const char *, size_t) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);", "char\t*strsignal(int sig);", "__END_DECLS", "#endif /* __DARWIN_C_LEVEL >= 200809L */", "", "/* C11 Annex K */", "", "#if defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1", "#include <sys/_types/_rsize_t.h>", "#include <sys/_types/_errno_t.h>", "", "__BEGIN_DECLS", "errno_t\tmemset_s(void *, rsize_t, int, rsize_t) __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0);", "__END_DECLS", "#endif", "", "/* Darwin extensions */", "", "#if __DARWIN_C_LEVEL >= __DARWIN_C_FULL", "#include <sys/_types/_ssize_t.h>", "", "__BEGIN_DECLS", "void\t*memmem(const void *, size_t, const void *, size_t) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);", "void     memset_pattern4(void *, const void *, size_t) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_3_0);", "void     memset_pattern8(void *, const void *, size_t) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_3_0);", "void     memset_pattern16(void *, const void *, size_t) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_3_0);", "", "char\t*strcasestr(const char *, const char *);", "char\t*strnstr(const char *, const char *, size_t);", "size_t\t strlcat(char *, const char *, size_t);", "size_t\t strlcpy(char *, const char *, size_t);", "void\t strmode(int, char *);", "char\t*strsep(char **, const char *);", "", "/* SUS places swab() in unistd.h.  It is listed here for source compatibility */", "void\t swab(const void * __restrict, void * __restrict, ssize_t);", "__END_DECLS", "", "/* Some functions historically defined in string.h were placed in strings.h", ' * by SUS.  We are using "strings.h" instead of <strings.h> to avoid an issue', " * where /Developer/Headers/FlatCarbon/Strings.h could be included instead on", " * case-insensitive file systems.", " */", '#include "strings.h"', "#endif /* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */", "", "", "#ifdef _USE_EXTENDED_LOCALES_", "#include <xlocale/_string.h>", "#endif /* _USE_EXTENDED_LOCALES_ */", "", "#if defined (__GNUC__) && _FORTIFY_SOURCE > 0 && !defined (__cplusplus)", "/* Security checking functions.  */", "#include <secure/_string.h>", "#endif", "", "#endif /* _STRING_H_ */" },
    ["stringlist.h"] = { "/*\t$NetBSD: stringlist.h,v 1.2 1997/01/17 06:11:36 lukem Exp $\t*/", "", "/*", " * Copyright (c) 1994 Christos Zoulas", " * All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by Christos Zoulas.", " * 4. The name of the author may not be used to endorse or promote products", " *    derived from this software without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS", " * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED", " * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY", " * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " * $FreeBSD: /repoman/r/ncvs/src/include/stringlist.h,v 1.3 2003/01/19 01:16:00 obrien Exp $", " */", "", "#ifndef _STRINGLIST_H", "#define _STRINGLIST_H ", "#include <sys/cdefs.h>", "#include <sys/types.h>", "", "/*", " * Simple string list", " */", "typedef struct _stringlist {", "\tchar\t**sl_str;", "\tsize_t\t  sl_max;", "\tsize_t\t  sl_cur;", "} StringList;", "", "__BEGIN_DECLS", "StringList *sl_init(void);", "int\t sl_add(StringList *, char *);", "void\t sl_free(StringList *, int);", "char\t*sl_find(StringList *, char *);", "__END_DECLS", "", "#endif /* _STRINGLIST_H */" },
    ["strings.h"] = { "/*", " * Copyright (c) 2000, 2007, 2010 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/*-", " * Copyright (c) 1990, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)strings.h\t8.1 (Berkeley) 6/2/93", " */", "", "#ifndef _STRINGS_H_", "#define _STRINGS_H_", "", "#include <_types.h>", "", "#include <sys/cdefs.h>", "#include <Availability.h>", "#include <sys/_types/_size_t.h>", "", "__BEGIN_DECLS", "/* Removed in Issue 7 */", "#if !defined(_POSIX_C_SOURCE) || _POSIX_C_SOURCE < 200809L", "int\t bcmp(const void *, const void *, size_t) __POSIX_C_DEPRECATED(200112L);", "void\t bcopy(const void *, void *, size_t) __POSIX_C_DEPRECATED(200112L);", "void\t bzero(void *, size_t) __POSIX_C_DEPRECATED(200112L);", "char\t*index(const char *, int) __POSIX_C_DEPRECATED(200112L);", "char\t*rindex(const char *, int) __POSIX_C_DEPRECATED(200112L);", "#endif", "", "int\t ffs(int);", "int\t strcasecmp(const char *, const char *);", "int\t strncasecmp(const char *, const char *, size_t);", "__END_DECLS", "", "/* Darwin extensions */", "#if __DARWIN_C_LEVEL >= __DARWIN_C_FULL", "__BEGIN_DECLS", "int\t ffsl(long) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int\t ffsll(long long) __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0);", "int\t fls(int) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int\t flsl(long) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int\t flsll(long long) __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0);", "__END_DECLS", "", "#include <string.h>", "#endif", "", "#endif  /* _STRINGS_H_ */", "" },
    ["struct.h"] = { "/*-", " * Copyright (c) 1983, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)struct.h\t8.1 (Berkeley) 6/2/93", " */", "", "#ifndef _STRUCT_H_", "#define\t_STRUCT_H_", "", "/* Offset of the field in the structure. */", "#define\tfldoff(name, field) \\", "\t((int)&(((struct name *)0)->field))", "", "/* Size of the field in the structure. */", "#define\tfldsiz(name, field) \\", "\t(sizeof(((struct name *)0)->field))", "", "/* Address of the structure from a field. */", "#define\tstrbase(name, addr, field) \\", "\t((struct name *)((char *)(addr) - fldoff(name, field)))", "", "#endif /* !_STRUCT_H_ */" },
    ["sysexits.h"] = { "/*", " * Copyright (c) 1987, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)sysexits.h\t8.1 (Berkeley) 6/2/93", " */", "", "#ifndef\t_SYSEXITS_H_", "#define\t_SYSEXITS_H_", "", "/*", " *  SYSEXITS.H -- Exit status codes for system programs.", " *", " *\tThis include file attempts to categorize possible error", " *\texit statuses for system programs, notably delivermail", " *\tand the Berkeley network.", " *", " *\tError numbers begin at EX__BASE to reduce the possibility of", " *\tclashing with other exit statuses that random programs may", " *\talready return.  The meaning of the codes is approximately", " *\tas follows:", " *", " *\tEX_USAGE -- The command was used incorrectly, e.g., with", " *\t\tthe wrong number of arguments, a bad flag, a bad", " *\t\tsyntax in a parameter, or whatever.", " *\tEX_DATAERR -- The input data was incorrect in some way.", " *\t\tThis should only be used for user's data & not", " *\t\tsystem files.", " *\tEX_NOINPUT -- An input file (not a system file) did not", " *\t\texist or was not readable.  This could also include", ' *\t\terrors like "No message" to a mailer (if it cared', " *\t\tto catch it).", " *\tEX_NOUSER -- The user specified did not exist.  This might", " *\t\tbe used for mail addresses or remote logins.", " *\tEX_NOHOST -- The host specified did not exist.  This is used", " *\t\tin mail addresses or network requests.", " *\tEX_UNAVAILABLE -- A service is unavailable.  This can occur", " *\t\tif a support program or file does not exist.  This", " *\t\tcan also be used as a catchall message when something", " *\t\tyou wanted to do doesn't work, but you don't know", " *\t\twhy.", " *\tEX_SOFTWARE -- An internal software error has been detected.", " *\t\tThis should be limited to non-operating system related", " *\t\terrors as possible.", " *\tEX_OSERR -- An operating system error has been detected.", ' *\t\tThis is intended to be used for such things as "cannot', ' *\t\tfork", "cannot create pipe", or the like.  It includes', " *\t\tthings like getuid returning a user that does not", " *\t\texist in the passwd file.", " *\tEX_OSFILE -- Some system file (e.g., /etc/passwd, /etc/utmp,", " *\t\tetc.) does not exist, cannot be opened, or has some", " *\t\tsort of error (e.g., syntax error).", " *\tEX_CANTCREAT -- A (user specified) output file cannot be", " *\t\tcreated.", " *\tEX_IOERR -- An error occurred while doing I/O on some file.", " *\tEX_TEMPFAIL -- temporary failure, indicating something that", " *\t\tis not really an error.  In sendmail, this means", " *\t\tthat a mailer (e.g.) could not create a connection,", " *\t\tand the request should be reattempted later.", " *\tEX_PROTOCOL -- the remote system returned something that", ' *\t\twas "not possible" during a protocol exchange.', " *\tEX_NOPERM -- You did not have sufficient permission to", " *\t\tperform the operation.  This is not intended for", " *\t\tfile system problems, which should use NOINPUT or", " *\t\tCANTCREAT, but rather for higher level permissions.", " */", "", "#define EX_OK\t\t0\t/* successful termination */", "", "#define EX__BASE\t64\t/* base value for error messages */", "", "#define EX_USAGE\t64\t/* command line usage error */", "#define EX_DATAERR\t65\t/* data format error */", "#define EX_NOINPUT\t66\t/* cannot open input */", "#define EX_NOUSER\t67\t/* addressee unknown */", "#define EX_NOHOST\t68\t/* host name unknown */", "#define EX_UNAVAILABLE\t69\t/* service unavailable */", "#define EX_SOFTWARE\t70\t/* internal software error */", "#define EX_OSERR\t71\t/* system error (e.g., can't fork) */", "#define EX_OSFILE\t72\t/* critical OS file missing */", "#define EX_CANTCREAT\t73\t/* can't create (user) output file */", "#define EX_IOERR\t74\t/* input/output error */", "#define EX_TEMPFAIL\t75\t/* temp failure; user is invited to retry */", "#define EX_PROTOCOL\t76\t/* remote error in protocol */", "#define EX_NOPERM\t77\t/* permission denied */", "#define EX_CONFIG\t78\t/* configuration error */", "", "#define EX__MAX\t78\t/* maximum listed value */", "", "#endif /* !_SYSEXITS_H_ */" },
    ["syslog.h"] = { "/*", " * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "#include <sys/syslog.h>", "" },
    ["tar.h"] = { "/*-", " * Copyright (c) 1994", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * This code is derived from software contributed to Berkeley by", " * Chuck Karish of Mindcraft, Inc.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)tar.h\t8.2 (Berkeley) 1/4/94", " */", "", "#ifndef _TAR_H", "#define _TAR_H", "", '#define\tTMAGIC\t\t"ustar"\t/* ustar and a null */', "#define\tTMAGLEN\t\t6", '#define\tTVERSION\t"00"\t/* 00 and no null */', "#define\tTVERSLEN\t2", "", "/* Values used in typeflag field */", "#define\tREGTYPE\t\t'0'\t/* Regular file */", "#define\tAREGTYPE\t'\\0'\t/* Regular file */", "#define\tLNKTYPE\t\t'1'\t/* Link */", "#define\tSYMTYPE\t\t'2'\t/* Reserved */", "#define\tCHRTYPE\t\t'3'\t/* Character special */", "#define\tBLKTYPE\t\t'4'\t/* Block special */", "#define\tDIRTYPE\t\t'5'\t/* Directory */", "#define\tFIFOTYPE\t'6'\t/* FIFO special */", "#define\tCONTTYPE\t'7'\t/* Reserved */", "", "/* Bits used in the mode field - values in octal */", "#define\tTSUID\t\t04000\t/* Set UID on execution */", "#define\tTSGID\t\t02000\t/* Set GID on execution */", "#define\tTSVTX\t\t01000\t/* Reserved */", "\t\t\t\t/* File permissions */", "#define\tTUREAD\t\t00400\t/* Read by owner */", "#define\tTUWRITE\t\t00200\t/* Write by owner */", "#define\tTUEXEC\t\t00100\t/* Execute/Search by owner */", "#define\tTGREAD\t\t00040\t/* Read by group */", "#define\tTGWRITE\t\t00020\t/* Write by group */", "#define\tTGEXEC\t\t00010\t/* Execute/Search by group */", "#define\tTOREAD\t\t00004\t/* Read by other */", "#define\tTOWRITE\t\t00002\t/* Write by other */", "#define\tTOEXEC\t\t00001\t/* Execute/Search by other */", "", "#endif" },
    ["tcl.h"] = { "/*", " * tcl.h --", " *", " *\tThis header file describes the externally-visible facilities of the", " *\tTcl interpreter.", " *", " * Copyright (c) 1987-1994 The Regents of the University of California.", " * Copyright (c) 1993-1996 Lucent Technologies.", " * Copyright (c) 1994-1998 Sun Microsystems, Inc.", " * Copyright (c) 1998-2000 by Scriptics Corporation.", " * Copyright (c) 2002 by Kevin B. Kenny.  All rights reserved.", " *", ' * See the file "license.terms" for information on usage and redistribution of', " * this file, and for a DISCLAIMER OF ALL WARRANTIES.", " *", " * RCS: @(#) $Id: tcl.h,v 1.254.2.16 2010/08/04 17:02:39 dgp Exp $", " */", "", "#ifndef _TCL", "#define _TCL", "", "/*", ' * For C++ compilers, use extern "C"', " */", "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "", "/*", " * The following defines are used to indicate the various release levels.", " */", "", "#define TCL_ALPHA_RELEASE\t0", "#define TCL_BETA_RELEASE\t1", "#define TCL_FINAL_RELEASE\t2", "", "/*", " * When version numbers change here, must also go into the following files and", " * update the version numbers:", " *", " * library/init.tcl\t(1 LOC patch)", " * unix/configure.in\t(2 LOC Major, 2 LOC minor, 1 LOC patch)", " * win/configure.in\t(as above)", " * win/tcl.m4\t\t(not patchlevel)", " * win/makefile.bc\t(not patchlevel) 2 LOC", " * README\t\t(sections 0 and 2, with and without separator)", " * macosx/Tcl.pbproj/project.pbxproj (not patchlevel) 1 LOC", " * macosx/Tcl.pbproj/default.pbxuser (not patchlevel) 1 LOC", " * macosx/Tcl.xcode/project.pbxproj (not patchlevel) 2 LOC", " * macosx/Tcl.xcode/default.pbxuser (not patchlevel) 1 LOC", " * macosx/Tcl-Common.xcconfig (not patchlevel) 1 LOC", " * win/README\t\t(not patchlevel) (sections 0 and 2)", " * unix/tcl.spec\t(1 LOC patch)", " * tools/tcl.hpj.in\t(not patchlevel, for windows installer)", " * tools/tcl.wse.in\t(for windows installer)", " * tools/tclSplash.bmp\t(not patchlevel)", " */", "", "#define TCL_MAJOR_VERSION   8", "#define TCL_MINOR_VERSION   5", "#define TCL_RELEASE_LEVEL   TCL_FINAL_RELEASE", "#define TCL_RELEASE_SERIAL  9", "", '#define TCL_VERSION\t    "8.5"', '#define TCL_PATCH_LEVEL\t    "8.5.9"', "", "/*", " * The following definitions set up the proper options for Windows compilers.", " * We use this method because there is no autoconf equivalent.", " */", "", "#ifndef __WIN32__", "#   if defined(_WIN32) || defined(WIN32) || defined(__MINGW32__) || defined(__BORLANDC__) || (defined(__WATCOMC__) && defined(__WINDOWS_386__))", "#\tdefine __WIN32__", "#\tifndef WIN32", "#\t    define WIN32", "#\tendif", "#\tifndef _WIN32", "#\t    define _WIN32", "#\tendif", "#   endif", "#endif", "", "/*", " * STRICT: See MSDN Article Q83456", " */", "", "#ifdef __WIN32__", "#   ifndef STRICT", "#\tdefine STRICT", "#   endif", "#endif /* __WIN32__ */", "", "/*", ' * Utility macros: STRINGIFY takes an argument and wraps it in "" (double', " * quotation marks), JOIN joins two arguments.", " */", "", "#ifndef STRINGIFY", "#  define STRINGIFY(x) STRINGIFY1(x)", "#  define STRINGIFY1(x) #x", "#endif", "#ifndef JOIN", "#  define JOIN(a,b) JOIN1(a,b)", "#  define JOIN1(a,b) a##b", "#endif", "", "/*", " * A special definition used to allow this header file to be included from", " * windows resource files so that they can obtain version information.", " * RC_INVOKED is defined by default by the windows RC tool.", " *", " * Resource compilers don't like all the C stuff, like typedefs and function", " * declarations, that occur below, so block them out.", " */", "", "#ifndef RC_INVOKED", "", "/*", " * Special macro to define mutexes, that doesn't do anything if we are not", " * using threads.", " */", "", "#ifdef TCL_THREADS", "#define TCL_DECLARE_MUTEX(name) static Tcl_Mutex name;", "#else", "#define TCL_DECLARE_MUTEX(name)", "#endif", "", "/*", " * Tcl's public routine Tcl_FSSeek() uses the values SEEK_SET, SEEK_CUR, and", " * SEEK_END, all #define'd by stdio.h .", " *", " * Also, many extensions need stdio.h, and they've grown accustomed to tcl.h", " * providing it for them rather than #include-ing it themselves as they", " * should, so also for their sake, we keep the #include to be consistent with", " * prior Tcl releases.", " */", "", "#include <stdio.h>", "", "/*", " * Support for functions with a variable number of arguments.", " *", " * The following TCL_VARARGS* macros are to support old extensions", " * written for older versions of Tcl where the macros permitted", " * support for the varargs.h system as well as stdarg.h .", " *", " * New code should just directly be written to use stdarg.h conventions.", " */", "", "#include <stdarg.h>", "#ifndef TCL_NO_DEPRECATED", "#    define TCL_VARARGS(type, name) (type name, ...)", "#    define TCL_VARARGS_DEF(type, name) (type name, ...)", "#    define TCL_VARARGS_START(type, name, list) (va_start(list, name), name)", "#endif", "", "/*", " * Macros used to declare a function to be exported by a DLL. Used by Windows,", " * maps to no-op declarations on non-Windows systems. The default build on", " * windows is for a DLL, which causes the DLLIMPORT and DLLEXPORT macros to be", " * nonempty. To build a static library, the macro STATIC_BUILD should be", " * defined.", " *", " * Note: when building static but linking dynamically to MSVCRT we must still", " *       correctly decorate the C library imported function.  Use CRTIMPORT", " *       for this purpose.  _DLL is defined by the compiler when linking to", " *       MSVCRT.", " */", "", "#if (defined(__WIN32__) && (defined(_MSC_VER) || (__BORLANDC__ >= 0x0550) || defined(__LCC__) || defined(__WATCOMC__) || (defined(__GNUC__) && defined(__declspec))))", "#   define HAVE_DECLSPEC 1", "#   ifdef STATIC_BUILD", "#       define DLLIMPORT", "#       define DLLEXPORT", "#       ifdef _DLL", "#           define CRTIMPORT __declspec(dllimport)", "#       else", "#           define CRTIMPORT", "#       endif", "#   else", "#       define DLLIMPORT __declspec(dllimport)", "#       define DLLEXPORT __declspec(dllexport)", "#       define CRTIMPORT __declspec(dllimport)", "#   endif", "#else", "#   define DLLIMPORT", "#   if defined(__GNUC__) && __GNUC__ > 3", '#       define DLLEXPORT __attribute__ ((visibility("default")))', "#   else", "#       define DLLEXPORT", "#   endif", "#   define CRTIMPORT", "#endif", "", "/*", " * These macros are used to control whether functions are being declared for", " * import or export. If a function is being declared while it is being built", " * to be included in a shared library, then it should have the DLLEXPORT", " * storage class. If is being declared for use by a module that is going to", " * link against the shared library, then it should have the DLLIMPORT storage", " * class. If the symbol is beind declared for a static build or for use from a", " * stub library, then the storage class should be empty.", " *", " * The convention is that a macro called BUILD_xxxx, where xxxx is the name of", " * a library we are building, is set on the compile line for sources that are", " * to be placed in the library. When this macro is set, the storage class will", " * be set to DLLEXPORT. At the end of the header file, the storage class will", " * be reset to DLLIMPORT.", " */", "", "#undef TCL_STORAGE_CLASS", "#ifdef BUILD_tcl", "#   define TCL_STORAGE_CLASS DLLEXPORT", "#else", "#   ifdef USE_TCL_STUBS", "#      define TCL_STORAGE_CLASS", "#   else", "#      define TCL_STORAGE_CLASS DLLIMPORT", "#   endif", "#endif", "", "/*", " * Definitions that allow this header file to be used either with or without", " * ANSI C features like function prototypes.", " */", "", "#undef _ANSI_ARGS_", "#undef CONST", "#ifndef INLINE", "#   define INLINE", "#endif", "", "#ifndef NO_CONST", "#   define CONST const", "#else", "#   define CONST", "#endif", "", "#ifndef NO_PROTOTYPES", "#   define _ANSI_ARGS_(x)\tx", "#else", "#   define _ANSI_ARGS_(x)\t()", "#endif", "", "#ifdef USE_NON_CONST", "#   ifdef USE_COMPAT_CONST", "#      error define at most one of USE_NON_CONST and USE_COMPAT_CONST", "#   endif", "#   define CONST84", "#   define CONST84_RETURN", "#else", "#   ifdef USE_COMPAT_CONST", "#      define CONST84", "#      define CONST84_RETURN CONST", "#   else", "#      define CONST84 CONST", "#      define CONST84_RETURN CONST", "#   endif", "#endif", "", "/*", " * Make sure EXTERN isn't defined elsewhere.", " */", "", "#ifdef EXTERN", "#   undef EXTERN", "#endif /* EXTERN */", "", "#ifdef __cplusplus", '#   define EXTERN extern "C" TCL_STORAGE_CLASS', "#else", "#   define EXTERN extern TCL_STORAGE_CLASS", "#endif", "", "/*", " * The following code is copied from winnt.h. If we don't replicate it here,", " * then <windows.h> can't be included after tcl.h, since tcl.h also defines", " * VOID. This block is skipped under Cygwin and Mingw.", " */", "", "#if defined(__WIN32__) && !defined(HAVE_WINNT_IGNORE_VOID)", "#ifndef VOID", "#define VOID void", "typedef char CHAR;", "typedef short SHORT;", "typedef long LONG;", "#endif", "#endif /* __WIN32__ && !HAVE_WINNT_IGNORE_VOID */", "", "/*", ' * Macro to use instead of "void" for arguments that must have type "void *"', ' * in ANSI C; maps them to type "char *" in non-ANSI systems.', " */", "", "#ifndef NO_VOID", "#define VOID\tvoid", "#else", "#define VOID\tchar", "#endif", "", "/*", " * Miscellaneous declarations.", " */", "", "#ifndef _CLIENTDATA", "#   ifndef NO_VOID", "\ttypedef void *ClientData;", "#   else", "\ttypedef int *ClientData;", "#   endif", "#   define _CLIENTDATA", "#endif", "", "/*", " * Darwin specific configure overrides (to support fat compiles, where", " * configure runs only once for multiple architectures):", " */", "", "#ifdef __APPLE__", "#   ifdef __LP64__", "#\tundef TCL_WIDE_INT_TYPE", "#\tdefine TCL_WIDE_INT_IS_LONG 1", "#\tdefine TCL_CFG_DO64BIT 1", "#    else /* !__LP64__ */", "#\tdefine TCL_WIDE_INT_TYPE long long", "#\tundef TCL_WIDE_INT_IS_LONG", "#\tundef TCL_CFG_DO64BIT", "#    endif /* __LP64__ */", "#    undef HAVE_STRUCT_STAT64", "#endif /* __APPLE__ */", "", "/*", " * Define Tcl_WideInt to be a type that is (at least) 64-bits wide, and define", " * Tcl_WideUInt to be the unsigned variant of that type (assuming that where", " * we have one, we can have the other.)", " *", " * Also defines the following macros:", " * TCL_WIDE_INT_IS_LONG - if wide ints are really longs (i.e. we're on a real", " *\t64-bit system.)", " * Tcl_WideAsLong - forgetful converter from wideInt to long.", " * Tcl_LongAsWide - sign-extending converter from long to wideInt.", " * Tcl_WideAsDouble - converter from wideInt to double.", " * Tcl_DoubleAsWide - converter from double to wideInt.", " *", " * The following invariant should hold for any long value 'longVal':", " *\tlongVal == Tcl_WideAsLong(Tcl_LongAsWide(longVal))", " *", " * Note on converting between Tcl_WideInt and strings. This implementation (in", " * tclObj.c) depends on the function", ' * sprintf(...,"%" TCL_LL_MODIFIER "d",...).', " */", "", "#if !defined(TCL_WIDE_INT_TYPE)&&!defined(TCL_WIDE_INT_IS_LONG)", "#   if defined(__GNUC__)", "#      define TCL_WIDE_INT_TYPE long long", "#      if defined(__WIN32__) && !defined(__CYGWIN__)", '#         define TCL_LL_MODIFIER        "I64"', "#      else", '#         define TCL_LL_MODIFIER\t"ll"', "#      endif", "typedef struct stat\tTcl_StatBuf;", "#   elif defined(__WIN32__)", "#      define TCL_WIDE_INT_TYPE __int64", "#      ifdef __BORLANDC__", "typedef struct stati64 Tcl_StatBuf;", '#         define TCL_LL_MODIFIER\t"L"', "#      else /* __BORLANDC__ */", "#         if _MSC_VER < 1400 || !defined(_M_IX86)", "typedef struct _stati64\tTcl_StatBuf;", "#         else", "typedef struct _stat64\tTcl_StatBuf;", "#         endif /* _MSC_VER < 1400 */", '#         define TCL_LL_MODIFIER\t"I64"', "#      endif /* __BORLANDC__ */", "#   else /* __WIN32__ */", "/*", " * Don't know what platform it is and configure hasn't discovered what is", " * going on for us. Try to guess...", " */", "#      ifdef NO_LIMITS_H", "#\t  error please define either TCL_WIDE_INT_TYPE or TCL_WIDE_INT_IS_LONG", "#      else /* !NO_LIMITS_H */", "#\t  include <limits.h>", "#\t  if (INT_MAX < LONG_MAX)", "#\t     define TCL_WIDE_INT_IS_LONG\t1", "#\t  else", "#\t     define TCL_WIDE_INT_TYPE long long", "#         endif", "#      endif /* NO_LIMITS_H */", "#   endif /* __WIN32__ */", "#endif /* !TCL_WIDE_INT_TYPE & !TCL_WIDE_INT_IS_LONG */", "#ifdef TCL_WIDE_INT_IS_LONG", "#   undef TCL_WIDE_INT_TYPE", "#   define TCL_WIDE_INT_TYPE\tlong", "#endif /* TCL_WIDE_INT_IS_LONG */", "", "typedef TCL_WIDE_INT_TYPE\t\tTcl_WideInt;", "typedef unsigned TCL_WIDE_INT_TYPE\tTcl_WideUInt;", "", "#ifdef TCL_WIDE_INT_IS_LONG", "typedef struct stat\tTcl_StatBuf;", "#   define Tcl_WideAsLong(val)\t\t((long)(val))", "#   define Tcl_LongAsWide(val)\t\t((long)(val))", "#   define Tcl_WideAsDouble(val)\t((double)((long)(val)))", "#   define Tcl_DoubleAsWide(val)\t((long)((double)(val)))", "#   ifndef TCL_LL_MODIFIER", '#      define TCL_LL_MODIFIER\t\t"l"', "#   endif /* !TCL_LL_MODIFIER */", "#else /* TCL_WIDE_INT_IS_LONG */", "/*", " * The next short section of defines are only done when not running on Windows", " * or some other strange platform.", " */", "#   ifndef TCL_LL_MODIFIER", "#      ifdef HAVE_STRUCT_STAT64", "typedef struct stat64\tTcl_StatBuf;", "#      else", "typedef struct stat\tTcl_StatBuf;", "#      endif /* HAVE_STRUCT_STAT64 */", '#      define TCL_LL_MODIFIER\t\t"ll"', "#   endif /* !TCL_LL_MODIFIER */", "#   define Tcl_WideAsLong(val)\t\t((long)((Tcl_WideInt)(val)))", "#   define Tcl_LongAsWide(val)\t\t((Tcl_WideInt)((long)(val)))", "#   define Tcl_WideAsDouble(val)\t((double)((Tcl_WideInt)(val)))", "#   define Tcl_DoubleAsWide(val)\t((Tcl_WideInt)((double)(val)))", "#endif /* TCL_WIDE_INT_IS_LONG */", "", "/*", " * Data structures defined opaquely in this module. The definitions below just", " * provide dummy types. A few fields are made visible in Tcl_Interp", " * structures, namely those used for returning a string result from commands.", " * Direct access to the result field is discouraged in Tcl 8.0. The", " * interpreter result is either an object or a string, and the two values are", " * kept consistent unless some C code sets interp->result directly.", " * Programmers should use either the function Tcl_GetObjResult() or", " * Tcl_GetStringResult() to read the interpreter's result. See the SetResult", " * man page for details.", " *", " * Note: any change to the Tcl_Interp definition below must be mirrored in the", ' * "real" definition in tclInt.h.', " *", " * Note: Tcl_ObjCmdProc functions do not directly set result and freeProc.", ' * Instead, they set a Tcl_Obj member in the "real" structure that can be', " * accessed with Tcl_GetObjResult() and Tcl_SetObjResult().", " */", "", "typedef struct Tcl_Interp {", "    char *result;\t\t/* If the last command returned a string", "\t\t\t\t * result, this points to it. */", "    void (*freeProc) _ANSI_ARGS_((char *blockPtr));", "\t\t\t\t/* Zero means the string result is statically", "\t\t\t\t * allocated. TCL_DYNAMIC means it was", "\t\t\t\t * allocated with ckalloc and should be freed", "\t\t\t\t * with ckfree. Other values give the address", "\t\t\t\t * of function to invoke to free the result.", "\t\t\t\t * Tcl_Eval must free it before executing next", "\t\t\t\t * command. */", "    int errorLine;\t\t/* When TCL_ERROR is returned, this gives the", "\t\t\t\t * line number within the command where the", "\t\t\t\t * error occurred (1 if first line). */", "} Tcl_Interp;", "", "typedef struct Tcl_AsyncHandler_ *Tcl_AsyncHandler;", "typedef struct Tcl_Channel_ *Tcl_Channel;", "typedef struct Tcl_ChannelTypeVersion_ *Tcl_ChannelTypeVersion;", "typedef struct Tcl_Command_ *Tcl_Command;", "typedef struct Tcl_Condition_ *Tcl_Condition;", "typedef struct Tcl_Dict_ *Tcl_Dict;", "typedef struct Tcl_EncodingState_ *Tcl_EncodingState;", "typedef struct Tcl_Encoding_ *Tcl_Encoding;", "typedef struct Tcl_Event Tcl_Event;", "typedef struct Tcl_InterpState_ *Tcl_InterpState;", "typedef struct Tcl_LoadHandle_ *Tcl_LoadHandle;", "typedef struct Tcl_Mutex_ *Tcl_Mutex;", "typedef struct Tcl_Pid_ *Tcl_Pid;", "typedef struct Tcl_RegExp_ *Tcl_RegExp;", "typedef struct Tcl_ThreadDataKey_ *Tcl_ThreadDataKey;", "typedef struct Tcl_ThreadId_ *Tcl_ThreadId;", "typedef struct Tcl_TimerToken_ *Tcl_TimerToken;", "typedef struct Tcl_Trace_ *Tcl_Trace;", "typedef struct Tcl_Var_ *Tcl_Var;", "", "/*", " * Definition of the interface to functions implementing threads. A function", " * following this definition is given to each call of 'Tcl_CreateThread' and", " * will be called as the main fuction of the new thread created by that call.", " */", "", "#if defined __WIN32__", "typedef unsigned (__stdcall Tcl_ThreadCreateProc) _ANSI_ARGS_((ClientData clientData));", "#else", "typedef void (Tcl_ThreadCreateProc) _ANSI_ARGS_((ClientData clientData));", "#endif", "", "/*", " * Threading function return types used for abstracting away platform", " * differences when writing a Tcl_ThreadCreateProc. See the NewThread function", " * in generic/tclThreadTest.c for it's usage.", " */", "", "#if defined __WIN32__", "#   define Tcl_ThreadCreateType\t\tunsigned __stdcall", "#   define TCL_THREAD_CREATE_RETURN\treturn 0", "#else", "#   define Tcl_ThreadCreateType\t\tvoid", "#   define TCL_THREAD_CREATE_RETURN", "#endif", "", "/*", " * Definition of values for default stacksize and the possible flags to be", " * given to Tcl_CreateThread.", " */", "", "#define TCL_THREAD_STACK_DEFAULT (0)    /* Use default size for stack. */", "#define TCL_THREAD_NOFLAGS\t (0000) /* Standard flags, default", "\t\t\t\t\t * behaviour. */", "#define TCL_THREAD_JOINABLE\t (0001) /* Mark the thread as joinable. */", "", "/*", " * Flag values passed to Tcl_StringCaseMatch.", " */", "", "#define TCL_MATCH_NOCASE\t(1<<0)", "", "/*", " * Flag values passed to Tcl_GetRegExpFromObj.", " */", "", "#define\tTCL_REG_BASIC\t\t000000\t/* BREs (convenience). */", "#define\tTCL_REG_EXTENDED\t000001\t/* EREs. */", "#define\tTCL_REG_ADVF\t\t000002\t/* Advanced features in EREs. */", "#define\tTCL_REG_ADVANCED\t000003\t/* AREs (which are also EREs). */", "#define\tTCL_REG_QUOTE\t\t000004\t/* No special characters, none. */", "#define\tTCL_REG_NOCASE\t\t000010\t/* Ignore case. */", "#define\tTCL_REG_NOSUB\t\t000020\t/* Don't care about subexpressions. */", "#define\tTCL_REG_EXPANDED\t000040\t/* Expanded format, white space &", "\t\t\t\t\t * comments. */", "#define\tTCL_REG_NLSTOP\t\t000100  /* \\n doesn't match . or [^ ] */", "#define\tTCL_REG_NLANCH\t\t000200  /* ^ matches after \\n, $ before. */", "#define\tTCL_REG_NEWLINE\t\t000300  /* Newlines are line terminators. */", "#define\tTCL_REG_CANMATCH\t001000  /* Report details on partial/limited", "\t\t\t\t\t * matches. */", "", "/*", " * Flags values passed to Tcl_RegExpExecObj.", " */", "", "#define\tTCL_REG_NOTBOL\t0001\t/* Beginning of string does not match ^.  */", "#define\tTCL_REG_NOTEOL\t0002\t/* End of string does not match $. */", "", "/*", " * Structures filled in by Tcl_RegExpInfo. Note that all offset values are", " * relative to the start of the match string, not the beginning of the entire", " * string.", " */", "", "typedef struct Tcl_RegExpIndices {", "    long start;\t\t\t/* Character offset of first character in", "\t\t\t\t * match. */", "    long end;\t\t\t/* Character offset of first character after", "\t\t\t\t * the match. */", "} Tcl_RegExpIndices;", "", "typedef struct Tcl_RegExpInfo {", "    int nsubs;\t\t\t/* Number of subexpressions in the compiled", "\t\t\t\t * expression. */", "    Tcl_RegExpIndices *matches;\t/* Array of nsubs match offset pairs. */", "    long extendStart;\t\t/* The offset at which a subsequent match", "\t\t\t\t * might begin. */", "    long reserved;\t\t/* Reserved for later use. */", "} Tcl_RegExpInfo;", "", "/*", " * Picky compilers complain if this typdef doesn't appear before the struct's", " * reference in tclDecls.h.", " */", "", "typedef Tcl_StatBuf *Tcl_Stat_;", "typedef struct stat *Tcl_OldStat_;", "", "/*", " * When a TCL command returns, the interpreter contains a result from the", " * command. Programmers are strongly encouraged to use one of the functions", " * Tcl_GetObjResult() or Tcl_GetStringResult() to read the interpreter's", " * result. See the SetResult man page for details. Besides this result, the", " * command function returns an integer code, which is one of the following:", " *", " * TCL_OK\t\tCommand completed normally; the interpreter's result", " *\t\t\tcontains the command's result.", " * TCL_ERROR\t\tThe command couldn't be completed successfully; the", " *\t\t\tinterpreter's result describes what went wrong.", " * TCL_RETURN\t\tThe command requests that the current function return;", " *\t\t\tthe interpreter's result contains the function's", " *\t\t\treturn value.", " * TCL_BREAK\t\tThe command requests that the innermost loop be", " *\t\t\texited; the interpreter's result is meaningless.", " * TCL_CONTINUE\t\tGo on to the next iteration of the current loop; the", " *\t\t\tinterpreter's result is meaningless.", " */", "", "#define TCL_OK\t\t\t0", "#define TCL_ERROR\t\t1", "#define TCL_RETURN\t\t2", "#define TCL_BREAK\t\t3", "#define TCL_CONTINUE\t\t4", "", "#define TCL_RESULT_SIZE\t\t200", "", "/*", " * Flags to control what substitutions are performed by Tcl_SubstObj():", " */", "", "#define TCL_SUBST_COMMANDS\t001", "#define TCL_SUBST_VARIABLES\t002", "#define TCL_SUBST_BACKSLASHES\t004", "#define TCL_SUBST_ALL\t\t007", "", "/*", " * Argument descriptors for math function callbacks in expressions:", " */", "", "typedef enum {", "    TCL_INT, TCL_DOUBLE, TCL_EITHER, TCL_WIDE_INT", "} Tcl_ValueType;", "", "typedef struct Tcl_Value {", "    Tcl_ValueType type;\t\t/* Indicates intValue or doubleValue is valid,", "\t\t\t\t * or both. */", "    long intValue;\t\t/* Integer value. */", "    double doubleValue;\t\t/* Double-precision floating value. */", "    Tcl_WideInt wideValue;\t/* Wide (min. 64-bit) integer value. */", "} Tcl_Value;", "", "/*", " * Forward declaration of Tcl_Obj to prevent an error when the forward", " * reference to Tcl_Obj is encountered in the function types declared below.", " */", "", "struct Tcl_Obj;", "", "/*", " * Function types defined by Tcl:", " */", "", "typedef int (Tcl_AppInitProc) _ANSI_ARGS_((Tcl_Interp *interp));", "typedef int (Tcl_AsyncProc) _ANSI_ARGS_((ClientData clientData,", "\tTcl_Interp *interp, int code));", "typedef void (Tcl_ChannelProc) _ANSI_ARGS_((ClientData clientData, int mask));", "typedef void (Tcl_CloseProc) _ANSI_ARGS_((ClientData data));", "typedef void (Tcl_CmdDeleteProc) _ANSI_ARGS_((ClientData clientData));", "typedef int (Tcl_CmdProc) _ANSI_ARGS_((ClientData clientData,", "\tTcl_Interp *interp, int argc, CONST84 char *argv[]));", "typedef void (Tcl_CmdTraceProc) _ANSI_ARGS_((ClientData clientData,", "\tTcl_Interp *interp, int level, char *command, Tcl_CmdProc *proc,", "\tClientData cmdClientData, int argc, CONST84 char *argv[]));", "typedef int (Tcl_CmdObjTraceProc) _ANSI_ARGS_((ClientData clientData,", "\tTcl_Interp *interp, int level, CONST char *command,", "\tTcl_Command commandInfo, int objc, struct Tcl_Obj * CONST * objv));", "typedef void (Tcl_CmdObjTraceDeleteProc) _ANSI_ARGS_((ClientData clientData));", "typedef void (Tcl_DupInternalRepProc) _ANSI_ARGS_((struct Tcl_Obj *srcPtr,", "\tstruct Tcl_Obj *dupPtr));", "typedef int (Tcl_EncodingConvertProc)_ANSI_ARGS_((ClientData clientData,", "\tCONST char *src, int srcLen, int flags, Tcl_EncodingState *statePtr,", "\tchar *dst, int dstLen, int *srcReadPtr, int *dstWrotePtr,", "\tint *dstCharsPtr));", "typedef void (Tcl_EncodingFreeProc)_ANSI_ARGS_((ClientData clientData));", "typedef int (Tcl_EventProc) _ANSI_ARGS_((Tcl_Event *evPtr, int flags));", "typedef void (Tcl_EventCheckProc) _ANSI_ARGS_((ClientData clientData,", "\tint flags));", "typedef int (Tcl_EventDeleteProc) _ANSI_ARGS_((Tcl_Event *evPtr,", "\tClientData clientData));", "typedef void (Tcl_EventSetupProc) _ANSI_ARGS_((ClientData clientData,", "\tint flags));", "typedef void (Tcl_ExitProc) _ANSI_ARGS_((ClientData clientData));", "typedef void (Tcl_FileProc) _ANSI_ARGS_((ClientData clientData, int mask));", "typedef void (Tcl_FileFreeProc) _ANSI_ARGS_((ClientData clientData));", "typedef void (Tcl_FreeInternalRepProc) _ANSI_ARGS_((struct Tcl_Obj *objPtr));", "typedef void (Tcl_FreeProc) _ANSI_ARGS_((char *blockPtr));", "typedef void (Tcl_IdleProc) _ANSI_ARGS_((ClientData clientData));", "typedef void (Tcl_InterpDeleteProc) _ANSI_ARGS_((ClientData clientData,", "\tTcl_Interp *interp));", "typedef int (Tcl_MathProc) _ANSI_ARGS_((ClientData clientData,", "\tTcl_Interp *interp, Tcl_Value *args, Tcl_Value *resultPtr));", "typedef void (Tcl_NamespaceDeleteProc) _ANSI_ARGS_((ClientData clientData));", "typedef int (Tcl_ObjCmdProc) _ANSI_ARGS_((ClientData clientData,", "\tTcl_Interp *interp, int objc, struct Tcl_Obj * CONST * objv));", "typedef int (Tcl_PackageInitProc) _ANSI_ARGS_((Tcl_Interp *interp));", "typedef int (Tcl_PackageUnloadProc) _ANSI_ARGS_((Tcl_Interp *interp,", "\tint flags));", "typedef void (Tcl_PanicProc) _ANSI_ARGS_((CONST char *format, ...));", "typedef void (Tcl_TcpAcceptProc) _ANSI_ARGS_((ClientData callbackData,", "\tTcl_Channel chan, char *address, int port));", "typedef void (Tcl_TimerProc) _ANSI_ARGS_((ClientData clientData));", "typedef int (Tcl_SetFromAnyProc) _ANSI_ARGS_((Tcl_Interp *interp,", "\tstruct Tcl_Obj *objPtr));", "typedef void (Tcl_UpdateStringProc) _ANSI_ARGS_((struct Tcl_Obj *objPtr));", "typedef char *(Tcl_VarTraceProc) _ANSI_ARGS_((ClientData clientData,", "\tTcl_Interp *interp, CONST84 char *part1, CONST84 char *part2,", "\tint flags));", "typedef void (Tcl_CommandTraceProc) _ANSI_ARGS_((ClientData clientData,", "\tTcl_Interp *interp, CONST char *oldName, CONST char *newName,", "\tint flags));", "typedef void (Tcl_CreateFileHandlerProc) _ANSI_ARGS_((int fd, int mask,", "\tTcl_FileProc *proc, ClientData clientData));", "typedef void (Tcl_DeleteFileHandlerProc) _ANSI_ARGS_((int fd));", "typedef void (Tcl_AlertNotifierProc) _ANSI_ARGS_((ClientData clientData));", "typedef void (Tcl_ServiceModeHookProc) _ANSI_ARGS_((int mode));", "typedef ClientData (Tcl_InitNotifierProc) _ANSI_ARGS_((VOID));", "typedef void (Tcl_FinalizeNotifierProc) _ANSI_ARGS_((ClientData clientData));", "typedef void (Tcl_MainLoopProc) _ANSI_ARGS_((void));", "", "/*", " * The following structure represents a type of object, which is a particular", " * internal representation for an object plus a set of functions that provide", " * standard operations on objects of that type.", " */", "", "typedef struct Tcl_ObjType {", '    char *name;\t\t\t/* Name of the type, e.g. "int". */', "    Tcl_FreeInternalRepProc *freeIntRepProc;", "\t\t\t\t/* Called to free any storage for the type's", "\t\t\t\t * internal rep. NULL if the internal rep does", "\t\t\t\t * not need freeing. */", "    Tcl_DupInternalRepProc *dupIntRepProc;", "\t\t\t\t/* Called to create a new object as a copy of", "\t\t\t\t * an existing object. */", "    Tcl_UpdateStringProc *updateStringProc;", "\t\t\t\t/* Called to update the string rep from the", "\t\t\t\t * type's internal representation. */", "    Tcl_SetFromAnyProc *setFromAnyProc;", "\t\t\t\t/* Called to convert the object's internal rep", "\t\t\t\t * to this type. Frees the internal rep of the", "\t\t\t\t * old type. Returns TCL_ERROR on failure. */", "} Tcl_ObjType;", "", "/*", " * One of the following structures exists for each object in the Tcl system.", " * An object stores a value as either a string, some internal representation,", " * or both.", " */", "", "typedef struct Tcl_Obj {", "    int refCount;\t\t/* When 0 the object will be freed. */", "    char *bytes;\t\t/* This points to the first byte of the", "\t\t\t\t * object's string representation. The array", "\t\t\t\t * must be followed by a null byte (i.e., at", "\t\t\t\t * offset length) but may also contain", "\t\t\t\t * embedded null characters. The array's", "\t\t\t\t * storage is allocated by ckalloc. NULL means", "\t\t\t\t * the string rep is invalid and must be", "\t\t\t\t * regenerated from the internal rep.  Clients", "\t\t\t\t * should use Tcl_GetStringFromObj or", "\t\t\t\t * Tcl_GetString to get a pointer to the byte", "\t\t\t\t * array as a readonly value. */", "    int length;\t\t\t/* The number of bytes at *bytes, not", "\t\t\t\t * including the terminating null. */", "    Tcl_ObjType *typePtr;\t/* Denotes the object's type. Always", "\t\t\t\t * corresponds to the type of the object's", "\t\t\t\t * internal rep. NULL indicates the object has", "\t\t\t\t * no internal rep (has no type). */", "    union {\t\t\t/* The internal representation: */", "\tlong longValue;\t\t/*   - an long integer value. */", "\tdouble doubleValue;\t/*   - a double-precision floating value. */", "\tVOID *otherValuePtr;\t/*   - another, type-specific value. */", "\tTcl_WideInt wideValue;\t/*   - a long long value. */", "\tstruct {\t\t/*   - internal rep as two pointers. */", "\t    VOID *ptr1;", "\t    VOID *ptr2;", "\t} twoPtrValue;", "\tstruct {\t\t/*   - internal rep as a wide int, tightly", "\t\t\t\t *     packed fields. */", "\t    VOID *ptr;\t\t/* Pointer to digits. */", "\t    unsigned long value;/* Alloc, used, and signum packed into a", "\t\t\t\t * single word. */", "\t} ptrAndLongRep;", "    } internalRep;", "} Tcl_Obj;", "", "/*", " * Macros to increment and decrement a Tcl_Obj's reference count, and to test", " * whether an object is shared (i.e. has reference count > 1). Note: clients", " * should use Tcl_DecrRefCount() when they are finished using an object, and", " * should never call TclFreeObj() directly. TclFreeObj() is only defined and", " * made public in tcl.h to support Tcl_DecrRefCount's macro definition. Note", ' * also that Tcl_DecrRefCount() refers to the parameter "obj" twice. This', " * means that you should avoid calling it with an expression that is expensive", " * to compute or has side effects.", " */", "", "void\t\tTcl_IncrRefCount _ANSI_ARGS_((Tcl_Obj *objPtr));", "void\t\tTcl_DecrRefCount _ANSI_ARGS_((Tcl_Obj *objPtr));", "int\t\tTcl_IsShared _ANSI_ARGS_((Tcl_Obj *objPtr));", "", "/*", " * The following structure contains the state needed by Tcl_SaveResult. No-one", " * outside of Tcl should access any of these fields. This structure is", " * typically allocated on the stack.", " */", "", "typedef struct Tcl_SavedResult {", "    char *result;", "    Tcl_FreeProc *freeProc;", "    Tcl_Obj *objResultPtr;", "    char *appendResult;", "    int appendAvl;", "    int appendUsed;", "    char resultSpace[TCL_RESULT_SIZE+1];", "} Tcl_SavedResult;", "", "/*", " * The following definitions support Tcl's namespace facility. Note: the first", " * five fields must match exactly the fields in a Namespace structure (see", " * tclInt.h).", " */", "", "typedef struct Tcl_Namespace {", "    char *name;\t\t\t/* The namespace's name within its parent", "\t\t\t\t * namespace. This contains no ::'s. The name", '\t\t\t\t * of the global namespace is "" although "::"', "\t\t\t\t * is an synonym. */", "    char *fullName;\t\t/* The namespace's fully qualified name. This", "\t\t\t\t * starts with ::. */", "    ClientData clientData;\t/* Arbitrary value associated with this", "\t\t\t\t * namespace. */", "    Tcl_NamespaceDeleteProc *deleteProc;", "\t\t\t\t/* Function invoked when deleting the", "\t\t\t\t * namespace to, e.g., free clientData. */", "    struct Tcl_Namespace *parentPtr;", "\t\t\t\t/* Points to the namespace that contains this", "\t\t\t\t * one. NULL if this is the global", "\t\t\t\t * namespace. */", "} Tcl_Namespace;", "", "/*", " * The following structure represents a call frame, or activation record. A", " * call frame defines a naming context for a procedure call: its local scope", " * (for local variables) and its namespace scope (used for non-local", " * variables; often the global :: namespace). A call frame can also define the", " * naming context for a namespace eval or namespace inscope command: the", " * namespace in which the command's code should execute. The Tcl_CallFrame", " * structures exist only while procedures or namespace eval/inscope's are", " * being executed, and provide a Tcl call stack.", " *", " * A call frame is initialized and pushed using Tcl_PushCallFrame and popped", " * using Tcl_PopCallFrame. Storage for a Tcl_CallFrame must be provided by the", " * Tcl_PushCallFrame caller, and callers typically allocate them on the C call", " * stack for efficiency. For this reason, Tcl_CallFrame is defined as a", " * structure and not as an opaque token. However, most Tcl_CallFrame fields", " * are hidden since applications should not access them directly; others are", ' * declared as "dummyX".', " *", " * WARNING!! The structure definition must be kept consistent with the", " * CallFrame structure in tclInt.h. If you change one, change the other.", " */", "", "typedef struct Tcl_CallFrame {", "    Tcl_Namespace *nsPtr;", "    int dummy1;", "    int dummy2;", "    VOID *dummy3;", "    VOID *dummy4;", "    VOID *dummy5;", "    int dummy6;", "    VOID *dummy7;", "    VOID *dummy8;", "    int dummy9;", "    VOID *dummy10;", "    VOID *dummy11;", "    VOID *dummy12;", "    VOID *dummy13;", "} Tcl_CallFrame;", "", "/*", " * Information about commands that is returned by Tcl_GetCommandInfo and", " * passed to Tcl_SetCommandInfo. objProc is an objc/objv object-based command", " * function while proc is a traditional Tcl argc/argv string-based function.", " * Tcl_CreateObjCommand and Tcl_CreateCommand ensure that both objProc and", " * proc are non-NULL and can be called to execute the command. However, it may", " * be faster to call one instead of the other. The member isNativeObjectProc", " * is set to 1 if an object-based function was registered by", " * Tcl_CreateObjCommand, and to 0 if a string-based function was registered by", " * Tcl_CreateCommand. The other function is typically set to a compatibility", " * wrapper that does string-to-object or object-to-string argument conversions", " * then calls the other function.", " */", "", "typedef struct Tcl_CmdInfo {", "    int isNativeObjectProc;\t/* 1 if objProc was registered by a call to", "\t\t\t\t * Tcl_CreateObjCommand; 0 otherwise.", "\t\t\t\t * Tcl_SetCmdInfo does not modify this", "\t\t\t\t * field. */", "    Tcl_ObjCmdProc *objProc;\t/* Command's object-based function. */", "    ClientData objClientData;\t/* ClientData for object proc. */", "    Tcl_CmdProc *proc;\t\t/* Command's string-based function. */", "    ClientData clientData;\t/* ClientData for string proc. */", "    Tcl_CmdDeleteProc *deleteProc;", "\t\t\t\t/* Function to call when command is", "\t\t\t\t * deleted. */", "    ClientData deleteData;\t/* Value to pass to deleteProc (usually the", "\t\t\t\t * same as clientData). */", "    Tcl_Namespace *namespacePtr;/* Points to the namespace that contains this", "\t\t\t\t * command. Note that Tcl_SetCmdInfo will not", "\t\t\t\t * change a command's namespace; use", "\t\t\t\t * TclRenameCommand or Tcl_Eval (of 'rename')", "\t\t\t\t * to do that. */", "} Tcl_CmdInfo;", "", "/*", " * The structure defined below is used to hold dynamic strings. The only", " * fields that clients should use are string and length, accessible via the", " * macros Tcl_DStringValue and Tcl_DStringLength.", " */", "", "#define TCL_DSTRING_STATIC_SIZE 200", "typedef struct Tcl_DString {", "    char *string;\t\t/* Points to beginning of string: either", "\t\t\t\t * staticSpace below or a malloced array. */", "    int length;\t\t\t/* Number of non-NULL characters in the", "\t\t\t\t * string. */", "    int spaceAvl;\t\t/* Total number of bytes available for the", "\t\t\t\t * string and its terminating NULL char. */", "    char staticSpace[TCL_DSTRING_STATIC_SIZE];", "\t\t\t\t/* Space to use in common case where string is", "\t\t\t\t * small. */", "} Tcl_DString;", "", "#define Tcl_DStringLength(dsPtr) ((dsPtr)->length)", "#define Tcl_DStringValue(dsPtr) ((dsPtr)->string)", "#define Tcl_DStringTrunc Tcl_DStringSetLength", "", "/*", " * Definitions for the maximum number of digits of precision that may be", ' * specified in the "tcl_precision" variable, and the number of bytes of', " * buffer space required by Tcl_PrintDouble.", " */", "", "#define TCL_MAX_PREC\t\t17", "#define TCL_DOUBLE_SPACE\t(TCL_MAX_PREC+10)", "", "/*", " * Definition for a number of bytes of buffer space sufficient to hold the", " * string representation of an integer in base 10 (assuming the existence of", " * 64-bit integers).", " */", "", "#define TCL_INTEGER_SPACE\t24", "", "/*", " * Flag values passed to Tcl_ConvertElement.", " * TCL_DONT_USE_BRACES forces it not to enclose the element in braces, but to", " *\tuse backslash quoting instead.", " * TCL_DONT_QUOTE_HASH disables the default quoting of the '#' character. It", " *\tis safe to leave the hash unquoted when the element is not the first", " *\telement of a list, and this flag can be used by the caller to indicate", " *\tthat condition.", " * (Careful! If you change these flag values be sure to change the definitions", " * at the front of tclUtil.c).", " */", "", "#define TCL_DONT_USE_BRACES\t1", "#define TCL_DONT_QUOTE_HASH\t8", "", "/*", " * Flag that may be passed to Tcl_GetIndexFromObj to force it to disallow", " * abbreviated strings.", " */", "", "#define TCL_EXACT\t1", "", "/*", " * Flag values passed to Tcl_RecordAndEval, Tcl_EvalObj, Tcl_EvalObjv.", " * WARNING: these bit choices must not conflict with the bit choices for", " * evalFlag bits in tclInt.h!", " *", " * Meanings:", " *\tTCL_NO_EVAL:\t\tJust record this command", " *\tTCL_EVAL_GLOBAL:\tExecute script in global namespace", " *\tTCL_EVAL_DIRECT:\tDo not compile this script", " *\tTCL_EVAL_INVOKE:\tMagical Tcl_EvalObjv mode for aliases/ensembles", " *\t\t\t\to Run in iPtr->lookupNsPtr or global namespace", " *\t\t\t\to Cut out of error traces", " *\t\t\t\to Don't reset the flags controlling ensemble", " *\t\t\t\t  error message rewriting.", " */", "#define TCL_NO_EVAL\t\t0x10000", "#define TCL_EVAL_GLOBAL\t\t0x20000", "#define TCL_EVAL_DIRECT\t\t0x40000", "#define TCL_EVAL_INVOKE\t\t0x80000", "", "/*", " * Special freeProc values that may be passed to Tcl_SetResult (see the man", " * page for details):", " */", "", "#define TCL_VOLATILE\t\t((Tcl_FreeProc *) 1)", "#define TCL_STATIC\t\t((Tcl_FreeProc *) 0)", "#define TCL_DYNAMIC\t\t((Tcl_FreeProc *) 3)", "", "/*", " * Flag values passed to variable-related functions.", " */", "", "#define TCL_GLOBAL_ONLY\t\t 1", "#define TCL_NAMESPACE_ONLY\t 2", "#define TCL_APPEND_VALUE\t 4", "#define TCL_LIST_ELEMENT\t 8", "#define TCL_TRACE_READS\t\t 0x10", "#define TCL_TRACE_WRITES\t 0x20", "#define TCL_TRACE_UNSETS\t 0x40", "#define TCL_TRACE_DESTROYED\t 0x80", "#define TCL_INTERP_DESTROYED\t 0x100", "#define TCL_LEAVE_ERR_MSG\t 0x200", "#define TCL_TRACE_ARRAY\t\t 0x800", "#ifndef TCL_REMOVE_OBSOLETE_TRACES", "/* Required to support old variable/vdelete/vinfo traces */", "#define TCL_TRACE_OLD_STYLE\t 0x1000", "#endif", "/* Indicate the semantics of the result of a trace */", "#define TCL_TRACE_RESULT_DYNAMIC 0x8000", "#define TCL_TRACE_RESULT_OBJECT  0x10000", "", "/*", " * Flag values for ensemble commands.", " */", "", "#define TCL_ENSEMBLE_PREFIX 0x02/* Flag value to say whether to allow", "\t\t\t\t * unambiguous prefixes of commands or to", "\t\t\t\t * require exact matches for command names. */", "", "/*", " * Flag values passed to command-related functions.", " */", "", "#define TCL_TRACE_RENAME 0x2000", "#define TCL_TRACE_DELETE 0x4000", "", "#define TCL_ALLOW_INLINE_COMPILATION 0x20000", "", "/*", " * The TCL_PARSE_PART1 flag is deprecated and has no effect. The part1 is now", " * always parsed whenever the part2 is NULL. (This is to avoid a common error", " * when converting code to use the new object based APIs and forgetting to", " * give the flag)", " */", "", "#ifndef TCL_NO_DEPRECATED", "#   define TCL_PARSE_PART1\t0x400", "#endif", "", "/*", " * Types for linked variables:", " */", "", "#define TCL_LINK_INT\t\t1", "#define TCL_LINK_DOUBLE\t\t2", "#define TCL_LINK_BOOLEAN\t3", "#define TCL_LINK_STRING\t\t4", "#define TCL_LINK_WIDE_INT\t5", "#define TCL_LINK_CHAR\t\t6", "#define TCL_LINK_UCHAR\t\t7", "#define TCL_LINK_SHORT\t\t8", "#define TCL_LINK_USHORT\t\t9", "#define TCL_LINK_UINT\t\t10", "#define TCL_LINK_LONG\t\t11", "#define TCL_LINK_ULONG\t\t12", "#define TCL_LINK_FLOAT\t\t13", "#define TCL_LINK_WIDE_UINT\t14", "#define TCL_LINK_READ_ONLY\t0x80", "", "/*", " * Forward declarations of Tcl_HashTable and related types.", " */", "", "typedef struct Tcl_HashKeyType Tcl_HashKeyType;", "typedef struct Tcl_HashTable Tcl_HashTable;", "typedef struct Tcl_HashEntry Tcl_HashEntry;", "", "typedef unsigned int (Tcl_HashKeyProc) _ANSI_ARGS_((Tcl_HashTable *tablePtr,", "\tVOID *keyPtr));", "typedef int (Tcl_CompareHashKeysProc) _ANSI_ARGS_((VOID *keyPtr,", "\tTcl_HashEntry *hPtr));", "typedef Tcl_HashEntry *(Tcl_AllocHashEntryProc) _ANSI_ARGS_((", "\tTcl_HashTable *tablePtr, VOID *keyPtr));", "typedef void (Tcl_FreeHashEntryProc) _ANSI_ARGS_((Tcl_HashEntry *hPtr));", "", "/*", " * This flag controls whether the hash table stores the hash of a key, or", " * recalculates it. There should be no reason for turning this flag off as it", " * is completely binary and source compatible unless you directly access the", " * bucketPtr member of the Tcl_HashTableEntry structure. This member has been", " * removed and the space used to store the hash value.", " */", "", "#ifndef TCL_HASH_KEY_STORE_HASH", "#   define TCL_HASH_KEY_STORE_HASH 1", "#endif", "", "/*", " * Structure definition for an entry in a hash table. No-one outside Tcl", " * should access any of these fields directly; use the macros defined below.", " */", "", "struct Tcl_HashEntry {", "    Tcl_HashEntry *nextPtr;\t/* Pointer to next entry in this hash bucket,", "\t\t\t\t * or NULL for end of chain. */", "    Tcl_HashTable *tablePtr;\t/* Pointer to table containing entry. */", "#if TCL_HASH_KEY_STORE_HASH", "    VOID *hash;\t\t\t/* Hash value, stored as pointer to ensure", "\t\t\t\t * that the offsets of the fields in this", "\t\t\t\t * structure are not changed. */", "#else", "    Tcl_HashEntry **bucketPtr;\t/* Pointer to bucket that points to first", "\t\t\t\t * entry in this entry's chain: used for", "\t\t\t\t * deleting the entry. */", "#endif", "    ClientData clientData;\t/* Application stores something here with", "\t\t\t\t * Tcl_SetHashValue. */", "    union {\t\t\t/* Key has one of these forms: */", "\tchar *oneWordValue;\t/* One-word value for key. */", "\tTcl_Obj *objPtr;\t/* Tcl_Obj * key value. */", "\tint words[1];\t\t/* Multiple integer words for key. The actual", "\t\t\t\t * size will be as large as necessary for this", "\t\t\t\t * table's keys. */", "\tchar string[4];\t\t/* String for key. The actual size will be as", "\t\t\t\t * large as needed to hold the key. */", "    } key;\t\t\t/* MUST BE LAST FIELD IN RECORD!! */", "};", "", "/*", " * Flags used in Tcl_HashKeyType.", " *", " * TCL_HASH_KEY_RANDOMIZE_HASH -", " *\t\t\t\tThere are some things, pointers for example", " *\t\t\t\twhich don't hash well because they do not use", " *\t\t\t\tthe lower bits. If this flag is set then the", " *\t\t\t\thash table will attempt to rectify this by", " *\t\t\t\trandomising the bits and then using the upper", " *\t\t\t\tN bits as the index into the table.", " * TCL_HASH_KEY_SYSTEM_HASH -\tIf this flag is set then all memory internally", " *                              allocated for the hash table that is not for an", " *                              entry will use the system heap.", " */", "", "#define TCL_HASH_KEY_RANDOMIZE_HASH 0x1", "#define TCL_HASH_KEY_SYSTEM_HASH    0x2", "", "/*", " * Structure definition for the methods associated with a hash table key type.", " */", "", "#define TCL_HASH_KEY_TYPE_VERSION 1", "struct Tcl_HashKeyType {", "    int version;\t\t/* Version of the table. If this structure is", "\t\t\t\t * extended in future then the version can be", "\t\t\t\t * used to distinguish between different", "\t\t\t\t * structures. */", "    int flags;\t\t\t/* Flags, see above for details. */", "    Tcl_HashKeyProc *hashKeyProc;", "\t\t\t\t/* Calculates a hash value for the key. If", "\t\t\t\t * this is NULL then the pointer itself is", "\t\t\t\t * used as a hash value. */", "    Tcl_CompareHashKeysProc *compareKeysProc;", "\t\t\t\t/* Compares two keys and returns zero if they", "\t\t\t\t * do not match, and non-zero if they do. If", "\t\t\t\t * this is NULL then the pointers are", "\t\t\t\t * compared. */", "    Tcl_AllocHashEntryProc *allocEntryProc;", "\t\t\t\t/* Called to allocate memory for a new entry,", "\t\t\t\t * i.e. if the key is a string then this could", "\t\t\t\t * allocate a single block which contains", "\t\t\t\t * enough space for both the entry and the", "\t\t\t\t * string. Only the key field of the allocated", "\t\t\t\t * Tcl_HashEntry structure needs to be filled", "\t\t\t\t * in. If something else needs to be done to", "\t\t\t\t * the key, i.e. incrementing a reference", "\t\t\t\t * count then that should be done by this", "\t\t\t\t * function. If this is NULL then Tcl_Alloc is", "\t\t\t\t * used to allocate enough space for a", "\t\t\t\t * Tcl_HashEntry and the key pointer is", "\t\t\t\t * assigned to key.oneWordValue. */", "    Tcl_FreeHashEntryProc *freeEntryProc;", "\t\t\t\t/* Called to free memory associated with an", "\t\t\t\t * entry. If something else needs to be done", "\t\t\t\t * to the key, i.e. decrementing a reference", "\t\t\t\t * count then that should be done by this", "\t\t\t\t * function. If this is NULL then Tcl_Free is", "\t\t\t\t * used to free the Tcl_HashEntry. */", "};", "", "/*", " * Structure definition for a hash table.  Must be in tcl.h so clients can", " * allocate space for these structures, but clients should never access any", " * fields in this structure.", " */", "", "#define TCL_SMALL_HASH_TABLE 4", "struct Tcl_HashTable {", "    Tcl_HashEntry **buckets;\t/* Pointer to bucket array. Each element", "\t\t\t\t * points to first entry in bucket's hash", "\t\t\t\t * chain, or NULL. */", "    Tcl_HashEntry *staticBuckets[TCL_SMALL_HASH_TABLE];", "\t\t\t\t/* Bucket array used for small tables (to", "\t\t\t\t * avoid mallocs and frees). */", "    int numBuckets;\t\t/* Total number of buckets allocated at", "\t\t\t\t * **bucketPtr. */", "    int numEntries;\t\t/* Total number of entries present in", "\t\t\t\t * table. */", "    int rebuildSize;\t\t/* Enlarge table when numEntries gets to be", "\t\t\t\t * this large. */", "    int downShift;\t\t/* Shift count used in hashing function.", "\t\t\t\t * Designed to use high-order bits of", "\t\t\t\t * randomized keys. */", "    int mask;\t\t\t/* Mask value used in hashing function. */", "    int keyType;\t\t/* Type of keys used in this table. It's", "\t\t\t\t * either TCL_CUSTOM_KEYS, TCL_STRING_KEYS,", "\t\t\t\t * TCL_ONE_WORD_KEYS, or an integer giving the", "\t\t\t\t * number of ints that is the size of the", "\t\t\t\t * key. */", "    Tcl_HashEntry *(*findProc) _ANSI_ARGS_((Tcl_HashTable *tablePtr,", "\t    CONST char *key));", "    Tcl_HashEntry *(*createProc) _ANSI_ARGS_((Tcl_HashTable *tablePtr,", "\t    CONST char *key, int *newPtr));", "    Tcl_HashKeyType *typePtr;\t/* Type of the keys used in the", "\t\t\t\t * Tcl_HashTable. */", "};", "", "/*", " * Structure definition for information used to keep track of searches through", " * hash tables:", " */", "", "typedef struct Tcl_HashSearch {", "    Tcl_HashTable *tablePtr;\t/* Table being searched. */", "    int nextIndex;\t\t/* Index of next bucket to be enumerated after", "\t\t\t\t * present one. */", "    Tcl_HashEntry *nextEntryPtr;/* Next entry to be enumerated in the current", "\t\t\t\t * bucket. */", "} Tcl_HashSearch;", "", "/*", " * Acceptable key types for hash tables:", " *", " * TCL_STRING_KEYS:\t\tThe keys are strings, they are copied into the", " *\t\t\t\tentry.", " * TCL_ONE_WORD_KEYS:\t\tThe keys are pointers, the pointer is stored", " *\t\t\t\tin the entry.", " * TCL_CUSTOM_TYPE_KEYS:\tThe keys are arbitrary types which are copied", " *\t\t\t\tinto the entry.", " * TCL_CUSTOM_PTR_KEYS:\t\tThe keys are pointers to arbitrary types, the", " *\t\t\t\tpointer is stored in the entry.", " *", " * While maintaining binary compatability the above have to be distinct values", " * as they are used to differentiate between old versions of the hash table", " * which don't have a typePtr and new ones which do. Once binary compatability", " * is discarded in favour of making more wide spread changes TCL_STRING_KEYS", " * can be the same as TCL_CUSTOM_TYPE_KEYS, and TCL_ONE_WORD_KEYS can be the", " * same as TCL_CUSTOM_PTR_KEYS because they simply determine how the key is", " * accessed from the entry and not the behaviour.", " */", "", "#define TCL_STRING_KEYS\t\t0", "#define TCL_ONE_WORD_KEYS\t1", "#define TCL_CUSTOM_TYPE_KEYS\t-2", "#define TCL_CUSTOM_PTR_KEYS\t-1", "", "/*", " * Structure definition for information used to keep track of searches through", " * dictionaries. These fields should not be accessed by code outside", " * tclDictObj.c", " */", "", "typedef struct {", "    void *next;\t\t\t/* Search position for underlying hash", "\t\t\t\t * table. */", "    int epoch;\t\t\t/* Epoch marker for dictionary being searched,", "\t\t\t\t * or -1 if search has terminated. */", "    Tcl_Dict dictionaryPtr;\t/* Reference to dictionary being searched. */", "} Tcl_DictSearch;", "", "/*", " * Flag values to pass to Tcl_DoOneEvent to disable searches for some kinds of", " * events:", " */", "", "#define TCL_DONT_WAIT\t\t(1<<1)", "#define TCL_WINDOW_EVENTS\t(1<<2)", "#define TCL_FILE_EVENTS\t\t(1<<3)", "#define TCL_TIMER_EVENTS\t(1<<4)", "#define TCL_IDLE_EVENTS\t\t(1<<5)\t/* WAS 0x10 ???? */", "#define TCL_ALL_EVENTS\t\t(~TCL_DONT_WAIT)", "", "/*", " * The following structure defines a generic event for the Tcl event system.", " * These are the things that are queued in calls to Tcl_QueueEvent and", " * serviced later by Tcl_DoOneEvent. There can be many different kinds of", " * events with different fields, corresponding to window events, timer events,", " * etc. The structure for a particular event consists of a Tcl_Event header", " * followed by additional information specific to that event.", " */", "", "struct Tcl_Event {", "    Tcl_EventProc *proc;\t/* Function to call to service this event. */", "    struct Tcl_Event *nextPtr;\t/* Next in list of pending events, or NULL. */", "};", "", "/*", " * Positions to pass to Tcl_QueueEvent:", " */", "", "typedef enum {", "    TCL_QUEUE_TAIL, TCL_QUEUE_HEAD, TCL_QUEUE_MARK", "} Tcl_QueuePosition;", "", "/*", " * Values to pass to Tcl_SetServiceMode to specify the behavior of notifier", " * event routines.", " */", "", "#define TCL_SERVICE_NONE 0", "#define TCL_SERVICE_ALL 1", "", "/*", " * The following structure keeps is used to hold a time value, either as an", " * absolute time (the number of seconds from the epoch) or as an elapsed time.", " * On Unix systems the epoch is Midnight Jan 1, 1970 GMT.", " */", "", "typedef struct Tcl_Time {", "    long sec;\t\t\t/* Seconds. */", "    long usec;\t\t\t/* Microseconds. */", "} Tcl_Time;", "", "typedef void (Tcl_SetTimerProc) _ANSI_ARGS_((Tcl_Time *timePtr));", "typedef int (Tcl_WaitForEventProc) _ANSI_ARGS_((Tcl_Time *timePtr));", "", "/*", " * TIP #233 (Virtualized Time)", " */", "", "typedef void (Tcl_GetTimeProc)   _ANSI_ARGS_((Tcl_Time *timebuf,", "\tClientData clientData));", "typedef void (Tcl_ScaleTimeProc) _ANSI_ARGS_((Tcl_Time *timebuf,", "\tClientData clientData));", "", "/*", " * Bits to pass to Tcl_CreateFileHandler and Tcl_CreateChannelHandler to", " * indicate what sorts of events are of interest:", " */", "", "#define TCL_READABLE\t\t(1<<1)", "#define TCL_WRITABLE\t\t(1<<2)", "#define TCL_EXCEPTION\t\t(1<<3)", "", "/*", " * Flag values to pass to Tcl_OpenCommandChannel to indicate the disposition", " * of the stdio handles. TCL_STDIN, TCL_STDOUT, TCL_STDERR, are also used in", " * Tcl_GetStdChannel.", " */", "", "#define TCL_STDIN\t\t(1<<1)", "#define TCL_STDOUT\t\t(1<<2)", "#define TCL_STDERR\t\t(1<<3)", "#define TCL_ENFORCE_MODE\t(1<<4)", "", "/*", " * Bits passed to Tcl_DriverClose2Proc to indicate which side of a channel", " * should be closed.", " */", "", "#define TCL_CLOSE_READ\t\t(1<<1)", "#define TCL_CLOSE_WRITE\t\t(1<<2)", "", "/*", " * Value to use as the closeProc for a channel that supports the close2Proc", " * interface.", " */", "", "#define TCL_CLOSE2PROC\t\t((Tcl_DriverCloseProc *) 1)", "", "/*", " * Channel version tag. This was introduced in 8.3.2/8.4.", " */", "", "#define TCL_CHANNEL_VERSION_1\t((Tcl_ChannelTypeVersion) 0x1)", "#define TCL_CHANNEL_VERSION_2\t((Tcl_ChannelTypeVersion) 0x2)", "#define TCL_CHANNEL_VERSION_3\t((Tcl_ChannelTypeVersion) 0x3)", "#define TCL_CHANNEL_VERSION_4\t((Tcl_ChannelTypeVersion) 0x4)", "#define TCL_CHANNEL_VERSION_5\t((Tcl_ChannelTypeVersion) 0x5)", "", "/*", " * TIP #218: Channel Actions, Ids for Tcl_DriverThreadActionProc.", " */", "", "#define TCL_CHANNEL_THREAD_INSERT (0)", "#define TCL_CHANNEL_THREAD_REMOVE (1)", "", "/*", " * Typedefs for the various operations in a channel type:", " */", "", "typedef int\t(Tcl_DriverBlockModeProc) _ANSI_ARGS_((", "\t\t    ClientData instanceData, int mode));", "typedef int\t(Tcl_DriverCloseProc) _ANSI_ARGS_((ClientData instanceData,", "\t\t    Tcl_Interp *interp));", "typedef int\t(Tcl_DriverClose2Proc) _ANSI_ARGS_((ClientData instanceData,", "\t\t    Tcl_Interp *interp, int flags));", "typedef int\t(Tcl_DriverInputProc) _ANSI_ARGS_((ClientData instanceData,", "\t\t    char *buf, int toRead, int *errorCodePtr));", "typedef int\t(Tcl_DriverOutputProc) _ANSI_ARGS_((ClientData instanceData,", "\t\t    CONST84 char *buf, int toWrite, int *errorCodePtr));", "typedef int\t(Tcl_DriverSeekProc) _ANSI_ARGS_((ClientData instanceData,", "\t\t    long offset, int mode, int *errorCodePtr));", "typedef int\t(Tcl_DriverSetOptionProc) _ANSI_ARGS_((", "\t\t    ClientData instanceData, Tcl_Interp *interp,", "\t\t    CONST char *optionName, CONST char *value));", "typedef int\t(Tcl_DriverGetOptionProc) _ANSI_ARGS_((", "\t\t    ClientData instanceData, Tcl_Interp *interp,", "\t\t    CONST84 char *optionName, Tcl_DString *dsPtr));", "typedef void\t(Tcl_DriverWatchProc) _ANSI_ARGS_((", "\t\t    ClientData instanceData, int mask));", "typedef int\t(Tcl_DriverGetHandleProc) _ANSI_ARGS_((", "\t\t    ClientData instanceData, int direction,", "\t\t    ClientData *handlePtr));", "typedef int\t(Tcl_DriverFlushProc) _ANSI_ARGS_((ClientData instanceData));", "typedef int\t(Tcl_DriverHandlerProc) _ANSI_ARGS_((", "\t\t    ClientData instanceData, int interestMask));", "typedef Tcl_WideInt (Tcl_DriverWideSeekProc) _ANSI_ARGS_((", "\t\t    ClientData instanceData, Tcl_WideInt offset,", "\t\t    int mode, int *errorCodePtr));", "/*", " * TIP #218, Channel Thread Actions", " */", "typedef void\t(Tcl_DriverThreadActionProc) _ANSI_ARGS_ ((", "\t\t    ClientData instanceData, int action));", "/*", " * TIP #208, File Truncation (etc.)", " */", "typedef int\t(Tcl_DriverTruncateProc) _ANSI_ARGS_((", "\t\t    ClientData instanceData, Tcl_WideInt length));", "", "/*", " * struct Tcl_ChannelType:", " *", " * One such structure exists for each type (kind) of channel. It collects", " * together in one place all the functions that are part of the specific", " * channel type.", " *", " * It is recommend that the Tcl_Channel* functions are used to access elements", " * of this structure, instead of direct accessing.", " */", "", "typedef struct Tcl_ChannelType {", "    char *typeName;\t\t/* The name of the channel type in Tcl", "\t\t\t\t * commands. This storage is owned by channel", "\t\t\t\t * type. */", "    Tcl_ChannelTypeVersion version;", "\t\t\t\t/* Version of the channel type. */", "    Tcl_DriverCloseProc *closeProc;", "\t\t\t\t/* Function to call to close the channel, or", "\t\t\t\t * TCL_CLOSE2PROC if the close2Proc should be", "\t\t\t\t * used instead. */", "    Tcl_DriverInputProc *inputProc;", "\t\t\t\t/* Function to call for input on channel. */", "    Tcl_DriverOutputProc *outputProc;", "\t\t\t\t/* Function to call for output on channel. */", "    Tcl_DriverSeekProc *seekProc;", "\t\t\t\t/* Function to call to seek on the channel.", "\t\t\t\t * May be NULL. */", "    Tcl_DriverSetOptionProc *setOptionProc;", "\t\t\t\t/* Set an option on a channel. */", "    Tcl_DriverGetOptionProc *getOptionProc;", "\t\t\t\t/* Get an option from a channel. */", "    Tcl_DriverWatchProc *watchProc;", "\t\t\t\t/* Set up the notifier to watch for events on", "\t\t\t\t * this channel. */", "    Tcl_DriverGetHandleProc *getHandleProc;", "\t\t\t\t/* Get an OS handle from the channel or NULL", "\t\t\t\t * if not supported. */", "    Tcl_DriverClose2Proc *close2Proc;", "\t\t\t\t/* Function to call to close the channel if", "\t\t\t\t * the device supports closing the read &", "\t\t\t\t * write sides independently. */", "    Tcl_DriverBlockModeProc *blockModeProc;", "\t\t\t\t/* Set blocking mode for the raw channel. May", "\t\t\t\t * be NULL. */", "    /*", "     * Only valid in TCL_CHANNEL_VERSION_2 channels or later.", "     */", "    Tcl_DriverFlushProc *flushProc;", "\t\t\t\t/* Function to call to flush a channel. May be", "\t\t\t\t * NULL. */", "    Tcl_DriverHandlerProc *handlerProc;", "\t\t\t\t/* Function to call to handle a channel event.", "\t\t\t\t * This will be passed up the stacked channel", "\t\t\t\t * chain. */", "    /*", "     * Only valid in TCL_CHANNEL_VERSION_3 channels or later.", "     */", "    Tcl_DriverWideSeekProc *wideSeekProc;", "\t\t\t\t/* Function to call to seek on the channel", "\t\t\t\t * which can handle 64-bit offsets. May be", "\t\t\t\t * NULL, and must be NULL if seekProc is", "\t\t\t\t * NULL. */", "    /*", "     * Only valid in TCL_CHANNEL_VERSION_4 channels or later.", "     * TIP #218, Channel Thread Actions.", "     */", "    Tcl_DriverThreadActionProc *threadActionProc;", "\t\t\t\t/* Function to call to notify the driver of", "\t\t\t\t * thread specific activity for a channel. May", "\t\t\t\t * be NULL. */", "", "    /*", "     * Only valid in TCL_CHANNEL_VERSION_5 channels or later.", "     * TIP #208, File Truncation.", "     */", "    Tcl_DriverTruncateProc *truncateProc;", "\t\t\t\t/* Function to call to truncate the underlying", "\t\t\t\t * file to a particular length. May be NULL if", "\t\t\t\t * the channel does not support truncation. */", "} Tcl_ChannelType;", "", "/*", " * The following flags determine whether the blockModeProc above should set", " * the channel into blocking or nonblocking mode. They are passed as arguments", " * to the blockModeProc function in the above structure.", " */", "", "#define TCL_MODE_BLOCKING\t0\t/* Put channel into blocking mode. */", "#define TCL_MODE_NONBLOCKING\t1\t/* Put channel into nonblocking", "\t\t\t\t\t * mode. */", "", "/*", " * Enum for different types of file paths.", " */", "", "typedef enum Tcl_PathType {", "    TCL_PATH_ABSOLUTE,", "    TCL_PATH_RELATIVE,", "    TCL_PATH_VOLUME_RELATIVE", "} Tcl_PathType;", "", "/*", " * The following structure is used to pass glob type data amongst the various", " * glob routines and Tcl_FSMatchInDirectory.", " */", "", "typedef struct Tcl_GlobTypeData {", "    int type;\t\t\t/* Corresponds to bcdpfls as in 'find -t'. */", "    int perm;\t\t\t/* Corresponds to file permissions. */", "    Tcl_Obj *macType;\t\t/* Acceptable Mac type. */", "    Tcl_Obj *macCreator;\t/* Acceptable Mac creator. */", "} Tcl_GlobTypeData;", "", "/*", " * Type and permission definitions for glob command.", " */", "", "#define TCL_GLOB_TYPE_BLOCK\t\t(1<<0)", "#define TCL_GLOB_TYPE_CHAR\t\t(1<<1)", "#define TCL_GLOB_TYPE_DIR\t\t(1<<2)", "#define TCL_GLOB_TYPE_PIPE\t\t(1<<3)", "#define TCL_GLOB_TYPE_FILE\t\t(1<<4)", "#define TCL_GLOB_TYPE_LINK\t\t(1<<5)", "#define TCL_GLOB_TYPE_SOCK\t\t(1<<6)", "#define TCL_GLOB_TYPE_MOUNT\t\t(1<<7)", "", "#define TCL_GLOB_PERM_RONLY\t\t(1<<0)", "#define TCL_GLOB_PERM_HIDDEN\t\t(1<<1)", "#define TCL_GLOB_PERM_R\t\t\t(1<<2)", "#define TCL_GLOB_PERM_W\t\t\t(1<<3)", "#define TCL_GLOB_PERM_X\t\t\t(1<<4)", "", "/*", " * Flags for the unload callback function.", " */", "", "#define TCL_UNLOAD_DETACH_FROM_INTERPRETER\t(1<<0)", "#define TCL_UNLOAD_DETACH_FROM_PROCESS\t\t(1<<1)", "", "/*", " * Typedefs for the various filesystem operations:", " */", "", "typedef int (Tcl_FSStatProc) _ANSI_ARGS_((Tcl_Obj *pathPtr, Tcl_StatBuf *buf));", "typedef int (Tcl_FSAccessProc) _ANSI_ARGS_((Tcl_Obj *pathPtr, int mode));", "typedef Tcl_Channel (Tcl_FSOpenFileChannelProc) _ANSI_ARGS_((", "\tTcl_Interp *interp, Tcl_Obj *pathPtr, int mode, int permissions));", "typedef int (Tcl_FSMatchInDirectoryProc) _ANSI_ARGS_((Tcl_Interp *interp,", "\tTcl_Obj *result, Tcl_Obj *pathPtr, CONST char *pattern,", "\tTcl_GlobTypeData * types));", "typedef Tcl_Obj * (Tcl_FSGetCwdProc) _ANSI_ARGS_((Tcl_Interp *interp));", "typedef int (Tcl_FSChdirProc) _ANSI_ARGS_((Tcl_Obj *pathPtr));", "typedef int (Tcl_FSLstatProc) _ANSI_ARGS_((Tcl_Obj *pathPtr,", "\tTcl_StatBuf *buf));", "typedef int (Tcl_FSCreateDirectoryProc) _ANSI_ARGS_((Tcl_Obj *pathPtr));", "typedef int (Tcl_FSDeleteFileProc) _ANSI_ARGS_((Tcl_Obj *pathPtr));", "typedef int (Tcl_FSCopyDirectoryProc) _ANSI_ARGS_((Tcl_Obj *srcPathPtr,", "\tTcl_Obj *destPathPtr, Tcl_Obj **errorPtr));", "typedef int (Tcl_FSCopyFileProc) _ANSI_ARGS_((Tcl_Obj *srcPathPtr,", "\tTcl_Obj *destPathPtr));", "typedef int (Tcl_FSRemoveDirectoryProc) _ANSI_ARGS_((Tcl_Obj *pathPtr,", "\tint recursive, Tcl_Obj **errorPtr));", "typedef int (Tcl_FSRenameFileProc) _ANSI_ARGS_((Tcl_Obj *srcPathPtr,", "\tTcl_Obj *destPathPtr));", "typedef void (Tcl_FSUnloadFileProc) _ANSI_ARGS_((Tcl_LoadHandle loadHandle));", "typedef Tcl_Obj * (Tcl_FSListVolumesProc) _ANSI_ARGS_((void));", "/* We have to declare the utime structure here. */", "struct utimbuf;", "typedef int (Tcl_FSUtimeProc) _ANSI_ARGS_((Tcl_Obj *pathPtr,", "\tstruct utimbuf *tval));", "typedef int (Tcl_FSNormalizePathProc) _ANSI_ARGS_((Tcl_Interp *interp,", "\tTcl_Obj *pathPtr, int nextCheckpoint));", "typedef int (Tcl_FSFileAttrsGetProc) _ANSI_ARGS_((Tcl_Interp *interp,", "\tint index, Tcl_Obj *pathPtr, Tcl_Obj **objPtrRef));", "typedef CONST char ** (Tcl_FSFileAttrStringsProc) _ANSI_ARGS_((", "\tTcl_Obj *pathPtr, Tcl_Obj **objPtrRef));", "typedef int (Tcl_FSFileAttrsSetProc) _ANSI_ARGS_((Tcl_Interp *interp,", "\tint index, Tcl_Obj *pathPtr, Tcl_Obj *objPtr));", "typedef Tcl_Obj * (Tcl_FSLinkProc) _ANSI_ARGS_((Tcl_Obj *pathPtr,", "\tTcl_Obj *toPtr, int linkType));", "typedef int (Tcl_FSLoadFileProc) _ANSI_ARGS_((Tcl_Interp * interp,", "\tTcl_Obj *pathPtr, Tcl_LoadHandle *handlePtr,", "\tTcl_FSUnloadFileProc **unloadProcPtr));", "typedef int (Tcl_FSPathInFilesystemProc) _ANSI_ARGS_((Tcl_Obj *pathPtr,", "\tClientData *clientDataPtr));", "typedef Tcl_Obj * (Tcl_FSFilesystemPathTypeProc) _ANSI_ARGS_((", "\tTcl_Obj *pathPtr));", "typedef Tcl_Obj * (Tcl_FSFilesystemSeparatorProc) _ANSI_ARGS_((", "\tTcl_Obj *pathPtr));", "typedef void (Tcl_FSFreeInternalRepProc) _ANSI_ARGS_((ClientData clientData));", "typedef ClientData (Tcl_FSDupInternalRepProc) _ANSI_ARGS_((", "\tClientData clientData));", "typedef Tcl_Obj * (Tcl_FSInternalToNormalizedProc) _ANSI_ARGS_((", "\tClientData clientData));", "typedef ClientData (Tcl_FSCreateInternalRepProc) _ANSI_ARGS_((", "\tTcl_Obj *pathPtr));", "", "typedef struct Tcl_FSVersion_ *Tcl_FSVersion;", "", "/*", " *----------------------------------------------------------------", " * Data structures related to hooking into the filesystem", " *----------------------------------------------------------------", " */", "", "/*", " * Filesystem version tag.  This was introduced in 8.4.", " */", "#define TCL_FILESYSTEM_VERSION_1\t((Tcl_FSVersion) 0x1)", "", "/*", " * struct Tcl_Filesystem:", " *", " * One such structure exists for each type (kind) of filesystem. It collects", " * together in one place all the functions that are part of the specific", " * filesystem. Tcl always accesses the filesystem through one of these", " * structures.", " *", " * Not all entries need be non-NULL; any which are NULL are simply ignored.", " * However, a complete filesystem should provide all of these functions. The", " * explanations in the structure show the importance of each function.", " */", "", "typedef struct Tcl_Filesystem {", "    CONST char *typeName;\t/* The name of the filesystem. */", "    int structureLength;\t/* Length of this structure, so future binary", "\t\t\t\t * compatibility can be assured. */", "    Tcl_FSVersion version;\t/* Version of the filesystem type. */", "    Tcl_FSPathInFilesystemProc *pathInFilesystemProc;", "\t\t\t\t/* Function to check whether a path is in this", "\t\t\t\t * filesystem. This is the most important", "\t\t\t\t * filesystem function. */", "    Tcl_FSDupInternalRepProc *dupInternalRepProc;", "\t\t\t\t/* Function to duplicate internal fs rep. May", "\t\t\t\t * be NULL (but then fs is less efficient). */", "    Tcl_FSFreeInternalRepProc *freeInternalRepProc;", "\t\t\t\t/* Function to free internal fs rep. Must be", "\t\t\t\t * implemented if internal representations", "\t\t\t\t * need freeing, otherwise it can be NULL. */", "    Tcl_FSInternalToNormalizedProc *internalToNormalizedProc;", "\t\t\t\t/* Function to convert internal representation", "\t\t\t\t * to a normalized path. Only required if the", "\t\t\t\t * fs creates pure path objects with no", "\t\t\t\t * string/path representation. */", "    Tcl_FSCreateInternalRepProc *createInternalRepProc;", "\t\t\t\t/* Function to create a filesystem-specific", "\t\t\t\t * internal representation. May be NULL if", "\t\t\t\t * paths have no internal representation, or", "\t\t\t\t * if the Tcl_FSPathInFilesystemProc for this", "\t\t\t\t * filesystem always immediately creates an", "\t\t\t\t * internal representation for paths it", "\t\t\t\t * accepts. */", "    Tcl_FSNormalizePathProc *normalizePathProc;", "\t\t\t\t/* Function to normalize a path.  Should be", "\t\t\t\t * implemented for all filesystems which can", "\t\t\t\t * have multiple string representations for", "\t\t\t\t * the same path object. */", "    Tcl_FSFilesystemPathTypeProc *filesystemPathTypeProc;", "\t\t\t\t/* Function to determine the type of a path in", "\t\t\t\t * this filesystem. May be NULL. */", "    Tcl_FSFilesystemSeparatorProc *filesystemSeparatorProc;", "\t\t\t\t/* Function to return the separator", "\t\t\t\t * character(s) for this filesystem. Must be", "\t\t\t\t * implemented. */", "    Tcl_FSStatProc *statProc;\t/* Function to process a 'Tcl_FSStat()' call.", "\t\t\t\t * Must be implemented for any reasonable", "\t\t\t\t * filesystem. */", "    Tcl_FSAccessProc *accessProc;", "\t\t\t\t/* Function to process a 'Tcl_FSAccess()'", "\t\t\t\t * call. Must be implemented for any", "\t\t\t\t * reasonable filesystem. */", "    Tcl_FSOpenFileChannelProc *openFileChannelProc;", "\t\t\t\t/* Function to process a", "\t\t\t\t * 'Tcl_FSOpenFileChannel()' call. Must be", "\t\t\t\t * implemented for any reasonable", "\t\t\t\t * filesystem. */", "    Tcl_FSMatchInDirectoryProc *matchInDirectoryProc;", "\t\t\t\t/* Function to process a", "\t\t\t\t * 'Tcl_FSMatchInDirectory()'.  If not", "\t\t\t\t * implemented, then glob and recursive copy", "\t\t\t\t * functionality will be lacking in the", "\t\t\t\t * filesystem. */", "    Tcl_FSUtimeProc *utimeProc;\t/* Function to process a 'Tcl_FSUtime()' call.", "\t\t\t\t * Required to allow setting (not reading) of", "\t\t\t\t * times with 'file mtime', 'file atime' and", "\t\t\t\t * the open-r/open-w/fcopy implementation of", "\t\t\t\t * 'file copy'. */", "    Tcl_FSLinkProc *linkProc;\t/* Function to process a 'Tcl_FSLink()' call.", "\t\t\t\t * Should be implemented only if the", "\t\t\t\t * filesystem supports links (reading or", "\t\t\t\t * creating). */", "    Tcl_FSListVolumesProc *listVolumesProc;", "\t\t\t\t/* Function to list any filesystem volumes", "\t\t\t\t * added by this filesystem. Should be", "\t\t\t\t * implemented only if the filesystem adds", "\t\t\t\t * volumes at the head of the filesystem. */", "    Tcl_FSFileAttrStringsProc *fileAttrStringsProc;", "\t\t\t\t/* Function to list all attributes strings", "\t\t\t\t * which are valid for this filesystem. If not", "\t\t\t\t * implemented the filesystem will not support", "\t\t\t\t * the 'file attributes' command. This allows", "\t\t\t\t * arbitrary additional information to be", "\t\t\t\t * attached to files in the filesystem. */", "    Tcl_FSFileAttrsGetProc *fileAttrsGetProc;", "\t\t\t\t/* Function to process a", "\t\t\t\t * 'Tcl_FSFileAttrsGet()' call, used by 'file", "\t\t\t\t * attributes'. */", "    Tcl_FSFileAttrsSetProc *fileAttrsSetProc;", "\t\t\t\t/* Function to process a", "\t\t\t\t * 'Tcl_FSFileAttrsSet()' call, used by 'file", "\t\t\t\t * attributes'.  */", "    Tcl_FSCreateDirectoryProc *createDirectoryProc;", "\t\t\t\t/* Function to process a", "\t\t\t\t * 'Tcl_FSCreateDirectory()' call. Should be", "\t\t\t\t * implemented unless the FS is read-only. */", "    Tcl_FSRemoveDirectoryProc *removeDirectoryProc;", "\t\t\t\t/* Function to process a", "\t\t\t\t * 'Tcl_FSRemoveDirectory()' call. Should be", "\t\t\t\t * implemented unless the FS is read-only. */", "    Tcl_FSDeleteFileProc *deleteFileProc;", "\t\t\t\t/* Function to process a 'Tcl_FSDeleteFile()'", "\t\t\t\t * call. Should be implemented unless the FS", "\t\t\t\t * is read-only. */", "    Tcl_FSCopyFileProc *copyFileProc;", "\t\t\t\t/* Function to process a 'Tcl_FSCopyFile()'", "\t\t\t\t * call. If not implemented Tcl will fall back", "\t\t\t\t * on open-r, open-w and fcopy as a copying", "\t\t\t\t * mechanism, for copying actions initiated in", "\t\t\t\t * Tcl (not C). */", "    Tcl_FSRenameFileProc *renameFileProc;", "\t\t\t\t/* Function to process a 'Tcl_FSRenameFile()'", "\t\t\t\t * call. If not implemented, Tcl will fall", "\t\t\t\t * back on a copy and delete mechanism, for", "\t\t\t\t * rename actions initiated in Tcl (not C). */", "    Tcl_FSCopyDirectoryProc *copyDirectoryProc;", "\t\t\t\t/* Function to process a", "\t\t\t\t * 'Tcl_FSCopyDirectory()' call. If not", "\t\t\t\t * implemented, Tcl will fall back on a", "\t\t\t\t * recursive create-dir, file copy mechanism,", "\t\t\t\t * for copying actions initiated in Tcl (not", "\t\t\t\t * C). */", "    Tcl_FSLstatProc *lstatProc;\t/* Function to process a 'Tcl_FSLstat()' call.", "\t\t\t\t * If not implemented, Tcl will attempt to use", "\t\t\t\t * the 'statProc' defined above instead. */", "    Tcl_FSLoadFileProc *loadFileProc;", "\t\t\t\t/* Function to process a 'Tcl_FSLoadFile()'", "\t\t\t\t * call. If not implemented, Tcl will fall", "\t\t\t\t * back on a copy to native-temp followed by a", "\t\t\t\t * Tcl_FSLoadFile on that temporary copy. */", "    Tcl_FSGetCwdProc *getCwdProc;", "\t\t\t\t/* Function to process a 'Tcl_FSGetCwd()'", "\t\t\t\t * call. Most filesystems need not implement", "\t\t\t\t * this. It will usually only be called once,", "\t\t\t\t * if 'getcwd' is called before 'chdir'. May", "\t\t\t\t * be NULL. */", "    Tcl_FSChdirProc *chdirProc;\t/* Function to process a 'Tcl_FSChdir()' call.", "\t\t\t\t * If filesystems do not implement this, it", "\t\t\t\t * will be emulated by a series of directory", "\t\t\t\t * access checks. Otherwise, virtual", "\t\t\t\t * filesystems which do implement it need only", "\t\t\t\t * respond with a positive return result if", "\t\t\t\t * the dirName is a valid directory in their", "\t\t\t\t * filesystem. They need not remember the", "\t\t\t\t * result, since that will be automatically", "\t\t\t\t * remembered for use by GetCwd. Real", "\t\t\t\t * filesystems should carry out the correct", "\t\t\t\t * action (i.e. call the correct system", "\t\t\t\t * 'chdir' api). If not implemented, then 'cd'", "\t\t\t\t * and 'pwd' will fail inside the", "\t\t\t\t * filesystem. */", "} Tcl_Filesystem;", "", "/*", " * The following definitions are used as values for the 'linkAction' flag to", " * Tcl_FSLink, or the linkProc of any filesystem. Any combination of flags can", " * be given. For link creation, the linkProc should create a link which", " * matches any of the types given.", " *", " * TCL_CREATE_SYMBOLIC_LINK -\tCreate a symbolic or soft link.", " * TCL_CREATE_HARD_LINK -\tCreate a hard link.", " */", "", "#define TCL_CREATE_SYMBOLIC_LINK\t0x01", "#define TCL_CREATE_HARD_LINK\t\t0x02", "", "/*", " * The following structure represents the Notifier functions that you can", " * override with the Tcl_SetNotifier call.", " */", "", "typedef struct Tcl_NotifierProcs {", "    Tcl_SetTimerProc *setTimerProc;", "    Tcl_WaitForEventProc *waitForEventProc;", "    Tcl_CreateFileHandlerProc *createFileHandlerProc;", "    Tcl_DeleteFileHandlerProc *deleteFileHandlerProc;", "    Tcl_InitNotifierProc *initNotifierProc;", "    Tcl_FinalizeNotifierProc *finalizeNotifierProc;", "    Tcl_AlertNotifierProc *alertNotifierProc;", "    Tcl_ServiceModeHookProc *serviceModeHookProc;", "} Tcl_NotifierProcs;", "", "/*", " * The following structure represents a user-defined encoding. It collects", " * together all the functions that are used by the specific encoding.", " */", "", "typedef struct Tcl_EncodingType {", '    CONST char *encodingName;\t/* The name of the encoding, e.g. "euc-jp".', "\t\t\t\t * This name is the unique key for this", "\t\t\t\t * encoding type. */", "    Tcl_EncodingConvertProc *toUtfProc;", "\t\t\t\t/* Function to convert from external encoding", "\t\t\t\t * into UTF-8. */", "    Tcl_EncodingConvertProc *fromUtfProc;", "\t\t\t\t/* Function to convert from UTF-8 into", "\t\t\t\t * external encoding. */", "    Tcl_EncodingFreeProc *freeProc;", "\t\t\t\t/* If non-NULL, function to call when this", "\t\t\t\t * encoding is deleted. */", "    ClientData clientData;\t/* Arbitrary value associated with encoding", "\t\t\t\t * type. Passed to conversion functions. */", "    int nullSize;\t\t/* Number of zero bytes that signify", "\t\t\t\t * end-of-string in this encoding. This number", "\t\t\t\t * is used to determine the source string", "\t\t\t\t * length when the srcLen argument is", "\t\t\t\t * negative. Must be 1 or 2. */", "} Tcl_EncodingType;", "", "/*", " * The following definitions are used as values for the conversion control", " * flags argument when converting text from one character set to another:", " *", " * TCL_ENCODING_START -\t\tSignifies that the source buffer is the first", " *\t\t\t\tblock in a (potentially multi-block) input", " *\t\t\t\tstream. Tells the conversion function to reset", " *\t\t\t\tto an initial state and perform any", " *\t\t\t\tinitialization that needs to occur before the", " *\t\t\t\tfirst byte is converted. If the source buffer", " *\t\t\t\tcontains the entire input stream to be", " *\t\t\t\tconverted, this flag should be set.", " * TCL_ENCODING_END -\t\tSignifies that the source buffer is the last", " *\t\t\t\tblock in a (potentially multi-block) input", " *\t\t\t\tstream. Tells the conversion routine to", " *\t\t\t\tperform any finalization that needs to occur", " *\t\t\t\tafter the last byte is converted and then to", " *\t\t\t\treset to an initial state. If the source", " *\t\t\t\tbuffer contains the entire input stream to be", " *\t\t\t\tconverted, this flag should be set.", " * TCL_ENCODING_STOPONERROR -\tIf set, then the converter will return", " *\t\t\t\timmediately upon encountering an invalid byte", " *\t\t\t\tsequence or a source character that has no", " *\t\t\t\tmapping in the target encoding. If clear, then", " *\t\t\t\tthe converter will skip the problem,", ' *\t\t\t\tsubstituting one or more "close" characters in', " *\t\t\t\tthe destination buffer and then continue to", " *\t\t\t\tconvert the source.", " */", "", "#define TCL_ENCODING_START\t\t0x01", "#define TCL_ENCODING_END\t\t0x02", "#define TCL_ENCODING_STOPONERROR\t0x04", "", "/*", " * The following data structures and declarations are for the new Tcl parser.", " */", "", "/*", " * For each word of a command, and for each piece of a word such as a variable", " * reference, one of the following structures is created to describe the", " * token.", " */", "", "typedef struct Tcl_Token {", "    int type;\t\t\t/* Type of token, such as TCL_TOKEN_WORD; see", "\t\t\t\t * below for valid types. */", "    CONST char *start;\t\t/* First character in token. */", "    int size;\t\t\t/* Number of bytes in token. */", "    int numComponents;\t\t/* If this token is composed of other tokens,", "\t\t\t\t * this field tells how many of them there are", "\t\t\t\t * (including components of components, etc.).", "\t\t\t\t * The component tokens immediately follow", "\t\t\t\t * this one. */", "} Tcl_Token;", "", "/*", " * Type values defined for Tcl_Token structures. These values are defined as", " * mask bits so that it's easy to check for collections of types.", " *", " * TCL_TOKEN_WORD -\t\tThe token describes one word of a command,", " *\t\t\t\tfrom the first non-blank character of the word", ' *\t\t\t\t(which may be " or {) up to but not including', " *\t\t\t\tthe space, semicolon, or bracket that", " *\t\t\t\tterminates the word. NumComponents counts the", " *\t\t\t\ttotal number of sub-tokens that make up the", " *\t\t\t\tword. This includes, for example, sub-tokens", " *\t\t\t\tof TCL_TOKEN_VARIABLE tokens.", " * TCL_TOKEN_SIMPLE_WORD -\tThis token is just like TCL_TOKEN_WORD except", " *\t\t\t\tthat the word is guaranteed to consist of a", " *\t\t\t\tsingle TCL_TOKEN_TEXT sub-token.", " * TCL_TOKEN_TEXT -\t\tThe token describes a range of literal text", " *\t\t\t\tthat is part of a word. NumComponents is", " *\t\t\t\talways 0.", " * TCL_TOKEN_BS -\t\tThe token describes a backslash sequence that", " *\t\t\t\tmust be collapsed. NumComponents is always 0.", " * TCL_TOKEN_COMMAND -\t\tThe token describes a command whose result", " *\t\t\t\tmust be substituted into the word. The token", " *\t\t\t\tincludes the enclosing brackets. NumComponents", " *\t\t\t\tis always 0.", " * TCL_TOKEN_VARIABLE -\t\tThe token describes a variable substitution,", " *\t\t\t\tincluding the dollar sign, variable name, and", " *\t\t\t\tarray index (if there is one) up through the", " *\t\t\t\tright parentheses. NumComponents tells how", " *\t\t\t\tmany additional tokens follow to represent the", " *\t\t\t\tvariable name. The first token will be a", " *\t\t\t\tTCL_TOKEN_TEXT token that describes the", " *\t\t\t\tvariable name. If the variable is an array", " *\t\t\t\treference then there will be one or more", " *\t\t\t\tadditional tokens, of type TCL_TOKEN_TEXT,", " *\t\t\t\tTCL_TOKEN_BS, TCL_TOKEN_COMMAND, and", " *\t\t\t\tTCL_TOKEN_VARIABLE, that describe the array", " *\t\t\t\tindex; numComponents counts the total number", " *\t\t\t\tof nested tokens that make up the variable", " *\t\t\t\treference, including sub-tokens of", " *\t\t\t\tTCL_TOKEN_VARIABLE tokens.", " * TCL_TOKEN_SUB_EXPR -\t\tThe token describes one subexpression of an", " *\t\t\t\texpression, from the first non-blank character", " *\t\t\t\tof the subexpression up to but not including", " *\t\t\t\tthe space, brace, or bracket that terminates", " *\t\t\t\tthe subexpression. NumComponents counts the", " *\t\t\t\ttotal number of following subtokens that make", " *\t\t\t\tup the subexpression; this includes all", " *\t\t\t\tsubtokens for any nested TCL_TOKEN_SUB_EXPR", " *\t\t\t\ttokens. For example, a numeric value used as a", " *\t\t\t\tprimitive operand is described by a", " *\t\t\t\tTCL_TOKEN_SUB_EXPR token followed by a", " *\t\t\t\tTCL_TOKEN_TEXT token. A binary subexpression", " *\t\t\t\tis described by a TCL_TOKEN_SUB_EXPR token", " *\t\t\t\tfollowed by the TCL_TOKEN_OPERATOR token for", " *\t\t\t\tthe operator, then TCL_TOKEN_SUB_EXPR tokens", " *\t\t\t\tfor the left then the right operands.", " * TCL_TOKEN_OPERATOR -\t\tThe token describes one expression operator.", " *\t\t\t\tAn operator might be the name of a math", ' *\t\t\t\tfunction such as "abs". A TCL_TOKEN_OPERATOR', " *\t\t\t\ttoken is always preceeded by one", " *\t\t\t\tTCL_TOKEN_SUB_EXPR token for the operator's", " *\t\t\t\tsubexpression, and is followed by zero or more", " *\t\t\t\tTCL_TOKEN_SUB_EXPR tokens for the operator's", " *\t\t\t\toperands. NumComponents is always 0.", " * TCL_TOKEN_EXPAND_WORD -\tThis token is just like TCL_TOKEN_WORD except", " *\t\t\t\tthat it marks a word that began with the", ' *\t\t\t\tliteral character prefix "{*}". This word is', " *\t\t\t\tmarked to be expanded - that is, broken into", " *\t\t\t\twords after substitution is complete.", " */", "", "#define TCL_TOKEN_WORD\t\t1", "#define TCL_TOKEN_SIMPLE_WORD\t2", "#define TCL_TOKEN_TEXT\t\t4", "#define TCL_TOKEN_BS\t\t8", "#define TCL_TOKEN_COMMAND\t16", "#define TCL_TOKEN_VARIABLE\t32", "#define TCL_TOKEN_SUB_EXPR\t64", "#define TCL_TOKEN_OPERATOR\t128", "#define TCL_TOKEN_EXPAND_WORD\t256", "", "/*", " * Parsing error types. On any parsing error, one of these values will be", " * stored in the error field of the Tcl_Parse structure defined below.", " */", "", "#define TCL_PARSE_SUCCESS\t\t0", "#define TCL_PARSE_QUOTE_EXTRA\t\t1", "#define TCL_PARSE_BRACE_EXTRA\t\t2", "#define TCL_PARSE_MISSING_BRACE\t\t3", "#define TCL_PARSE_MISSING_BRACKET\t4", "#define TCL_PARSE_MISSING_PAREN\t\t5", "#define TCL_PARSE_MISSING_QUOTE\t\t6", "#define TCL_PARSE_MISSING_VAR_BRACE\t7", "#define TCL_PARSE_SYNTAX\t\t8", "#define TCL_PARSE_BAD_NUMBER\t\t9", "", "/*", " * A structure of the following type is filled in by Tcl_ParseCommand. It", " * describes a single command parsed from an input string.", " */", "", "#define NUM_STATIC_TOKENS 20", "", "typedef struct Tcl_Parse {", "    CONST char *commentStart;\t/* Pointer to # that begins the first of one", "\t\t\t\t * or more comments preceding the command. */", "    int commentSize;\t\t/* Number of bytes in comments (up through", "\t\t\t\t * newline character that terminates the last", "\t\t\t\t * comment). If there were no comments, this", "\t\t\t\t * field is 0. */", "    CONST char *commandStart;\t/* First character in first word of", "\t\t\t\t * command. */", "    int commandSize;\t\t/* Number of bytes in command, including first", "\t\t\t\t * character of first word, up through the", "\t\t\t\t * terminating newline, close bracket, or", "\t\t\t\t * semicolon. */", "    int numWords;\t\t/* Total number of words in command. May be", "\t\t\t\t * 0. */", "    Tcl_Token *tokenPtr;\t/* Pointer to first token representing the", "\t\t\t\t * words of the command. Initially points to", "\t\t\t\t * staticTokens, but may change to point to", "\t\t\t\t * malloc-ed space if command exceeds space in", "\t\t\t\t * staticTokens. */", "    int numTokens;\t\t/* Total number of tokens in command. */", "    int tokensAvailable;\t/* Total number of tokens available at", "\t\t\t\t * *tokenPtr. */", "    int errorType;\t\t/* One of the parsing error types defined", "\t\t\t\t * above. */", "", "    /*", "     * The fields below are intended only for the private use of the parser.", "     * They should not be used by functions that invoke Tcl_ParseCommand.", "     */", "", "    CONST char *string;\t\t/* The original command string passed to", "\t\t\t\t * Tcl_ParseCommand. */", "    CONST char *end;\t\t/* Points to the character just after the last", "\t\t\t\t * one in the command string. */", "    Tcl_Interp *interp;\t\t/* Interpreter to use for error reporting, or", "\t\t\t\t * NULL. */", "    CONST char *term;\t\t/* Points to character in string that", "\t\t\t\t * terminated most recent token. Filled in by", "\t\t\t\t * ParseTokens. If an error occurs, points to", "\t\t\t\t * beginning of region where the error", "\t\t\t\t * occurred (e.g. the open brace if the close", "\t\t\t\t * brace is missing). */", "    int incomplete;\t\t/* This field is set to 1 by Tcl_ParseCommand", "\t\t\t\t * if the command appears to be incomplete.", "\t\t\t\t * This information is used by", "\t\t\t\t * Tcl_CommandComplete. */", "    Tcl_Token staticTokens[NUM_STATIC_TOKENS];", "\t\t\t\t/* Initial space for tokens for command. This", "\t\t\t\t * space should be large enough to accommodate", "\t\t\t\t * most commands; dynamic space is allocated", "\t\t\t\t * for very large commands that don't fit", "\t\t\t\t * here. */", "} Tcl_Parse;", "", "/*", " * The following definitions are the error codes returned by the conversion", " * routines:", " *", " * TCL_OK -\t\t\tAll characters were converted.", " * TCL_CONVERT_NOSPACE -\tThe output buffer would not have been large", " *\t\t\t\tenough for all of the converted data; as many", " *\t\t\t\tcharacters as could fit were converted though.", " * TCL_CONVERT_MULTIBYTE -\tThe last few bytes in the source string were", " *\t\t\t\tthe beginning of a multibyte sequence, but", " *\t\t\t\tmore bytes were needed to complete this", " *\t\t\t\tsequence. A subsequent call to the conversion", " *\t\t\t\troutine should pass the beginning of this", " *\t\t\t\tunconverted sequence plus additional bytes", " *\t\t\t\tfrom the source stream to properly convert the", " *\t\t\t\tformerly split-up multibyte sequence.", " * TCL_CONVERT_SYNTAX -\t\tThe source stream contained an invalid", " *\t\t\t\tcharacter sequence. This may occur if the", " *\t\t\t\tinput stream has been damaged or if the input", " *\t\t\t\tencoding method was misidentified. This error", " *\t\t\t\tis reported only if TCL_ENCODING_STOPONERROR", " *\t\t\t\twas specified.", " * TCL_CONVERT_UNKNOWN -\tThe source string contained a character that", " *\t\t\t\tcould not be represented in the target", " *\t\t\t\tencoding. This error is reported only if", " *\t\t\t\tTCL_ENCODING_STOPONERROR was specified.", " */", "", "#define TCL_CONVERT_MULTIBYTE\t-1", "#define TCL_CONVERT_SYNTAX\t-2", "#define TCL_CONVERT_UNKNOWN\t-3", "#define TCL_CONVERT_NOSPACE\t-4", "", "/*", " * The maximum number of bytes that are necessary to represent a single", " * Unicode character in UTF-8. The valid values should be 3 or 6 (or perhaps 1", " * if we want to support a non-unicode enabled core). If 3, then Tcl_UniChar", " * must be 2-bytes in size (UCS-2) (the default). If 6, then Tcl_UniChar must", " * be 4-bytes in size (UCS-4). At this time UCS-2 mode is the default and", " * recommended mode. UCS-4 is experimental and not recommended. It works for", " * the core, but most extensions expect UCS-2.", " */", "", "#ifndef TCL_UTF_MAX", "#define TCL_UTF_MAX\t\t3", "#endif", "", "/*", " * This represents a Unicode character. Any changes to this should also be", " * reflected in regcustom.h.", " */", "", "#if TCL_UTF_MAX > 3", "    /*", "     * unsigned int isn't 100% accurate as it should be a strict 4-byte value", "     * (perhaps wchar_t). 64-bit systems may have troubles. The size of this", "     * value must be reflected correctly in regcustom.h and", "     * in tclEncoding.c.", "     * XXX: Tcl is currently UCS-2 and planning UTF-16 for the Unicode", "     * XXX: string rep that Tcl_UniChar represents.  Changing the size", "     * XXX: of Tcl_UniChar is /not/ supported.", "     */", "typedef unsigned int Tcl_UniChar;", "#else", "typedef unsigned short Tcl_UniChar;", "#endif", "", "/*", " * TIP #59: The following structure is used in calls 'Tcl_RegisterConfig' to", " * provide the system with the embedded configuration data.", " */", "", "typedef struct Tcl_Config {", "    CONST char *key;\t\t/* Configuration key to register. ASCII", "\t\t\t\t * encoded, thus UTF-8. */", "    CONST char *value;\t\t/* The value associated with the key. System", "\t\t\t\t * encoding. */", "} Tcl_Config;", "", "/*", " * Flags for TIP#143 limits, detailing which limits are active in an", " * interpreter. Used for Tcl_{Add,Remove}LimitHandler type argument.", " */", "", "#define TCL_LIMIT_COMMANDS\t0x01", "#define TCL_LIMIT_TIME\t\t0x02", "", "/*", " * Structure containing information about a limit handler to be called when a", " * command- or time-limit is exceeded by an interpreter.", " */", "", "typedef void (Tcl_LimitHandlerProc) _ANSI_ARGS_((ClientData clientData,", "\tTcl_Interp *interp));", "typedef void (Tcl_LimitHandlerDeleteProc) _ANSI_ARGS_((ClientData clientData));", "", "typedef struct mp_int mp_int;", "#define MP_INT_DECLARED", "typedef unsigned int mp_digit;", "#define MP_DIGIT_DECLARED", "", "/*", " * The following constant is used to test for older versions of Tcl in the", " * stubs tables.", " *", " * Jan Nijtman's plus patch uses 0xFCA1BACF, so we need to pick a different", " * value since the stubs tables don't match.", " */", "", "#define TCL_STUB_MAGIC\t\t((int) 0xFCA3BACF)", "", "/*", " * The following function is required to be defined in all stubs aware", " * extensions. The function is actually implemented in the stub library, not", " * the main Tcl library, although there is a trivial implementation in the", " * main library in case an extension is statically linked into an application.", " */", "", "EXTERN CONST char *\tTcl_InitStubs _ANSI_ARGS_((Tcl_Interp *interp,", "\t\t\t    CONST char *version, int exact));", "EXTERN CONST char *\tTclTomMathInitializeStubs _ANSI_ARGS_((", "\t\t\t    Tcl_Interp *interp, CONST char *version,", "\t\t\t    int epoch, int revision));", "", "#ifndef USE_TCL_STUBS", "", "/*", " * When not using stubs, make it a macro.", " */", "", "#define Tcl_InitStubs(interp, version, exact) \\", "    Tcl_PkgInitStubsCheck(interp, version, exact)", "", "#endif", "", "    /*", "     * TODO - tommath stubs export goes here!", "     */", "", "", "/*", " * Public functions that are not accessible via the stubs table.", " * Tcl_GetMemoryInfo is needed for AOLserver. [Bug 1868171]", " */", "", "EXTERN void\t\tTcl_Main _ANSI_ARGS_((int argc, char **argv,", "\t\t\t    Tcl_AppInitProc *appInitProc));", "EXTERN CONST char *\tTcl_PkgInitStubsCheck _ANSI_ARGS_((Tcl_Interp *interp,", "\t\t\t    CONST char *version, int exact));", "#if defined(TCL_THREADS) && defined(USE_THREAD_ALLOC)", "EXTERN void\t\tTcl_GetMemoryInfo _ANSI_ARGS_((Tcl_DString *dsPtr));", "#endif", "", "/*", " * Include the public function declarations that are accessible via the stubs", " * table.", " */", "", '#include "tclDecls.h"', "", "/*", " * Include platform specific public function declarations that are accessible", " * via the stubs table.", " */", "", '#include "tclPlatDecls.h"', "", "/*", " * The following declarations either map ckalloc and ckfree to malloc and", " * free, or they map them to functions with all sorts of debugging hooks", " * defined in tclCkalloc.c.", " */", "", "#ifdef TCL_MEM_DEBUG", "", "#   define ckalloc(x) Tcl_DbCkalloc(x, __FILE__, __LINE__)", "#   define ckfree(x)  Tcl_DbCkfree(x, __FILE__, __LINE__)", "#   define ckrealloc(x,y) Tcl_DbCkrealloc((x), (y),__FILE__, __LINE__)", "#   define attemptckalloc(x) Tcl_AttemptDbCkalloc(x, __FILE__, __LINE__)", "#   define attemptckrealloc(x,y) Tcl_AttemptDbCkrealloc((x), (y), __FILE__, __LINE__)", "", "#else /* !TCL_MEM_DEBUG */", "", "/*", " * If we are not using the debugging allocator, we should call the Tcl_Alloc,", " * et al. routines in order to guarantee that every module is using the same", " * memory allocator both inside and outside of the Tcl library.", " */", "", "#   define ckalloc(x) Tcl_Alloc(x)", "#   define ckfree(x) Tcl_Free(x)", "#   define ckrealloc(x,y) Tcl_Realloc(x,y)", "#   define attemptckalloc(x) Tcl_AttemptAlloc(x)", "#   define attemptckrealloc(x,y) Tcl_AttemptRealloc(x,y)", "#   undef  Tcl_InitMemory", "#   define Tcl_InitMemory(x)", "#   undef  Tcl_DumpActiveMemory", "#   define Tcl_DumpActiveMemory(x)", "#   undef  Tcl_ValidateAllMemory", "#   define Tcl_ValidateAllMemory(x,y)", "", "#endif /* !TCL_MEM_DEBUG */", "", "#ifdef TCL_MEM_DEBUG", "#   define Tcl_IncrRefCount(objPtr) \\", "\tTcl_DbIncrRefCount(objPtr, __FILE__, __LINE__)", "#   define Tcl_DecrRefCount(objPtr) \\", "\tTcl_DbDecrRefCount(objPtr, __FILE__, __LINE__)", "#   define Tcl_IsShared(objPtr) \\", "\tTcl_DbIsShared(objPtr, __FILE__, __LINE__)", "#else", "#   define Tcl_IncrRefCount(objPtr) \\", "\t++(objPtr)->refCount", "    /*", "     * Use do/while0 idiom for optimum correctness without compiler warnings.", "     * http://c2.com/cgi/wiki?TrivialDoWhileLoop", "     */", "#   define Tcl_DecrRefCount(objPtr) \\", "\tdo { if (--(objPtr)->refCount <= 0) TclFreeObj(objPtr); } while(0)", "#   define Tcl_IsShared(objPtr) \\", "\t((objPtr)->refCount > 1)", "#endif", "", "/*", " * Macros and definitions that help to debug the use of Tcl objects. When", " * TCL_MEM_DEBUG is defined, the Tcl_New declarations are overridden to call", " * debugging versions of the object creation functions.", " */", "", "#ifdef TCL_MEM_DEBUG", "#  undef  Tcl_NewBignumObj", "#  define Tcl_NewBignumObj(val) \\", "     Tcl_DbNewBignumObj(val, __FILE__, __LINE__)", "#  undef  Tcl_NewBooleanObj", "#  define Tcl_NewBooleanObj(val) \\", "     Tcl_DbNewBooleanObj(val, __FILE__, __LINE__)", "#  undef  Tcl_NewByteArrayObj", "#  define Tcl_NewByteArrayObj(bytes, len) \\", "     Tcl_DbNewByteArrayObj(bytes, len, __FILE__, __LINE__)", "#  undef  Tcl_NewDoubleObj", "#  define Tcl_NewDoubleObj(val) \\", "     Tcl_DbNewDoubleObj(val, __FILE__, __LINE__)", "#  undef  Tcl_NewIntObj", "#  define Tcl_NewIntObj(val) \\", "     Tcl_DbNewLongObj(val, __FILE__, __LINE__)", "#  undef  Tcl_NewListObj", "#  define Tcl_NewListObj(objc, objv) \\", "     Tcl_DbNewListObj(objc, objv, __FILE__, __LINE__)", "#  undef  Tcl_NewLongObj", "#  define Tcl_NewLongObj(val) \\", "     Tcl_DbNewLongObj(val, __FILE__, __LINE__)", "#  undef  Tcl_NewObj", "#  define Tcl_NewObj() \\", "     Tcl_DbNewObj(__FILE__, __LINE__)", "#  undef  Tcl_NewStringObj", "#  define Tcl_NewStringObj(bytes, len) \\", "     Tcl_DbNewStringObj(bytes, len, __FILE__, __LINE__)", "#  undef  Tcl_NewWideIntObj", "#  define Tcl_NewWideIntObj(val) \\", "     Tcl_DbNewWideIntObj(val, __FILE__, __LINE__)", "#endif /* TCL_MEM_DEBUG */", "", "/*", " * Macros for clients to use to access fields of hash entries:", " */", "", "#define Tcl_GetHashValue(h) ((h)->clientData)", "#define Tcl_SetHashValue(h, value) ((h)->clientData = (ClientData) (value))", "#define Tcl_GetHashKey(tablePtr, h) \\", "\t((char *) (((tablePtr)->keyType == TCL_ONE_WORD_KEYS || \\", "\t\t    (tablePtr)->keyType == TCL_CUSTOM_PTR_KEYS) \\", "\t\t   ? (h)->key.oneWordValue \\", "\t\t   : (h)->key.string))", "", "/*", " * Macros to use for clients to use to invoke find and create functions for", " * hash tables:", " */", "", "#undef  Tcl_FindHashEntry", "#define Tcl_FindHashEntry(tablePtr, key) \\", "\t(*((tablePtr)->findProc))(tablePtr, key)", "#undef  Tcl_CreateHashEntry", "#define Tcl_CreateHashEntry(tablePtr, key, newPtr) \\", "\t(*((tablePtr)->createProc))(tablePtr, key, newPtr)", "", "/*", " * Macros that eliminate the overhead of the thread synchronization functions", " * when compiling without thread support.", " */", "", "#ifndef TCL_THREADS", "#undef  Tcl_MutexLock", "#define Tcl_MutexLock(mutexPtr)", "#undef  Tcl_MutexUnlock", "#define Tcl_MutexUnlock(mutexPtr)", "#undef  Tcl_MutexFinalize", "#define Tcl_MutexFinalize(mutexPtr)", "#undef  Tcl_ConditionNotify", "#define Tcl_ConditionNotify(condPtr)", "#undef  Tcl_ConditionWait", "#define Tcl_ConditionWait(condPtr, mutexPtr, timePtr)", "#undef  Tcl_ConditionFinalize", "#define Tcl_ConditionFinalize(condPtr)", "#endif /* TCL_THREADS */", "", "#ifndef TCL_NO_DEPRECATED", "    /*", "     * Deprecated Tcl functions:", "     */", "", "#   undef  Tcl_EvalObj", "#   define Tcl_EvalObj(interp,objPtr) \\", "\tTcl_EvalObjEx((interp),(objPtr),0)", "#   undef  Tcl_GlobalEvalObj", "#   define Tcl_GlobalEvalObj(interp,objPtr) \\", "\tTcl_EvalObjEx((interp),(objPtr),TCL_EVAL_GLOBAL)", "", "    /*", "     * These function have been renamed. The old names are deprecated, but we", "     * define these macros for backwards compatibilty.", "     */", "", "#   define Tcl_Ckalloc\t\tTcl_Alloc", "#   define Tcl_Ckfree\t\tTcl_Free", "#   define Tcl_Ckrealloc\tTcl_Realloc", "#   define Tcl_Return\t\tTcl_SetResult", "#   define Tcl_TildeSubst\tTcl_TranslateFileName", "#   define panic\t\tTcl_Panic", "#   define panicVA\t\tTcl_PanicVA", "#endif", "", "/*", " * Convenience declaration of Tcl_AppInit for backwards compatibility. This", " * function is not *implemented* by the tcl library, so the storage class is", " * neither DLLEXPORT nor DLLIMPORT.", " */", "", "#undef TCL_STORAGE_CLASS", "#define TCL_STORAGE_CLASS", "", "EXTERN int\t\tTcl_AppInit _ANSI_ARGS_((Tcl_Interp *interp));", "", "#undef TCL_STORAGE_CLASS", "#define TCL_STORAGE_CLASS DLLIMPORT", "", "#endif /* RC_INVOKED */", "", "/*", " * end block for C++", " */", "", "#ifdef __cplusplus", "}", "#endif", "", "#endif /* _TCL */", "\f", "/*", " * Local Variables:", " * mode: c", " * c-basic-offset: 4", " * fill-column: 78", " * End:", " */" },
    ["tclDecls.h"] = { "/*", " * tclDecls.h --", " *", " *\tDeclarations of functions in the platform independent public Tcl API.", " *", " * Copyright (c) 1998-1999 by Scriptics Corporation.", " *", ' * See the file "license.terms" for information on usage and redistribution', " * of this file, and for a DISCLAIMER OF ALL WARRANTIES.", " *", " * RCS: @(#) $Id: tclDecls.h,v 1.130.2.2 2010/02/07 22:16:54 nijtmans Exp $", " */", "", "#ifndef _TCLDECLS", "#define _TCLDECLS", "", "#undef TCL_STORAGE_CLASS", "#ifdef BUILD_tcl", "#   define TCL_STORAGE_CLASS DLLEXPORT", "#else", "#   ifdef USE_TCL_STUBS", "#      define TCL_STORAGE_CLASS", "#   else", "#      define TCL_STORAGE_CLASS DLLIMPORT", "#   endif", "#endif", "", "/*", " * WARNING: This file is automatically generated by the tools/genStubs.tcl", " * script.  Any modifications to the function declarations below should be made", " * in the generic/tcl.decls script.", " */", "", "/* !BEGIN!: Do not edit below this line. */", "", "/*", " * Exported function declarations:", " */", "", "#ifndef Tcl_PkgProvideEx_TCL_DECLARED", "#define Tcl_PkgProvideEx_TCL_DECLARED", "/* 0 */", "EXTERN int\t\tTcl_PkgProvideEx(Tcl_Interp *interp,", "\t\t\t\tCONST char *name, CONST char *version,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tcl_PkgRequireEx_TCL_DECLARED", "#define Tcl_PkgRequireEx_TCL_DECLARED", "/* 1 */", "EXTERN CONST84_RETURN char * Tcl_PkgRequireEx(Tcl_Interp *interp,", "\t\t\t\tCONST char *name, CONST char *version,", "\t\t\t\tint exact, ClientData *clientDataPtr);", "#endif", "#ifndef Tcl_Panic_TCL_DECLARED", "#define Tcl_Panic_TCL_DECLARED", "/* 2 */", "EXTERN void\t\tTcl_Panic(CONST char *format, ...);", "#endif", "#ifndef Tcl_Alloc_TCL_DECLARED", "#define Tcl_Alloc_TCL_DECLARED", "/* 3 */", "EXTERN char *\t\tTcl_Alloc(unsigned int size);", "#endif", "#ifndef Tcl_Free_TCL_DECLARED", "#define Tcl_Free_TCL_DECLARED", "/* 4 */", "EXTERN void\t\tTcl_Free(char *ptr);", "#endif", "#ifndef Tcl_Realloc_TCL_DECLARED", "#define Tcl_Realloc_TCL_DECLARED", "/* 5 */", "EXTERN char *\t\tTcl_Realloc(char *ptr, unsigned int size);", "#endif", "#ifndef Tcl_DbCkalloc_TCL_DECLARED", "#define Tcl_DbCkalloc_TCL_DECLARED", "/* 6 */", "EXTERN char *\t\tTcl_DbCkalloc(unsigned int size, CONST char *file,", "\t\t\t\tint line);", "#endif", "#ifndef Tcl_DbCkfree_TCL_DECLARED", "#define Tcl_DbCkfree_TCL_DECLARED", "/* 7 */", "EXTERN int\t\tTcl_DbCkfree(char *ptr, CONST char *file, int line);", "#endif", "#ifndef Tcl_DbCkrealloc_TCL_DECLARED", "#define Tcl_DbCkrealloc_TCL_DECLARED", "/* 8 */", "EXTERN char *\t\tTcl_DbCkrealloc(char *ptr, unsigned int size,", "\t\t\t\tCONST char *file, int line);", "#endif", "#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */", "#ifndef Tcl_CreateFileHandler_TCL_DECLARED", "#define Tcl_CreateFileHandler_TCL_DECLARED", "/* 9 */", "EXTERN void\t\tTcl_CreateFileHandler(int fd, int mask,", "\t\t\t\tTcl_FileProc *proc, ClientData clientData);", "#endif", "#endif /* UNIX */", "#ifdef MAC_OSX_TCL /* MACOSX */", "#ifndef Tcl_CreateFileHandler_TCL_DECLARED", "#define Tcl_CreateFileHandler_TCL_DECLARED", "/* 9 */", "EXTERN void\t\tTcl_CreateFileHandler(int fd, int mask,", "\t\t\t\tTcl_FileProc *proc, ClientData clientData);", "#endif", "#endif /* MACOSX */", "#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */", "#ifndef Tcl_DeleteFileHandler_TCL_DECLARED", "#define Tcl_DeleteFileHandler_TCL_DECLARED", "/* 10 */", "EXTERN void\t\tTcl_DeleteFileHandler(int fd);", "#endif", "#endif /* UNIX */", "#ifdef MAC_OSX_TCL /* MACOSX */", "#ifndef Tcl_DeleteFileHandler_TCL_DECLARED", "#define Tcl_DeleteFileHandler_TCL_DECLARED", "/* 10 */", "EXTERN void\t\tTcl_DeleteFileHandler(int fd);", "#endif", "#endif /* MACOSX */", "#ifndef Tcl_SetTimer_TCL_DECLARED", "#define Tcl_SetTimer_TCL_DECLARED", "/* 11 */", "EXTERN void\t\tTcl_SetTimer(Tcl_Time *timePtr);", "#endif", "#ifndef Tcl_Sleep_TCL_DECLARED", "#define Tcl_Sleep_TCL_DECLARED", "/* 12 */", "EXTERN void\t\tTcl_Sleep(int ms);", "#endif", "#ifndef Tcl_WaitForEvent_TCL_DECLARED", "#define Tcl_WaitForEvent_TCL_DECLARED", "/* 13 */", "EXTERN int\t\tTcl_WaitForEvent(Tcl_Time *timePtr);", "#endif", "#ifndef Tcl_AppendAllObjTypes_TCL_DECLARED", "#define Tcl_AppendAllObjTypes_TCL_DECLARED", "/* 14 */", "EXTERN int\t\tTcl_AppendAllObjTypes(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *objPtr);", "#endif", "#ifndef Tcl_AppendStringsToObj_TCL_DECLARED", "#define Tcl_AppendStringsToObj_TCL_DECLARED", "/* 15 */", "EXTERN void\t\tTcl_AppendStringsToObj(Tcl_Obj *objPtr, ...);", "#endif", "#ifndef Tcl_AppendToObj_TCL_DECLARED", "#define Tcl_AppendToObj_TCL_DECLARED", "/* 16 */", "EXTERN void\t\tTcl_AppendToObj(Tcl_Obj *objPtr, CONST char *bytes,", "\t\t\t\tint length);", "#endif", "#ifndef Tcl_ConcatObj_TCL_DECLARED", "#define Tcl_ConcatObj_TCL_DECLARED", "/* 17 */", "EXTERN Tcl_Obj *\tTcl_ConcatObj(int objc, Tcl_Obj *CONST objv[]);", "#endif", "#ifndef Tcl_ConvertToType_TCL_DECLARED", "#define Tcl_ConvertToType_TCL_DECLARED", "/* 18 */", "EXTERN int\t\tTcl_ConvertToType(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *objPtr, Tcl_ObjType *typePtr);", "#endif", "#ifndef Tcl_DbDecrRefCount_TCL_DECLARED", "#define Tcl_DbDecrRefCount_TCL_DECLARED", "/* 19 */", "EXTERN void\t\tTcl_DbDecrRefCount(Tcl_Obj *objPtr, CONST char *file,", "\t\t\t\tint line);", "#endif", "#ifndef Tcl_DbIncrRefCount_TCL_DECLARED", "#define Tcl_DbIncrRefCount_TCL_DECLARED", "/* 20 */", "EXTERN void\t\tTcl_DbIncrRefCount(Tcl_Obj *objPtr, CONST char *file,", "\t\t\t\tint line);", "#endif", "#ifndef Tcl_DbIsShared_TCL_DECLARED", "#define Tcl_DbIsShared_TCL_DECLARED", "/* 21 */", "EXTERN int\t\tTcl_DbIsShared(Tcl_Obj *objPtr, CONST char *file,", "\t\t\t\tint line);", "#endif", "#ifndef Tcl_DbNewBooleanObj_TCL_DECLARED", "#define Tcl_DbNewBooleanObj_TCL_DECLARED", "/* 22 */", "EXTERN Tcl_Obj *\tTcl_DbNewBooleanObj(int boolValue, CONST char *file,", "\t\t\t\tint line);", "#endif", "#ifndef Tcl_DbNewByteArrayObj_TCL_DECLARED", "#define Tcl_DbNewByteArrayObj_TCL_DECLARED", "/* 23 */", "EXTERN Tcl_Obj *\tTcl_DbNewByteArrayObj(CONST unsigned char *bytes,", "\t\t\t\tint length, CONST char *file, int line);", "#endif", "#ifndef Tcl_DbNewDoubleObj_TCL_DECLARED", "#define Tcl_DbNewDoubleObj_TCL_DECLARED", "/* 24 */", "EXTERN Tcl_Obj *\tTcl_DbNewDoubleObj(double doubleValue,", "\t\t\t\tCONST char *file, int line);", "#endif", "#ifndef Tcl_DbNewListObj_TCL_DECLARED", "#define Tcl_DbNewListObj_TCL_DECLARED", "/* 25 */", "EXTERN Tcl_Obj *\tTcl_DbNewListObj(int objc, Tcl_Obj *CONST *objv,", "\t\t\t\tCONST char *file, int line);", "#endif", "#ifndef Tcl_DbNewLongObj_TCL_DECLARED", "#define Tcl_DbNewLongObj_TCL_DECLARED", "/* 26 */", "EXTERN Tcl_Obj *\tTcl_DbNewLongObj(long longValue, CONST char *file,", "\t\t\t\tint line);", "#endif", "#ifndef Tcl_DbNewObj_TCL_DECLARED", "#define Tcl_DbNewObj_TCL_DECLARED", "/* 27 */", "EXTERN Tcl_Obj *\tTcl_DbNewObj(CONST char *file, int line);", "#endif", "#ifndef Tcl_DbNewStringObj_TCL_DECLARED", "#define Tcl_DbNewStringObj_TCL_DECLARED", "/* 28 */", "EXTERN Tcl_Obj *\tTcl_DbNewStringObj(CONST char *bytes, int length,", "\t\t\t\tCONST char *file, int line);", "#endif", "#ifndef Tcl_DuplicateObj_TCL_DECLARED", "#define Tcl_DuplicateObj_TCL_DECLARED", "/* 29 */", "EXTERN Tcl_Obj *\tTcl_DuplicateObj(Tcl_Obj *objPtr);", "#endif", "#ifndef TclFreeObj_TCL_DECLARED", "#define TclFreeObj_TCL_DECLARED", "/* 30 */", "EXTERN void\t\tTclFreeObj(Tcl_Obj *objPtr);", "#endif", "#ifndef Tcl_GetBoolean_TCL_DECLARED", "#define Tcl_GetBoolean_TCL_DECLARED", "/* 31 */", "EXTERN int\t\tTcl_GetBoolean(Tcl_Interp *interp, CONST char *src,", "\t\t\t\tint *boolPtr);", "#endif", "#ifndef Tcl_GetBooleanFromObj_TCL_DECLARED", "#define Tcl_GetBooleanFromObj_TCL_DECLARED", "/* 32 */", "EXTERN int\t\tTcl_GetBooleanFromObj(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *objPtr, int *boolPtr);", "#endif", "#ifndef Tcl_GetByteArrayFromObj_TCL_DECLARED", "#define Tcl_GetByteArrayFromObj_TCL_DECLARED", "/* 33 */", "EXTERN unsigned char *\tTcl_GetByteArrayFromObj(Tcl_Obj *objPtr,", "\t\t\t\tint *lengthPtr);", "#endif", "#ifndef Tcl_GetDouble_TCL_DECLARED", "#define Tcl_GetDouble_TCL_DECLARED", "/* 34 */", "EXTERN int\t\tTcl_GetDouble(Tcl_Interp *interp, CONST char *src,", "\t\t\t\tdouble *doublePtr);", "#endif", "#ifndef Tcl_GetDoubleFromObj_TCL_DECLARED", "#define Tcl_GetDoubleFromObj_TCL_DECLARED", "/* 35 */", "EXTERN int\t\tTcl_GetDoubleFromObj(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *objPtr, double *doublePtr);", "#endif", "#ifndef Tcl_GetIndexFromObj_TCL_DECLARED", "#define Tcl_GetIndexFromObj_TCL_DECLARED", "/* 36 */", "EXTERN int\t\tTcl_GetIndexFromObj(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *objPtr, CONST84 char **tablePtr,", "\t\t\t\tCONST char *msg, int flags, int *indexPtr);", "#endif", "#ifndef Tcl_GetInt_TCL_DECLARED", "#define Tcl_GetInt_TCL_DECLARED", "/* 37 */", "EXTERN int\t\tTcl_GetInt(Tcl_Interp *interp, CONST char *src,", "\t\t\t\tint *intPtr);", "#endif", "#ifndef Tcl_GetIntFromObj_TCL_DECLARED", "#define Tcl_GetIntFromObj_TCL_DECLARED", "/* 38 */", "EXTERN int\t\tTcl_GetIntFromObj(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *objPtr, int *intPtr);", "#endif", "#ifndef Tcl_GetLongFromObj_TCL_DECLARED", "#define Tcl_GetLongFromObj_TCL_DECLARED", "/* 39 */", "EXTERN int\t\tTcl_GetLongFromObj(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *objPtr, long *longPtr);", "#endif", "#ifndef Tcl_GetObjType_TCL_DECLARED", "#define Tcl_GetObjType_TCL_DECLARED", "/* 40 */", "EXTERN Tcl_ObjType *\tTcl_GetObjType(CONST char *typeName);", "#endif", "#ifndef Tcl_GetStringFromObj_TCL_DECLARED", "#define Tcl_GetStringFromObj_TCL_DECLARED", "/* 41 */", "EXTERN char *\t\tTcl_GetStringFromObj(Tcl_Obj *objPtr, int *lengthPtr);", "#endif", "#ifndef Tcl_InvalidateStringRep_TCL_DECLARED", "#define Tcl_InvalidateStringRep_TCL_DECLARED", "/* 42 */", "EXTERN void\t\tTcl_InvalidateStringRep(Tcl_Obj *objPtr);", "#endif", "#ifndef Tcl_ListObjAppendList_TCL_DECLARED", "#define Tcl_ListObjAppendList_TCL_DECLARED", "/* 43 */", "EXTERN int\t\tTcl_ListObjAppendList(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *listPtr, Tcl_Obj *elemListPtr);", "#endif", "#ifndef Tcl_ListObjAppendElement_TCL_DECLARED", "#define Tcl_ListObjAppendElement_TCL_DECLARED", "/* 44 */", "EXTERN int\t\tTcl_ListObjAppendElement(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *listPtr, Tcl_Obj *objPtr);", "#endif", "#ifndef Tcl_ListObjGetElements_TCL_DECLARED", "#define Tcl_ListObjGetElements_TCL_DECLARED", "/* 45 */", "EXTERN int\t\tTcl_ListObjGetElements(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *listPtr, int *objcPtr,", "\t\t\t\tTcl_Obj ***objvPtr);", "#endif", "#ifndef Tcl_ListObjIndex_TCL_DECLARED", "#define Tcl_ListObjIndex_TCL_DECLARED", "/* 46 */", "EXTERN int\t\tTcl_ListObjIndex(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *listPtr, int index,", "\t\t\t\tTcl_Obj **objPtrPtr);", "#endif", "#ifndef Tcl_ListObjLength_TCL_DECLARED", "#define Tcl_ListObjLength_TCL_DECLARED", "/* 47 */", "EXTERN int\t\tTcl_ListObjLength(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *listPtr, int *lengthPtr);", "#endif", "#ifndef Tcl_ListObjReplace_TCL_DECLARED", "#define Tcl_ListObjReplace_TCL_DECLARED", "/* 48 */", "EXTERN int\t\tTcl_ListObjReplace(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *listPtr, int first, int count,", "\t\t\t\tint objc, Tcl_Obj *CONST objv[]);", "#endif", "#ifndef Tcl_NewBooleanObj_TCL_DECLARED", "#define Tcl_NewBooleanObj_TCL_DECLARED", "/* 49 */", "EXTERN Tcl_Obj *\tTcl_NewBooleanObj(int boolValue);", "#endif", "#ifndef Tcl_NewByteArrayObj_TCL_DECLARED", "#define Tcl_NewByteArrayObj_TCL_DECLARED", "/* 50 */", "EXTERN Tcl_Obj *\tTcl_NewByteArrayObj(CONST unsigned char *bytes,", "\t\t\t\tint length);", "#endif", "#ifndef Tcl_NewDoubleObj_TCL_DECLARED", "#define Tcl_NewDoubleObj_TCL_DECLARED", "/* 51 */", "EXTERN Tcl_Obj *\tTcl_NewDoubleObj(double doubleValue);", "#endif", "#ifndef Tcl_NewIntObj_TCL_DECLARED", "#define Tcl_NewIntObj_TCL_DECLARED", "/* 52 */", "EXTERN Tcl_Obj *\tTcl_NewIntObj(int intValue);", "#endif", "#ifndef Tcl_NewListObj_TCL_DECLARED", "#define Tcl_NewListObj_TCL_DECLARED", "/* 53 */", "EXTERN Tcl_Obj *\tTcl_NewListObj(int objc, Tcl_Obj *CONST objv[]);", "#endif", "#ifndef Tcl_NewLongObj_TCL_DECLARED", "#define Tcl_NewLongObj_TCL_DECLARED", "/* 54 */", "EXTERN Tcl_Obj *\tTcl_NewLongObj(long longValue);", "#endif", "#ifndef Tcl_NewObj_TCL_DECLARED", "#define Tcl_NewObj_TCL_DECLARED", "/* 55 */", "EXTERN Tcl_Obj *\tTcl_NewObj(void);", "#endif", "#ifndef Tcl_NewStringObj_TCL_DECLARED", "#define Tcl_NewStringObj_TCL_DECLARED", "/* 56 */", "EXTERN Tcl_Obj *\tTcl_NewStringObj(CONST char *bytes, int length);", "#endif", "#ifndef Tcl_SetBooleanObj_TCL_DECLARED", "#define Tcl_SetBooleanObj_TCL_DECLARED", "/* 57 */", "EXTERN void\t\tTcl_SetBooleanObj(Tcl_Obj *objPtr, int boolValue);", "#endif", "#ifndef Tcl_SetByteArrayLength_TCL_DECLARED", "#define Tcl_SetByteArrayLength_TCL_DECLARED", "/* 58 */", "EXTERN unsigned char *\tTcl_SetByteArrayLength(Tcl_Obj *objPtr, int length);", "#endif", "#ifndef Tcl_SetByteArrayObj_TCL_DECLARED", "#define Tcl_SetByteArrayObj_TCL_DECLARED", "/* 59 */", "EXTERN void\t\tTcl_SetByteArrayObj(Tcl_Obj *objPtr,", "\t\t\t\tCONST unsigned char *bytes, int length);", "#endif", "#ifndef Tcl_SetDoubleObj_TCL_DECLARED", "#define Tcl_SetDoubleObj_TCL_DECLARED", "/* 60 */", "EXTERN void\t\tTcl_SetDoubleObj(Tcl_Obj *objPtr, double doubleValue);", "#endif", "#ifndef Tcl_SetIntObj_TCL_DECLARED", "#define Tcl_SetIntObj_TCL_DECLARED", "/* 61 */", "EXTERN void\t\tTcl_SetIntObj(Tcl_Obj *objPtr, int intValue);", "#endif", "#ifndef Tcl_SetListObj_TCL_DECLARED", "#define Tcl_SetListObj_TCL_DECLARED", "/* 62 */", "EXTERN void\t\tTcl_SetListObj(Tcl_Obj *objPtr, int objc,", "\t\t\t\tTcl_Obj *CONST objv[]);", "#endif", "#ifndef Tcl_SetLongObj_TCL_DECLARED", "#define Tcl_SetLongObj_TCL_DECLARED", "/* 63 */", "EXTERN void\t\tTcl_SetLongObj(Tcl_Obj *objPtr, long longValue);", "#endif", "#ifndef Tcl_SetObjLength_TCL_DECLARED", "#define Tcl_SetObjLength_TCL_DECLARED", "/* 64 */", "EXTERN void\t\tTcl_SetObjLength(Tcl_Obj *objPtr, int length);", "#endif", "#ifndef Tcl_SetStringObj_TCL_DECLARED", "#define Tcl_SetStringObj_TCL_DECLARED", "/* 65 */", "EXTERN void\t\tTcl_SetStringObj(Tcl_Obj *objPtr, CONST char *bytes,", "\t\t\t\tint length);", "#endif", "#ifndef Tcl_AddErrorInfo_TCL_DECLARED", "#define Tcl_AddErrorInfo_TCL_DECLARED", "/* 66 */", "EXTERN void\t\tTcl_AddErrorInfo(Tcl_Interp *interp,", "\t\t\t\tCONST char *message);", "#endif", "#ifndef Tcl_AddObjErrorInfo_TCL_DECLARED", "#define Tcl_AddObjErrorInfo_TCL_DECLARED", "/* 67 */", "EXTERN void\t\tTcl_AddObjErrorInfo(Tcl_Interp *interp,", "\t\t\t\tCONST char *message, int length);", "#endif", "#ifndef Tcl_AllowExceptions_TCL_DECLARED", "#define Tcl_AllowExceptions_TCL_DECLARED", "/* 68 */", "EXTERN void\t\tTcl_AllowExceptions(Tcl_Interp *interp);", "#endif", "#ifndef Tcl_AppendElement_TCL_DECLARED", "#define Tcl_AppendElement_TCL_DECLARED", "/* 69 */", "EXTERN void\t\tTcl_AppendElement(Tcl_Interp *interp,", "\t\t\t\tCONST char *element);", "#endif", "#ifndef Tcl_AppendResult_TCL_DECLARED", "#define Tcl_AppendResult_TCL_DECLARED", "/* 70 */", "EXTERN void\t\tTcl_AppendResult(Tcl_Interp *interp, ...);", "#endif", "#ifndef Tcl_AsyncCreate_TCL_DECLARED", "#define Tcl_AsyncCreate_TCL_DECLARED", "/* 71 */", "EXTERN Tcl_AsyncHandler\t Tcl_AsyncCreate(Tcl_AsyncProc *proc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tcl_AsyncDelete_TCL_DECLARED", "#define Tcl_AsyncDelete_TCL_DECLARED", "/* 72 */", "EXTERN void\t\tTcl_AsyncDelete(Tcl_AsyncHandler async);", "#endif", "#ifndef Tcl_AsyncInvoke_TCL_DECLARED", "#define Tcl_AsyncInvoke_TCL_DECLARED", "/* 73 */", "EXTERN int\t\tTcl_AsyncInvoke(Tcl_Interp *interp, int code);", "#endif", "#ifndef Tcl_AsyncMark_TCL_DECLARED", "#define Tcl_AsyncMark_TCL_DECLARED", "/* 74 */", "EXTERN void\t\tTcl_AsyncMark(Tcl_AsyncHandler async);", "#endif", "#ifndef Tcl_AsyncReady_TCL_DECLARED", "#define Tcl_AsyncReady_TCL_DECLARED", "/* 75 */", "EXTERN int\t\tTcl_AsyncReady(void);", "#endif", "#ifndef Tcl_BackgroundError_TCL_DECLARED", "#define Tcl_BackgroundError_TCL_DECLARED", "/* 76 */", "EXTERN void\t\tTcl_BackgroundError(Tcl_Interp *interp);", "#endif", "#ifndef Tcl_Backslash_TCL_DECLARED", "#define Tcl_Backslash_TCL_DECLARED", "/* 77 */", "EXTERN char\t\tTcl_Backslash(CONST char *src, int *readPtr);", "#endif", "#ifndef Tcl_BadChannelOption_TCL_DECLARED", "#define Tcl_BadChannelOption_TCL_DECLARED", "/* 78 */", "EXTERN int\t\tTcl_BadChannelOption(Tcl_Interp *interp,", "\t\t\t\tCONST char *optionName,", "\t\t\t\tCONST char *optionList);", "#endif", "#ifndef Tcl_CallWhenDeleted_TCL_DECLARED", "#define Tcl_CallWhenDeleted_TCL_DECLARED", "/* 79 */", "EXTERN void\t\tTcl_CallWhenDeleted(Tcl_Interp *interp,", "\t\t\t\tTcl_InterpDeleteProc *proc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tcl_CancelIdleCall_TCL_DECLARED", "#define Tcl_CancelIdleCall_TCL_DECLARED", "/* 80 */", "EXTERN void\t\tTcl_CancelIdleCall(Tcl_IdleProc *idleProc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tcl_Close_TCL_DECLARED", "#define Tcl_Close_TCL_DECLARED", "/* 81 */", "EXTERN int\t\tTcl_Close(Tcl_Interp *interp, Tcl_Channel chan);", "#endif", "#ifndef Tcl_CommandComplete_TCL_DECLARED", "#define Tcl_CommandComplete_TCL_DECLARED", "/* 82 */", "EXTERN int\t\tTcl_CommandComplete(CONST char *cmd);", "#endif", "#ifndef Tcl_Concat_TCL_DECLARED", "#define Tcl_Concat_TCL_DECLARED", "/* 83 */", "EXTERN char *\t\tTcl_Concat(int argc, CONST84 char *CONST *argv);", "#endif", "#ifndef Tcl_ConvertElement_TCL_DECLARED", "#define Tcl_ConvertElement_TCL_DECLARED", "/* 84 */", "EXTERN int\t\tTcl_ConvertElement(CONST char *src, char *dst,", "\t\t\t\tint flags);", "#endif", "#ifndef Tcl_ConvertCountedElement_TCL_DECLARED", "#define Tcl_ConvertCountedElement_TCL_DECLARED", "/* 85 */", "EXTERN int\t\tTcl_ConvertCountedElement(CONST char *src,", "\t\t\t\tint length, char *dst, int flags);", "#endif", "#ifndef Tcl_CreateAlias_TCL_DECLARED", "#define Tcl_CreateAlias_TCL_DECLARED", "/* 86 */", "EXTERN int\t\tTcl_CreateAlias(Tcl_Interp *slave,", "\t\t\t\tCONST char *slaveCmd, Tcl_Interp *target,", "\t\t\t\tCONST char *targetCmd, int argc,", "\t\t\t\tCONST84 char *CONST *argv);", "#endif", "#ifndef Tcl_CreateAliasObj_TCL_DECLARED", "#define Tcl_CreateAliasObj_TCL_DECLARED", "/* 87 */", "EXTERN int\t\tTcl_CreateAliasObj(Tcl_Interp *slave,", "\t\t\t\tCONST char *slaveCmd, Tcl_Interp *target,", "\t\t\t\tCONST char *targetCmd, int objc,", "\t\t\t\tTcl_Obj *CONST objv[]);", "#endif", "#ifndef Tcl_CreateChannel_TCL_DECLARED", "#define Tcl_CreateChannel_TCL_DECLARED", "/* 88 */", "EXTERN Tcl_Channel\tTcl_CreateChannel(Tcl_ChannelType *typePtr,", "\t\t\t\tCONST char *chanName,", "\t\t\t\tClientData instanceData, int mask);", "#endif", "#ifndef Tcl_CreateChannelHandler_TCL_DECLARED", "#define Tcl_CreateChannelHandler_TCL_DECLARED", "/* 89 */", "EXTERN void\t\tTcl_CreateChannelHandler(Tcl_Channel chan, int mask,", "\t\t\t\tTcl_ChannelProc *proc, ClientData clientData);", "#endif", "#ifndef Tcl_CreateCloseHandler_TCL_DECLARED", "#define Tcl_CreateCloseHandler_TCL_DECLARED", "/* 90 */", "EXTERN void\t\tTcl_CreateCloseHandler(Tcl_Channel chan,", "\t\t\t\tTcl_CloseProc *proc, ClientData clientData);", "#endif", "#ifndef Tcl_CreateCommand_TCL_DECLARED", "#define Tcl_CreateCommand_TCL_DECLARED", "/* 91 */", "EXTERN Tcl_Command\tTcl_CreateCommand(Tcl_Interp *interp,", "\t\t\t\tCONST char *cmdName, Tcl_CmdProc *proc,", "\t\t\t\tClientData clientData,", "\t\t\t\tTcl_CmdDeleteProc *deleteProc);", "#endif", "#ifndef Tcl_CreateEventSource_TCL_DECLARED", "#define Tcl_CreateEventSource_TCL_DECLARED", "/* 92 */", "EXTERN void\t\tTcl_CreateEventSource(Tcl_EventSetupProc *setupProc,", "\t\t\t\tTcl_EventCheckProc *checkProc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tcl_CreateExitHandler_TCL_DECLARED", "#define Tcl_CreateExitHandler_TCL_DECLARED", "/* 93 */", "EXTERN void\t\tTcl_CreateExitHandler(Tcl_ExitProc *proc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tcl_CreateInterp_TCL_DECLARED", "#define Tcl_CreateInterp_TCL_DECLARED", "/* 94 */", "EXTERN Tcl_Interp *\tTcl_CreateInterp(void);", "#endif", "#ifndef Tcl_CreateMathFunc_TCL_DECLARED", "#define Tcl_CreateMathFunc_TCL_DECLARED", "/* 95 */", "EXTERN void\t\tTcl_CreateMathFunc(Tcl_Interp *interp,", "\t\t\t\tCONST char *name, int numArgs,", "\t\t\t\tTcl_ValueType *argTypes, Tcl_MathProc *proc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tcl_CreateObjCommand_TCL_DECLARED", "#define Tcl_CreateObjCommand_TCL_DECLARED", "/* 96 */", "EXTERN Tcl_Command\tTcl_CreateObjCommand(Tcl_Interp *interp,", "\t\t\t\tCONST char *cmdName, Tcl_ObjCmdProc *proc,", "\t\t\t\tClientData clientData,", "\t\t\t\tTcl_CmdDeleteProc *deleteProc);", "#endif", "#ifndef Tcl_CreateSlave_TCL_DECLARED", "#define Tcl_CreateSlave_TCL_DECLARED", "/* 97 */", "EXTERN Tcl_Interp *\tTcl_CreateSlave(Tcl_Interp *interp,", "\t\t\t\tCONST char *slaveName, int isSafe);", "#endif", "#ifndef Tcl_CreateTimerHandler_TCL_DECLARED", "#define Tcl_CreateTimerHandler_TCL_DECLARED", "/* 98 */", "EXTERN Tcl_TimerToken\tTcl_CreateTimerHandler(int milliseconds,", "\t\t\t\tTcl_TimerProc *proc, ClientData clientData);", "#endif", "#ifndef Tcl_CreateTrace_TCL_DECLARED", "#define Tcl_CreateTrace_TCL_DECLARED", "/* 99 */", "EXTERN Tcl_Trace\tTcl_CreateTrace(Tcl_Interp *interp, int level,", "\t\t\t\tTcl_CmdTraceProc *proc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tcl_DeleteAssocData_TCL_DECLARED", "#define Tcl_DeleteAssocData_TCL_DECLARED", "/* 100 */", "EXTERN void\t\tTcl_DeleteAssocData(Tcl_Interp *interp,", "\t\t\t\tCONST char *name);", "#endif", "#ifndef Tcl_DeleteChannelHandler_TCL_DECLARED", "#define Tcl_DeleteChannelHandler_TCL_DECLARED", "/* 101 */", "EXTERN void\t\tTcl_DeleteChannelHandler(Tcl_Channel chan,", "\t\t\t\tTcl_ChannelProc *proc, ClientData clientData);", "#endif", "#ifndef Tcl_DeleteCloseHandler_TCL_DECLARED", "#define Tcl_DeleteCloseHandler_TCL_DECLARED", "/* 102 */", "EXTERN void\t\tTcl_DeleteCloseHandler(Tcl_Channel chan,", "\t\t\t\tTcl_CloseProc *proc, ClientData clientData);", "#endif", "#ifndef Tcl_DeleteCommand_TCL_DECLARED", "#define Tcl_DeleteCommand_TCL_DECLARED", "/* 103 */", "EXTERN int\t\tTcl_DeleteCommand(Tcl_Interp *interp,", "\t\t\t\tCONST char *cmdName);", "#endif", "#ifndef Tcl_DeleteCommandFromToken_TCL_DECLARED", "#define Tcl_DeleteCommandFromToken_TCL_DECLARED", "/* 104 */", "EXTERN int\t\tTcl_DeleteCommandFromToken(Tcl_Interp *interp,", "\t\t\t\tTcl_Command command);", "#endif", "#ifndef Tcl_DeleteEvents_TCL_DECLARED", "#define Tcl_DeleteEvents_TCL_DECLARED", "/* 105 */", "EXTERN void\t\tTcl_DeleteEvents(Tcl_EventDeleteProc *proc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tcl_DeleteEventSource_TCL_DECLARED", "#define Tcl_DeleteEventSource_TCL_DECLARED", "/* 106 */", "EXTERN void\t\tTcl_DeleteEventSource(Tcl_EventSetupProc *setupProc,", "\t\t\t\tTcl_EventCheckProc *checkProc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tcl_DeleteExitHandler_TCL_DECLARED", "#define Tcl_DeleteExitHandler_TCL_DECLARED", "/* 107 */", "EXTERN void\t\tTcl_DeleteExitHandler(Tcl_ExitProc *proc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tcl_DeleteHashEntry_TCL_DECLARED", "#define Tcl_DeleteHashEntry_TCL_DECLARED", "/* 108 */", "EXTERN void\t\tTcl_DeleteHashEntry(Tcl_HashEntry *entryPtr);", "#endif", "#ifndef Tcl_DeleteHashTable_TCL_DECLARED", "#define Tcl_DeleteHashTable_TCL_DECLARED", "/* 109 */", "EXTERN void\t\tTcl_DeleteHashTable(Tcl_HashTable *tablePtr);", "#endif", "#ifndef Tcl_DeleteInterp_TCL_DECLARED", "#define Tcl_DeleteInterp_TCL_DECLARED", "/* 110 */", "EXTERN void\t\tTcl_DeleteInterp(Tcl_Interp *interp);", "#endif", "#ifndef Tcl_DetachPids_TCL_DECLARED", "#define Tcl_DetachPids_TCL_DECLARED", "/* 111 */", "EXTERN void\t\tTcl_DetachPids(int numPids, Tcl_Pid *pidPtr);", "#endif", "#ifndef Tcl_DeleteTimerHandler_TCL_DECLARED", "#define Tcl_DeleteTimerHandler_TCL_DECLARED", "/* 112 */", "EXTERN void\t\tTcl_DeleteTimerHandler(Tcl_TimerToken token);", "#endif", "#ifndef Tcl_DeleteTrace_TCL_DECLARED", "#define Tcl_DeleteTrace_TCL_DECLARED", "/* 113 */", "EXTERN void\t\tTcl_DeleteTrace(Tcl_Interp *interp, Tcl_Trace trace);", "#endif", "#ifndef Tcl_DontCallWhenDeleted_TCL_DECLARED", "#define Tcl_DontCallWhenDeleted_TCL_DECLARED", "/* 114 */", "EXTERN void\t\tTcl_DontCallWhenDeleted(Tcl_Interp *interp,", "\t\t\t\tTcl_InterpDeleteProc *proc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tcl_DoOneEvent_TCL_DECLARED", "#define Tcl_DoOneEvent_TCL_DECLARED", "/* 115 */", "EXTERN int\t\tTcl_DoOneEvent(int flags);", "#endif", "#ifndef Tcl_DoWhenIdle_TCL_DECLARED", "#define Tcl_DoWhenIdle_TCL_DECLARED", "/* 116 */", "EXTERN void\t\tTcl_DoWhenIdle(Tcl_IdleProc *proc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tcl_DStringAppend_TCL_DECLARED", "#define Tcl_DStringAppend_TCL_DECLARED", "/* 117 */", "EXTERN char *\t\tTcl_DStringAppend(Tcl_DString *dsPtr,", "\t\t\t\tCONST char *bytes, int length);", "#endif", "#ifndef Tcl_DStringAppendElement_TCL_DECLARED", "#define Tcl_DStringAppendElement_TCL_DECLARED", "/* 118 */", "EXTERN char *\t\tTcl_DStringAppendElement(Tcl_DString *dsPtr,", "\t\t\t\tCONST char *element);", "#endif", "#ifndef Tcl_DStringEndSublist_TCL_DECLARED", "#define Tcl_DStringEndSublist_TCL_DECLARED", "/* 119 */", "EXTERN void\t\tTcl_DStringEndSublist(Tcl_DString *dsPtr);", "#endif", "#ifndef Tcl_DStringFree_TCL_DECLARED", "#define Tcl_DStringFree_TCL_DECLARED", "/* 120 */", "EXTERN void\t\tTcl_DStringFree(Tcl_DString *dsPtr);", "#endif", "#ifndef Tcl_DStringGetResult_TCL_DECLARED", "#define Tcl_DStringGetResult_TCL_DECLARED", "/* 121 */", "EXTERN void\t\tTcl_DStringGetResult(Tcl_Interp *interp,", "\t\t\t\tTcl_DString *dsPtr);", "#endif", "#ifndef Tcl_DStringInit_TCL_DECLARED", "#define Tcl_DStringInit_TCL_DECLARED", "/* 122 */", "EXTERN void\t\tTcl_DStringInit(Tcl_DString *dsPtr);", "#endif", "#ifndef Tcl_DStringResult_TCL_DECLARED", "#define Tcl_DStringResult_TCL_DECLARED", "/* 123 */", "EXTERN void\t\tTcl_DStringResult(Tcl_Interp *interp,", "\t\t\t\tTcl_DString *dsPtr);", "#endif", "#ifndef Tcl_DStringSetLength_TCL_DECLARED", "#define Tcl_DStringSetLength_TCL_DECLARED", "/* 124 */", "EXTERN void\t\tTcl_DStringSetLength(Tcl_DString *dsPtr, int length);", "#endif", "#ifndef Tcl_DStringStartSublist_TCL_DECLARED", "#define Tcl_DStringStartSublist_TCL_DECLARED", "/* 125 */", "EXTERN void\t\tTcl_DStringStartSublist(Tcl_DString *dsPtr);", "#endif", "#ifndef Tcl_Eof_TCL_DECLARED", "#define Tcl_Eof_TCL_DECLARED", "/* 126 */", "EXTERN int\t\tTcl_Eof(Tcl_Channel chan);", "#endif", "#ifndef Tcl_ErrnoId_TCL_DECLARED", "#define Tcl_ErrnoId_TCL_DECLARED", "/* 127 */", "EXTERN CONST84_RETURN char * Tcl_ErrnoId(void);", "#endif", "#ifndef Tcl_ErrnoMsg_TCL_DECLARED", "#define Tcl_ErrnoMsg_TCL_DECLARED", "/* 128 */", "EXTERN CONST84_RETURN char * Tcl_ErrnoMsg(int err);", "#endif", "#ifndef Tcl_Eval_TCL_DECLARED", "#define Tcl_Eval_TCL_DECLARED", "/* 129 */", "EXTERN int\t\tTcl_Eval(Tcl_Interp *interp, CONST char *script);", "#endif", "#ifndef Tcl_EvalFile_TCL_DECLARED", "#define Tcl_EvalFile_TCL_DECLARED", "/* 130 */", "EXTERN int\t\tTcl_EvalFile(Tcl_Interp *interp,", "\t\t\t\tCONST char *fileName);", "#endif", "#ifndef Tcl_EvalObj_TCL_DECLARED", "#define Tcl_EvalObj_TCL_DECLARED", "/* 131 */", "EXTERN int\t\tTcl_EvalObj(Tcl_Interp *interp, Tcl_Obj *objPtr);", "#endif", "#ifndef Tcl_EventuallyFree_TCL_DECLARED", "#define Tcl_EventuallyFree_TCL_DECLARED", "/* 132 */", "EXTERN void\t\tTcl_EventuallyFree(ClientData clientData,", "\t\t\t\tTcl_FreeProc *freeProc);", "#endif", "#ifndef Tcl_Exit_TCL_DECLARED", "#define Tcl_Exit_TCL_DECLARED", "/* 133 */", "EXTERN void\t\tTcl_Exit(int status);", "#endif", "#ifndef Tcl_ExposeCommand_TCL_DECLARED", "#define Tcl_ExposeCommand_TCL_DECLARED", "/* 134 */", "EXTERN int\t\tTcl_ExposeCommand(Tcl_Interp *interp,", "\t\t\t\tCONST char *hiddenCmdToken,", "\t\t\t\tCONST char *cmdName);", "#endif", "#ifndef Tcl_ExprBoolean_TCL_DECLARED", "#define Tcl_ExprBoolean_TCL_DECLARED", "/* 135 */", "EXTERN int\t\tTcl_ExprBoolean(Tcl_Interp *interp, CONST char *expr,", "\t\t\t\tint *ptr);", "#endif", "#ifndef Tcl_ExprBooleanObj_TCL_DECLARED", "#define Tcl_ExprBooleanObj_TCL_DECLARED", "/* 136 */", "EXTERN int\t\tTcl_ExprBooleanObj(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *objPtr, int *ptr);", "#endif", "#ifndef Tcl_ExprDouble_TCL_DECLARED", "#define Tcl_ExprDouble_TCL_DECLARED", "/* 137 */", "EXTERN int\t\tTcl_ExprDouble(Tcl_Interp *interp, CONST char *expr,", "\t\t\t\tdouble *ptr);", "#endif", "#ifndef Tcl_ExprDoubleObj_TCL_DECLARED", "#define Tcl_ExprDoubleObj_TCL_DECLARED", "/* 138 */", "EXTERN int\t\tTcl_ExprDoubleObj(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *objPtr, double *ptr);", "#endif", "#ifndef Tcl_ExprLong_TCL_DECLARED", "#define Tcl_ExprLong_TCL_DECLARED", "/* 139 */", "EXTERN int\t\tTcl_ExprLong(Tcl_Interp *interp, CONST char *expr,", "\t\t\t\tlong *ptr);", "#endif", "#ifndef Tcl_ExprLongObj_TCL_DECLARED", "#define Tcl_ExprLongObj_TCL_DECLARED", "/* 140 */", "EXTERN int\t\tTcl_ExprLongObj(Tcl_Interp *interp, Tcl_Obj *objPtr,", "\t\t\t\tlong *ptr);", "#endif", "#ifndef Tcl_ExprObj_TCL_DECLARED", "#define Tcl_ExprObj_TCL_DECLARED", "/* 141 */", "EXTERN int\t\tTcl_ExprObj(Tcl_Interp *interp, Tcl_Obj *objPtr,", "\t\t\t\tTcl_Obj **resultPtrPtr);", "#endif", "#ifndef Tcl_ExprString_TCL_DECLARED", "#define Tcl_ExprString_TCL_DECLARED", "/* 142 */", "EXTERN int\t\tTcl_ExprString(Tcl_Interp *interp, CONST char *expr);", "#endif", "#ifndef Tcl_Finalize_TCL_DECLARED", "#define Tcl_Finalize_TCL_DECLARED", "/* 143 */", "EXTERN void\t\tTcl_Finalize(void);", "#endif", "#ifndef Tcl_FindExecutable_TCL_DECLARED", "#define Tcl_FindExecutable_TCL_DECLARED", "/* 144 */", "EXTERN void\t\tTcl_FindExecutable(CONST char *argv0);", "#endif", "#ifndef Tcl_FirstHashEntry_TCL_DECLARED", "#define Tcl_FirstHashEntry_TCL_DECLARED", "/* 145 */", "EXTERN Tcl_HashEntry *\tTcl_FirstHashEntry(Tcl_HashTable *tablePtr,", "\t\t\t\tTcl_HashSearch *searchPtr);", "#endif", "#ifndef Tcl_Flush_TCL_DECLARED", "#define Tcl_Flush_TCL_DECLARED", "/* 146 */", "EXTERN int\t\tTcl_Flush(Tcl_Channel chan);", "#endif", "#ifndef Tcl_FreeResult_TCL_DECLARED", "#define Tcl_FreeResult_TCL_DECLARED", "/* 147 */", "EXTERN void\t\tTcl_FreeResult(Tcl_Interp *interp);", "#endif", "#ifndef Tcl_GetAlias_TCL_DECLARED", "#define Tcl_GetAlias_TCL_DECLARED", "/* 148 */", "EXTERN int\t\tTcl_GetAlias(Tcl_Interp *interp,", "\t\t\t\tCONST char *slaveCmd,", "\t\t\t\tTcl_Interp **targetInterpPtr,", "\t\t\t\tCONST84 char **targetCmdPtr, int *argcPtr,", "\t\t\t\tCONST84 char ***argvPtr);", "#endif", "#ifndef Tcl_GetAliasObj_TCL_DECLARED", "#define Tcl_GetAliasObj_TCL_DECLARED", "/* 149 */", "EXTERN int\t\tTcl_GetAliasObj(Tcl_Interp *interp,", "\t\t\t\tCONST char *slaveCmd,", "\t\t\t\tTcl_Interp **targetInterpPtr,", "\t\t\t\tCONST84 char **targetCmdPtr, int *objcPtr,", "\t\t\t\tTcl_Obj ***objv);", "#endif", "#ifndef Tcl_GetAssocData_TCL_DECLARED", "#define Tcl_GetAssocData_TCL_DECLARED", "/* 150 */", "EXTERN ClientData\tTcl_GetAssocData(Tcl_Interp *interp,", "\t\t\t\tCONST char *name,", "\t\t\t\tTcl_InterpDeleteProc **procPtr);", "#endif", "#ifndef Tcl_GetChannel_TCL_DECLARED", "#define Tcl_GetChannel_TCL_DECLARED", "/* 151 */", "EXTERN Tcl_Channel\tTcl_GetChannel(Tcl_Interp *interp,", "\t\t\t\tCONST char *chanName, int *modePtr);", "#endif", "#ifndef Tcl_GetChannelBufferSize_TCL_DECLARED", "#define Tcl_GetChannelBufferSize_TCL_DECLARED", "/* 152 */", "EXTERN int\t\tTcl_GetChannelBufferSize(Tcl_Channel chan);", "#endif", "#ifndef Tcl_GetChannelHandle_TCL_DECLARED", "#define Tcl_GetChannelHandle_TCL_DECLARED", "/* 153 */", "EXTERN int\t\tTcl_GetChannelHandle(Tcl_Channel chan, int direction,", "\t\t\t\tClientData *handlePtr);", "#endif", "#ifndef Tcl_GetChannelInstanceData_TCL_DECLARED", "#define Tcl_GetChannelInstanceData_TCL_DECLARED", "/* 154 */", "EXTERN ClientData\tTcl_GetChannelInstanceData(Tcl_Channel chan);", "#endif", "#ifndef Tcl_GetChannelMode_TCL_DECLARED", "#define Tcl_GetChannelMode_TCL_DECLARED", "/* 155 */", "EXTERN int\t\tTcl_GetChannelMode(Tcl_Channel chan);", "#endif", "#ifndef Tcl_GetChannelName_TCL_DECLARED", "#define Tcl_GetChannelName_TCL_DECLARED", "/* 156 */", "EXTERN CONST84_RETURN char * Tcl_GetChannelName(Tcl_Channel chan);", "#endif", "#ifndef Tcl_GetChannelOption_TCL_DECLARED", "#define Tcl_GetChannelOption_TCL_DECLARED", "/* 157 */", "EXTERN int\t\tTcl_GetChannelOption(Tcl_Interp *interp,", "\t\t\t\tTcl_Channel chan, CONST char *optionName,", "\t\t\t\tTcl_DString *dsPtr);", "#endif", "#ifndef Tcl_GetChannelType_TCL_DECLARED", "#define Tcl_GetChannelType_TCL_DECLARED", "/* 158 */", "EXTERN Tcl_ChannelType * Tcl_GetChannelType(Tcl_Channel chan);", "#endif", "#ifndef Tcl_GetCommandInfo_TCL_DECLARED", "#define Tcl_GetCommandInfo_TCL_DECLARED", "/* 159 */", "EXTERN int\t\tTcl_GetCommandInfo(Tcl_Interp *interp,", "\t\t\t\tCONST char *cmdName, Tcl_CmdInfo *infoPtr);", "#endif", "#ifndef Tcl_GetCommandName_TCL_DECLARED", "#define Tcl_GetCommandName_TCL_DECLARED", "/* 160 */", "EXTERN CONST84_RETURN char * Tcl_GetCommandName(Tcl_Interp *interp,", "\t\t\t\tTcl_Command command);", "#endif", "#ifndef Tcl_GetErrno_TCL_DECLARED", "#define Tcl_GetErrno_TCL_DECLARED", "/* 161 */", "EXTERN int\t\tTcl_GetErrno(void);", "#endif", "#ifndef Tcl_GetHostName_TCL_DECLARED", "#define Tcl_GetHostName_TCL_DECLARED", "/* 162 */", "EXTERN CONST84_RETURN char * Tcl_GetHostName(void);", "#endif", "#ifndef Tcl_GetInterpPath_TCL_DECLARED", "#define Tcl_GetInterpPath_TCL_DECLARED", "/* 163 */", "EXTERN int\t\tTcl_GetInterpPath(Tcl_Interp *askInterp,", "\t\t\t\tTcl_Interp *slaveInterp);", "#endif", "#ifndef Tcl_GetMaster_TCL_DECLARED", "#define Tcl_GetMaster_TCL_DECLARED", "/* 164 */", "EXTERN Tcl_Interp *\tTcl_GetMaster(Tcl_Interp *interp);", "#endif", "#ifndef Tcl_GetNameOfExecutable_TCL_DECLARED", "#define Tcl_GetNameOfExecutable_TCL_DECLARED", "/* 165 */", "EXTERN CONST char *\tTcl_GetNameOfExecutable(void);", "#endif", "#ifndef Tcl_GetObjResult_TCL_DECLARED", "#define Tcl_GetObjResult_TCL_DECLARED", "/* 166 */", "EXTERN Tcl_Obj *\tTcl_GetObjResult(Tcl_Interp *interp);", "#endif", "#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */", "#ifndef Tcl_GetOpenFile_TCL_DECLARED", "#define Tcl_GetOpenFile_TCL_DECLARED", "/* 167 */", "EXTERN int\t\tTcl_GetOpenFile(Tcl_Interp *interp,", "\t\t\t\tCONST char *chanID, int forWriting,", "\t\t\t\tint checkUsage, ClientData *filePtr);", "#endif", "#endif /* UNIX */", "#ifdef MAC_OSX_TCL /* MACOSX */", "#ifndef Tcl_GetOpenFile_TCL_DECLARED", "#define Tcl_GetOpenFile_TCL_DECLARED", "/* 167 */", "EXTERN int\t\tTcl_GetOpenFile(Tcl_Interp *interp,", "\t\t\t\tCONST char *chanID, int forWriting,", "\t\t\t\tint checkUsage, ClientData *filePtr);", "#endif", "#endif /* MACOSX */", "#ifndef Tcl_GetPathType_TCL_DECLARED", "#define Tcl_GetPathType_TCL_DECLARED", "/* 168 */", "EXTERN Tcl_PathType\tTcl_GetPathType(CONST char *path);", "#endif", "#ifndef Tcl_Gets_TCL_DECLARED", "#define Tcl_Gets_TCL_DECLARED", "/* 169 */", "EXTERN int\t\tTcl_Gets(Tcl_Channel chan, Tcl_DString *dsPtr);", "#endif", "#ifndef Tcl_GetsObj_TCL_DECLARED", "#define Tcl_GetsObj_TCL_DECLARED", "/* 170 */", "EXTERN int\t\tTcl_GetsObj(Tcl_Channel chan, Tcl_Obj *objPtr);", "#endif", "#ifndef Tcl_GetServiceMode_TCL_DECLARED", "#define Tcl_GetServiceMode_TCL_DECLARED", "/* 171 */", "EXTERN int\t\tTcl_GetServiceMode(void);", "#endif", "#ifndef Tcl_GetSlave_TCL_DECLARED", "#define Tcl_GetSlave_TCL_DECLARED", "/* 172 */", "EXTERN Tcl_Interp *\tTcl_GetSlave(Tcl_Interp *interp,", "\t\t\t\tCONST char *slaveName);", "#endif", "#ifndef Tcl_GetStdChannel_TCL_DECLARED", "#define Tcl_GetStdChannel_TCL_DECLARED", "/* 173 */", "EXTERN Tcl_Channel\tTcl_GetStdChannel(int type);", "#endif", "#ifndef Tcl_GetStringResult_TCL_DECLARED", "#define Tcl_GetStringResult_TCL_DECLARED", "/* 174 */", "EXTERN CONST84_RETURN char * Tcl_GetStringResult(Tcl_Interp *interp);", "#endif", "#ifndef Tcl_GetVar_TCL_DECLARED", "#define Tcl_GetVar_TCL_DECLARED", "/* 175 */", "EXTERN CONST84_RETURN char * Tcl_GetVar(Tcl_Interp *interp,", "\t\t\t\tCONST char *varName, int flags);", "#endif", "#ifndef Tcl_GetVar2_TCL_DECLARED", "#define Tcl_GetVar2_TCL_DECLARED", "/* 176 */", "EXTERN CONST84_RETURN char * Tcl_GetVar2(Tcl_Interp *interp,", "\t\t\t\tCONST char *part1, CONST char *part2,", "\t\t\t\tint flags);", "#endif", "#ifndef Tcl_GlobalEval_TCL_DECLARED", "#define Tcl_GlobalEval_TCL_DECLARED", "/* 177 */", "EXTERN int\t\tTcl_GlobalEval(Tcl_Interp *interp,", "\t\t\t\tCONST char *command);", "#endif", "#ifndef Tcl_GlobalEvalObj_TCL_DECLARED", "#define Tcl_GlobalEvalObj_TCL_DECLARED", "/* 178 */", "EXTERN int\t\tTcl_GlobalEvalObj(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *objPtr);", "#endif", "#ifndef Tcl_HideCommand_TCL_DECLARED", "#define Tcl_HideCommand_TCL_DECLARED", "/* 179 */", "EXTERN int\t\tTcl_HideCommand(Tcl_Interp *interp,", "\t\t\t\tCONST char *cmdName,", "\t\t\t\tCONST char *hiddenCmdToken);", "#endif", "#ifndef Tcl_Init_TCL_DECLARED", "#define Tcl_Init_TCL_DECLARED", "/* 180 */", "EXTERN int\t\tTcl_Init(Tcl_Interp *interp);", "#endif", "#ifndef Tcl_InitHashTable_TCL_DECLARED", "#define Tcl_InitHashTable_TCL_DECLARED", "/* 181 */", "EXTERN void\t\tTcl_InitHashTable(Tcl_HashTable *tablePtr,", "\t\t\t\tint keyType);", "#endif", "#ifndef Tcl_InputBlocked_TCL_DECLARED", "#define Tcl_InputBlocked_TCL_DECLARED", "/* 182 */", "EXTERN int\t\tTcl_InputBlocked(Tcl_Channel chan);", "#endif", "#ifndef Tcl_InputBuffered_TCL_DECLARED", "#define Tcl_InputBuffered_TCL_DECLARED", "/* 183 */", "EXTERN int\t\tTcl_InputBuffered(Tcl_Channel chan);", "#endif", "#ifndef Tcl_InterpDeleted_TCL_DECLARED", "#define Tcl_InterpDeleted_TCL_DECLARED", "/* 184 */", "EXTERN int\t\tTcl_InterpDeleted(Tcl_Interp *interp);", "#endif", "#ifndef Tcl_IsSafe_TCL_DECLARED", "#define Tcl_IsSafe_TCL_DECLARED", "/* 185 */", "EXTERN int\t\tTcl_IsSafe(Tcl_Interp *interp);", "#endif", "#ifndef Tcl_JoinPath_TCL_DECLARED", "#define Tcl_JoinPath_TCL_DECLARED", "/* 186 */", "EXTERN char *\t\tTcl_JoinPath(int argc, CONST84 char *CONST *argv,", "\t\t\t\tTcl_DString *resultPtr);", "#endif", "#ifndef Tcl_LinkVar_TCL_DECLARED", "#define Tcl_LinkVar_TCL_DECLARED", "/* 187 */", "EXTERN int\t\tTcl_LinkVar(Tcl_Interp *interp, CONST char *varName,", "\t\t\t\tchar *addr, int type);", "#endif", "/* Slot 188 is reserved */", "#ifndef Tcl_MakeFileChannel_TCL_DECLARED", "#define Tcl_MakeFileChannel_TCL_DECLARED", "/* 189 */", "EXTERN Tcl_Channel\tTcl_MakeFileChannel(ClientData handle, int mode);", "#endif", "#ifndef Tcl_MakeSafe_TCL_DECLARED", "#define Tcl_MakeSafe_TCL_DECLARED", "/* 190 */", "EXTERN int\t\tTcl_MakeSafe(Tcl_Interp *interp);", "#endif", "#ifndef Tcl_MakeTcpClientChannel_TCL_DECLARED", "#define Tcl_MakeTcpClientChannel_TCL_DECLARED", "/* 191 */", "EXTERN Tcl_Channel\tTcl_MakeTcpClientChannel(ClientData tcpSocket);", "#endif", "#ifndef Tcl_Merge_TCL_DECLARED", "#define Tcl_Merge_TCL_DECLARED", "/* 192 */", "EXTERN char *\t\tTcl_Merge(int argc, CONST84 char *CONST *argv);", "#endif", "#ifndef Tcl_NextHashEntry_TCL_DECLARED", "#define Tcl_NextHashEntry_TCL_DECLARED", "/* 193 */", "EXTERN Tcl_HashEntry *\tTcl_NextHashEntry(Tcl_HashSearch *searchPtr);", "#endif", "#ifndef Tcl_NotifyChannel_TCL_DECLARED", "#define Tcl_NotifyChannel_TCL_DECLARED", "/* 194 */", "EXTERN void\t\tTcl_NotifyChannel(Tcl_Channel channel, int mask);", "#endif", "#ifndef Tcl_ObjGetVar2_TCL_DECLARED", "#define Tcl_ObjGetVar2_TCL_DECLARED", "/* 195 */", "EXTERN Tcl_Obj *\tTcl_ObjGetVar2(Tcl_Interp *interp, Tcl_Obj *part1Ptr,", "\t\t\t\tTcl_Obj *part2Ptr, int flags);", "#endif", "#ifndef Tcl_ObjSetVar2_TCL_DECLARED", "#define Tcl_ObjSetVar2_TCL_DECLARED", "/* 196 */", "EXTERN Tcl_Obj *\tTcl_ObjSetVar2(Tcl_Interp *interp, Tcl_Obj *part1Ptr,", "\t\t\t\tTcl_Obj *part2Ptr, Tcl_Obj *newValuePtr,", "\t\t\t\tint flags);", "#endif", "#ifndef Tcl_OpenCommandChannel_TCL_DECLARED", "#define Tcl_OpenCommandChannel_TCL_DECLARED", "/* 197 */", "EXTERN Tcl_Channel\tTcl_OpenCommandChannel(Tcl_Interp *interp, int argc,", "\t\t\t\tCONST84 char **argv, int flags);", "#endif", "#ifndef Tcl_OpenFileChannel_TCL_DECLARED", "#define Tcl_OpenFileChannel_TCL_DECLARED", "/* 198 */", "EXTERN Tcl_Channel\tTcl_OpenFileChannel(Tcl_Interp *interp,", "\t\t\t\tCONST char *fileName, CONST char *modeString,", "\t\t\t\tint permissions);", "#endif", "#ifndef Tcl_OpenTcpClient_TCL_DECLARED", "#define Tcl_OpenTcpClient_TCL_DECLARED", "/* 199 */", "EXTERN Tcl_Channel\tTcl_OpenTcpClient(Tcl_Interp *interp, int port,", "\t\t\t\tCONST char *address, CONST char *myaddr,", "\t\t\t\tint myport, int async);", "#endif", "#ifndef Tcl_OpenTcpServer_TCL_DECLARED", "#define Tcl_OpenTcpServer_TCL_DECLARED", "/* 200 */", "EXTERN Tcl_Channel\tTcl_OpenTcpServer(Tcl_Interp *interp, int port,", "\t\t\t\tCONST char *host,", "\t\t\t\tTcl_TcpAcceptProc *acceptProc,", "\t\t\t\tClientData callbackData);", "#endif", "#ifndef Tcl_Preserve_TCL_DECLARED", "#define Tcl_Preserve_TCL_DECLARED", "/* 201 */", "EXTERN void\t\tTcl_Preserve(ClientData data);", "#endif", "#ifndef Tcl_PrintDouble_TCL_DECLARED", "#define Tcl_PrintDouble_TCL_DECLARED", "/* 202 */", "EXTERN void\t\tTcl_PrintDouble(Tcl_Interp *interp, double value,", "\t\t\t\tchar *dst);", "#endif", "#ifndef Tcl_PutEnv_TCL_DECLARED", "#define Tcl_PutEnv_TCL_DECLARED", "/* 203 */", "EXTERN int\t\tTcl_PutEnv(CONST char *assignment);", "#endif", "#ifndef Tcl_PosixError_TCL_DECLARED", "#define Tcl_PosixError_TCL_DECLARED", "/* 204 */", "EXTERN CONST84_RETURN char * Tcl_PosixError(Tcl_Interp *interp);", "#endif", "#ifndef Tcl_QueueEvent_TCL_DECLARED", "#define Tcl_QueueEvent_TCL_DECLARED", "/* 205 */", "EXTERN void\t\tTcl_QueueEvent(Tcl_Event *evPtr,", "\t\t\t\tTcl_QueuePosition position);", "#endif", "#ifndef Tcl_Read_TCL_DECLARED", "#define Tcl_Read_TCL_DECLARED", "/* 206 */", "EXTERN int\t\tTcl_Read(Tcl_Channel chan, char *bufPtr, int toRead);", "#endif", "#ifndef Tcl_ReapDetachedProcs_TCL_DECLARED", "#define Tcl_ReapDetachedProcs_TCL_DECLARED", "/* 207 */", "EXTERN void\t\tTcl_ReapDetachedProcs(void);", "#endif", "#ifndef Tcl_RecordAndEval_TCL_DECLARED", "#define Tcl_RecordAndEval_TCL_DECLARED", "/* 208 */", "EXTERN int\t\tTcl_RecordAndEval(Tcl_Interp *interp,", "\t\t\t\tCONST char *cmd, int flags);", "#endif", "#ifndef Tcl_RecordAndEvalObj_TCL_DECLARED", "#define Tcl_RecordAndEvalObj_TCL_DECLARED", "/* 209 */", "EXTERN int\t\tTcl_RecordAndEvalObj(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *cmdPtr, int flags);", "#endif", "#ifndef Tcl_RegisterChannel_TCL_DECLARED", "#define Tcl_RegisterChannel_TCL_DECLARED", "/* 210 */", "EXTERN void\t\tTcl_RegisterChannel(Tcl_Interp *interp,", "\t\t\t\tTcl_Channel chan);", "#endif", "#ifndef Tcl_RegisterObjType_TCL_DECLARED", "#define Tcl_RegisterObjType_TCL_DECLARED", "/* 211 */", "EXTERN void\t\tTcl_RegisterObjType(Tcl_ObjType *typePtr);", "#endif", "#ifndef Tcl_RegExpCompile_TCL_DECLARED", "#define Tcl_RegExpCompile_TCL_DECLARED", "/* 212 */", "EXTERN Tcl_RegExp\tTcl_RegExpCompile(Tcl_Interp *interp,", "\t\t\t\tCONST char *pattern);", "#endif", "#ifndef Tcl_RegExpExec_TCL_DECLARED", "#define Tcl_RegExpExec_TCL_DECLARED", "/* 213 */", "EXTERN int\t\tTcl_RegExpExec(Tcl_Interp *interp, Tcl_RegExp regexp,", "\t\t\t\tCONST char *text, CONST char *start);", "#endif", "#ifndef Tcl_RegExpMatch_TCL_DECLARED", "#define Tcl_RegExpMatch_TCL_DECLARED", "/* 214 */", "EXTERN int\t\tTcl_RegExpMatch(Tcl_Interp *interp, CONST char *text,", "\t\t\t\tCONST char *pattern);", "#endif", "#ifndef Tcl_RegExpRange_TCL_DECLARED", "#define Tcl_RegExpRange_TCL_DECLARED", "/* 215 */", "EXTERN void\t\tTcl_RegExpRange(Tcl_RegExp regexp, int index,", "\t\t\t\tCONST84 char **startPtr,", "\t\t\t\tCONST84 char **endPtr);", "#endif", "#ifndef Tcl_Release_TCL_DECLARED", "#define Tcl_Release_TCL_DECLARED", "/* 216 */", "EXTERN void\t\tTcl_Release(ClientData clientData);", "#endif", "#ifndef Tcl_ResetResult_TCL_DECLARED", "#define Tcl_ResetResult_TCL_DECLARED", "/* 217 */", "EXTERN void\t\tTcl_ResetResult(Tcl_Interp *interp);", "#endif", "#ifndef Tcl_ScanElement_TCL_DECLARED", "#define Tcl_ScanElement_TCL_DECLARED", "/* 218 */", "EXTERN int\t\tTcl_ScanElement(CONST char *str, int *flagPtr);", "#endif", "#ifndef Tcl_ScanCountedElement_TCL_DECLARED", "#define Tcl_ScanCountedElement_TCL_DECLARED", "/* 219 */", "EXTERN int\t\tTcl_ScanCountedElement(CONST char *str, int length,", "\t\t\t\tint *flagPtr);", "#endif", "#ifndef Tcl_SeekOld_TCL_DECLARED", "#define Tcl_SeekOld_TCL_DECLARED", "/* 220 */", "EXTERN int\t\tTcl_SeekOld(Tcl_Channel chan, int offset, int mode);", "#endif", "#ifndef Tcl_ServiceAll_TCL_DECLARED", "#define Tcl_ServiceAll_TCL_DECLARED", "/* 221 */", "EXTERN int\t\tTcl_ServiceAll(void);", "#endif", "#ifndef Tcl_ServiceEvent_TCL_DECLARED", "#define Tcl_ServiceEvent_TCL_DECLARED", "/* 222 */", "EXTERN int\t\tTcl_ServiceEvent(int flags);", "#endif", "#ifndef Tcl_SetAssocData_TCL_DECLARED", "#define Tcl_SetAssocData_TCL_DECLARED", "/* 223 */", "EXTERN void\t\tTcl_SetAssocData(Tcl_Interp *interp,", "\t\t\t\tCONST char *name, Tcl_InterpDeleteProc *proc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tcl_SetChannelBufferSize_TCL_DECLARED", "#define Tcl_SetChannelBufferSize_TCL_DECLARED", "/* 224 */", "EXTERN void\t\tTcl_SetChannelBufferSize(Tcl_Channel chan, int sz);", "#endif", "#ifndef Tcl_SetChannelOption_TCL_DECLARED", "#define Tcl_SetChannelOption_TCL_DECLARED", "/* 225 */", "EXTERN int\t\tTcl_SetChannelOption(Tcl_Interp *interp,", "\t\t\t\tTcl_Channel chan, CONST char *optionName,", "\t\t\t\tCONST char *newValue);", "#endif", "#ifndef Tcl_SetCommandInfo_TCL_DECLARED", "#define Tcl_SetCommandInfo_TCL_DECLARED", "/* 226 */", "EXTERN int\t\tTcl_SetCommandInfo(Tcl_Interp *interp,", "\t\t\t\tCONST char *cmdName,", "\t\t\t\tCONST Tcl_CmdInfo *infoPtr);", "#endif", "#ifndef Tcl_SetErrno_TCL_DECLARED", "#define Tcl_SetErrno_TCL_DECLARED", "/* 227 */", "EXTERN void\t\tTcl_SetErrno(int err);", "#endif", "#ifndef Tcl_SetErrorCode_TCL_DECLARED", "#define Tcl_SetErrorCode_TCL_DECLARED", "/* 228 */", "EXTERN void\t\tTcl_SetErrorCode(Tcl_Interp *interp, ...);", "#endif", "#ifndef Tcl_SetMaxBlockTime_TCL_DECLARED", "#define Tcl_SetMaxBlockTime_TCL_DECLARED", "/* 229 */", "EXTERN void\t\tTcl_SetMaxBlockTime(Tcl_Time *timePtr);", "#endif", "#ifndef Tcl_SetPanicProc_TCL_DECLARED", "#define Tcl_SetPanicProc_TCL_DECLARED", "/* 230 */", "EXTERN void\t\tTcl_SetPanicProc(Tcl_PanicProc *panicProc);", "#endif", "#ifndef Tcl_SetRecursionLimit_TCL_DECLARED", "#define Tcl_SetRecursionLimit_TCL_DECLARED", "/* 231 */", "EXTERN int\t\tTcl_SetRecursionLimit(Tcl_Interp *interp, int depth);", "#endif", "#ifndef Tcl_SetResult_TCL_DECLARED", "#define Tcl_SetResult_TCL_DECLARED", "/* 232 */", "EXTERN void\t\tTcl_SetResult(Tcl_Interp *interp, char *result,", "\t\t\t\tTcl_FreeProc *freeProc);", "#endif", "#ifndef Tcl_SetServiceMode_TCL_DECLARED", "#define Tcl_SetServiceMode_TCL_DECLARED", "/* 233 */", "EXTERN int\t\tTcl_SetServiceMode(int mode);", "#endif", "#ifndef Tcl_SetObjErrorCode_TCL_DECLARED", "#define Tcl_SetObjErrorCode_TCL_DECLARED", "/* 234 */", "EXTERN void\t\tTcl_SetObjErrorCode(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *errorObjPtr);", "#endif", "#ifndef Tcl_SetObjResult_TCL_DECLARED", "#define Tcl_SetObjResult_TCL_DECLARED", "/* 235 */", "EXTERN void\t\tTcl_SetObjResult(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *resultObjPtr);", "#endif", "#ifndef Tcl_SetStdChannel_TCL_DECLARED", "#define Tcl_SetStdChannel_TCL_DECLARED", "/* 236 */", "EXTERN void\t\tTcl_SetStdChannel(Tcl_Channel channel, int type);", "#endif", "#ifndef Tcl_SetVar_TCL_DECLARED", "#define Tcl_SetVar_TCL_DECLARED", "/* 237 */", "EXTERN CONST84_RETURN char * Tcl_SetVar(Tcl_Interp *interp,", "\t\t\t\tCONST char *varName, CONST char *newValue,", "\t\t\t\tint flags);", "#endif", "#ifndef Tcl_SetVar2_TCL_DECLARED", "#define Tcl_SetVar2_TCL_DECLARED", "/* 238 */", "EXTERN CONST84_RETURN char * Tcl_SetVar2(Tcl_Interp *interp,", "\t\t\t\tCONST char *part1, CONST char *part2,", "\t\t\t\tCONST char *newValue, int flags);", "#endif", "#ifndef Tcl_SignalId_TCL_DECLARED", "#define Tcl_SignalId_TCL_DECLARED", "/* 239 */", "EXTERN CONST84_RETURN char * Tcl_SignalId(int sig);", "#endif", "#ifndef Tcl_SignalMsg_TCL_DECLARED", "#define Tcl_SignalMsg_TCL_DECLARED", "/* 240 */", "EXTERN CONST84_RETURN char * Tcl_SignalMsg(int sig);", "#endif", "#ifndef Tcl_SourceRCFile_TCL_DECLARED", "#define Tcl_SourceRCFile_TCL_DECLARED", "/* 241 */", "EXTERN void\t\tTcl_SourceRCFile(Tcl_Interp *interp);", "#endif", "#ifndef Tcl_SplitList_TCL_DECLARED", "#define Tcl_SplitList_TCL_DECLARED", "/* 242 */", "EXTERN int\t\tTcl_SplitList(Tcl_Interp *interp,", "\t\t\t\tCONST char *listStr, int *argcPtr,", "\t\t\t\tCONST84 char ***argvPtr);", "#endif", "#ifndef Tcl_SplitPath_TCL_DECLARED", "#define Tcl_SplitPath_TCL_DECLARED", "/* 243 */", "EXTERN void\t\tTcl_SplitPath(CONST char *path, int *argcPtr,", "\t\t\t\tCONST84 char ***argvPtr);", "#endif", "#ifndef Tcl_StaticPackage_TCL_DECLARED", "#define Tcl_StaticPackage_TCL_DECLARED", "/* 244 */", "EXTERN void\t\tTcl_StaticPackage(Tcl_Interp *interp,", "\t\t\t\tCONST char *pkgName,", "\t\t\t\tTcl_PackageInitProc *initProc,", "\t\t\t\tTcl_PackageInitProc *safeInitProc);", "#endif", "#ifndef Tcl_StringMatch_TCL_DECLARED", "#define Tcl_StringMatch_TCL_DECLARED", "/* 245 */", "EXTERN int\t\tTcl_StringMatch(CONST char *str, CONST char *pattern);", "#endif", "#ifndef Tcl_TellOld_TCL_DECLARED", "#define Tcl_TellOld_TCL_DECLARED", "/* 246 */", "EXTERN int\t\tTcl_TellOld(Tcl_Channel chan);", "#endif", "#ifndef Tcl_TraceVar_TCL_DECLARED", "#define Tcl_TraceVar_TCL_DECLARED", "/* 247 */", "EXTERN int\t\tTcl_TraceVar(Tcl_Interp *interp, CONST char *varName,", "\t\t\t\tint flags, Tcl_VarTraceProc *proc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tcl_TraceVar2_TCL_DECLARED", "#define Tcl_TraceVar2_TCL_DECLARED", "/* 248 */", "EXTERN int\t\tTcl_TraceVar2(Tcl_Interp *interp, CONST char *part1,", "\t\t\t\tCONST char *part2, int flags,", "\t\t\t\tTcl_VarTraceProc *proc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tcl_TranslateFileName_TCL_DECLARED", "#define Tcl_TranslateFileName_TCL_DECLARED", "/* 249 */", "EXTERN char *\t\tTcl_TranslateFileName(Tcl_Interp *interp,", "\t\t\t\tCONST char *name, Tcl_DString *bufferPtr);", "#endif", "#ifndef Tcl_Ungets_TCL_DECLARED", "#define Tcl_Ungets_TCL_DECLARED", "/* 250 */", "EXTERN int\t\tTcl_Ungets(Tcl_Channel chan, CONST char *str,", "\t\t\t\tint len, int atHead);", "#endif", "#ifndef Tcl_UnlinkVar_TCL_DECLARED", "#define Tcl_UnlinkVar_TCL_DECLARED", "/* 251 */", "EXTERN void\t\tTcl_UnlinkVar(Tcl_Interp *interp,", "\t\t\t\tCONST char *varName);", "#endif", "#ifndef Tcl_UnregisterChannel_TCL_DECLARED", "#define Tcl_UnregisterChannel_TCL_DECLARED", "/* 252 */", "EXTERN int\t\tTcl_UnregisterChannel(Tcl_Interp *interp,", "\t\t\t\tTcl_Channel chan);", "#endif", "#ifndef Tcl_UnsetVar_TCL_DECLARED", "#define Tcl_UnsetVar_TCL_DECLARED", "/* 253 */", "EXTERN int\t\tTcl_UnsetVar(Tcl_Interp *interp, CONST char *varName,", "\t\t\t\tint flags);", "#endif", "#ifndef Tcl_UnsetVar2_TCL_DECLARED", "#define Tcl_UnsetVar2_TCL_DECLARED", "/* 254 */", "EXTERN int\t\tTcl_UnsetVar2(Tcl_Interp *interp, CONST char *part1,", "\t\t\t\tCONST char *part2, int flags);", "#endif", "#ifndef Tcl_UntraceVar_TCL_DECLARED", "#define Tcl_UntraceVar_TCL_DECLARED", "/* 255 */", "EXTERN void\t\tTcl_UntraceVar(Tcl_Interp *interp,", "\t\t\t\tCONST char *varName, int flags,", "\t\t\t\tTcl_VarTraceProc *proc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tcl_UntraceVar2_TCL_DECLARED", "#define Tcl_UntraceVar2_TCL_DECLARED", "/* 256 */", "EXTERN void\t\tTcl_UntraceVar2(Tcl_Interp *interp,", "\t\t\t\tCONST char *part1, CONST char *part2,", "\t\t\t\tint flags, Tcl_VarTraceProc *proc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tcl_UpdateLinkedVar_TCL_DECLARED", "#define Tcl_UpdateLinkedVar_TCL_DECLARED", "/* 257 */", "EXTERN void\t\tTcl_UpdateLinkedVar(Tcl_Interp *interp,", "\t\t\t\tCONST char *varName);", "#endif", "#ifndef Tcl_UpVar_TCL_DECLARED", "#define Tcl_UpVar_TCL_DECLARED", "/* 258 */", "EXTERN int\t\tTcl_UpVar(Tcl_Interp *interp, CONST char *frameName,", "\t\t\t\tCONST char *varName, CONST char *localName,", "\t\t\t\tint flags);", "#endif", "#ifndef Tcl_UpVar2_TCL_DECLARED", "#define Tcl_UpVar2_TCL_DECLARED", "/* 259 */", "EXTERN int\t\tTcl_UpVar2(Tcl_Interp *interp, CONST char *frameName,", "\t\t\t\tCONST char *part1, CONST char *part2,", "\t\t\t\tCONST char *localName, int flags);", "#endif", "#ifndef Tcl_VarEval_TCL_DECLARED", "#define Tcl_VarEval_TCL_DECLARED", "/* 260 */", "EXTERN int\t\tTcl_VarEval(Tcl_Interp *interp, ...);", "#endif", "#ifndef Tcl_VarTraceInfo_TCL_DECLARED", "#define Tcl_VarTraceInfo_TCL_DECLARED", "/* 261 */", "EXTERN ClientData\tTcl_VarTraceInfo(Tcl_Interp *interp,", "\t\t\t\tCONST char *varName, int flags,", "\t\t\t\tTcl_VarTraceProc *procPtr,", "\t\t\t\tClientData prevClientData);", "#endif", "#ifndef Tcl_VarTraceInfo2_TCL_DECLARED", "#define Tcl_VarTraceInfo2_TCL_DECLARED", "/* 262 */", "EXTERN ClientData\tTcl_VarTraceInfo2(Tcl_Interp *interp,", "\t\t\t\tCONST char *part1, CONST char *part2,", "\t\t\t\tint flags, Tcl_VarTraceProc *procPtr,", "\t\t\t\tClientData prevClientData);", "#endif", "#ifndef Tcl_Write_TCL_DECLARED", "#define Tcl_Write_TCL_DECLARED", "/* 263 */", "EXTERN int\t\tTcl_Write(Tcl_Channel chan, CONST char *s, int slen);", "#endif", "#ifndef Tcl_WrongNumArgs_TCL_DECLARED", "#define Tcl_WrongNumArgs_TCL_DECLARED", "/* 264 */", "EXTERN void\t\tTcl_WrongNumArgs(Tcl_Interp *interp, int objc,", "\t\t\t\tTcl_Obj *CONST objv[], CONST char *message);", "#endif", "#ifndef Tcl_DumpActiveMemory_TCL_DECLARED", "#define Tcl_DumpActiveMemory_TCL_DECLARED", "/* 265 */", "EXTERN int\t\tTcl_DumpActiveMemory(CONST char *fileName);", "#endif", "#ifndef Tcl_ValidateAllMemory_TCL_DECLARED", "#define Tcl_ValidateAllMemory_TCL_DECLARED", "/* 266 */", "EXTERN void\t\tTcl_ValidateAllMemory(CONST char *file, int line);", "#endif", "#ifndef Tcl_AppendResultVA_TCL_DECLARED", "#define Tcl_AppendResultVA_TCL_DECLARED", "/* 267 */", "EXTERN void\t\tTcl_AppendResultVA(Tcl_Interp *interp,", "\t\t\t\tva_list argList);", "#endif", "#ifndef Tcl_AppendStringsToObjVA_TCL_DECLARED", "#define Tcl_AppendStringsToObjVA_TCL_DECLARED", "/* 268 */", "EXTERN void\t\tTcl_AppendStringsToObjVA(Tcl_Obj *objPtr,", "\t\t\t\tva_list argList);", "#endif", "#ifndef Tcl_HashStats_TCL_DECLARED", "#define Tcl_HashStats_TCL_DECLARED", "/* 269 */", "EXTERN char *\t\tTcl_HashStats(Tcl_HashTable *tablePtr);", "#endif", "#ifndef Tcl_ParseVar_TCL_DECLARED", "#define Tcl_ParseVar_TCL_DECLARED", "/* 270 */", "EXTERN CONST84_RETURN char * Tcl_ParseVar(Tcl_Interp *interp,", "\t\t\t\tCONST char *start, CONST84 char **termPtr);", "#endif", "#ifndef Tcl_PkgPresent_TCL_DECLARED", "#define Tcl_PkgPresent_TCL_DECLARED", "/* 271 */", "EXTERN CONST84_RETURN char * Tcl_PkgPresent(Tcl_Interp *interp,", "\t\t\t\tCONST char *name, CONST char *version,", "\t\t\t\tint exact);", "#endif", "#ifndef Tcl_PkgPresentEx_TCL_DECLARED", "#define Tcl_PkgPresentEx_TCL_DECLARED", "/* 272 */", "EXTERN CONST84_RETURN char * Tcl_PkgPresentEx(Tcl_Interp *interp,", "\t\t\t\tCONST char *name, CONST char *version,", "\t\t\t\tint exact, ClientData *clientDataPtr);", "#endif", "#ifndef Tcl_PkgProvide_TCL_DECLARED", "#define Tcl_PkgProvide_TCL_DECLARED", "/* 273 */", "EXTERN int\t\tTcl_PkgProvide(Tcl_Interp *interp, CONST char *name,", "\t\t\t\tCONST char *version);", "#endif", "#ifndef Tcl_PkgRequire_TCL_DECLARED", "#define Tcl_PkgRequire_TCL_DECLARED", "/* 274 */", "EXTERN CONST84_RETURN char * Tcl_PkgRequire(Tcl_Interp *interp,", "\t\t\t\tCONST char *name, CONST char *version,", "\t\t\t\tint exact);", "#endif", "#ifndef Tcl_SetErrorCodeVA_TCL_DECLARED", "#define Tcl_SetErrorCodeVA_TCL_DECLARED", "/* 275 */", "EXTERN void\t\tTcl_SetErrorCodeVA(Tcl_Interp *interp,", "\t\t\t\tva_list argList);", "#endif", "#ifndef Tcl_VarEvalVA_TCL_DECLARED", "#define Tcl_VarEvalVA_TCL_DECLARED", "/* 276 */", "EXTERN int\t\tTcl_VarEvalVA(Tcl_Interp *interp, va_list argList);", "#endif", "#ifndef Tcl_WaitPid_TCL_DECLARED", "#define Tcl_WaitPid_TCL_DECLARED", "/* 277 */", "EXTERN Tcl_Pid\t\tTcl_WaitPid(Tcl_Pid pid, int *statPtr, int options);", "#endif", "#ifndef Tcl_PanicVA_TCL_DECLARED", "#define Tcl_PanicVA_TCL_DECLARED", "/* 278 */", "EXTERN void\t\tTcl_PanicVA(CONST char *format, va_list argList);", "#endif", "#ifndef Tcl_GetVersion_TCL_DECLARED", "#define Tcl_GetVersion_TCL_DECLARED", "/* 279 */", "EXTERN void\t\tTcl_GetVersion(int *major, int *minor,", "\t\t\t\tint *patchLevel, int *type);", "#endif", "#ifndef Tcl_InitMemory_TCL_DECLARED", "#define Tcl_InitMemory_TCL_DECLARED", "/* 280 */", "EXTERN void\t\tTcl_InitMemory(Tcl_Interp *interp);", "#endif", "#ifndef Tcl_StackChannel_TCL_DECLARED", "#define Tcl_StackChannel_TCL_DECLARED", "/* 281 */", "EXTERN Tcl_Channel\tTcl_StackChannel(Tcl_Interp *interp,", "\t\t\t\tTcl_ChannelType *typePtr,", "\t\t\t\tClientData instanceData, int mask,", "\t\t\t\tTcl_Channel prevChan);", "#endif", "#ifndef Tcl_UnstackChannel_TCL_DECLARED", "#define Tcl_UnstackChannel_TCL_DECLARED", "/* 282 */", "EXTERN int\t\tTcl_UnstackChannel(Tcl_Interp *interp,", "\t\t\t\tTcl_Channel chan);", "#endif", "#ifndef Tcl_GetStackedChannel_TCL_DECLARED", "#define Tcl_GetStackedChannel_TCL_DECLARED", "/* 283 */", "EXTERN Tcl_Channel\tTcl_GetStackedChannel(Tcl_Channel chan);", "#endif", "#ifndef Tcl_SetMainLoop_TCL_DECLARED", "#define Tcl_SetMainLoop_TCL_DECLARED", "/* 284 */", "EXTERN void\t\tTcl_SetMainLoop(Tcl_MainLoopProc *proc);", "#endif", "/* Slot 285 is reserved */", "#ifndef Tcl_AppendObjToObj_TCL_DECLARED", "#define Tcl_AppendObjToObj_TCL_DECLARED", "/* 286 */", "EXTERN void\t\tTcl_AppendObjToObj(Tcl_Obj *objPtr,", "\t\t\t\tTcl_Obj *appendObjPtr);", "#endif", "#ifndef Tcl_CreateEncoding_TCL_DECLARED", "#define Tcl_CreateEncoding_TCL_DECLARED", "/* 287 */", "EXTERN Tcl_Encoding\tTcl_CreateEncoding(CONST Tcl_EncodingType *typePtr);", "#endif", "#ifndef Tcl_CreateThreadExitHandler_TCL_DECLARED", "#define Tcl_CreateThreadExitHandler_TCL_DECLARED", "/* 288 */", "EXTERN void\t\tTcl_CreateThreadExitHandler(Tcl_ExitProc *proc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tcl_DeleteThreadExitHandler_TCL_DECLARED", "#define Tcl_DeleteThreadExitHandler_TCL_DECLARED", "/* 289 */", "EXTERN void\t\tTcl_DeleteThreadExitHandler(Tcl_ExitProc *proc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tcl_DiscardResult_TCL_DECLARED", "#define Tcl_DiscardResult_TCL_DECLARED", "/* 290 */", "EXTERN void\t\tTcl_DiscardResult(Tcl_SavedResult *statePtr);", "#endif", "#ifndef Tcl_EvalEx_TCL_DECLARED", "#define Tcl_EvalEx_TCL_DECLARED", "/* 291 */", "EXTERN int\t\tTcl_EvalEx(Tcl_Interp *interp, CONST char *script,", "\t\t\t\tint numBytes, int flags);", "#endif", "#ifndef Tcl_EvalObjv_TCL_DECLARED", "#define Tcl_EvalObjv_TCL_DECLARED", "/* 292 */", "EXTERN int\t\tTcl_EvalObjv(Tcl_Interp *interp, int objc,", "\t\t\t\tTcl_Obj *CONST objv[], int flags);", "#endif", "#ifndef Tcl_EvalObjEx_TCL_DECLARED", "#define Tcl_EvalObjEx_TCL_DECLARED", "/* 293 */", "EXTERN int\t\tTcl_EvalObjEx(Tcl_Interp *interp, Tcl_Obj *objPtr,", "\t\t\t\tint flags);", "#endif", "#ifndef Tcl_ExitThread_TCL_DECLARED", "#define Tcl_ExitThread_TCL_DECLARED", "/* 294 */", "EXTERN void\t\tTcl_ExitThread(int status);", "#endif", "#ifndef Tcl_ExternalToUtf_TCL_DECLARED", "#define Tcl_ExternalToUtf_TCL_DECLARED", "/* 295 */", "EXTERN int\t\tTcl_ExternalToUtf(Tcl_Interp *interp,", "\t\t\t\tTcl_Encoding encoding, CONST char *src,", "\t\t\t\tint srcLen, int flags,", "\t\t\t\tTcl_EncodingState *statePtr, char *dst,", "\t\t\t\tint dstLen, int *srcReadPtr,", "\t\t\t\tint *dstWrotePtr, int *dstCharsPtr);", "#endif", "#ifndef Tcl_ExternalToUtfDString_TCL_DECLARED", "#define Tcl_ExternalToUtfDString_TCL_DECLARED", "/* 296 */", "EXTERN char *\t\tTcl_ExternalToUtfDString(Tcl_Encoding encoding,", "\t\t\t\tCONST char *src, int srcLen,", "\t\t\t\tTcl_DString *dsPtr);", "#endif", "#ifndef Tcl_FinalizeThread_TCL_DECLARED", "#define Tcl_FinalizeThread_TCL_DECLARED", "/* 297 */", "EXTERN void\t\tTcl_FinalizeThread(void);", "#endif", "#ifndef Tcl_FinalizeNotifier_TCL_DECLARED", "#define Tcl_FinalizeNotifier_TCL_DECLARED", "/* 298 */", "EXTERN void\t\tTcl_FinalizeNotifier(ClientData clientData);", "#endif", "#ifndef Tcl_FreeEncoding_TCL_DECLARED", "#define Tcl_FreeEncoding_TCL_DECLARED", "/* 299 */", "EXTERN void\t\tTcl_FreeEncoding(Tcl_Encoding encoding);", "#endif", "#ifndef Tcl_GetCurrentThread_TCL_DECLARED", "#define Tcl_GetCurrentThread_TCL_DECLARED", "/* 300 */", "EXTERN Tcl_ThreadId\tTcl_GetCurrentThread(void);", "#endif", "#ifndef Tcl_GetEncoding_TCL_DECLARED", "#define Tcl_GetEncoding_TCL_DECLARED", "/* 301 */", "EXTERN Tcl_Encoding\tTcl_GetEncoding(Tcl_Interp *interp, CONST char *name);", "#endif", "#ifndef Tcl_GetEncodingName_TCL_DECLARED", "#define Tcl_GetEncodingName_TCL_DECLARED", "/* 302 */", "EXTERN CONST84_RETURN char * Tcl_GetEncodingName(Tcl_Encoding encoding);", "#endif", "#ifndef Tcl_GetEncodingNames_TCL_DECLARED", "#define Tcl_GetEncodingNames_TCL_DECLARED", "/* 303 */", "EXTERN void\t\tTcl_GetEncodingNames(Tcl_Interp *interp);", "#endif", "#ifndef Tcl_GetIndexFromObjStruct_TCL_DECLARED", "#define Tcl_GetIndexFromObjStruct_TCL_DECLARED", "/* 304 */", "EXTERN int\t\tTcl_GetIndexFromObjStruct(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *objPtr, CONST VOID *tablePtr,", "\t\t\t\tint offset, CONST char *msg, int flags,", "\t\t\t\tint *indexPtr);", "#endif", "#ifndef Tcl_GetThreadData_TCL_DECLARED", "#define Tcl_GetThreadData_TCL_DECLARED", "/* 305 */", "EXTERN VOID *\t\tTcl_GetThreadData(Tcl_ThreadDataKey *keyPtr,", "\t\t\t\tint size);", "#endif", "#ifndef Tcl_GetVar2Ex_TCL_DECLARED", "#define Tcl_GetVar2Ex_TCL_DECLARED", "/* 306 */", "EXTERN Tcl_Obj *\tTcl_GetVar2Ex(Tcl_Interp *interp, CONST char *part1,", "\t\t\t\tCONST char *part2, int flags);", "#endif", "#ifndef Tcl_InitNotifier_TCL_DECLARED", "#define Tcl_InitNotifier_TCL_DECLARED", "/* 307 */", "EXTERN ClientData\tTcl_InitNotifier(void);", "#endif", "#ifndef Tcl_MutexLock_TCL_DECLARED", "#define Tcl_MutexLock_TCL_DECLARED", "/* 308 */", "EXTERN void\t\tTcl_MutexLock(Tcl_Mutex *mutexPtr);", "#endif", "#ifndef Tcl_MutexUnlock_TCL_DECLARED", "#define Tcl_MutexUnlock_TCL_DECLARED", "/* 309 */", "EXTERN void\t\tTcl_MutexUnlock(Tcl_Mutex *mutexPtr);", "#endif", "#ifndef Tcl_ConditionNotify_TCL_DECLARED", "#define Tcl_ConditionNotify_TCL_DECLARED", "/* 310 */", "EXTERN void\t\tTcl_ConditionNotify(Tcl_Condition *condPtr);", "#endif", "#ifndef Tcl_ConditionWait_TCL_DECLARED", "#define Tcl_ConditionWait_TCL_DECLARED", "/* 311 */", "EXTERN void\t\tTcl_ConditionWait(Tcl_Condition *condPtr,", "\t\t\t\tTcl_Mutex *mutexPtr, Tcl_Time *timePtr);", "#endif", "#ifndef Tcl_NumUtfChars_TCL_DECLARED", "#define Tcl_NumUtfChars_TCL_DECLARED", "/* 312 */", "EXTERN int\t\tTcl_NumUtfChars(CONST char *src, int length);", "#endif", "#ifndef Tcl_ReadChars_TCL_DECLARED", "#define Tcl_ReadChars_TCL_DECLARED", "/* 313 */", "EXTERN int\t\tTcl_ReadChars(Tcl_Channel channel, Tcl_Obj *objPtr,", "\t\t\t\tint charsToRead, int appendFlag);", "#endif", "#ifndef Tcl_RestoreResult_TCL_DECLARED", "#define Tcl_RestoreResult_TCL_DECLARED", "/* 314 */", "EXTERN void\t\tTcl_RestoreResult(Tcl_Interp *interp,", "\t\t\t\tTcl_SavedResult *statePtr);", "#endif", "#ifndef Tcl_SaveResult_TCL_DECLARED", "#define Tcl_SaveResult_TCL_DECLARED", "/* 315 */", "EXTERN void\t\tTcl_SaveResult(Tcl_Interp *interp,", "\t\t\t\tTcl_SavedResult *statePtr);", "#endif", "#ifndef Tcl_SetSystemEncoding_TCL_DECLARED", "#define Tcl_SetSystemEncoding_TCL_DECLARED", "/* 316 */", "EXTERN int\t\tTcl_SetSystemEncoding(Tcl_Interp *interp,", "\t\t\t\tCONST char *name);", "#endif", "#ifndef Tcl_SetVar2Ex_TCL_DECLARED", "#define Tcl_SetVar2Ex_TCL_DECLARED", "/* 317 */", "EXTERN Tcl_Obj *\tTcl_SetVar2Ex(Tcl_Interp *interp, CONST char *part1,", "\t\t\t\tCONST char *part2, Tcl_Obj *newValuePtr,", "\t\t\t\tint flags);", "#endif", "#ifndef Tcl_ThreadAlert_TCL_DECLARED", "#define Tcl_ThreadAlert_TCL_DECLARED", "/* 318 */", "EXTERN void\t\tTcl_ThreadAlert(Tcl_ThreadId threadId);", "#endif", "#ifndef Tcl_ThreadQueueEvent_TCL_DECLARED", "#define Tcl_ThreadQueueEvent_TCL_DECLARED", "/* 319 */", "EXTERN void\t\tTcl_ThreadQueueEvent(Tcl_ThreadId threadId,", "\t\t\t\tTcl_Event *evPtr, Tcl_QueuePosition position);", "#endif", "#ifndef Tcl_UniCharAtIndex_TCL_DECLARED", "#define Tcl_UniCharAtIndex_TCL_DECLARED", "/* 320 */", "EXTERN Tcl_UniChar\tTcl_UniCharAtIndex(CONST char *src, int index);", "#endif", "#ifndef Tcl_UniCharToLower_TCL_DECLARED", "#define Tcl_UniCharToLower_TCL_DECLARED", "/* 321 */", "EXTERN Tcl_UniChar\tTcl_UniCharToLower(int ch);", "#endif", "#ifndef Tcl_UniCharToTitle_TCL_DECLARED", "#define Tcl_UniCharToTitle_TCL_DECLARED", "/* 322 */", "EXTERN Tcl_UniChar\tTcl_UniCharToTitle(int ch);", "#endif", "#ifndef Tcl_UniCharToUpper_TCL_DECLARED", "#define Tcl_UniCharToUpper_TCL_DECLARED", "/* 323 */", "EXTERN Tcl_UniChar\tTcl_UniCharToUpper(int ch);", "#endif", "#ifndef Tcl_UniCharToUtf_TCL_DECLARED", "#define Tcl_UniCharToUtf_TCL_DECLARED", "/* 324 */", "EXTERN int\t\tTcl_UniCharToUtf(int ch, char *buf);", "#endif", "#ifndef Tcl_UtfAtIndex_TCL_DECLARED", "#define Tcl_UtfAtIndex_TCL_DECLARED", "/* 325 */", "EXTERN CONST84_RETURN char * Tcl_UtfAtIndex(CONST char *src, int index);", "#endif", "#ifndef Tcl_UtfCharComplete_TCL_DECLARED", "#define Tcl_UtfCharComplete_TCL_DECLARED", "/* 326 */", "EXTERN int\t\tTcl_UtfCharComplete(CONST char *src, int length);", "#endif", "#ifndef Tcl_UtfBackslash_TCL_DECLARED", "#define Tcl_UtfBackslash_TCL_DECLARED", "/* 327 */", "EXTERN int\t\tTcl_UtfBackslash(CONST char *src, int *readPtr,", "\t\t\t\tchar *dst);", "#endif", "#ifndef Tcl_UtfFindFirst_TCL_DECLARED", "#define Tcl_UtfFindFirst_TCL_DECLARED", "/* 328 */", "EXTERN CONST84_RETURN char * Tcl_UtfFindFirst(CONST char *src, int ch);", "#endif", "#ifndef Tcl_UtfFindLast_TCL_DECLARED", "#define Tcl_UtfFindLast_TCL_DECLARED", "/* 329 */", "EXTERN CONST84_RETURN char * Tcl_UtfFindLast(CONST char *src, int ch);", "#endif", "#ifndef Tcl_UtfNext_TCL_DECLARED", "#define Tcl_UtfNext_TCL_DECLARED", "/* 330 */", "EXTERN CONST84_RETURN char * Tcl_UtfNext(CONST char *src);", "#endif", "#ifndef Tcl_UtfPrev_TCL_DECLARED", "#define Tcl_UtfPrev_TCL_DECLARED", "/* 331 */", "EXTERN CONST84_RETURN char * Tcl_UtfPrev(CONST char *src, CONST char *start);", "#endif", "#ifndef Tcl_UtfToExternal_TCL_DECLARED", "#define Tcl_UtfToExternal_TCL_DECLARED", "/* 332 */", "EXTERN int\t\tTcl_UtfToExternal(Tcl_Interp *interp,", "\t\t\t\tTcl_Encoding encoding, CONST char *src,", "\t\t\t\tint srcLen, int flags,", "\t\t\t\tTcl_EncodingState *statePtr, char *dst,", "\t\t\t\tint dstLen, int *srcReadPtr,", "\t\t\t\tint *dstWrotePtr, int *dstCharsPtr);", "#endif", "#ifndef Tcl_UtfToExternalDString_TCL_DECLARED", "#define Tcl_UtfToExternalDString_TCL_DECLARED", "/* 333 */", "EXTERN char *\t\tTcl_UtfToExternalDString(Tcl_Encoding encoding,", "\t\t\t\tCONST char *src, int srcLen,", "\t\t\t\tTcl_DString *dsPtr);", "#endif", "#ifndef Tcl_UtfToLower_TCL_DECLARED", "#define Tcl_UtfToLower_TCL_DECLARED", "/* 334 */", "EXTERN int\t\tTcl_UtfToLower(char *src);", "#endif", "#ifndef Tcl_UtfToTitle_TCL_DECLARED", "#define Tcl_UtfToTitle_TCL_DECLARED", "/* 335 */", "EXTERN int\t\tTcl_UtfToTitle(char *src);", "#endif", "#ifndef Tcl_UtfToUniChar_TCL_DECLARED", "#define Tcl_UtfToUniChar_TCL_DECLARED", "/* 336 */", "EXTERN int\t\tTcl_UtfToUniChar(CONST char *src, Tcl_UniChar *chPtr);", "#endif", "#ifndef Tcl_UtfToUpper_TCL_DECLARED", "#define Tcl_UtfToUpper_TCL_DECLARED", "/* 337 */", "EXTERN int\t\tTcl_UtfToUpper(char *src);", "#endif", "#ifndef Tcl_WriteChars_TCL_DECLARED", "#define Tcl_WriteChars_TCL_DECLARED", "/* 338 */", "EXTERN int\t\tTcl_WriteChars(Tcl_Channel chan, CONST char *src,", "\t\t\t\tint srcLen);", "#endif", "#ifndef Tcl_WriteObj_TCL_DECLARED", "#define Tcl_WriteObj_TCL_DECLARED", "/* 339 */", "EXTERN int\t\tTcl_WriteObj(Tcl_Channel chan, Tcl_Obj *objPtr);", "#endif", "#ifndef Tcl_GetString_TCL_DECLARED", "#define Tcl_GetString_TCL_DECLARED", "/* 340 */", "EXTERN char *\t\tTcl_GetString(Tcl_Obj *objPtr);", "#endif", "#ifndef Tcl_GetDefaultEncodingDir_TCL_DECLARED", "#define Tcl_GetDefaultEncodingDir_TCL_DECLARED", "/* 341 */", "EXTERN CONST84_RETURN char * Tcl_GetDefaultEncodingDir(void);", "#endif", "#ifndef Tcl_SetDefaultEncodingDir_TCL_DECLARED", "#define Tcl_SetDefaultEncodingDir_TCL_DECLARED", "/* 342 */", "EXTERN void\t\tTcl_SetDefaultEncodingDir(CONST char *path);", "#endif", "#ifndef Tcl_AlertNotifier_TCL_DECLARED", "#define Tcl_AlertNotifier_TCL_DECLARED", "/* 343 */", "EXTERN void\t\tTcl_AlertNotifier(ClientData clientData);", "#endif", "#ifndef Tcl_ServiceModeHook_TCL_DECLARED", "#define Tcl_ServiceModeHook_TCL_DECLARED", "/* 344 */", "EXTERN void\t\tTcl_ServiceModeHook(int mode);", "#endif", "#ifndef Tcl_UniCharIsAlnum_TCL_DECLARED", "#define Tcl_UniCharIsAlnum_TCL_DECLARED", "/* 345 */", "EXTERN int\t\tTcl_UniCharIsAlnum(int ch);", "#endif", "#ifndef Tcl_UniCharIsAlpha_TCL_DECLARED", "#define Tcl_UniCharIsAlpha_TCL_DECLARED", "/* 346 */", "EXTERN int\t\tTcl_UniCharIsAlpha(int ch);", "#endif", "#ifndef Tcl_UniCharIsDigit_TCL_DECLARED", "#define Tcl_UniCharIsDigit_TCL_DECLARED", "/* 347 */", "EXTERN int\t\tTcl_UniCharIsDigit(int ch);", "#endif", "#ifndef Tcl_UniCharIsLower_TCL_DECLARED", "#define Tcl_UniCharIsLower_TCL_DECLARED", "/* 348 */", "EXTERN int\t\tTcl_UniCharIsLower(int ch);", "#endif", "#ifndef Tcl_UniCharIsSpace_TCL_DECLARED", "#define Tcl_UniCharIsSpace_TCL_DECLARED", "/* 349 */", "EXTERN int\t\tTcl_UniCharIsSpace(int ch);", "#endif", "#ifndef Tcl_UniCharIsUpper_TCL_DECLARED", "#define Tcl_UniCharIsUpper_TCL_DECLARED", "/* 350 */", "EXTERN int\t\tTcl_UniCharIsUpper(int ch);", "#endif", "#ifndef Tcl_UniCharIsWordChar_TCL_DECLARED", "#define Tcl_UniCharIsWordChar_TCL_DECLARED", "/* 351 */", "EXTERN int\t\tTcl_UniCharIsWordChar(int ch);", "#endif", "#ifndef Tcl_UniCharLen_TCL_DECLARED", "#define Tcl_UniCharLen_TCL_DECLARED", "/* 352 */", "EXTERN int\t\tTcl_UniCharLen(CONST Tcl_UniChar *uniStr);", "#endif", "#ifndef Tcl_UniCharNcmp_TCL_DECLARED", "#define Tcl_UniCharNcmp_TCL_DECLARED", "/* 353 */", "EXTERN int\t\tTcl_UniCharNcmp(CONST Tcl_UniChar *ucs,", "\t\t\t\tCONST Tcl_UniChar *uct,", "\t\t\t\tunsigned long numChars);", "#endif", "#ifndef Tcl_UniCharToUtfDString_TCL_DECLARED", "#define Tcl_UniCharToUtfDString_TCL_DECLARED", "/* 354 */", "EXTERN char *\t\tTcl_UniCharToUtfDString(CONST Tcl_UniChar *uniStr,", "\t\t\t\tint uniLength, Tcl_DString *dsPtr);", "#endif", "#ifndef Tcl_UtfToUniCharDString_TCL_DECLARED", "#define Tcl_UtfToUniCharDString_TCL_DECLARED", "/* 355 */", "EXTERN Tcl_UniChar *\tTcl_UtfToUniCharDString(CONST char *src, int length,", "\t\t\t\tTcl_DString *dsPtr);", "#endif", "#ifndef Tcl_GetRegExpFromObj_TCL_DECLARED", "#define Tcl_GetRegExpFromObj_TCL_DECLARED", "/* 356 */", "EXTERN Tcl_RegExp\tTcl_GetRegExpFromObj(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *patObj, int flags);", "#endif", "#ifndef Tcl_EvalTokens_TCL_DECLARED", "#define Tcl_EvalTokens_TCL_DECLARED", "/* 357 */", "EXTERN Tcl_Obj *\tTcl_EvalTokens(Tcl_Interp *interp,", "\t\t\t\tTcl_Token *tokenPtr, int count);", "#endif", "#ifndef Tcl_FreeParse_TCL_DECLARED", "#define Tcl_FreeParse_TCL_DECLARED", "/* 358 */", "EXTERN void\t\tTcl_FreeParse(Tcl_Parse *parsePtr);", "#endif", "#ifndef Tcl_LogCommandInfo_TCL_DECLARED", "#define Tcl_LogCommandInfo_TCL_DECLARED", "/* 359 */", "EXTERN void\t\tTcl_LogCommandInfo(Tcl_Interp *interp,", "\t\t\t\tCONST char *script, CONST char *command,", "\t\t\t\tint length);", "#endif", "#ifndef Tcl_ParseBraces_TCL_DECLARED", "#define Tcl_ParseBraces_TCL_DECLARED", "/* 360 */", "EXTERN int\t\tTcl_ParseBraces(Tcl_Interp *interp,", "\t\t\t\tCONST char *start, int numBytes,", "\t\t\t\tTcl_Parse *parsePtr, int append,", "\t\t\t\tCONST84 char **termPtr);", "#endif", "#ifndef Tcl_ParseCommand_TCL_DECLARED", "#define Tcl_ParseCommand_TCL_DECLARED", "/* 361 */", "EXTERN int\t\tTcl_ParseCommand(Tcl_Interp *interp,", "\t\t\t\tCONST char *start, int numBytes, int nested,", "\t\t\t\tTcl_Parse *parsePtr);", "#endif", "#ifndef Tcl_ParseExpr_TCL_DECLARED", "#define Tcl_ParseExpr_TCL_DECLARED", "/* 362 */", "EXTERN int\t\tTcl_ParseExpr(Tcl_Interp *interp, CONST char *start,", "\t\t\t\tint numBytes, Tcl_Parse *parsePtr);", "#endif", "#ifndef Tcl_ParseQuotedString_TCL_DECLARED", "#define Tcl_ParseQuotedString_TCL_DECLARED", "/* 363 */", "EXTERN int\t\tTcl_ParseQuotedString(Tcl_Interp *interp,", "\t\t\t\tCONST char *start, int numBytes,", "\t\t\t\tTcl_Parse *parsePtr, int append,", "\t\t\t\tCONST84 char **termPtr);", "#endif", "#ifndef Tcl_ParseVarName_TCL_DECLARED", "#define Tcl_ParseVarName_TCL_DECLARED", "/* 364 */", "EXTERN int\t\tTcl_ParseVarName(Tcl_Interp *interp,", "\t\t\t\tCONST char *start, int numBytes,", "\t\t\t\tTcl_Parse *parsePtr, int append);", "#endif", "#ifndef Tcl_GetCwd_TCL_DECLARED", "#define Tcl_GetCwd_TCL_DECLARED", "/* 365 */", "EXTERN char *\t\tTcl_GetCwd(Tcl_Interp *interp, Tcl_DString *cwdPtr);", "#endif", "#ifndef Tcl_Chdir_TCL_DECLARED", "#define Tcl_Chdir_TCL_DECLARED", "/* 366 */", "EXTERN int\t\tTcl_Chdir(CONST char *dirName);", "#endif", "#ifndef Tcl_Access_TCL_DECLARED", "#define Tcl_Access_TCL_DECLARED", "/* 367 */", "EXTERN int\t\tTcl_Access(CONST char *path, int mode);", "#endif", "#ifndef Tcl_Stat_TCL_DECLARED", "#define Tcl_Stat_TCL_DECLARED", "/* 368 */", "EXTERN int\t\tTcl_Stat(CONST char *path, struct stat *bufPtr);", "#endif", "#ifndef Tcl_UtfNcmp_TCL_DECLARED", "#define Tcl_UtfNcmp_TCL_DECLARED", "/* 369 */", "EXTERN int\t\tTcl_UtfNcmp(CONST char *s1, CONST char *s2,", "\t\t\t\tunsigned long n);", "#endif", "#ifndef Tcl_UtfNcasecmp_TCL_DECLARED", "#define Tcl_UtfNcasecmp_TCL_DECLARED", "/* 370 */", "EXTERN int\t\tTcl_UtfNcasecmp(CONST char *s1, CONST char *s2,", "\t\t\t\tunsigned long n);", "#endif", "#ifndef Tcl_StringCaseMatch_TCL_DECLARED", "#define Tcl_StringCaseMatch_TCL_DECLARED", "/* 371 */", "EXTERN int\t\tTcl_StringCaseMatch(CONST char *str,", "\t\t\t\tCONST char *pattern, int nocase);", "#endif", "#ifndef Tcl_UniCharIsControl_TCL_DECLARED", "#define Tcl_UniCharIsControl_TCL_DECLARED", "/* 372 */", "EXTERN int\t\tTcl_UniCharIsControl(int ch);", "#endif", "#ifndef Tcl_UniCharIsGraph_TCL_DECLARED", "#define Tcl_UniCharIsGraph_TCL_DECLARED", "/* 373 */", "EXTERN int\t\tTcl_UniCharIsGraph(int ch);", "#endif", "#ifndef Tcl_UniCharIsPrint_TCL_DECLARED", "#define Tcl_UniCharIsPrint_TCL_DECLARED", "/* 374 */", "EXTERN int\t\tTcl_UniCharIsPrint(int ch);", "#endif", "#ifndef Tcl_UniCharIsPunct_TCL_DECLARED", "#define Tcl_UniCharIsPunct_TCL_DECLARED", "/* 375 */", "EXTERN int\t\tTcl_UniCharIsPunct(int ch);", "#endif", "#ifndef Tcl_RegExpExecObj_TCL_DECLARED", "#define Tcl_RegExpExecObj_TCL_DECLARED", "/* 376 */", "EXTERN int\t\tTcl_RegExpExecObj(Tcl_Interp *interp,", "\t\t\t\tTcl_RegExp regexp, Tcl_Obj *textObj,", "\t\t\t\tint offset, int nmatches, int flags);", "#endif", "#ifndef Tcl_RegExpGetInfo_TCL_DECLARED", "#define Tcl_RegExpGetInfo_TCL_DECLARED", "/* 377 */", "EXTERN void\t\tTcl_RegExpGetInfo(Tcl_RegExp regexp,", "\t\t\t\tTcl_RegExpInfo *infoPtr);", "#endif", "#ifndef Tcl_NewUnicodeObj_TCL_DECLARED", "#define Tcl_NewUnicodeObj_TCL_DECLARED", "/* 378 */", "EXTERN Tcl_Obj *\tTcl_NewUnicodeObj(CONST Tcl_UniChar *unicode,", "\t\t\t\tint numChars);", "#endif", "#ifndef Tcl_SetUnicodeObj_TCL_DECLARED", "#define Tcl_SetUnicodeObj_TCL_DECLARED", "/* 379 */", "EXTERN void\t\tTcl_SetUnicodeObj(Tcl_Obj *objPtr,", "\t\t\t\tCONST Tcl_UniChar *unicode, int numChars);", "#endif", "#ifndef Tcl_GetCharLength_TCL_DECLARED", "#define Tcl_GetCharLength_TCL_DECLARED", "/* 380 */", "EXTERN int\t\tTcl_GetCharLength(Tcl_Obj *objPtr);", "#endif", "#ifndef Tcl_GetUniChar_TCL_DECLARED", "#define Tcl_GetUniChar_TCL_DECLARED", "/* 381 */", "EXTERN Tcl_UniChar\tTcl_GetUniChar(Tcl_Obj *objPtr, int index);", "#endif", "#ifndef Tcl_GetUnicode_TCL_DECLARED", "#define Tcl_GetUnicode_TCL_DECLARED", "/* 382 */", "EXTERN Tcl_UniChar *\tTcl_GetUnicode(Tcl_Obj *objPtr);", "#endif", "#ifndef Tcl_GetRange_TCL_DECLARED", "#define Tcl_GetRange_TCL_DECLARED", "/* 383 */", "EXTERN Tcl_Obj *\tTcl_GetRange(Tcl_Obj *objPtr, int first, int last);", "#endif", "#ifndef Tcl_AppendUnicodeToObj_TCL_DECLARED", "#define Tcl_AppendUnicodeToObj_TCL_DECLARED", "/* 384 */", "EXTERN void\t\tTcl_AppendUnicodeToObj(Tcl_Obj *objPtr,", "\t\t\t\tCONST Tcl_UniChar *unicode, int length);", "#endif", "#ifndef Tcl_RegExpMatchObj_TCL_DECLARED", "#define Tcl_RegExpMatchObj_TCL_DECLARED", "/* 385 */", "EXTERN int\t\tTcl_RegExpMatchObj(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *textObj, Tcl_Obj *patternObj);", "#endif", "#ifndef Tcl_SetNotifier_TCL_DECLARED", "#define Tcl_SetNotifier_TCL_DECLARED", "/* 386 */", "EXTERN void\t\tTcl_SetNotifier(Tcl_NotifierProcs *notifierProcPtr);", "#endif", "#ifndef Tcl_GetAllocMutex_TCL_DECLARED", "#define Tcl_GetAllocMutex_TCL_DECLARED", "/* 387 */", "EXTERN Tcl_Mutex *\tTcl_GetAllocMutex(void);", "#endif", "#ifndef Tcl_GetChannelNames_TCL_DECLARED", "#define Tcl_GetChannelNames_TCL_DECLARED", "/* 388 */", "EXTERN int\t\tTcl_GetChannelNames(Tcl_Interp *interp);", "#endif", "#ifndef Tcl_GetChannelNamesEx_TCL_DECLARED", "#define Tcl_GetChannelNamesEx_TCL_DECLARED", "/* 389 */", "EXTERN int\t\tTcl_GetChannelNamesEx(Tcl_Interp *interp,", "\t\t\t\tCONST char *pattern);", "#endif", "#ifndef Tcl_ProcObjCmd_TCL_DECLARED", "#define Tcl_ProcObjCmd_TCL_DECLARED", "/* 390 */", "EXTERN int\t\tTcl_ProcObjCmd(ClientData clientData,", "\t\t\t\tTcl_Interp *interp, int objc,", "\t\t\t\tTcl_Obj *CONST objv[]);", "#endif", "#ifndef Tcl_ConditionFinalize_TCL_DECLARED", "#define Tcl_ConditionFinalize_TCL_DECLARED", "/* 391 */", "EXTERN void\t\tTcl_ConditionFinalize(Tcl_Condition *condPtr);", "#endif", "#ifndef Tcl_MutexFinalize_TCL_DECLARED", "#define Tcl_MutexFinalize_TCL_DECLARED", "/* 392 */", "EXTERN void\t\tTcl_MutexFinalize(Tcl_Mutex *mutex);", "#endif", "#ifndef Tcl_CreateThread_TCL_DECLARED", "#define Tcl_CreateThread_TCL_DECLARED", "/* 393 */", "EXTERN int\t\tTcl_CreateThread(Tcl_ThreadId *idPtr,", "\t\t\t\tTcl_ThreadCreateProc proc,", "\t\t\t\tClientData clientData, int stackSize,", "\t\t\t\tint flags);", "#endif", "#ifndef Tcl_ReadRaw_TCL_DECLARED", "#define Tcl_ReadRaw_TCL_DECLARED", "/* 394 */", "EXTERN int\t\tTcl_ReadRaw(Tcl_Channel chan, char *dst,", "\t\t\t\tint bytesToRead);", "#endif", "#ifndef Tcl_WriteRaw_TCL_DECLARED", "#define Tcl_WriteRaw_TCL_DECLARED", "/* 395 */", "EXTERN int\t\tTcl_WriteRaw(Tcl_Channel chan, CONST char *src,", "\t\t\t\tint srcLen);", "#endif", "#ifndef Tcl_GetTopChannel_TCL_DECLARED", "#define Tcl_GetTopChannel_TCL_DECLARED", "/* 396 */", "EXTERN Tcl_Channel\tTcl_GetTopChannel(Tcl_Channel chan);", "#endif", "#ifndef Tcl_ChannelBuffered_TCL_DECLARED", "#define Tcl_ChannelBuffered_TCL_DECLARED", "/* 397 */", "EXTERN int\t\tTcl_ChannelBuffered(Tcl_Channel chan);", "#endif", "#ifndef Tcl_ChannelName_TCL_DECLARED", "#define Tcl_ChannelName_TCL_DECLARED", "/* 398 */", "EXTERN CONST84_RETURN char * Tcl_ChannelName(", "\t\t\t\tCONST Tcl_ChannelType *chanTypePtr);", "#endif", "#ifndef Tcl_ChannelVersion_TCL_DECLARED", "#define Tcl_ChannelVersion_TCL_DECLARED", "/* 399 */", "EXTERN Tcl_ChannelTypeVersion Tcl_ChannelVersion(", "\t\t\t\tCONST Tcl_ChannelType *chanTypePtr);", "#endif", "#ifndef Tcl_ChannelBlockModeProc_TCL_DECLARED", "#define Tcl_ChannelBlockModeProc_TCL_DECLARED", "/* 400 */", "EXTERN Tcl_DriverBlockModeProc * Tcl_ChannelBlockModeProc(", "\t\t\t\tCONST Tcl_ChannelType *chanTypePtr);", "#endif", "#ifndef Tcl_ChannelCloseProc_TCL_DECLARED", "#define Tcl_ChannelCloseProc_TCL_DECLARED", "/* 401 */", "EXTERN Tcl_DriverCloseProc * Tcl_ChannelCloseProc(", "\t\t\t\tCONST Tcl_ChannelType *chanTypePtr);", "#endif", "#ifndef Tcl_ChannelClose2Proc_TCL_DECLARED", "#define Tcl_ChannelClose2Proc_TCL_DECLARED", "/* 402 */", "EXTERN Tcl_DriverClose2Proc * Tcl_ChannelClose2Proc(", "\t\t\t\tCONST Tcl_ChannelType *chanTypePtr);", "#endif", "#ifndef Tcl_ChannelInputProc_TCL_DECLARED", "#define Tcl_ChannelInputProc_TCL_DECLARED", "/* 403 */", "EXTERN Tcl_DriverInputProc * Tcl_ChannelInputProc(", "\t\t\t\tCONST Tcl_ChannelType *chanTypePtr);", "#endif", "#ifndef Tcl_ChannelOutputProc_TCL_DECLARED", "#define Tcl_ChannelOutputProc_TCL_DECLARED", "/* 404 */", "EXTERN Tcl_DriverOutputProc * Tcl_ChannelOutputProc(", "\t\t\t\tCONST Tcl_ChannelType *chanTypePtr);", "#endif", "#ifndef Tcl_ChannelSeekProc_TCL_DECLARED", "#define Tcl_ChannelSeekProc_TCL_DECLARED", "/* 405 */", "EXTERN Tcl_DriverSeekProc * Tcl_ChannelSeekProc(", "\t\t\t\tCONST Tcl_ChannelType *chanTypePtr);", "#endif", "#ifndef Tcl_ChannelSetOptionProc_TCL_DECLARED", "#define Tcl_ChannelSetOptionProc_TCL_DECLARED", "/* 406 */", "EXTERN Tcl_DriverSetOptionProc * Tcl_ChannelSetOptionProc(", "\t\t\t\tCONST Tcl_ChannelType *chanTypePtr);", "#endif", "#ifndef Tcl_ChannelGetOptionProc_TCL_DECLARED", "#define Tcl_ChannelGetOptionProc_TCL_DECLARED", "/* 407 */", "EXTERN Tcl_DriverGetOptionProc * Tcl_ChannelGetOptionProc(", "\t\t\t\tCONST Tcl_ChannelType *chanTypePtr);", "#endif", "#ifndef Tcl_ChannelWatchProc_TCL_DECLARED", "#define Tcl_ChannelWatchProc_TCL_DECLARED", "/* 408 */", "EXTERN Tcl_DriverWatchProc * Tcl_ChannelWatchProc(", "\t\t\t\tCONST Tcl_ChannelType *chanTypePtr);", "#endif", "#ifndef Tcl_ChannelGetHandleProc_TCL_DECLARED", "#define Tcl_ChannelGetHandleProc_TCL_DECLARED", "/* 409 */", "EXTERN Tcl_DriverGetHandleProc * Tcl_ChannelGetHandleProc(", "\t\t\t\tCONST Tcl_ChannelType *chanTypePtr);", "#endif", "#ifndef Tcl_ChannelFlushProc_TCL_DECLARED", "#define Tcl_ChannelFlushProc_TCL_DECLARED", "/* 410 */", "EXTERN Tcl_DriverFlushProc * Tcl_ChannelFlushProc(", "\t\t\t\tCONST Tcl_ChannelType *chanTypePtr);", "#endif", "#ifndef Tcl_ChannelHandlerProc_TCL_DECLARED", "#define Tcl_ChannelHandlerProc_TCL_DECLARED", "/* 411 */", "EXTERN Tcl_DriverHandlerProc * Tcl_ChannelHandlerProc(", "\t\t\t\tCONST Tcl_ChannelType *chanTypePtr);", "#endif", "#ifndef Tcl_JoinThread_TCL_DECLARED", "#define Tcl_JoinThread_TCL_DECLARED", "/* 412 */", "EXTERN int\t\tTcl_JoinThread(Tcl_ThreadId threadId, int *result);", "#endif", "#ifndef Tcl_IsChannelShared_TCL_DECLARED", "#define Tcl_IsChannelShared_TCL_DECLARED", "/* 413 */", "EXTERN int\t\tTcl_IsChannelShared(Tcl_Channel channel);", "#endif", "#ifndef Tcl_IsChannelRegistered_TCL_DECLARED", "#define Tcl_IsChannelRegistered_TCL_DECLARED", "/* 414 */", "EXTERN int\t\tTcl_IsChannelRegistered(Tcl_Interp *interp,", "\t\t\t\tTcl_Channel channel);", "#endif", "#ifndef Tcl_CutChannel_TCL_DECLARED", "#define Tcl_CutChannel_TCL_DECLARED", "/* 415 */", "EXTERN void\t\tTcl_CutChannel(Tcl_Channel channel);", "#endif", "#ifndef Tcl_SpliceChannel_TCL_DECLARED", "#define Tcl_SpliceChannel_TCL_DECLARED", "/* 416 */", "EXTERN void\t\tTcl_SpliceChannel(Tcl_Channel channel);", "#endif", "#ifndef Tcl_ClearChannelHandlers_TCL_DECLARED", "#define Tcl_ClearChannelHandlers_TCL_DECLARED", "/* 417 */", "EXTERN void\t\tTcl_ClearChannelHandlers(Tcl_Channel channel);", "#endif", "#ifndef Tcl_IsChannelExisting_TCL_DECLARED", "#define Tcl_IsChannelExisting_TCL_DECLARED", "/* 418 */", "EXTERN int\t\tTcl_IsChannelExisting(CONST char *channelName);", "#endif", "#ifndef Tcl_UniCharNcasecmp_TCL_DECLARED", "#define Tcl_UniCharNcasecmp_TCL_DECLARED", "/* 419 */", "EXTERN int\t\tTcl_UniCharNcasecmp(CONST Tcl_UniChar *ucs,", "\t\t\t\tCONST Tcl_UniChar *uct,", "\t\t\t\tunsigned long numChars);", "#endif", "#ifndef Tcl_UniCharCaseMatch_TCL_DECLARED", "#define Tcl_UniCharCaseMatch_TCL_DECLARED", "/* 420 */", "EXTERN int\t\tTcl_UniCharCaseMatch(CONST Tcl_UniChar *uniStr,", "\t\t\t\tCONST Tcl_UniChar *uniPattern, int nocase);", "#endif", "#ifndef Tcl_FindHashEntry_TCL_DECLARED", "#define Tcl_FindHashEntry_TCL_DECLARED", "/* 421 */", "EXTERN Tcl_HashEntry *\tTcl_FindHashEntry(Tcl_HashTable *tablePtr,", "\t\t\t\tCONST char *key);", "#endif", "#ifndef Tcl_CreateHashEntry_TCL_DECLARED", "#define Tcl_CreateHashEntry_TCL_DECLARED", "/* 422 */", "EXTERN Tcl_HashEntry *\tTcl_CreateHashEntry(Tcl_HashTable *tablePtr,", "\t\t\t\tCONST char *key, int *newPtr);", "#endif", "#ifndef Tcl_InitCustomHashTable_TCL_DECLARED", "#define Tcl_InitCustomHashTable_TCL_DECLARED", "/* 423 */", "EXTERN void\t\tTcl_InitCustomHashTable(Tcl_HashTable *tablePtr,", "\t\t\t\tint keyType, Tcl_HashKeyType *typePtr);", "#endif", "#ifndef Tcl_InitObjHashTable_TCL_DECLARED", "#define Tcl_InitObjHashTable_TCL_DECLARED", "/* 424 */", "EXTERN void\t\tTcl_InitObjHashTable(Tcl_HashTable *tablePtr);", "#endif", "#ifndef Tcl_CommandTraceInfo_TCL_DECLARED", "#define Tcl_CommandTraceInfo_TCL_DECLARED", "/* 425 */", "EXTERN ClientData\tTcl_CommandTraceInfo(Tcl_Interp *interp,", "\t\t\t\tCONST char *varName, int flags,", "\t\t\t\tTcl_CommandTraceProc *procPtr,", "\t\t\t\tClientData prevClientData);", "#endif", "#ifndef Tcl_TraceCommand_TCL_DECLARED", "#define Tcl_TraceCommand_TCL_DECLARED", "/* 426 */", "EXTERN int\t\tTcl_TraceCommand(Tcl_Interp *interp,", "\t\t\t\tCONST char *varName, int flags,", "\t\t\t\tTcl_CommandTraceProc *proc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tcl_UntraceCommand_TCL_DECLARED", "#define Tcl_UntraceCommand_TCL_DECLARED", "/* 427 */", "EXTERN void\t\tTcl_UntraceCommand(Tcl_Interp *interp,", "\t\t\t\tCONST char *varName, int flags,", "\t\t\t\tTcl_CommandTraceProc *proc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tcl_AttemptAlloc_TCL_DECLARED", "#define Tcl_AttemptAlloc_TCL_DECLARED", "/* 428 */", "EXTERN char *\t\tTcl_AttemptAlloc(unsigned int size);", "#endif", "#ifndef Tcl_AttemptDbCkalloc_TCL_DECLARED", "#define Tcl_AttemptDbCkalloc_TCL_DECLARED", "/* 429 */", "EXTERN char *\t\tTcl_AttemptDbCkalloc(unsigned int size,", "\t\t\t\tCONST char *file, int line);", "#endif", "#ifndef Tcl_AttemptRealloc_TCL_DECLARED", "#define Tcl_AttemptRealloc_TCL_DECLARED", "/* 430 */", "EXTERN char *\t\tTcl_AttemptRealloc(char *ptr, unsigned int size);", "#endif", "#ifndef Tcl_AttemptDbCkrealloc_TCL_DECLARED", "#define Tcl_AttemptDbCkrealloc_TCL_DECLARED", "/* 431 */", "EXTERN char *\t\tTcl_AttemptDbCkrealloc(char *ptr, unsigned int size,", "\t\t\t\tCONST char *file, int line);", "#endif", "#ifndef Tcl_AttemptSetObjLength_TCL_DECLARED", "#define Tcl_AttemptSetObjLength_TCL_DECLARED", "/* 432 */", "EXTERN int\t\tTcl_AttemptSetObjLength(Tcl_Obj *objPtr, int length);", "#endif", "#ifndef Tcl_GetChannelThread_TCL_DECLARED", "#define Tcl_GetChannelThread_TCL_DECLARED", "/* 433 */", "EXTERN Tcl_ThreadId\tTcl_GetChannelThread(Tcl_Channel channel);", "#endif", "#ifndef Tcl_GetUnicodeFromObj_TCL_DECLARED", "#define Tcl_GetUnicodeFromObj_TCL_DECLARED", "/* 434 */", "EXTERN Tcl_UniChar *\tTcl_GetUnicodeFromObj(Tcl_Obj *objPtr,", "\t\t\t\tint *lengthPtr);", "#endif", "#ifndef Tcl_GetMathFuncInfo_TCL_DECLARED", "#define Tcl_GetMathFuncInfo_TCL_DECLARED", "/* 435 */", "EXTERN int\t\tTcl_GetMathFuncInfo(Tcl_Interp *interp,", "\t\t\t\tCONST char *name, int *numArgsPtr,", "\t\t\t\tTcl_ValueType **argTypesPtr,", "\t\t\t\tTcl_MathProc **procPtr,", "\t\t\t\tClientData *clientDataPtr);", "#endif", "#ifndef Tcl_ListMathFuncs_TCL_DECLARED", "#define Tcl_ListMathFuncs_TCL_DECLARED", "/* 436 */", "EXTERN Tcl_Obj *\tTcl_ListMathFuncs(Tcl_Interp *interp,", "\t\t\t\tCONST char *pattern);", "#endif", "#ifndef Tcl_SubstObj_TCL_DECLARED", "#define Tcl_SubstObj_TCL_DECLARED", "/* 437 */", "EXTERN Tcl_Obj *\tTcl_SubstObj(Tcl_Interp *interp, Tcl_Obj *objPtr,", "\t\t\t\tint flags);", "#endif", "#ifndef Tcl_DetachChannel_TCL_DECLARED", "#define Tcl_DetachChannel_TCL_DECLARED", "/* 438 */", "EXTERN int\t\tTcl_DetachChannel(Tcl_Interp *interp,", "\t\t\t\tTcl_Channel channel);", "#endif", "#ifndef Tcl_IsStandardChannel_TCL_DECLARED", "#define Tcl_IsStandardChannel_TCL_DECLARED", "/* 439 */", "EXTERN int\t\tTcl_IsStandardChannel(Tcl_Channel channel);", "#endif", "#ifndef Tcl_FSCopyFile_TCL_DECLARED", "#define Tcl_FSCopyFile_TCL_DECLARED", "/* 440 */", "EXTERN int\t\tTcl_FSCopyFile(Tcl_Obj *srcPathPtr,", "\t\t\t\tTcl_Obj *destPathPtr);", "#endif", "#ifndef Tcl_FSCopyDirectory_TCL_DECLARED", "#define Tcl_FSCopyDirectory_TCL_DECLARED", "/* 441 */", "EXTERN int\t\tTcl_FSCopyDirectory(Tcl_Obj *srcPathPtr,", "\t\t\t\tTcl_Obj *destPathPtr, Tcl_Obj **errorPtr);", "#endif", "#ifndef Tcl_FSCreateDirectory_TCL_DECLARED", "#define Tcl_FSCreateDirectory_TCL_DECLARED", "/* 442 */", "EXTERN int\t\tTcl_FSCreateDirectory(Tcl_Obj *pathPtr);", "#endif", "#ifndef Tcl_FSDeleteFile_TCL_DECLARED", "#define Tcl_FSDeleteFile_TCL_DECLARED", "/* 443 */", "EXTERN int\t\tTcl_FSDeleteFile(Tcl_Obj *pathPtr);", "#endif", "#ifndef Tcl_FSLoadFile_TCL_DECLARED", "#define Tcl_FSLoadFile_TCL_DECLARED", "/* 444 */", "EXTERN int\t\tTcl_FSLoadFile(Tcl_Interp *interp, Tcl_Obj *pathPtr,", "\t\t\t\tCONST char *sym1, CONST char *sym2,", "\t\t\t\tTcl_PackageInitProc **proc1Ptr,", "\t\t\t\tTcl_PackageInitProc **proc2Ptr,", "\t\t\t\tTcl_LoadHandle *handlePtr,", "\t\t\t\tTcl_FSUnloadFileProc **unloadProcPtr);", "#endif", "#ifndef Tcl_FSMatchInDirectory_TCL_DECLARED", "#define Tcl_FSMatchInDirectory_TCL_DECLARED", "/* 445 */", "EXTERN int\t\tTcl_FSMatchInDirectory(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *result, Tcl_Obj *pathPtr,", "\t\t\t\tCONST char *pattern, Tcl_GlobTypeData *types);", "#endif", "#ifndef Tcl_FSLink_TCL_DECLARED", "#define Tcl_FSLink_TCL_DECLARED", "/* 446 */", "EXTERN Tcl_Obj *\tTcl_FSLink(Tcl_Obj *pathPtr, Tcl_Obj *toPtr,", "\t\t\t\tint linkAction);", "#endif", "#ifndef Tcl_FSRemoveDirectory_TCL_DECLARED", "#define Tcl_FSRemoveDirectory_TCL_DECLARED", "/* 447 */", "EXTERN int\t\tTcl_FSRemoveDirectory(Tcl_Obj *pathPtr,", "\t\t\t\tint recursive, Tcl_Obj **errorPtr);", "#endif", "#ifndef Tcl_FSRenameFile_TCL_DECLARED", "#define Tcl_FSRenameFile_TCL_DECLARED", "/* 448 */", "EXTERN int\t\tTcl_FSRenameFile(Tcl_Obj *srcPathPtr,", "\t\t\t\tTcl_Obj *destPathPtr);", "#endif", "#ifndef Tcl_FSLstat_TCL_DECLARED", "#define Tcl_FSLstat_TCL_DECLARED", "/* 449 */", "EXTERN int\t\tTcl_FSLstat(Tcl_Obj *pathPtr, Tcl_StatBuf *buf);", "#endif", "#ifndef Tcl_FSUtime_TCL_DECLARED", "#define Tcl_FSUtime_TCL_DECLARED", "/* 450 */", "EXTERN int\t\tTcl_FSUtime(Tcl_Obj *pathPtr, struct utimbuf *tval);", "#endif", "#ifndef Tcl_FSFileAttrsGet_TCL_DECLARED", "#define Tcl_FSFileAttrsGet_TCL_DECLARED", "/* 451 */", "EXTERN int\t\tTcl_FSFileAttrsGet(Tcl_Interp *interp, int index,", "\t\t\t\tTcl_Obj *pathPtr, Tcl_Obj **objPtrRef);", "#endif", "#ifndef Tcl_FSFileAttrsSet_TCL_DECLARED", "#define Tcl_FSFileAttrsSet_TCL_DECLARED", "/* 452 */", "EXTERN int\t\tTcl_FSFileAttrsSet(Tcl_Interp *interp, int index,", "\t\t\t\tTcl_Obj *pathPtr, Tcl_Obj *objPtr);", "#endif", "#ifndef Tcl_FSFileAttrStrings_TCL_DECLARED", "#define Tcl_FSFileAttrStrings_TCL_DECLARED", "/* 453 */", "EXTERN CONST char **\tTcl_FSFileAttrStrings(Tcl_Obj *pathPtr,", "\t\t\t\tTcl_Obj **objPtrRef);", "#endif", "#ifndef Tcl_FSStat_TCL_DECLARED", "#define Tcl_FSStat_TCL_DECLARED", "/* 454 */", "EXTERN int\t\tTcl_FSStat(Tcl_Obj *pathPtr, Tcl_StatBuf *buf);", "#endif", "#ifndef Tcl_FSAccess_TCL_DECLARED", "#define Tcl_FSAccess_TCL_DECLARED", "/* 455 */", "EXTERN int\t\tTcl_FSAccess(Tcl_Obj *pathPtr, int mode);", "#endif", "#ifndef Tcl_FSOpenFileChannel_TCL_DECLARED", "#define Tcl_FSOpenFileChannel_TCL_DECLARED", "/* 456 */", "EXTERN Tcl_Channel\tTcl_FSOpenFileChannel(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *pathPtr, CONST char *modeString,", "\t\t\t\tint permissions);", "#endif", "#ifndef Tcl_FSGetCwd_TCL_DECLARED", "#define Tcl_FSGetCwd_TCL_DECLARED", "/* 457 */", "EXTERN Tcl_Obj *\tTcl_FSGetCwd(Tcl_Interp *interp);", "#endif", "#ifndef Tcl_FSChdir_TCL_DECLARED", "#define Tcl_FSChdir_TCL_DECLARED", "/* 458 */", "EXTERN int\t\tTcl_FSChdir(Tcl_Obj *pathPtr);", "#endif", "#ifndef Tcl_FSConvertToPathType_TCL_DECLARED", "#define Tcl_FSConvertToPathType_TCL_DECLARED", "/* 459 */", "EXTERN int\t\tTcl_FSConvertToPathType(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *pathPtr);", "#endif", "#ifndef Tcl_FSJoinPath_TCL_DECLARED", "#define Tcl_FSJoinPath_TCL_DECLARED", "/* 460 */", "EXTERN Tcl_Obj *\tTcl_FSJoinPath(Tcl_Obj *listObj, int elements);", "#endif", "#ifndef Tcl_FSSplitPath_TCL_DECLARED", "#define Tcl_FSSplitPath_TCL_DECLARED", "/* 461 */", "EXTERN Tcl_Obj *\tTcl_FSSplitPath(Tcl_Obj *pathPtr, int *lenPtr);", "#endif", "#ifndef Tcl_FSEqualPaths_TCL_DECLARED", "#define Tcl_FSEqualPaths_TCL_DECLARED", "/* 462 */", "EXTERN int\t\tTcl_FSEqualPaths(Tcl_Obj *firstPtr,", "\t\t\t\tTcl_Obj *secondPtr);", "#endif", "#ifndef Tcl_FSGetNormalizedPath_TCL_DECLARED", "#define Tcl_FSGetNormalizedPath_TCL_DECLARED", "/* 463 */", "EXTERN Tcl_Obj *\tTcl_FSGetNormalizedPath(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *pathPtr);", "#endif", "#ifndef Tcl_FSJoinToPath_TCL_DECLARED", "#define Tcl_FSJoinToPath_TCL_DECLARED", "/* 464 */", "EXTERN Tcl_Obj *\tTcl_FSJoinToPath(Tcl_Obj *pathPtr, int objc,", "\t\t\t\tTcl_Obj *CONST objv[]);", "#endif", "#ifndef Tcl_FSGetInternalRep_TCL_DECLARED", "#define Tcl_FSGetInternalRep_TCL_DECLARED", "/* 465 */", "EXTERN ClientData\tTcl_FSGetInternalRep(Tcl_Obj *pathPtr,", "\t\t\t\tTcl_Filesystem *fsPtr);", "#endif", "#ifndef Tcl_FSGetTranslatedPath_TCL_DECLARED", "#define Tcl_FSGetTranslatedPath_TCL_DECLARED", "/* 466 */", "EXTERN Tcl_Obj *\tTcl_FSGetTranslatedPath(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *pathPtr);", "#endif", "#ifndef Tcl_FSEvalFile_TCL_DECLARED", "#define Tcl_FSEvalFile_TCL_DECLARED", "/* 467 */", "EXTERN int\t\tTcl_FSEvalFile(Tcl_Interp *interp, Tcl_Obj *fileName);", "#endif", "#ifndef Tcl_FSNewNativePath_TCL_DECLARED", "#define Tcl_FSNewNativePath_TCL_DECLARED", "/* 468 */", "EXTERN Tcl_Obj *\tTcl_FSNewNativePath(Tcl_Filesystem *fromFilesystem,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tcl_FSGetNativePath_TCL_DECLARED", "#define Tcl_FSGetNativePath_TCL_DECLARED", "/* 469 */", "EXTERN CONST char *\tTcl_FSGetNativePath(Tcl_Obj *pathPtr);", "#endif", "#ifndef Tcl_FSFileSystemInfo_TCL_DECLARED", "#define Tcl_FSFileSystemInfo_TCL_DECLARED", "/* 470 */", "EXTERN Tcl_Obj *\tTcl_FSFileSystemInfo(Tcl_Obj *pathPtr);", "#endif", "#ifndef Tcl_FSPathSeparator_TCL_DECLARED", "#define Tcl_FSPathSeparator_TCL_DECLARED", "/* 471 */", "EXTERN Tcl_Obj *\tTcl_FSPathSeparator(Tcl_Obj *pathPtr);", "#endif", "#ifndef Tcl_FSListVolumes_TCL_DECLARED", "#define Tcl_FSListVolumes_TCL_DECLARED", "/* 472 */", "EXTERN Tcl_Obj *\tTcl_FSListVolumes(void);", "#endif", "#ifndef Tcl_FSRegister_TCL_DECLARED", "#define Tcl_FSRegister_TCL_DECLARED", "/* 473 */", "EXTERN int\t\tTcl_FSRegister(ClientData clientData,", "\t\t\t\tTcl_Filesystem *fsPtr);", "#endif", "#ifndef Tcl_FSUnregister_TCL_DECLARED", "#define Tcl_FSUnregister_TCL_DECLARED", "/* 474 */", "EXTERN int\t\tTcl_FSUnregister(Tcl_Filesystem *fsPtr);", "#endif", "#ifndef Tcl_FSData_TCL_DECLARED", "#define Tcl_FSData_TCL_DECLARED", "/* 475 */", "EXTERN ClientData\tTcl_FSData(Tcl_Filesystem *fsPtr);", "#endif", "#ifndef Tcl_FSGetTranslatedStringPath_TCL_DECLARED", "#define Tcl_FSGetTranslatedStringPath_TCL_DECLARED", "/* 476 */", "EXTERN CONST char *\tTcl_FSGetTranslatedStringPath(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *pathPtr);", "#endif", "#ifndef Tcl_FSGetFileSystemForPath_TCL_DECLARED", "#define Tcl_FSGetFileSystemForPath_TCL_DECLARED", "/* 477 */", "EXTERN Tcl_Filesystem *\t Tcl_FSGetFileSystemForPath(Tcl_Obj *pathPtr);", "#endif", "#ifndef Tcl_FSGetPathType_TCL_DECLARED", "#define Tcl_FSGetPathType_TCL_DECLARED", "/* 478 */", "EXTERN Tcl_PathType\tTcl_FSGetPathType(Tcl_Obj *pathPtr);", "#endif", "#ifndef Tcl_OutputBuffered_TCL_DECLARED", "#define Tcl_OutputBuffered_TCL_DECLARED", "/* 479 */", "EXTERN int\t\tTcl_OutputBuffered(Tcl_Channel chan);", "#endif", "#ifndef Tcl_FSMountsChanged_TCL_DECLARED", "#define Tcl_FSMountsChanged_TCL_DECLARED", "/* 480 */", "EXTERN void\t\tTcl_FSMountsChanged(Tcl_Filesystem *fsPtr);", "#endif", "#ifndef Tcl_EvalTokensStandard_TCL_DECLARED", "#define Tcl_EvalTokensStandard_TCL_DECLARED", "/* 481 */", "EXTERN int\t\tTcl_EvalTokensStandard(Tcl_Interp *interp,", "\t\t\t\tTcl_Token *tokenPtr, int count);", "#endif", "#ifndef Tcl_GetTime_TCL_DECLARED", "#define Tcl_GetTime_TCL_DECLARED", "/* 482 */", "EXTERN void\t\tTcl_GetTime(Tcl_Time *timeBuf);", "#endif", "#ifndef Tcl_CreateObjTrace_TCL_DECLARED", "#define Tcl_CreateObjTrace_TCL_DECLARED", "/* 483 */", "EXTERN Tcl_Trace\tTcl_CreateObjTrace(Tcl_Interp *interp, int level,", "\t\t\t\tint flags, Tcl_CmdObjTraceProc *objProc,", "\t\t\t\tClientData clientData,", "\t\t\t\tTcl_CmdObjTraceDeleteProc *delProc);", "#endif", "#ifndef Tcl_GetCommandInfoFromToken_TCL_DECLARED", "#define Tcl_GetCommandInfoFromToken_TCL_DECLARED", "/* 484 */", "EXTERN int\t\tTcl_GetCommandInfoFromToken(Tcl_Command token,", "\t\t\t\tTcl_CmdInfo *infoPtr);", "#endif", "#ifndef Tcl_SetCommandInfoFromToken_TCL_DECLARED", "#define Tcl_SetCommandInfoFromToken_TCL_DECLARED", "/* 485 */", "EXTERN int\t\tTcl_SetCommandInfoFromToken(Tcl_Command token,", "\t\t\t\tCONST Tcl_CmdInfo *infoPtr);", "#endif", "#ifndef Tcl_DbNewWideIntObj_TCL_DECLARED", "#define Tcl_DbNewWideIntObj_TCL_DECLARED", "/* 486 */", "EXTERN Tcl_Obj *\tTcl_DbNewWideIntObj(Tcl_WideInt wideValue,", "\t\t\t\tCONST char *file, int line);", "#endif", "#ifndef Tcl_GetWideIntFromObj_TCL_DECLARED", "#define Tcl_GetWideIntFromObj_TCL_DECLARED", "/* 487 */", "EXTERN int\t\tTcl_GetWideIntFromObj(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *objPtr, Tcl_WideInt *widePtr);", "#endif", "#ifndef Tcl_NewWideIntObj_TCL_DECLARED", "#define Tcl_NewWideIntObj_TCL_DECLARED", "/* 488 */", "EXTERN Tcl_Obj *\tTcl_NewWideIntObj(Tcl_WideInt wideValue);", "#endif", "#ifndef Tcl_SetWideIntObj_TCL_DECLARED", "#define Tcl_SetWideIntObj_TCL_DECLARED", "/* 489 */", "EXTERN void\t\tTcl_SetWideIntObj(Tcl_Obj *objPtr,", "\t\t\t\tTcl_WideInt wideValue);", "#endif", "#ifndef Tcl_AllocStatBuf_TCL_DECLARED", "#define Tcl_AllocStatBuf_TCL_DECLARED", "/* 490 */", "EXTERN Tcl_StatBuf *\tTcl_AllocStatBuf(void);", "#endif", "#ifndef Tcl_Seek_TCL_DECLARED", "#define Tcl_Seek_TCL_DECLARED", "/* 491 */", "EXTERN Tcl_WideInt\tTcl_Seek(Tcl_Channel chan, Tcl_WideInt offset,", "\t\t\t\tint mode);", "#endif", "#ifndef Tcl_Tell_TCL_DECLARED", "#define Tcl_Tell_TCL_DECLARED", "/* 492 */", "EXTERN Tcl_WideInt\tTcl_Tell(Tcl_Channel chan);", "#endif", "#ifndef Tcl_ChannelWideSeekProc_TCL_DECLARED", "#define Tcl_ChannelWideSeekProc_TCL_DECLARED", "/* 493 */", "EXTERN Tcl_DriverWideSeekProc * Tcl_ChannelWideSeekProc(", "\t\t\t\tCONST Tcl_ChannelType *chanTypePtr);", "#endif", "#ifndef Tcl_DictObjPut_TCL_DECLARED", "#define Tcl_DictObjPut_TCL_DECLARED", "/* 494 */", "EXTERN int\t\tTcl_DictObjPut(Tcl_Interp *interp, Tcl_Obj *dictPtr,", "\t\t\t\tTcl_Obj *keyPtr, Tcl_Obj *valuePtr);", "#endif", "#ifndef Tcl_DictObjGet_TCL_DECLARED", "#define Tcl_DictObjGet_TCL_DECLARED", "/* 495 */", "EXTERN int\t\tTcl_DictObjGet(Tcl_Interp *interp, Tcl_Obj *dictPtr,", "\t\t\t\tTcl_Obj *keyPtr, Tcl_Obj **valuePtrPtr);", "#endif", "#ifndef Tcl_DictObjRemove_TCL_DECLARED", "#define Tcl_DictObjRemove_TCL_DECLARED", "/* 496 */", "EXTERN int\t\tTcl_DictObjRemove(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *dictPtr, Tcl_Obj *keyPtr);", "#endif", "#ifndef Tcl_DictObjSize_TCL_DECLARED", "#define Tcl_DictObjSize_TCL_DECLARED", "/* 497 */", "EXTERN int\t\tTcl_DictObjSize(Tcl_Interp *interp, Tcl_Obj *dictPtr,", "\t\t\t\tint *sizePtr);", "#endif", "#ifndef Tcl_DictObjFirst_TCL_DECLARED", "#define Tcl_DictObjFirst_TCL_DECLARED", "/* 498 */", "EXTERN int\t\tTcl_DictObjFirst(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *dictPtr, Tcl_DictSearch *searchPtr,", "\t\t\t\tTcl_Obj **keyPtrPtr, Tcl_Obj **valuePtrPtr,", "\t\t\t\tint *donePtr);", "#endif", "#ifndef Tcl_DictObjNext_TCL_DECLARED", "#define Tcl_DictObjNext_TCL_DECLARED", "/* 499 */", "EXTERN void\t\tTcl_DictObjNext(Tcl_DictSearch *searchPtr,", "\t\t\t\tTcl_Obj **keyPtrPtr, Tcl_Obj **valuePtrPtr,", "\t\t\t\tint *donePtr);", "#endif", "#ifndef Tcl_DictObjDone_TCL_DECLARED", "#define Tcl_DictObjDone_TCL_DECLARED", "/* 500 */", "EXTERN void\t\tTcl_DictObjDone(Tcl_DictSearch *searchPtr);", "#endif", "#ifndef Tcl_DictObjPutKeyList_TCL_DECLARED", "#define Tcl_DictObjPutKeyList_TCL_DECLARED", "/* 501 */", "EXTERN int\t\tTcl_DictObjPutKeyList(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *dictPtr, int keyc,", "\t\t\t\tTcl_Obj *CONST *keyv, Tcl_Obj *valuePtr);", "#endif", "#ifndef Tcl_DictObjRemoveKeyList_TCL_DECLARED", "#define Tcl_DictObjRemoveKeyList_TCL_DECLARED", "/* 502 */", "EXTERN int\t\tTcl_DictObjRemoveKeyList(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *dictPtr, int keyc,", "\t\t\t\tTcl_Obj *CONST *keyv);", "#endif", "#ifndef Tcl_NewDictObj_TCL_DECLARED", "#define Tcl_NewDictObj_TCL_DECLARED", "/* 503 */", "EXTERN Tcl_Obj *\tTcl_NewDictObj(void);", "#endif", "#ifndef Tcl_DbNewDictObj_TCL_DECLARED", "#define Tcl_DbNewDictObj_TCL_DECLARED", "/* 504 */", "EXTERN Tcl_Obj *\tTcl_DbNewDictObj(CONST char *file, int line);", "#endif", "#ifndef Tcl_RegisterConfig_TCL_DECLARED", "#define Tcl_RegisterConfig_TCL_DECLARED", "/* 505 */", "EXTERN void\t\tTcl_RegisterConfig(Tcl_Interp *interp,", "\t\t\t\tCONST char *pkgName,", "\t\t\t\tTcl_Config *configuration,", "\t\t\t\tCONST char *valEncoding);", "#endif", "#ifndef Tcl_CreateNamespace_TCL_DECLARED", "#define Tcl_CreateNamespace_TCL_DECLARED", "/* 506 */", "EXTERN Tcl_Namespace *\tTcl_CreateNamespace(Tcl_Interp *interp,", "\t\t\t\tCONST char *name, ClientData clientData,", "\t\t\t\tTcl_NamespaceDeleteProc *deleteProc);", "#endif", "#ifndef Tcl_DeleteNamespace_TCL_DECLARED", "#define Tcl_DeleteNamespace_TCL_DECLARED", "/* 507 */", "EXTERN void\t\tTcl_DeleteNamespace(Tcl_Namespace *nsPtr);", "#endif", "#ifndef Tcl_AppendExportList_TCL_DECLARED", "#define Tcl_AppendExportList_TCL_DECLARED", "/* 508 */", "EXTERN int\t\tTcl_AppendExportList(Tcl_Interp *interp,", "\t\t\t\tTcl_Namespace *nsPtr, Tcl_Obj *objPtr);", "#endif", "#ifndef Tcl_Export_TCL_DECLARED", "#define Tcl_Export_TCL_DECLARED", "/* 509 */", "EXTERN int\t\tTcl_Export(Tcl_Interp *interp, Tcl_Namespace *nsPtr,", "\t\t\t\tCONST char *pattern, int resetListFirst);", "#endif", "#ifndef Tcl_Import_TCL_DECLARED", "#define Tcl_Import_TCL_DECLARED", "/* 510 */", "EXTERN int\t\tTcl_Import(Tcl_Interp *interp, Tcl_Namespace *nsPtr,", "\t\t\t\tCONST char *pattern, int allowOverwrite);", "#endif", "#ifndef Tcl_ForgetImport_TCL_DECLARED", "#define Tcl_ForgetImport_TCL_DECLARED", "/* 511 */", "EXTERN int\t\tTcl_ForgetImport(Tcl_Interp *interp,", "\t\t\t\tTcl_Namespace *nsPtr, CONST char *pattern);", "#endif", "#ifndef Tcl_GetCurrentNamespace_TCL_DECLARED", "#define Tcl_GetCurrentNamespace_TCL_DECLARED", "/* 512 */", "EXTERN Tcl_Namespace *\tTcl_GetCurrentNamespace(Tcl_Interp *interp);", "#endif", "#ifndef Tcl_GetGlobalNamespace_TCL_DECLARED", "#define Tcl_GetGlobalNamespace_TCL_DECLARED", "/* 513 */", "EXTERN Tcl_Namespace *\tTcl_GetGlobalNamespace(Tcl_Interp *interp);", "#endif", "#ifndef Tcl_FindNamespace_TCL_DECLARED", "#define Tcl_FindNamespace_TCL_DECLARED", "/* 514 */", "EXTERN Tcl_Namespace *\tTcl_FindNamespace(Tcl_Interp *interp,", "\t\t\t\tCONST char *name,", "\t\t\t\tTcl_Namespace *contextNsPtr, int flags);", "#endif", "#ifndef Tcl_FindCommand_TCL_DECLARED", "#define Tcl_FindCommand_TCL_DECLARED", "/* 515 */", "EXTERN Tcl_Command\tTcl_FindCommand(Tcl_Interp *interp, CONST char *name,", "\t\t\t\tTcl_Namespace *contextNsPtr, int flags);", "#endif", "#ifndef Tcl_GetCommandFromObj_TCL_DECLARED", "#define Tcl_GetCommandFromObj_TCL_DECLARED", "/* 516 */", "EXTERN Tcl_Command\tTcl_GetCommandFromObj(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *objPtr);", "#endif", "#ifndef Tcl_GetCommandFullName_TCL_DECLARED", "#define Tcl_GetCommandFullName_TCL_DECLARED", "/* 517 */", "EXTERN void\t\tTcl_GetCommandFullName(Tcl_Interp *interp,", "\t\t\t\tTcl_Command command, Tcl_Obj *objPtr);", "#endif", "#ifndef Tcl_FSEvalFileEx_TCL_DECLARED", "#define Tcl_FSEvalFileEx_TCL_DECLARED", "/* 518 */", "EXTERN int\t\tTcl_FSEvalFileEx(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *fileName, CONST char *encodingName);", "#endif", "#ifndef Tcl_SetExitProc_TCL_DECLARED", "#define Tcl_SetExitProc_TCL_DECLARED", "/* 519 */", "EXTERN Tcl_ExitProc *\tTcl_SetExitProc(Tcl_ExitProc *proc);", "#endif", "#ifndef Tcl_LimitAddHandler_TCL_DECLARED", "#define Tcl_LimitAddHandler_TCL_DECLARED", "/* 520 */", "EXTERN void\t\tTcl_LimitAddHandler(Tcl_Interp *interp, int type,", "\t\t\t\tTcl_LimitHandlerProc *handlerProc,", "\t\t\t\tClientData clientData,", "\t\t\t\tTcl_LimitHandlerDeleteProc *deleteProc);", "#endif", "#ifndef Tcl_LimitRemoveHandler_TCL_DECLARED", "#define Tcl_LimitRemoveHandler_TCL_DECLARED", "/* 521 */", "EXTERN void\t\tTcl_LimitRemoveHandler(Tcl_Interp *interp, int type,", "\t\t\t\tTcl_LimitHandlerProc *handlerProc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tcl_LimitReady_TCL_DECLARED", "#define Tcl_LimitReady_TCL_DECLARED", "/* 522 */", "EXTERN int\t\tTcl_LimitReady(Tcl_Interp *interp);", "#endif", "#ifndef Tcl_LimitCheck_TCL_DECLARED", "#define Tcl_LimitCheck_TCL_DECLARED", "/* 523 */", "EXTERN int\t\tTcl_LimitCheck(Tcl_Interp *interp);", "#endif", "#ifndef Tcl_LimitExceeded_TCL_DECLARED", "#define Tcl_LimitExceeded_TCL_DECLARED", "/* 524 */", "EXTERN int\t\tTcl_LimitExceeded(Tcl_Interp *interp);", "#endif", "#ifndef Tcl_LimitSetCommands_TCL_DECLARED", "#define Tcl_LimitSetCommands_TCL_DECLARED", "/* 525 */", "EXTERN void\t\tTcl_LimitSetCommands(Tcl_Interp *interp,", "\t\t\t\tint commandLimit);", "#endif", "#ifndef Tcl_LimitSetTime_TCL_DECLARED", "#define Tcl_LimitSetTime_TCL_DECLARED", "/* 526 */", "EXTERN void\t\tTcl_LimitSetTime(Tcl_Interp *interp,", "\t\t\t\tTcl_Time *timeLimitPtr);", "#endif", "#ifndef Tcl_LimitSetGranularity_TCL_DECLARED", "#define Tcl_LimitSetGranularity_TCL_DECLARED", "/* 527 */", "EXTERN void\t\tTcl_LimitSetGranularity(Tcl_Interp *interp, int type,", "\t\t\t\tint granularity);", "#endif", "#ifndef Tcl_LimitTypeEnabled_TCL_DECLARED", "#define Tcl_LimitTypeEnabled_TCL_DECLARED", "/* 528 */", "EXTERN int\t\tTcl_LimitTypeEnabled(Tcl_Interp *interp, int type);", "#endif", "#ifndef Tcl_LimitTypeExceeded_TCL_DECLARED", "#define Tcl_LimitTypeExceeded_TCL_DECLARED", "/* 529 */", "EXTERN int\t\tTcl_LimitTypeExceeded(Tcl_Interp *interp, int type);", "#endif", "#ifndef Tcl_LimitTypeSet_TCL_DECLARED", "#define Tcl_LimitTypeSet_TCL_DECLARED", "/* 530 */", "EXTERN void\t\tTcl_LimitTypeSet(Tcl_Interp *interp, int type);", "#endif", "#ifndef Tcl_LimitTypeReset_TCL_DECLARED", "#define Tcl_LimitTypeReset_TCL_DECLARED", "/* 531 */", "EXTERN void\t\tTcl_LimitTypeReset(Tcl_Interp *interp, int type);", "#endif", "#ifndef Tcl_LimitGetCommands_TCL_DECLARED", "#define Tcl_LimitGetCommands_TCL_DECLARED", "/* 532 */", "EXTERN int\t\tTcl_LimitGetCommands(Tcl_Interp *interp);", "#endif", "#ifndef Tcl_LimitGetTime_TCL_DECLARED", "#define Tcl_LimitGetTime_TCL_DECLARED", "/* 533 */", "EXTERN void\t\tTcl_LimitGetTime(Tcl_Interp *interp,", "\t\t\t\tTcl_Time *timeLimitPtr);", "#endif", "#ifndef Tcl_LimitGetGranularity_TCL_DECLARED", "#define Tcl_LimitGetGranularity_TCL_DECLARED", "/* 534 */", "EXTERN int\t\tTcl_LimitGetGranularity(Tcl_Interp *interp, int type);", "#endif", "#ifndef Tcl_SaveInterpState_TCL_DECLARED", "#define Tcl_SaveInterpState_TCL_DECLARED", "/* 535 */", "EXTERN Tcl_InterpState\tTcl_SaveInterpState(Tcl_Interp *interp, int status);", "#endif", "#ifndef Tcl_RestoreInterpState_TCL_DECLARED", "#define Tcl_RestoreInterpState_TCL_DECLARED", "/* 536 */", "EXTERN int\t\tTcl_RestoreInterpState(Tcl_Interp *interp,", "\t\t\t\tTcl_InterpState state);", "#endif", "#ifndef Tcl_DiscardInterpState_TCL_DECLARED", "#define Tcl_DiscardInterpState_TCL_DECLARED", "/* 537 */", "EXTERN void\t\tTcl_DiscardInterpState(Tcl_InterpState state);", "#endif", "#ifndef Tcl_SetReturnOptions_TCL_DECLARED", "#define Tcl_SetReturnOptions_TCL_DECLARED", "/* 538 */", "EXTERN int\t\tTcl_SetReturnOptions(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *options);", "#endif", "#ifndef Tcl_GetReturnOptions_TCL_DECLARED", "#define Tcl_GetReturnOptions_TCL_DECLARED", "/* 539 */", "EXTERN Tcl_Obj *\tTcl_GetReturnOptions(Tcl_Interp *interp, int result);", "#endif", "#ifndef Tcl_IsEnsemble_TCL_DECLARED", "#define Tcl_IsEnsemble_TCL_DECLARED", "/* 540 */", "EXTERN int\t\tTcl_IsEnsemble(Tcl_Command token);", "#endif", "#ifndef Tcl_CreateEnsemble_TCL_DECLARED", "#define Tcl_CreateEnsemble_TCL_DECLARED", "/* 541 */", "EXTERN Tcl_Command\tTcl_CreateEnsemble(Tcl_Interp *interp,", "\t\t\t\tCONST char *name,", "\t\t\t\tTcl_Namespace *namespacePtr, int flags);", "#endif", "#ifndef Tcl_FindEnsemble_TCL_DECLARED", "#define Tcl_FindEnsemble_TCL_DECLARED", "/* 542 */", "EXTERN Tcl_Command\tTcl_FindEnsemble(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *cmdNameObj, int flags);", "#endif", "#ifndef Tcl_SetEnsembleSubcommandList_TCL_DECLARED", "#define Tcl_SetEnsembleSubcommandList_TCL_DECLARED", "/* 543 */", "EXTERN int\t\tTcl_SetEnsembleSubcommandList(Tcl_Interp *interp,", "\t\t\t\tTcl_Command token, Tcl_Obj *subcmdList);", "#endif", "#ifndef Tcl_SetEnsembleMappingDict_TCL_DECLARED", "#define Tcl_SetEnsembleMappingDict_TCL_DECLARED", "/* 544 */", "EXTERN int\t\tTcl_SetEnsembleMappingDict(Tcl_Interp *interp,", "\t\t\t\tTcl_Command token, Tcl_Obj *mapDict);", "#endif", "#ifndef Tcl_SetEnsembleUnknownHandler_TCL_DECLARED", "#define Tcl_SetEnsembleUnknownHandler_TCL_DECLARED", "/* 545 */", "EXTERN int\t\tTcl_SetEnsembleUnknownHandler(Tcl_Interp *interp,", "\t\t\t\tTcl_Command token, Tcl_Obj *unknownList);", "#endif", "#ifndef Tcl_SetEnsembleFlags_TCL_DECLARED", "#define Tcl_SetEnsembleFlags_TCL_DECLARED", "/* 546 */", "EXTERN int\t\tTcl_SetEnsembleFlags(Tcl_Interp *interp,", "\t\t\t\tTcl_Command token, int flags);", "#endif", "#ifndef Tcl_GetEnsembleSubcommandList_TCL_DECLARED", "#define Tcl_GetEnsembleSubcommandList_TCL_DECLARED", "/* 547 */", "EXTERN int\t\tTcl_GetEnsembleSubcommandList(Tcl_Interp *interp,", "\t\t\t\tTcl_Command token, Tcl_Obj **subcmdListPtr);", "#endif", "#ifndef Tcl_GetEnsembleMappingDict_TCL_DECLARED", "#define Tcl_GetEnsembleMappingDict_TCL_DECLARED", "/* 548 */", "EXTERN int\t\tTcl_GetEnsembleMappingDict(Tcl_Interp *interp,", "\t\t\t\tTcl_Command token, Tcl_Obj **mapDictPtr);", "#endif", "#ifndef Tcl_GetEnsembleUnknownHandler_TCL_DECLARED", "#define Tcl_GetEnsembleUnknownHandler_TCL_DECLARED", "/* 549 */", "EXTERN int\t\tTcl_GetEnsembleUnknownHandler(Tcl_Interp *interp,", "\t\t\t\tTcl_Command token, Tcl_Obj **unknownListPtr);", "#endif", "#ifndef Tcl_GetEnsembleFlags_TCL_DECLARED", "#define Tcl_GetEnsembleFlags_TCL_DECLARED", "/* 550 */", "EXTERN int\t\tTcl_GetEnsembleFlags(Tcl_Interp *interp,", "\t\t\t\tTcl_Command token, int *flagsPtr);", "#endif", "#ifndef Tcl_GetEnsembleNamespace_TCL_DECLARED", "#define Tcl_GetEnsembleNamespace_TCL_DECLARED", "/* 551 */", "EXTERN int\t\tTcl_GetEnsembleNamespace(Tcl_Interp *interp,", "\t\t\t\tTcl_Command token,", "\t\t\t\tTcl_Namespace **namespacePtrPtr);", "#endif", "#ifndef Tcl_SetTimeProc_TCL_DECLARED", "#define Tcl_SetTimeProc_TCL_DECLARED", "/* 552 */", "EXTERN void\t\tTcl_SetTimeProc(Tcl_GetTimeProc *getProc,", "\t\t\t\tTcl_ScaleTimeProc *scaleProc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tcl_QueryTimeProc_TCL_DECLARED", "#define Tcl_QueryTimeProc_TCL_DECLARED", "/* 553 */", "EXTERN void\t\tTcl_QueryTimeProc(Tcl_GetTimeProc **getProc,", "\t\t\t\tTcl_ScaleTimeProc **scaleProc,", "\t\t\t\tClientData *clientData);", "#endif", "#ifndef Tcl_ChannelThreadActionProc_TCL_DECLARED", "#define Tcl_ChannelThreadActionProc_TCL_DECLARED", "/* 554 */", "EXTERN Tcl_DriverThreadActionProc * Tcl_ChannelThreadActionProc(", "\t\t\t\tCONST Tcl_ChannelType *chanTypePtr);", "#endif", "#ifndef Tcl_NewBignumObj_TCL_DECLARED", "#define Tcl_NewBignumObj_TCL_DECLARED", "/* 555 */", "EXTERN Tcl_Obj *\tTcl_NewBignumObj(mp_int *value);", "#endif", "#ifndef Tcl_DbNewBignumObj_TCL_DECLARED", "#define Tcl_DbNewBignumObj_TCL_DECLARED", "/* 556 */", "EXTERN Tcl_Obj *\tTcl_DbNewBignumObj(mp_int *value, CONST char *file,", "\t\t\t\tint line);", "#endif", "#ifndef Tcl_SetBignumObj_TCL_DECLARED", "#define Tcl_SetBignumObj_TCL_DECLARED", "/* 557 */", "EXTERN void\t\tTcl_SetBignumObj(Tcl_Obj *obj, mp_int *value);", "#endif", "#ifndef Tcl_GetBignumFromObj_TCL_DECLARED", "#define Tcl_GetBignumFromObj_TCL_DECLARED", "/* 558 */", "EXTERN int\t\tTcl_GetBignumFromObj(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *obj, mp_int *value);", "#endif", "#ifndef Tcl_TakeBignumFromObj_TCL_DECLARED", "#define Tcl_TakeBignumFromObj_TCL_DECLARED", "/* 559 */", "EXTERN int\t\tTcl_TakeBignumFromObj(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *obj, mp_int *value);", "#endif", "#ifndef Tcl_TruncateChannel_TCL_DECLARED", "#define Tcl_TruncateChannel_TCL_DECLARED", "/* 560 */", "EXTERN int\t\tTcl_TruncateChannel(Tcl_Channel chan,", "\t\t\t\tTcl_WideInt length);", "#endif", "#ifndef Tcl_ChannelTruncateProc_TCL_DECLARED", "#define Tcl_ChannelTruncateProc_TCL_DECLARED", "/* 561 */", "EXTERN Tcl_DriverTruncateProc * Tcl_ChannelTruncateProc(", "\t\t\t\tCONST Tcl_ChannelType *chanTypePtr);", "#endif", "#ifndef Tcl_SetChannelErrorInterp_TCL_DECLARED", "#define Tcl_SetChannelErrorInterp_TCL_DECLARED", "/* 562 */", "EXTERN void\t\tTcl_SetChannelErrorInterp(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *msg);", "#endif", "#ifndef Tcl_GetChannelErrorInterp_TCL_DECLARED", "#define Tcl_GetChannelErrorInterp_TCL_DECLARED", "/* 563 */", "EXTERN void\t\tTcl_GetChannelErrorInterp(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj **msg);", "#endif", "#ifndef Tcl_SetChannelError_TCL_DECLARED", "#define Tcl_SetChannelError_TCL_DECLARED", "/* 564 */", "EXTERN void\t\tTcl_SetChannelError(Tcl_Channel chan, Tcl_Obj *msg);", "#endif", "#ifndef Tcl_GetChannelError_TCL_DECLARED", "#define Tcl_GetChannelError_TCL_DECLARED", "/* 565 */", "EXTERN void\t\tTcl_GetChannelError(Tcl_Channel chan, Tcl_Obj **msg);", "#endif", "#ifndef Tcl_InitBignumFromDouble_TCL_DECLARED", "#define Tcl_InitBignumFromDouble_TCL_DECLARED", "/* 566 */", "EXTERN int\t\tTcl_InitBignumFromDouble(Tcl_Interp *interp,", "\t\t\t\tdouble initval, mp_int *toInit);", "#endif", "#ifndef Tcl_GetNamespaceUnknownHandler_TCL_DECLARED", "#define Tcl_GetNamespaceUnknownHandler_TCL_DECLARED", "/* 567 */", "EXTERN Tcl_Obj *\tTcl_GetNamespaceUnknownHandler(Tcl_Interp *interp,", "\t\t\t\tTcl_Namespace *nsPtr);", "#endif", "#ifndef Tcl_SetNamespaceUnknownHandler_TCL_DECLARED", "#define Tcl_SetNamespaceUnknownHandler_TCL_DECLARED", "/* 568 */", "EXTERN int\t\tTcl_SetNamespaceUnknownHandler(Tcl_Interp *interp,", "\t\t\t\tTcl_Namespace *nsPtr, Tcl_Obj *handlerPtr);", "#endif", "#ifndef Tcl_GetEncodingFromObj_TCL_DECLARED", "#define Tcl_GetEncodingFromObj_TCL_DECLARED", "/* 569 */", "EXTERN int\t\tTcl_GetEncodingFromObj(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *objPtr, Tcl_Encoding *encodingPtr);", "#endif", "#ifndef Tcl_GetEncodingSearchPath_TCL_DECLARED", "#define Tcl_GetEncodingSearchPath_TCL_DECLARED", "/* 570 */", "EXTERN Tcl_Obj *\tTcl_GetEncodingSearchPath(void);", "#endif", "#ifndef Tcl_SetEncodingSearchPath_TCL_DECLARED", "#define Tcl_SetEncodingSearchPath_TCL_DECLARED", "/* 571 */", "EXTERN int\t\tTcl_SetEncodingSearchPath(Tcl_Obj *searchPath);", "#endif", "#ifndef Tcl_GetEncodingNameFromEnvironment_TCL_DECLARED", "#define Tcl_GetEncodingNameFromEnvironment_TCL_DECLARED", "/* 572 */", "EXTERN CONST char *\tTcl_GetEncodingNameFromEnvironment(", "\t\t\t\tTcl_DString *bufPtr);", "#endif", "#ifndef Tcl_PkgRequireProc_TCL_DECLARED", "#define Tcl_PkgRequireProc_TCL_DECLARED", "/* 573 */", "EXTERN int\t\tTcl_PkgRequireProc(Tcl_Interp *interp,", "\t\t\t\tCONST char *name, int objc,", "\t\t\t\tTcl_Obj *CONST objv[],", "\t\t\t\tClientData *clientDataPtr);", "#endif", "#ifndef Tcl_AppendObjToErrorInfo_TCL_DECLARED", "#define Tcl_AppendObjToErrorInfo_TCL_DECLARED", "/* 574 */", "EXTERN void\t\tTcl_AppendObjToErrorInfo(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *objPtr);", "#endif", "#ifndef Tcl_AppendLimitedToObj_TCL_DECLARED", "#define Tcl_AppendLimitedToObj_TCL_DECLARED", "/* 575 */", "EXTERN void\t\tTcl_AppendLimitedToObj(Tcl_Obj *objPtr,", "\t\t\t\tCONST char *bytes, int length, int limit,", "\t\t\t\tCONST char *ellipsis);", "#endif", "#ifndef Tcl_Format_TCL_DECLARED", "#define Tcl_Format_TCL_DECLARED", "/* 576 */", "EXTERN Tcl_Obj *\tTcl_Format(Tcl_Interp *interp, CONST char *format,", "\t\t\t\tint objc, Tcl_Obj *CONST objv[]);", "#endif", "#ifndef Tcl_AppendFormatToObj_TCL_DECLARED", "#define Tcl_AppendFormatToObj_TCL_DECLARED", "/* 577 */", "EXTERN int\t\tTcl_AppendFormatToObj(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *objPtr, CONST char *format,", "\t\t\t\tint objc, Tcl_Obj *CONST objv[]);", "#endif", "#ifndef Tcl_ObjPrintf_TCL_DECLARED", "#define Tcl_ObjPrintf_TCL_DECLARED", "/* 578 */", "EXTERN Tcl_Obj *\tTcl_ObjPrintf(CONST char *format, ...);", "#endif", "#ifndef Tcl_AppendPrintfToObj_TCL_DECLARED", "#define Tcl_AppendPrintfToObj_TCL_DECLARED", "/* 579 */", "EXTERN void\t\tTcl_AppendPrintfToObj(Tcl_Obj *objPtr,", "\t\t\t\tCONST char *format, ...);", "#endif", "", "typedef struct TclStubHooks {", "    struct TclPlatStubs *tclPlatStubs;", "    struct TclIntStubs *tclIntStubs;", "    struct TclIntPlatStubs *tclIntPlatStubs;", "} TclStubHooks;", "", "typedef struct TclStubs {", "    int magic;", "    struct TclStubHooks *hooks;", "", "    int (*tcl_PkgProvideEx) (Tcl_Interp *interp, CONST char *name, CONST char *version, ClientData clientData); /* 0 */", "    CONST84_RETURN char * (*tcl_PkgRequireEx) (Tcl_Interp *interp, CONST char *name, CONST char *version, int exact, ClientData *clientDataPtr); /* 1 */", "    void (*tcl_Panic) (CONST char *format, ...); /* 2 */", "    char * (*tcl_Alloc) (unsigned int size); /* 3 */", "    void (*tcl_Free) (char *ptr); /* 4 */", "    char * (*tcl_Realloc) (char *ptr, unsigned int size); /* 5 */", "    char * (*tcl_DbCkalloc) (unsigned int size, CONST char *file, int line); /* 6 */", "    int (*tcl_DbCkfree) (char *ptr, CONST char *file, int line); /* 7 */", "    char * (*tcl_DbCkrealloc) (char *ptr, unsigned int size, CONST char *file, int line); /* 8 */", "#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */", "    void (*tcl_CreateFileHandler) (int fd, int mask, Tcl_FileProc *proc, ClientData clientData); /* 9 */", "#endif /* UNIX */", "#ifdef __WIN32__ /* WIN */", "    void *reserved9;", "#endif /* WIN */", "#ifdef MAC_OSX_TCL /* MACOSX */", "    void (*tcl_CreateFileHandler) (int fd, int mask, Tcl_FileProc *proc, ClientData clientData); /* 9 */", "#endif /* MACOSX */", "#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */", "    void (*tcl_DeleteFileHandler) (int fd); /* 10 */", "#endif /* UNIX */", "#ifdef __WIN32__ /* WIN */", "    void *reserved10;", "#endif /* WIN */", "#ifdef MAC_OSX_TCL /* MACOSX */", "    void (*tcl_DeleteFileHandler) (int fd); /* 10 */", "#endif /* MACOSX */", "    void (*tcl_SetTimer) (Tcl_Time *timePtr); /* 11 */", "    void (*tcl_Sleep) (int ms); /* 12 */", "    int (*tcl_WaitForEvent) (Tcl_Time *timePtr); /* 13 */", "    int (*tcl_AppendAllObjTypes) (Tcl_Interp *interp, Tcl_Obj *objPtr); /* 14 */", "    void (*tcl_AppendStringsToObj) (Tcl_Obj *objPtr, ...); /* 15 */", "    void (*tcl_AppendToObj) (Tcl_Obj *objPtr, CONST char *bytes, int length); /* 16 */", "    Tcl_Obj * (*tcl_ConcatObj) (int objc, Tcl_Obj *CONST objv[]); /* 17 */", "    int (*tcl_ConvertToType) (Tcl_Interp *interp, Tcl_Obj *objPtr, Tcl_ObjType *typePtr); /* 18 */", "    void (*tcl_DbDecrRefCount) (Tcl_Obj *objPtr, CONST char *file, int line); /* 19 */", "    void (*tcl_DbIncrRefCount) (Tcl_Obj *objPtr, CONST char *file, int line); /* 20 */", "    int (*tcl_DbIsShared) (Tcl_Obj *objPtr, CONST char *file, int line); /* 21 */", "    Tcl_Obj * (*tcl_DbNewBooleanObj) (int boolValue, CONST char *file, int line); /* 22 */", "    Tcl_Obj * (*tcl_DbNewByteArrayObj) (CONST unsigned char *bytes, int length, CONST char *file, int line); /* 23 */", "    Tcl_Obj * (*tcl_DbNewDoubleObj) (double doubleValue, CONST char *file, int line); /* 24 */", "    Tcl_Obj * (*tcl_DbNewListObj) (int objc, Tcl_Obj *CONST *objv, CONST char *file, int line); /* 25 */", "    Tcl_Obj * (*tcl_DbNewLongObj) (long longValue, CONST char *file, int line); /* 26 */", "    Tcl_Obj * (*tcl_DbNewObj) (CONST char *file, int line); /* 27 */", "    Tcl_Obj * (*tcl_DbNewStringObj) (CONST char *bytes, int length, CONST char *file, int line); /* 28 */", "    Tcl_Obj * (*tcl_DuplicateObj) (Tcl_Obj *objPtr); /* 29 */", "    void (*tclFreeObj) (Tcl_Obj *objPtr); /* 30 */", "    int (*tcl_GetBoolean) (Tcl_Interp *interp, CONST char *src, int *boolPtr); /* 31 */", "    int (*tcl_GetBooleanFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, int *boolPtr); /* 32 */", "    unsigned char * (*tcl_GetByteArrayFromObj) (Tcl_Obj *objPtr, int *lengthPtr); /* 33 */", "    int (*tcl_GetDouble) (Tcl_Interp *interp, CONST char *src, double *doublePtr); /* 34 */", "    int (*tcl_GetDoubleFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, double *doublePtr); /* 35 */", "    int (*tcl_GetIndexFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, CONST84 char **tablePtr, CONST char *msg, int flags, int *indexPtr); /* 36 */", "    int (*tcl_GetInt) (Tcl_Interp *interp, CONST char *src, int *intPtr); /* 37 */", "    int (*tcl_GetIntFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, int *intPtr); /* 38 */", "    int (*tcl_GetLongFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, long *longPtr); /* 39 */", "    Tcl_ObjType * (*tcl_GetObjType) (CONST char *typeName); /* 40 */", "    char * (*tcl_GetStringFromObj) (Tcl_Obj *objPtr, int *lengthPtr); /* 41 */", "    void (*tcl_InvalidateStringRep) (Tcl_Obj *objPtr); /* 42 */", "    int (*tcl_ListObjAppendList) (Tcl_Interp *interp, Tcl_Obj *listPtr, Tcl_Obj *elemListPtr); /* 43 */", "    int (*tcl_ListObjAppendElement) (Tcl_Interp *interp, Tcl_Obj *listPtr, Tcl_Obj *objPtr); /* 44 */", "    int (*tcl_ListObjGetElements) (Tcl_Interp *interp, Tcl_Obj *listPtr, int *objcPtr, Tcl_Obj ***objvPtr); /* 45 */", "    int (*tcl_ListObjIndex) (Tcl_Interp *interp, Tcl_Obj *listPtr, int index, Tcl_Obj **objPtrPtr); /* 46 */", "    int (*tcl_ListObjLength) (Tcl_Interp *interp, Tcl_Obj *listPtr, int *lengthPtr); /* 47 */", "    int (*tcl_ListObjReplace) (Tcl_Interp *interp, Tcl_Obj *listPtr, int first, int count, int objc, Tcl_Obj *CONST objv[]); /* 48 */", "    Tcl_Obj * (*tcl_NewBooleanObj) (int boolValue); /* 49 */", "    Tcl_Obj * (*tcl_NewByteArrayObj) (CONST unsigned char *bytes, int length); /* 50 */", "    Tcl_Obj * (*tcl_NewDoubleObj) (double doubleValue); /* 51 */", "    Tcl_Obj * (*tcl_NewIntObj) (int intValue); /* 52 */", "    Tcl_Obj * (*tcl_NewListObj) (int objc, Tcl_Obj *CONST objv[]); /* 53 */", "    Tcl_Obj * (*tcl_NewLongObj) (long longValue); /* 54 */", "    Tcl_Obj * (*tcl_NewObj) (void); /* 55 */", "    Tcl_Obj * (*tcl_NewStringObj) (CONST char *bytes, int length); /* 56 */", "    void (*tcl_SetBooleanObj) (Tcl_Obj *objPtr, int boolValue); /* 57 */", "    unsigned char * (*tcl_SetByteArrayLength) (Tcl_Obj *objPtr, int length); /* 58 */", "    void (*tcl_SetByteArrayObj) (Tcl_Obj *objPtr, CONST unsigned char *bytes, int length); /* 59 */", "    void (*tcl_SetDoubleObj) (Tcl_Obj *objPtr, double doubleValue); /* 60 */", "    void (*tcl_SetIntObj) (Tcl_Obj *objPtr, int intValue); /* 61 */", "    void (*tcl_SetListObj) (Tcl_Obj *objPtr, int objc, Tcl_Obj *CONST objv[]); /* 62 */", "    void (*tcl_SetLongObj) (Tcl_Obj *objPtr, long longValue); /* 63 */", "    void (*tcl_SetObjLength) (Tcl_Obj *objPtr, int length); /* 64 */", "    void (*tcl_SetStringObj) (Tcl_Obj *objPtr, CONST char *bytes, int length); /* 65 */", "    void (*tcl_AddErrorInfo) (Tcl_Interp *interp, CONST char *message); /* 66 */", "    void (*tcl_AddObjErrorInfo) (Tcl_Interp *interp, CONST char *message, int length); /* 67 */", "    void (*tcl_AllowExceptions) (Tcl_Interp *interp); /* 68 */", "    void (*tcl_AppendElement) (Tcl_Interp *interp, CONST char *element); /* 69 */", "    void (*tcl_AppendResult) (Tcl_Interp *interp, ...); /* 70 */", "    Tcl_AsyncHandler (*tcl_AsyncCreate) (Tcl_AsyncProc *proc, ClientData clientData); /* 71 */", "    void (*tcl_AsyncDelete) (Tcl_AsyncHandler async); /* 72 */", "    int (*tcl_AsyncInvoke) (Tcl_Interp *interp, int code); /* 73 */", "    void (*tcl_AsyncMark) (Tcl_AsyncHandler async); /* 74 */", "    int (*tcl_AsyncReady) (void); /* 75 */", "    void (*tcl_BackgroundError) (Tcl_Interp *interp); /* 76 */", "    char (*tcl_Backslash) (CONST char *src, int *readPtr); /* 77 */", "    int (*tcl_BadChannelOption) (Tcl_Interp *interp, CONST char *optionName, CONST char *optionList); /* 78 */", "    void (*tcl_CallWhenDeleted) (Tcl_Interp *interp, Tcl_InterpDeleteProc *proc, ClientData clientData); /* 79 */", "    void (*tcl_CancelIdleCall) (Tcl_IdleProc *idleProc, ClientData clientData); /* 80 */", "    int (*tcl_Close) (Tcl_Interp *interp, Tcl_Channel chan); /* 81 */", "    int (*tcl_CommandComplete) (CONST char *cmd); /* 82 */", "    char * (*tcl_Concat) (int argc, CONST84 char *CONST *argv); /* 83 */", "    int (*tcl_ConvertElement) (CONST char *src, char *dst, int flags); /* 84 */", "    int (*tcl_ConvertCountedElement) (CONST char *src, int length, char *dst, int flags); /* 85 */", "    int (*tcl_CreateAlias) (Tcl_Interp *slave, CONST char *slaveCmd, Tcl_Interp *target, CONST char *targetCmd, int argc, CONST84 char *CONST *argv); /* 86 */", "    int (*tcl_CreateAliasObj) (Tcl_Interp *slave, CONST char *slaveCmd, Tcl_Interp *target, CONST char *targetCmd, int objc, Tcl_Obj *CONST objv[]); /* 87 */", "    Tcl_Channel (*tcl_CreateChannel) (Tcl_ChannelType *typePtr, CONST char *chanName, ClientData instanceData, int mask); /* 88 */", "    void (*tcl_CreateChannelHandler) (Tcl_Channel chan, int mask, Tcl_ChannelProc *proc, ClientData clientData); /* 89 */", "    void (*tcl_CreateCloseHandler) (Tcl_Channel chan, Tcl_CloseProc *proc, ClientData clientData); /* 90 */", "    Tcl_Command (*tcl_CreateCommand) (Tcl_Interp *interp, CONST char *cmdName, Tcl_CmdProc *proc, ClientData clientData, Tcl_CmdDeleteProc *deleteProc); /* 91 */", "    void (*tcl_CreateEventSource) (Tcl_EventSetupProc *setupProc, Tcl_EventCheckProc *checkProc, ClientData clientData); /* 92 */", "    void (*tcl_CreateExitHandler) (Tcl_ExitProc *proc, ClientData clientData); /* 93 */", "    Tcl_Interp * (*tcl_CreateInterp) (void); /* 94 */", "    void (*tcl_CreateMathFunc) (Tcl_Interp *interp, CONST char *name, int numArgs, Tcl_ValueType *argTypes, Tcl_MathProc *proc, ClientData clientData); /* 95 */", "    Tcl_Command (*tcl_CreateObjCommand) (Tcl_Interp *interp, CONST char *cmdName, Tcl_ObjCmdProc *proc, ClientData clientData, Tcl_CmdDeleteProc *deleteProc); /* 96 */", "    Tcl_Interp * (*tcl_CreateSlave) (Tcl_Interp *interp, CONST char *slaveName, int isSafe); /* 97 */", "    Tcl_TimerToken (*tcl_CreateTimerHandler) (int milliseconds, Tcl_TimerProc *proc, ClientData clientData); /* 98 */", "    Tcl_Trace (*tcl_CreateTrace) (Tcl_Interp *interp, int level, Tcl_CmdTraceProc *proc, ClientData clientData); /* 99 */", "    void (*tcl_DeleteAssocData) (Tcl_Interp *interp, CONST char *name); /* 100 */", "    void (*tcl_DeleteChannelHandler) (Tcl_Channel chan, Tcl_ChannelProc *proc, ClientData clientData); /* 101 */", "    void (*tcl_DeleteCloseHandler) (Tcl_Channel chan, Tcl_CloseProc *proc, ClientData clientData); /* 102 */", "    int (*tcl_DeleteCommand) (Tcl_Interp *interp, CONST char *cmdName); /* 103 */", "    int (*tcl_DeleteCommandFromToken) (Tcl_Interp *interp, Tcl_Command command); /* 104 */", "    void (*tcl_DeleteEvents) (Tcl_EventDeleteProc *proc, ClientData clientData); /* 105 */", "    void (*tcl_DeleteEventSource) (Tcl_EventSetupProc *setupProc, Tcl_EventCheckProc *checkProc, ClientData clientData); /* 106 */", "    void (*tcl_DeleteExitHandler) (Tcl_ExitProc *proc, ClientData clientData); /* 107 */", "    void (*tcl_DeleteHashEntry) (Tcl_HashEntry *entryPtr); /* 108 */", "    void (*tcl_DeleteHashTable) (Tcl_HashTable *tablePtr); /* 109 */", "    void (*tcl_DeleteInterp) (Tcl_Interp *interp); /* 110 */", "    void (*tcl_DetachPids) (int numPids, Tcl_Pid *pidPtr); /* 111 */", "    void (*tcl_DeleteTimerHandler) (Tcl_TimerToken token); /* 112 */", "    void (*tcl_DeleteTrace) (Tcl_Interp *interp, Tcl_Trace trace); /* 113 */", "    void (*tcl_DontCallWhenDeleted) (Tcl_Interp *interp, Tcl_InterpDeleteProc *proc, ClientData clientData); /* 114 */", "    int (*tcl_DoOneEvent) (int flags); /* 115 */", "    void (*tcl_DoWhenIdle) (Tcl_IdleProc *proc, ClientData clientData); /* 116 */", "    char * (*tcl_DStringAppend) (Tcl_DString *dsPtr, CONST char *bytes, int length); /* 117 */", "    char * (*tcl_DStringAppendElement) (Tcl_DString *dsPtr, CONST char *element); /* 118 */", "    void (*tcl_DStringEndSublist) (Tcl_DString *dsPtr); /* 119 */", "    void (*tcl_DStringFree) (Tcl_DString *dsPtr); /* 120 */", "    void (*tcl_DStringGetResult) (Tcl_Interp *interp, Tcl_DString *dsPtr); /* 121 */", "    void (*tcl_DStringInit) (Tcl_DString *dsPtr); /* 122 */", "    void (*tcl_DStringResult) (Tcl_Interp *interp, Tcl_DString *dsPtr); /* 123 */", "    void (*tcl_DStringSetLength) (Tcl_DString *dsPtr, int length); /* 124 */", "    void (*tcl_DStringStartSublist) (Tcl_DString *dsPtr); /* 125 */", "    int (*tcl_Eof) (Tcl_Channel chan); /* 126 */", "    CONST84_RETURN char * (*tcl_ErrnoId) (void); /* 127 */", "    CONST84_RETURN char * (*tcl_ErrnoMsg) (int err); /* 128 */", "    int (*tcl_Eval) (Tcl_Interp *interp, CONST char *script); /* 129 */", "    int (*tcl_EvalFile) (Tcl_Interp *interp, CONST char *fileName); /* 130 */", "    int (*tcl_EvalObj) (Tcl_Interp *interp, Tcl_Obj *objPtr); /* 131 */", "    void (*tcl_EventuallyFree) (ClientData clientData, Tcl_FreeProc *freeProc); /* 132 */", "    void (*tcl_Exit) (int status); /* 133 */", "    int (*tcl_ExposeCommand) (Tcl_Interp *interp, CONST char *hiddenCmdToken, CONST char *cmdName); /* 134 */", "    int (*tcl_ExprBoolean) (Tcl_Interp *interp, CONST char *expr, int *ptr); /* 135 */", "    int (*tcl_ExprBooleanObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, int *ptr); /* 136 */", "    int (*tcl_ExprDouble) (Tcl_Interp *interp, CONST char *expr, double *ptr); /* 137 */", "    int (*tcl_ExprDoubleObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, double *ptr); /* 138 */", "    int (*tcl_ExprLong) (Tcl_Interp *interp, CONST char *expr, long *ptr); /* 139 */", "    int (*tcl_ExprLongObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, long *ptr); /* 140 */", "    int (*tcl_ExprObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, Tcl_Obj **resultPtrPtr); /* 141 */", "    int (*tcl_ExprString) (Tcl_Interp *interp, CONST char *expr); /* 142 */", "    void (*tcl_Finalize) (void); /* 143 */", "    void (*tcl_FindExecutable) (CONST char *argv0); /* 144 */", "    Tcl_HashEntry * (*tcl_FirstHashEntry) (Tcl_HashTable *tablePtr, Tcl_HashSearch *searchPtr); /* 145 */", "    int (*tcl_Flush) (Tcl_Channel chan); /* 146 */", "    void (*tcl_FreeResult) (Tcl_Interp *interp); /* 147 */", "    int (*tcl_GetAlias) (Tcl_Interp *interp, CONST char *slaveCmd, Tcl_Interp **targetInterpPtr, CONST84 char **targetCmdPtr, int *argcPtr, CONST84 char ***argvPtr); /* 148 */", "    int (*tcl_GetAliasObj) (Tcl_Interp *interp, CONST char *slaveCmd, Tcl_Interp **targetInterpPtr, CONST84 char **targetCmdPtr, int *objcPtr, Tcl_Obj ***objv); /* 149 */", "    ClientData (*tcl_GetAssocData) (Tcl_Interp *interp, CONST char *name, Tcl_InterpDeleteProc **procPtr); /* 150 */", "    Tcl_Channel (*tcl_GetChannel) (Tcl_Interp *interp, CONST char *chanName, int *modePtr); /* 151 */", "    int (*tcl_GetChannelBufferSize) (Tcl_Channel chan); /* 152 */", "    int (*tcl_GetChannelHandle) (Tcl_Channel chan, int direction, ClientData *handlePtr); /* 153 */", "    ClientData (*tcl_GetChannelInstanceData) (Tcl_Channel chan); /* 154 */", "    int (*tcl_GetChannelMode) (Tcl_Channel chan); /* 155 */", "    CONST84_RETURN char * (*tcl_GetChannelName) (Tcl_Channel chan); /* 156 */", "    int (*tcl_GetChannelOption) (Tcl_Interp *interp, Tcl_Channel chan, CONST char *optionName, Tcl_DString *dsPtr); /* 157 */", "    Tcl_ChannelType * (*tcl_GetChannelType) (Tcl_Channel chan); /* 158 */", "    int (*tcl_GetCommandInfo) (Tcl_Interp *interp, CONST char *cmdName, Tcl_CmdInfo *infoPtr); /* 159 */", "    CONST84_RETURN char * (*tcl_GetCommandName) (Tcl_Interp *interp, Tcl_Command command); /* 160 */", "    int (*tcl_GetErrno) (void); /* 161 */", "    CONST84_RETURN char * (*tcl_GetHostName) (void); /* 162 */", "    int (*tcl_GetInterpPath) (Tcl_Interp *askInterp, Tcl_Interp *slaveInterp); /* 163 */", "    Tcl_Interp * (*tcl_GetMaster) (Tcl_Interp *interp); /* 164 */", "    CONST char * (*tcl_GetNameOfExecutable) (void); /* 165 */", "    Tcl_Obj * (*tcl_GetObjResult) (Tcl_Interp *interp); /* 166 */", "#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */", "    int (*tcl_GetOpenFile) (Tcl_Interp *interp, CONST char *chanID, int forWriting, int checkUsage, ClientData *filePtr); /* 167 */", "#endif /* UNIX */", "#ifdef __WIN32__ /* WIN */", "    void *reserved167;", "#endif /* WIN */", "#ifdef MAC_OSX_TCL /* MACOSX */", "    int (*tcl_GetOpenFile) (Tcl_Interp *interp, CONST char *chanID, int forWriting, int checkUsage, ClientData *filePtr); /* 167 */", "#endif /* MACOSX */", "    Tcl_PathType (*tcl_GetPathType) (CONST char *path); /* 168 */", "    int (*tcl_Gets) (Tcl_Channel chan, Tcl_DString *dsPtr); /* 169 */", "    int (*tcl_GetsObj) (Tcl_Channel chan, Tcl_Obj *objPtr); /* 170 */", "    int (*tcl_GetServiceMode) (void); /* 171 */", "    Tcl_Interp * (*tcl_GetSlave) (Tcl_Interp *interp, CONST char *slaveName); /* 172 */", "    Tcl_Channel (*tcl_GetStdChannel) (int type); /* 173 */", "    CONST84_RETURN char * (*tcl_GetStringResult) (Tcl_Interp *interp); /* 174 */", "    CONST84_RETURN char * (*tcl_GetVar) (Tcl_Interp *interp, CONST char *varName, int flags); /* 175 */", "    CONST84_RETURN char * (*tcl_GetVar2) (Tcl_Interp *interp, CONST char *part1, CONST char *part2, int flags); /* 176 */", "    int (*tcl_GlobalEval) (Tcl_Interp *interp, CONST char *command); /* 177 */", "    int (*tcl_GlobalEvalObj) (Tcl_Interp *interp, Tcl_Obj *objPtr); /* 178 */", "    int (*tcl_HideCommand) (Tcl_Interp *interp, CONST char *cmdName, CONST char *hiddenCmdToken); /* 179 */", "    int (*tcl_Init) (Tcl_Interp *interp); /* 180 */", "    void (*tcl_InitHashTable) (Tcl_HashTable *tablePtr, int keyType); /* 181 */", "    int (*tcl_InputBlocked) (Tcl_Channel chan); /* 182 */", "    int (*tcl_InputBuffered) (Tcl_Channel chan); /* 183 */", "    int (*tcl_InterpDeleted) (Tcl_Interp *interp); /* 184 */", "    int (*tcl_IsSafe) (Tcl_Interp *interp); /* 185 */", "    char * (*tcl_JoinPath) (int argc, CONST84 char *CONST *argv, Tcl_DString *resultPtr); /* 186 */", "    int (*tcl_LinkVar) (Tcl_Interp *interp, CONST char *varName, char *addr, int type); /* 187 */", "    void *reserved188;", "    Tcl_Channel (*tcl_MakeFileChannel) (ClientData handle, int mode); /* 189 */", "    int (*tcl_MakeSafe) (Tcl_Interp *interp); /* 190 */", "    Tcl_Channel (*tcl_MakeTcpClientChannel) (ClientData tcpSocket); /* 191 */", "    char * (*tcl_Merge) (int argc, CONST84 char *CONST *argv); /* 192 */", "    Tcl_HashEntry * (*tcl_NextHashEntry) (Tcl_HashSearch *searchPtr); /* 193 */", "    void (*tcl_NotifyChannel) (Tcl_Channel channel, int mask); /* 194 */", "    Tcl_Obj * (*tcl_ObjGetVar2) (Tcl_Interp *interp, Tcl_Obj *part1Ptr, Tcl_Obj *part2Ptr, int flags); /* 195 */", "    Tcl_Obj * (*tcl_ObjSetVar2) (Tcl_Interp *interp, Tcl_Obj *part1Ptr, Tcl_Obj *part2Ptr, Tcl_Obj *newValuePtr, int flags); /* 196 */", "    Tcl_Channel (*tcl_OpenCommandChannel) (Tcl_Interp *interp, int argc, CONST84 char **argv, int flags); /* 197 */", "    Tcl_Channel (*tcl_OpenFileChannel) (Tcl_Interp *interp, CONST char *fileName, CONST char *modeString, int permissions); /* 198 */", "    Tcl_Channel (*tcl_OpenTcpClient) (Tcl_Interp *interp, int port, CONST char *address, CONST char *myaddr, int myport, int async); /* 199 */", "    Tcl_Channel (*tcl_OpenTcpServer) (Tcl_Interp *interp, int port, CONST char *host, Tcl_TcpAcceptProc *acceptProc, ClientData callbackData); /* 200 */", "    void (*tcl_Preserve) (ClientData data); /* 201 */", "    void (*tcl_PrintDouble) (Tcl_Interp *interp, double value, char *dst); /* 202 */", "    int (*tcl_PutEnv) (CONST char *assignment); /* 203 */", "    CONST84_RETURN char * (*tcl_PosixError) (Tcl_Interp *interp); /* 204 */", "    void (*tcl_QueueEvent) (Tcl_Event *evPtr, Tcl_QueuePosition position); /* 205 */", "    int (*tcl_Read) (Tcl_Channel chan, char *bufPtr, int toRead); /* 206 */", "    void (*tcl_ReapDetachedProcs) (void); /* 207 */", "    int (*tcl_RecordAndEval) (Tcl_Interp *interp, CONST char *cmd, int flags); /* 208 */", "    int (*tcl_RecordAndEvalObj) (Tcl_Interp *interp, Tcl_Obj *cmdPtr, int flags); /* 209 */", "    void (*tcl_RegisterChannel) (Tcl_Interp *interp, Tcl_Channel chan); /* 210 */", "    void (*tcl_RegisterObjType) (Tcl_ObjType *typePtr); /* 211 */", "    Tcl_RegExp (*tcl_RegExpCompile) (Tcl_Interp *interp, CONST char *pattern); /* 212 */", "    int (*tcl_RegExpExec) (Tcl_Interp *interp, Tcl_RegExp regexp, CONST char *text, CONST char *start); /* 213 */", "    int (*tcl_RegExpMatch) (Tcl_Interp *interp, CONST char *text, CONST char *pattern); /* 214 */", "    void (*tcl_RegExpRange) (Tcl_RegExp regexp, int index, CONST84 char **startPtr, CONST84 char **endPtr); /* 215 */", "    void (*tcl_Release) (ClientData clientData); /* 216 */", "    void (*tcl_ResetResult) (Tcl_Interp *interp); /* 217 */", "    int (*tcl_ScanElement) (CONST char *str, int *flagPtr); /* 218 */", "    int (*tcl_ScanCountedElement) (CONST char *str, int length, int *flagPtr); /* 219 */", "    int (*tcl_SeekOld) (Tcl_Channel chan, int offset, int mode); /* 220 */", "    int (*tcl_ServiceAll) (void); /* 221 */", "    int (*tcl_ServiceEvent) (int flags); /* 222 */", "    void (*tcl_SetAssocData) (Tcl_Interp *interp, CONST char *name, Tcl_InterpDeleteProc *proc, ClientData clientData); /* 223 */", "    void (*tcl_SetChannelBufferSize) (Tcl_Channel chan, int sz); /* 224 */", "    int (*tcl_SetChannelOption) (Tcl_Interp *interp, Tcl_Channel chan, CONST char *optionName, CONST char *newValue); /* 225 */", "    int (*tcl_SetCommandInfo) (Tcl_Interp *interp, CONST char *cmdName, CONST Tcl_CmdInfo *infoPtr); /* 226 */", "    void (*tcl_SetErrno) (int err); /* 227 */", "    void (*tcl_SetErrorCode) (Tcl_Interp *interp, ...); /* 228 */", "    void (*tcl_SetMaxBlockTime) (Tcl_Time *timePtr); /* 229 */", "    void (*tcl_SetPanicProc) (Tcl_PanicProc *panicProc); /* 230 */", "    int (*tcl_SetRecursionLimit) (Tcl_Interp *interp, int depth); /* 231 */", "    void (*tcl_SetResult) (Tcl_Interp *interp, char *result, Tcl_FreeProc *freeProc); /* 232 */", "    int (*tcl_SetServiceMode) (int mode); /* 233 */", "    void (*tcl_SetObjErrorCode) (Tcl_Interp *interp, Tcl_Obj *errorObjPtr); /* 234 */", "    void (*tcl_SetObjResult) (Tcl_Interp *interp, Tcl_Obj *resultObjPtr); /* 235 */", "    void (*tcl_SetStdChannel) (Tcl_Channel channel, int type); /* 236 */", "    CONST84_RETURN char * (*tcl_SetVar) (Tcl_Interp *interp, CONST char *varName, CONST char *newValue, int flags); /* 237 */", "    CONST84_RETURN char * (*tcl_SetVar2) (Tcl_Interp *interp, CONST char *part1, CONST char *part2, CONST char *newValue, int flags); /* 238 */", "    CONST84_RETURN char * (*tcl_SignalId) (int sig); /* 239 */", "    CONST84_RETURN char * (*tcl_SignalMsg) (int sig); /* 240 */", "    void (*tcl_SourceRCFile) (Tcl_Interp *interp); /* 241 */", "    int (*tcl_SplitList) (Tcl_Interp *interp, CONST char *listStr, int *argcPtr, CONST84 char ***argvPtr); /* 242 */", "    void (*tcl_SplitPath) (CONST char *path, int *argcPtr, CONST84 char ***argvPtr); /* 243 */", "    void (*tcl_StaticPackage) (Tcl_Interp *interp, CONST char *pkgName, Tcl_PackageInitProc *initProc, Tcl_PackageInitProc *safeInitProc); /* 244 */", "    int (*tcl_StringMatch) (CONST char *str, CONST char *pattern); /* 245 */", "    int (*tcl_TellOld) (Tcl_Channel chan); /* 246 */", "    int (*tcl_TraceVar) (Tcl_Interp *interp, CONST char *varName, int flags, Tcl_VarTraceProc *proc, ClientData clientData); /* 247 */", "    int (*tcl_TraceVar2) (Tcl_Interp *interp, CONST char *part1, CONST char *part2, int flags, Tcl_VarTraceProc *proc, ClientData clientData); /* 248 */", "    char * (*tcl_TranslateFileName) (Tcl_Interp *interp, CONST char *name, Tcl_DString *bufferPtr); /* 249 */", "    int (*tcl_Ungets) (Tcl_Channel chan, CONST char *str, int len, int atHead); /* 250 */", "    void (*tcl_UnlinkVar) (Tcl_Interp *interp, CONST char *varName); /* 251 */", "    int (*tcl_UnregisterChannel) (Tcl_Interp *interp, Tcl_Channel chan); /* 252 */", "    int (*tcl_UnsetVar) (Tcl_Interp *interp, CONST char *varName, int flags); /* 253 */", "    int (*tcl_UnsetVar2) (Tcl_Interp *interp, CONST char *part1, CONST char *part2, int flags); /* 254 */", "    void (*tcl_UntraceVar) (Tcl_Interp *interp, CONST char *varName, int flags, Tcl_VarTraceProc *proc, ClientData clientData); /* 255 */", "    void (*tcl_UntraceVar2) (Tcl_Interp *interp, CONST char *part1, CONST char *part2, int flags, Tcl_VarTraceProc *proc, ClientData clientData); /* 256 */", "    void (*tcl_UpdateLinkedVar) (Tcl_Interp *interp, CONST char *varName); /* 257 */", "    int (*tcl_UpVar) (Tcl_Interp *interp, CONST char *frameName, CONST char *varName, CONST char *localName, int flags); /* 258 */", "    int (*tcl_UpVar2) (Tcl_Interp *interp, CONST char *frameName, CONST char *part1, CONST char *part2, CONST char *localName, int flags); /* 259 */", "    int (*tcl_VarEval) (Tcl_Interp *interp, ...); /* 260 */", "    ClientData (*tcl_VarTraceInfo) (Tcl_Interp *interp, CONST char *varName, int flags, Tcl_VarTraceProc *procPtr, ClientData prevClientData); /* 261 */", "    ClientData (*tcl_VarTraceInfo2) (Tcl_Interp *interp, CONST char *part1, CONST char *part2, int flags, Tcl_VarTraceProc *procPtr, ClientData prevClientData); /* 262 */", "    int (*tcl_Write) (Tcl_Channel chan, CONST char *s, int slen); /* 263 */", "    void (*tcl_WrongNumArgs) (Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[], CONST char *message); /* 264 */", "    int (*tcl_DumpActiveMemory) (CONST char *fileName); /* 265 */", "    void (*tcl_ValidateAllMemory) (CONST char *file, int line); /* 266 */", "    void (*tcl_AppendResultVA) (Tcl_Interp *interp, va_list argList); /* 267 */", "    void (*tcl_AppendStringsToObjVA) (Tcl_Obj *objPtr, va_list argList); /* 268 */", "    char * (*tcl_HashStats) (Tcl_HashTable *tablePtr); /* 269 */", "    CONST84_RETURN char * (*tcl_ParseVar) (Tcl_Interp *interp, CONST char *start, CONST84 char **termPtr); /* 270 */", "    CONST84_RETURN char * (*tcl_PkgPresent) (Tcl_Interp *interp, CONST char *name, CONST char *version, int exact); /* 271 */", "    CONST84_RETURN char * (*tcl_PkgPresentEx) (Tcl_Interp *interp, CONST char *name, CONST char *version, int exact, ClientData *clientDataPtr); /* 272 */", "    int (*tcl_PkgProvide) (Tcl_Interp *interp, CONST char *name, CONST char *version); /* 273 */", "    CONST84_RETURN char * (*tcl_PkgRequire) (Tcl_Interp *interp, CONST char *name, CONST char *version, int exact); /* 274 */", "    void (*tcl_SetErrorCodeVA) (Tcl_Interp *interp, va_list argList); /* 275 */", "    int (*tcl_VarEvalVA) (Tcl_Interp *interp, va_list argList); /* 276 */", "    Tcl_Pid (*tcl_WaitPid) (Tcl_Pid pid, int *statPtr, int options); /* 277 */", "    void (*tcl_PanicVA) (CONST char *format, va_list argList); /* 278 */", "    void (*tcl_GetVersion) (int *major, int *minor, int *patchLevel, int *type); /* 279 */", "    void (*tcl_InitMemory) (Tcl_Interp *interp); /* 280 */", "    Tcl_Channel (*tcl_StackChannel) (Tcl_Interp *interp, Tcl_ChannelType *typePtr, ClientData instanceData, int mask, Tcl_Channel prevChan); /* 281 */", "    int (*tcl_UnstackChannel) (Tcl_Interp *interp, Tcl_Channel chan); /* 282 */", "    Tcl_Channel (*tcl_GetStackedChannel) (Tcl_Channel chan); /* 283 */", "    void (*tcl_SetMainLoop) (Tcl_MainLoopProc *proc); /* 284 */", "    void *reserved285;", "    void (*tcl_AppendObjToObj) (Tcl_Obj *objPtr, Tcl_Obj *appendObjPtr); /* 286 */", "    Tcl_Encoding (*tcl_CreateEncoding) (CONST Tcl_EncodingType *typePtr); /* 287 */", "    void (*tcl_CreateThreadExitHandler) (Tcl_ExitProc *proc, ClientData clientData); /* 288 */", "    void (*tcl_DeleteThreadExitHandler) (Tcl_ExitProc *proc, ClientData clientData); /* 289 */", "    void (*tcl_DiscardResult) (Tcl_SavedResult *statePtr); /* 290 */", "    int (*tcl_EvalEx) (Tcl_Interp *interp, CONST char *script, int numBytes, int flags); /* 291 */", "    int (*tcl_EvalObjv) (Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[], int flags); /* 292 */", "    int (*tcl_EvalObjEx) (Tcl_Interp *interp, Tcl_Obj *objPtr, int flags); /* 293 */", "    void (*tcl_ExitThread) (int status); /* 294 */", "    int (*tcl_ExternalToUtf) (Tcl_Interp *interp, Tcl_Encoding encoding, CONST char *src, int srcLen, int flags, Tcl_EncodingState *statePtr, char *dst, int dstLen, int *srcReadPtr, int *dstWrotePtr, int *dstCharsPtr); /* 295 */", "    char * (*tcl_ExternalToUtfDString) (Tcl_Encoding encoding, CONST char *src, int srcLen, Tcl_DString *dsPtr); /* 296 */", "    void (*tcl_FinalizeThread) (void); /* 297 */", "    void (*tcl_FinalizeNotifier) (ClientData clientData); /* 298 */", "    void (*tcl_FreeEncoding) (Tcl_Encoding encoding); /* 299 */", "    Tcl_ThreadId (*tcl_GetCurrentThread) (void); /* 300 */", "    Tcl_Encoding (*tcl_GetEncoding) (Tcl_Interp *interp, CONST char *name); /* 301 */", "    CONST84_RETURN char * (*tcl_GetEncodingName) (Tcl_Encoding encoding); /* 302 */", "    void (*tcl_GetEncodingNames) (Tcl_Interp *interp); /* 303 */", "    int (*tcl_GetIndexFromObjStruct) (Tcl_Interp *interp, Tcl_Obj *objPtr, CONST VOID *tablePtr, int offset, CONST char *msg, int flags, int *indexPtr); /* 304 */", "    VOID * (*tcl_GetThreadData) (Tcl_ThreadDataKey *keyPtr, int size); /* 305 */", "    Tcl_Obj * (*tcl_GetVar2Ex) (Tcl_Interp *interp, CONST char *part1, CONST char *part2, int flags); /* 306 */", "    ClientData (*tcl_InitNotifier) (void); /* 307 */", "    void (*tcl_MutexLock) (Tcl_Mutex *mutexPtr); /* 308 */", "    void (*tcl_MutexUnlock) (Tcl_Mutex *mutexPtr); /* 309 */", "    void (*tcl_ConditionNotify) (Tcl_Condition *condPtr); /* 310 */", "    void (*tcl_ConditionWait) (Tcl_Condition *condPtr, Tcl_Mutex *mutexPtr, Tcl_Time *timePtr); /* 311 */", "    int (*tcl_NumUtfChars) (CONST char *src, int length); /* 312 */", "    int (*tcl_ReadChars) (Tcl_Channel channel, Tcl_Obj *objPtr, int charsToRead, int appendFlag); /* 313 */", "    void (*tcl_RestoreResult) (Tcl_Interp *interp, Tcl_SavedResult *statePtr); /* 314 */", "    void (*tcl_SaveResult) (Tcl_Interp *interp, Tcl_SavedResult *statePtr); /* 315 */", "    int (*tcl_SetSystemEncoding) (Tcl_Interp *interp, CONST char *name); /* 316 */", "    Tcl_Obj * (*tcl_SetVar2Ex) (Tcl_Interp *interp, CONST char *part1, CONST char *part2, Tcl_Obj *newValuePtr, int flags); /* 317 */", "    void (*tcl_ThreadAlert) (Tcl_ThreadId threadId); /* 318 */", "    void (*tcl_ThreadQueueEvent) (Tcl_ThreadId threadId, Tcl_Event *evPtr, Tcl_QueuePosition position); /* 319 */", "    Tcl_UniChar (*tcl_UniCharAtIndex) (CONST char *src, int index); /* 320 */", "    Tcl_UniChar (*tcl_UniCharToLower) (int ch); /* 321 */", "    Tcl_UniChar (*tcl_UniCharToTitle) (int ch); /* 322 */", "    Tcl_UniChar (*tcl_UniCharToUpper) (int ch); /* 323 */", "    int (*tcl_UniCharToUtf) (int ch, char *buf); /* 324 */", "    CONST84_RETURN char * (*tcl_UtfAtIndex) (CONST char *src, int index); /* 325 */", "    int (*tcl_UtfCharComplete) (CONST char *src, int length); /* 326 */", "    int (*tcl_UtfBackslash) (CONST char *src, int *readPtr, char *dst); /* 327 */", "    CONST84_RETURN char * (*tcl_UtfFindFirst) (CONST char *src, int ch); /* 328 */", "    CONST84_RETURN char * (*tcl_UtfFindLast) (CONST char *src, int ch); /* 329 */", "    CONST84_RETURN char * (*tcl_UtfNext) (CONST char *src); /* 330 */", "    CONST84_RETURN char * (*tcl_UtfPrev) (CONST char *src, CONST char *start); /* 331 */", "    int (*tcl_UtfToExternal) (Tcl_Interp *interp, Tcl_Encoding encoding, CONST char *src, int srcLen, int flags, Tcl_EncodingState *statePtr, char *dst, int dstLen, int *srcReadPtr, int *dstWrotePtr, int *dstCharsPtr); /* 332 */", "    char * (*tcl_UtfToExternalDString) (Tcl_Encoding encoding, CONST char *src, int srcLen, Tcl_DString *dsPtr); /* 333 */", "    int (*tcl_UtfToLower) (char *src); /* 334 */", "    int (*tcl_UtfToTitle) (char *src); /* 335 */", "    int (*tcl_UtfToUniChar) (CONST char *src, Tcl_UniChar *chPtr); /* 336 */", "    int (*tcl_UtfToUpper) (char *src); /* 337 */", "    int (*tcl_WriteChars) (Tcl_Channel chan, CONST char *src, int srcLen); /* 338 */", "    int (*tcl_WriteObj) (Tcl_Channel chan, Tcl_Obj *objPtr); /* 339 */", "    char * (*tcl_GetString) (Tcl_Obj *objPtr); /* 340 */", "    CONST84_RETURN char * (*tcl_GetDefaultEncodingDir) (void); /* 341 */", "    void (*tcl_SetDefaultEncodingDir) (CONST char *path); /* 342 */", "    void (*tcl_AlertNotifier) (ClientData clientData); /* 343 */", "    void (*tcl_ServiceModeHook) (int mode); /* 344 */", "    int (*tcl_UniCharIsAlnum) (int ch); /* 345 */", "    int (*tcl_UniCharIsAlpha) (int ch); /* 346 */", "    int (*tcl_UniCharIsDigit) (int ch); /* 347 */", "    int (*tcl_UniCharIsLower) (int ch); /* 348 */", "    int (*tcl_UniCharIsSpace) (int ch); /* 349 */", "    int (*tcl_UniCharIsUpper) (int ch); /* 350 */", "    int (*tcl_UniCharIsWordChar) (int ch); /* 351 */", "    int (*tcl_UniCharLen) (CONST Tcl_UniChar *uniStr); /* 352 */", "    int (*tcl_UniCharNcmp) (CONST Tcl_UniChar *ucs, CONST Tcl_UniChar *uct, unsigned long numChars); /* 353 */", "    char * (*tcl_UniCharToUtfDString) (CONST Tcl_UniChar *uniStr, int uniLength, Tcl_DString *dsPtr); /* 354 */", "    Tcl_UniChar * (*tcl_UtfToUniCharDString) (CONST char *src, int length, Tcl_DString *dsPtr); /* 355 */", "    Tcl_RegExp (*tcl_GetRegExpFromObj) (Tcl_Interp *interp, Tcl_Obj *patObj, int flags); /* 356 */", "    Tcl_Obj * (*tcl_EvalTokens) (Tcl_Interp *interp, Tcl_Token *tokenPtr, int count); /* 357 */", "    void (*tcl_FreeParse) (Tcl_Parse *parsePtr); /* 358 */", "    void (*tcl_LogCommandInfo) (Tcl_Interp *interp, CONST char *script, CONST char *command, int length); /* 359 */", "    int (*tcl_ParseBraces) (Tcl_Interp *interp, CONST char *start, int numBytes, Tcl_Parse *parsePtr, int append, CONST84 char **termPtr); /* 360 */", "    int (*tcl_ParseCommand) (Tcl_Interp *interp, CONST char *start, int numBytes, int nested, Tcl_Parse *parsePtr); /* 361 */", "    int (*tcl_ParseExpr) (Tcl_Interp *interp, CONST char *start, int numBytes, Tcl_Parse *parsePtr); /* 362 */", "    int (*tcl_ParseQuotedString) (Tcl_Interp *interp, CONST char *start, int numBytes, Tcl_Parse *parsePtr, int append, CONST84 char **termPtr); /* 363 */", "    int (*tcl_ParseVarName) (Tcl_Interp *interp, CONST char *start, int numBytes, Tcl_Parse *parsePtr, int append); /* 364 */", "    char * (*tcl_GetCwd) (Tcl_Interp *interp, Tcl_DString *cwdPtr); /* 365 */", "    int (*tcl_Chdir) (CONST char *dirName); /* 366 */", "    int (*tcl_Access) (CONST char *path, int mode); /* 367 */", "    int (*tcl_Stat) (CONST char *path, struct stat *bufPtr); /* 368 */", "    int (*tcl_UtfNcmp) (CONST char *s1, CONST char *s2, unsigned long n); /* 369 */", "    int (*tcl_UtfNcasecmp) (CONST char *s1, CONST char *s2, unsigned long n); /* 370 */", "    int (*tcl_StringCaseMatch) (CONST char *str, CONST char *pattern, int nocase); /* 371 */", "    int (*tcl_UniCharIsControl) (int ch); /* 372 */", "    int (*tcl_UniCharIsGraph) (int ch); /* 373 */", "    int (*tcl_UniCharIsPrint) (int ch); /* 374 */", "    int (*tcl_UniCharIsPunct) (int ch); /* 375 */", "    int (*tcl_RegExpExecObj) (Tcl_Interp *interp, Tcl_RegExp regexp, Tcl_Obj *textObj, int offset, int nmatches, int flags); /* 376 */", "    void (*tcl_RegExpGetInfo) (Tcl_RegExp regexp, Tcl_RegExpInfo *infoPtr); /* 377 */", "    Tcl_Obj * (*tcl_NewUnicodeObj) (CONST Tcl_UniChar *unicode, int numChars); /* 378 */", "    void (*tcl_SetUnicodeObj) (Tcl_Obj *objPtr, CONST Tcl_UniChar *unicode, int numChars); /* 379 */", "    int (*tcl_GetCharLength) (Tcl_Obj *objPtr); /* 380 */", "    Tcl_UniChar (*tcl_GetUniChar) (Tcl_Obj *objPtr, int index); /* 381 */", "    Tcl_UniChar * (*tcl_GetUnicode) (Tcl_Obj *objPtr); /* 382 */", "    Tcl_Obj * (*tcl_GetRange) (Tcl_Obj *objPtr, int first, int last); /* 383 */", "    void (*tcl_AppendUnicodeToObj) (Tcl_Obj *objPtr, CONST Tcl_UniChar *unicode, int length); /* 384 */", "    int (*tcl_RegExpMatchObj) (Tcl_Interp *interp, Tcl_Obj *textObj, Tcl_Obj *patternObj); /* 385 */", "    void (*tcl_SetNotifier) (Tcl_NotifierProcs *notifierProcPtr); /* 386 */", "    Tcl_Mutex * (*tcl_GetAllocMutex) (void); /* 387 */", "    int (*tcl_GetChannelNames) (Tcl_Interp *interp); /* 388 */", "    int (*tcl_GetChannelNamesEx) (Tcl_Interp *interp, CONST char *pattern); /* 389 */", "    int (*tcl_ProcObjCmd) (ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]); /* 390 */", "    void (*tcl_ConditionFinalize) (Tcl_Condition *condPtr); /* 391 */", "    void (*tcl_MutexFinalize) (Tcl_Mutex *mutex); /* 392 */", "    int (*tcl_CreateThread) (Tcl_ThreadId *idPtr, Tcl_ThreadCreateProc proc, ClientData clientData, int stackSize, int flags); /* 393 */", "    int (*tcl_ReadRaw) (Tcl_Channel chan, char *dst, int bytesToRead); /* 394 */", "    int (*tcl_WriteRaw) (Tcl_Channel chan, CONST char *src, int srcLen); /* 395 */", "    Tcl_Channel (*tcl_GetTopChannel) (Tcl_Channel chan); /* 396 */", "    int (*tcl_ChannelBuffered) (Tcl_Channel chan); /* 397 */", "    CONST84_RETURN char * (*tcl_ChannelName) (CONST Tcl_ChannelType *chanTypePtr); /* 398 */", "    Tcl_ChannelTypeVersion (*tcl_ChannelVersion) (CONST Tcl_ChannelType *chanTypePtr); /* 399 */", "    Tcl_DriverBlockModeProc * (*tcl_ChannelBlockModeProc) (CONST Tcl_ChannelType *chanTypePtr); /* 400 */", "    Tcl_DriverCloseProc * (*tcl_ChannelCloseProc) (CONST Tcl_ChannelType *chanTypePtr); /* 401 */", "    Tcl_DriverClose2Proc * (*tcl_ChannelClose2Proc) (CONST Tcl_ChannelType *chanTypePtr); /* 402 */", "    Tcl_DriverInputProc * (*tcl_ChannelInputProc) (CONST Tcl_ChannelType *chanTypePtr); /* 403 */", "    Tcl_DriverOutputProc * (*tcl_ChannelOutputProc) (CONST Tcl_ChannelType *chanTypePtr); /* 404 */", "    Tcl_DriverSeekProc * (*tcl_ChannelSeekProc) (CONST Tcl_ChannelType *chanTypePtr); /* 405 */", "    Tcl_DriverSetOptionProc * (*tcl_ChannelSetOptionProc) (CONST Tcl_ChannelType *chanTypePtr); /* 406 */", "    Tcl_DriverGetOptionProc * (*tcl_ChannelGetOptionProc) (CONST Tcl_ChannelType *chanTypePtr); /* 407 */", "    Tcl_DriverWatchProc * (*tcl_ChannelWatchProc) (CONST Tcl_ChannelType *chanTypePtr); /* 408 */", "    Tcl_DriverGetHandleProc * (*tcl_ChannelGetHandleProc) (CONST Tcl_ChannelType *chanTypePtr); /* 409 */", "    Tcl_DriverFlushProc * (*tcl_ChannelFlushProc) (CONST Tcl_ChannelType *chanTypePtr); /* 410 */", "    Tcl_DriverHandlerProc * (*tcl_ChannelHandlerProc) (CONST Tcl_ChannelType *chanTypePtr); /* 411 */", "    int (*tcl_JoinThread) (Tcl_ThreadId threadId, int *result); /* 412 */", "    int (*tcl_IsChannelShared) (Tcl_Channel channel); /* 413 */", "    int (*tcl_IsChannelRegistered) (Tcl_Interp *interp, Tcl_Channel channel); /* 414 */", "    void (*tcl_CutChannel) (Tcl_Channel channel); /* 415 */", "    void (*tcl_SpliceChannel) (Tcl_Channel channel); /* 416 */", "    void (*tcl_ClearChannelHandlers) (Tcl_Channel channel); /* 417 */", "    int (*tcl_IsChannelExisting) (CONST char *channelName); /* 418 */", "    int (*tcl_UniCharNcasecmp) (CONST Tcl_UniChar *ucs, CONST Tcl_UniChar *uct, unsigned long numChars); /* 419 */", "    int (*tcl_UniCharCaseMatch) (CONST Tcl_UniChar *uniStr, CONST Tcl_UniChar *uniPattern, int nocase); /* 420 */", "    Tcl_HashEntry * (*tcl_FindHashEntry) (Tcl_HashTable *tablePtr, CONST char *key); /* 421 */", "    Tcl_HashEntry * (*tcl_CreateHashEntry) (Tcl_HashTable *tablePtr, CONST char *key, int *newPtr); /* 422 */", "    void (*tcl_InitCustomHashTable) (Tcl_HashTable *tablePtr, int keyType, Tcl_HashKeyType *typePtr); /* 423 */", "    void (*tcl_InitObjHashTable) (Tcl_HashTable *tablePtr); /* 424 */", "    ClientData (*tcl_CommandTraceInfo) (Tcl_Interp *interp, CONST char *varName, int flags, Tcl_CommandTraceProc *procPtr, ClientData prevClientData); /* 425 */", "    int (*tcl_TraceCommand) (Tcl_Interp *interp, CONST char *varName, int flags, Tcl_CommandTraceProc *proc, ClientData clientData); /* 426 */", "    void (*tcl_UntraceCommand) (Tcl_Interp *interp, CONST char *varName, int flags, Tcl_CommandTraceProc *proc, ClientData clientData); /* 427 */", "    char * (*tcl_AttemptAlloc) (unsigned int size); /* 428 */", "    char * (*tcl_AttemptDbCkalloc) (unsigned int size, CONST char *file, int line); /* 429 */", "    char * (*tcl_AttemptRealloc) (char *ptr, unsigned int size); /* 430 */", "    char * (*tcl_AttemptDbCkrealloc) (char *ptr, unsigned int size, CONST char *file, int line); /* 431 */", "    int (*tcl_AttemptSetObjLength) (Tcl_Obj *objPtr, int length); /* 432 */", "    Tcl_ThreadId (*tcl_GetChannelThread) (Tcl_Channel channel); /* 433 */", "    Tcl_UniChar * (*tcl_GetUnicodeFromObj) (Tcl_Obj *objPtr, int *lengthPtr); /* 434 */", "    int (*tcl_GetMathFuncInfo) (Tcl_Interp *interp, CONST char *name, int *numArgsPtr, Tcl_ValueType **argTypesPtr, Tcl_MathProc **procPtr, ClientData *clientDataPtr); /* 435 */", "    Tcl_Obj * (*tcl_ListMathFuncs) (Tcl_Interp *interp, CONST char *pattern); /* 436 */", "    Tcl_Obj * (*tcl_SubstObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, int flags); /* 437 */", "    int (*tcl_DetachChannel) (Tcl_Interp *interp, Tcl_Channel channel); /* 438 */", "    int (*tcl_IsStandardChannel) (Tcl_Channel channel); /* 439 */", "    int (*tcl_FSCopyFile) (Tcl_Obj *srcPathPtr, Tcl_Obj *destPathPtr); /* 440 */", "    int (*tcl_FSCopyDirectory) (Tcl_Obj *srcPathPtr, Tcl_Obj *destPathPtr, Tcl_Obj **errorPtr); /* 441 */", "    int (*tcl_FSCreateDirectory) (Tcl_Obj *pathPtr); /* 442 */", "    int (*tcl_FSDeleteFile) (Tcl_Obj *pathPtr); /* 443 */", "    int (*tcl_FSLoadFile) (Tcl_Interp *interp, Tcl_Obj *pathPtr, CONST char *sym1, CONST char *sym2, Tcl_PackageInitProc **proc1Ptr, Tcl_PackageInitProc **proc2Ptr, Tcl_LoadHandle *handlePtr, Tcl_FSUnloadFileProc **unloadProcPtr); /* 444 */", "    int (*tcl_FSMatchInDirectory) (Tcl_Interp *interp, Tcl_Obj *result, Tcl_Obj *pathPtr, CONST char *pattern, Tcl_GlobTypeData *types); /* 445 */", "    Tcl_Obj * (*tcl_FSLink) (Tcl_Obj *pathPtr, Tcl_Obj *toPtr, int linkAction); /* 446 */", "    int (*tcl_FSRemoveDirectory) (Tcl_Obj *pathPtr, int recursive, Tcl_Obj **errorPtr); /* 447 */", "    int (*tcl_FSRenameFile) (Tcl_Obj *srcPathPtr, Tcl_Obj *destPathPtr); /* 448 */", "    int (*tcl_FSLstat) (Tcl_Obj *pathPtr, Tcl_StatBuf *buf); /* 449 */", "    int (*tcl_FSUtime) (Tcl_Obj *pathPtr, struct utimbuf *tval); /* 450 */", "    int (*tcl_FSFileAttrsGet) (Tcl_Interp *interp, int index, Tcl_Obj *pathPtr, Tcl_Obj **objPtrRef); /* 451 */", "    int (*tcl_FSFileAttrsSet) (Tcl_Interp *interp, int index, Tcl_Obj *pathPtr, Tcl_Obj *objPtr); /* 452 */", "    CONST char ** (*tcl_FSFileAttrStrings) (Tcl_Obj *pathPtr, Tcl_Obj **objPtrRef); /* 453 */", "    int (*tcl_FSStat) (Tcl_Obj *pathPtr, Tcl_StatBuf *buf); /* 454 */", "    int (*tcl_FSAccess) (Tcl_Obj *pathPtr, int mode); /* 455 */", "    Tcl_Channel (*tcl_FSOpenFileChannel) (Tcl_Interp *interp, Tcl_Obj *pathPtr, CONST char *modeString, int permissions); /* 456 */", "    Tcl_Obj * (*tcl_FSGetCwd) (Tcl_Interp *interp); /* 457 */", "    int (*tcl_FSChdir) (Tcl_Obj *pathPtr); /* 458 */", "    int (*tcl_FSConvertToPathType) (Tcl_Interp *interp, Tcl_Obj *pathPtr); /* 459 */", "    Tcl_Obj * (*tcl_FSJoinPath) (Tcl_Obj *listObj, int elements); /* 460 */", "    Tcl_Obj * (*tcl_FSSplitPath) (Tcl_Obj *pathPtr, int *lenPtr); /* 461 */", "    int (*tcl_FSEqualPaths) (Tcl_Obj *firstPtr, Tcl_Obj *secondPtr); /* 462 */", "    Tcl_Obj * (*tcl_FSGetNormalizedPath) (Tcl_Interp *interp, Tcl_Obj *pathPtr); /* 463 */", "    Tcl_Obj * (*tcl_FSJoinToPath) (Tcl_Obj *pathPtr, int objc, Tcl_Obj *CONST objv[]); /* 464 */", "    ClientData (*tcl_FSGetInternalRep) (Tcl_Obj *pathPtr, Tcl_Filesystem *fsPtr); /* 465 */", "    Tcl_Obj * (*tcl_FSGetTranslatedPath) (Tcl_Interp *interp, Tcl_Obj *pathPtr); /* 466 */", "    int (*tcl_FSEvalFile) (Tcl_Interp *interp, Tcl_Obj *fileName); /* 467 */", "    Tcl_Obj * (*tcl_FSNewNativePath) (Tcl_Filesystem *fromFilesystem, ClientData clientData); /* 468 */", "    CONST char * (*tcl_FSGetNativePath) (Tcl_Obj *pathPtr); /* 469 */", "    Tcl_Obj * (*tcl_FSFileSystemInfo) (Tcl_Obj *pathPtr); /* 470 */", "    Tcl_Obj * (*tcl_FSPathSeparator) (Tcl_Obj *pathPtr); /* 471 */", "    Tcl_Obj * (*tcl_FSListVolumes) (void); /* 472 */", "    int (*tcl_FSRegister) (ClientData clientData, Tcl_Filesystem *fsPtr); /* 473 */", "    int (*tcl_FSUnregister) (Tcl_Filesystem *fsPtr); /* 474 */", "    ClientData (*tcl_FSData) (Tcl_Filesystem *fsPtr); /* 475 */", "    CONST char * (*tcl_FSGetTranslatedStringPath) (Tcl_Interp *interp, Tcl_Obj *pathPtr); /* 476 */", "    Tcl_Filesystem * (*tcl_FSGetFileSystemForPath) (Tcl_Obj *pathPtr); /* 477 */", "    Tcl_PathType (*tcl_FSGetPathType) (Tcl_Obj *pathPtr); /* 478 */", "    int (*tcl_OutputBuffered) (Tcl_Channel chan); /* 479 */", "    void (*tcl_FSMountsChanged) (Tcl_Filesystem *fsPtr); /* 480 */", "    int (*tcl_EvalTokensStandard) (Tcl_Interp *interp, Tcl_Token *tokenPtr, int count); /* 481 */", "    void (*tcl_GetTime) (Tcl_Time *timeBuf); /* 482 */", "    Tcl_Trace (*tcl_CreateObjTrace) (Tcl_Interp *interp, int level, int flags, Tcl_CmdObjTraceProc *objProc, ClientData clientData, Tcl_CmdObjTraceDeleteProc *delProc); /* 483 */", "    int (*tcl_GetCommandInfoFromToken) (Tcl_Command token, Tcl_CmdInfo *infoPtr); /* 484 */", "    int (*tcl_SetCommandInfoFromToken) (Tcl_Command token, CONST Tcl_CmdInfo *infoPtr); /* 485 */", "    Tcl_Obj * (*tcl_DbNewWideIntObj) (Tcl_WideInt wideValue, CONST char *file, int line); /* 486 */", "    int (*tcl_GetWideIntFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, Tcl_WideInt *widePtr); /* 487 */", "    Tcl_Obj * (*tcl_NewWideIntObj) (Tcl_WideInt wideValue); /* 488 */", "    void (*tcl_SetWideIntObj) (Tcl_Obj *objPtr, Tcl_WideInt wideValue); /* 489 */", "    Tcl_StatBuf * (*tcl_AllocStatBuf) (void); /* 490 */", "    Tcl_WideInt (*tcl_Seek) (Tcl_Channel chan, Tcl_WideInt offset, int mode); /* 491 */", "    Tcl_WideInt (*tcl_Tell) (Tcl_Channel chan); /* 492 */", "    Tcl_DriverWideSeekProc * (*tcl_ChannelWideSeekProc) (CONST Tcl_ChannelType *chanTypePtr); /* 493 */", "    int (*tcl_DictObjPut) (Tcl_Interp *interp, Tcl_Obj *dictPtr, Tcl_Obj *keyPtr, Tcl_Obj *valuePtr); /* 494 */", "    int (*tcl_DictObjGet) (Tcl_Interp *interp, Tcl_Obj *dictPtr, Tcl_Obj *keyPtr, Tcl_Obj **valuePtrPtr); /* 495 */", "    int (*tcl_DictObjRemove) (Tcl_Interp *interp, Tcl_Obj *dictPtr, Tcl_Obj *keyPtr); /* 496 */", "    int (*tcl_DictObjSize) (Tcl_Interp *interp, Tcl_Obj *dictPtr, int *sizePtr); /* 497 */", "    int (*tcl_DictObjFirst) (Tcl_Interp *interp, Tcl_Obj *dictPtr, Tcl_DictSearch *searchPtr, Tcl_Obj **keyPtrPtr, Tcl_Obj **valuePtrPtr, int *donePtr); /* 498 */", "    void (*tcl_DictObjNext) (Tcl_DictSearch *searchPtr, Tcl_Obj **keyPtrPtr, Tcl_Obj **valuePtrPtr, int *donePtr); /* 499 */", "    void (*tcl_DictObjDone) (Tcl_DictSearch *searchPtr); /* 500 */", "    int (*tcl_DictObjPutKeyList) (Tcl_Interp *interp, Tcl_Obj *dictPtr, int keyc, Tcl_Obj *CONST *keyv, Tcl_Obj *valuePtr); /* 501 */", "    int (*tcl_DictObjRemoveKeyList) (Tcl_Interp *interp, Tcl_Obj *dictPtr, int keyc, Tcl_Obj *CONST *keyv); /* 502 */", "    Tcl_Obj * (*tcl_NewDictObj) (void); /* 503 */", "    Tcl_Obj * (*tcl_DbNewDictObj) (CONST char *file, int line); /* 504 */", "    void (*tcl_RegisterConfig) (Tcl_Interp *interp, CONST char *pkgName, Tcl_Config *configuration, CONST char *valEncoding); /* 505 */", "    Tcl_Namespace * (*tcl_CreateNamespace) (Tcl_Interp *interp, CONST char *name, ClientData clientData, Tcl_NamespaceDeleteProc *deleteProc); /* 506 */", "    void (*tcl_DeleteNamespace) (Tcl_Namespace *nsPtr); /* 507 */", "    int (*tcl_AppendExportList) (Tcl_Interp *interp, Tcl_Namespace *nsPtr, Tcl_Obj *objPtr); /* 508 */", "    int (*tcl_Export) (Tcl_Interp *interp, Tcl_Namespace *nsPtr, CONST char *pattern, int resetListFirst); /* 509 */", "    int (*tcl_Import) (Tcl_Interp *interp, Tcl_Namespace *nsPtr, CONST char *pattern, int allowOverwrite); /* 510 */", "    int (*tcl_ForgetImport) (Tcl_Interp *interp, Tcl_Namespace *nsPtr, CONST char *pattern); /* 511 */", "    Tcl_Namespace * (*tcl_GetCurrentNamespace) (Tcl_Interp *interp); /* 512 */", "    Tcl_Namespace * (*tcl_GetGlobalNamespace) (Tcl_Interp *interp); /* 513 */", "    Tcl_Namespace * (*tcl_FindNamespace) (Tcl_Interp *interp, CONST char *name, Tcl_Namespace *contextNsPtr, int flags); /* 514 */", "    Tcl_Command (*tcl_FindCommand) (Tcl_Interp *interp, CONST char *name, Tcl_Namespace *contextNsPtr, int flags); /* 515 */", "    Tcl_Command (*tcl_GetCommandFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr); /* 516 */", "    void (*tcl_GetCommandFullName) (Tcl_Interp *interp, Tcl_Command command, Tcl_Obj *objPtr); /* 517 */", "    int (*tcl_FSEvalFileEx) (Tcl_Interp *interp, Tcl_Obj *fileName, CONST char *encodingName); /* 518 */", "    Tcl_ExitProc * (*tcl_SetExitProc) (Tcl_ExitProc *proc); /* 519 */", "    void (*tcl_LimitAddHandler) (Tcl_Interp *interp, int type, Tcl_LimitHandlerProc *handlerProc, ClientData clientData, Tcl_LimitHandlerDeleteProc *deleteProc); /* 520 */", "    void (*tcl_LimitRemoveHandler) (Tcl_Interp *interp, int type, Tcl_LimitHandlerProc *handlerProc, ClientData clientData); /* 521 */", "    int (*tcl_LimitReady) (Tcl_Interp *interp); /* 522 */", "    int (*tcl_LimitCheck) (Tcl_Interp *interp); /* 523 */", "    int (*tcl_LimitExceeded) (Tcl_Interp *interp); /* 524 */", "    void (*tcl_LimitSetCommands) (Tcl_Interp *interp, int commandLimit); /* 525 */", "    void (*tcl_LimitSetTime) (Tcl_Interp *interp, Tcl_Time *timeLimitPtr); /* 526 */", "    void (*tcl_LimitSetGranularity) (Tcl_Interp *interp, int type, int granularity); /* 527 */", "    int (*tcl_LimitTypeEnabled) (Tcl_Interp *interp, int type); /* 528 */", "    int (*tcl_LimitTypeExceeded) (Tcl_Interp *interp, int type); /* 529 */", "    void (*tcl_LimitTypeSet) (Tcl_Interp *interp, int type); /* 530 */", "    void (*tcl_LimitTypeReset) (Tcl_Interp *interp, int type); /* 531 */", "    int (*tcl_LimitGetCommands) (Tcl_Interp *interp); /* 532 */", "    void (*tcl_LimitGetTime) (Tcl_Interp *interp, Tcl_Time *timeLimitPtr); /* 533 */", "    int (*tcl_LimitGetGranularity) (Tcl_Interp *interp, int type); /* 534 */", "    Tcl_InterpState (*tcl_SaveInterpState) (Tcl_Interp *interp, int status); /* 535 */", "    int (*tcl_RestoreInterpState) (Tcl_Interp *interp, Tcl_InterpState state); /* 536 */", "    void (*tcl_DiscardInterpState) (Tcl_InterpState state); /* 537 */", "    int (*tcl_SetReturnOptions) (Tcl_Interp *interp, Tcl_Obj *options); /* 538 */", "    Tcl_Obj * (*tcl_GetReturnOptions) (Tcl_Interp *interp, int result); /* 539 */", "    int (*tcl_IsEnsemble) (Tcl_Command token); /* 540 */", "    Tcl_Command (*tcl_CreateEnsemble) (Tcl_Interp *interp, CONST char *name, Tcl_Namespace *namespacePtr, int flags); /* 541 */", "    Tcl_Command (*tcl_FindEnsemble) (Tcl_Interp *interp, Tcl_Obj *cmdNameObj, int flags); /* 542 */", "    int (*tcl_SetEnsembleSubcommandList) (Tcl_Interp *interp, Tcl_Command token, Tcl_Obj *subcmdList); /* 543 */", "    int (*tcl_SetEnsembleMappingDict) (Tcl_Interp *interp, Tcl_Command token, Tcl_Obj *mapDict); /* 544 */", "    int (*tcl_SetEnsembleUnknownHandler) (Tcl_Interp *interp, Tcl_Command token, Tcl_Obj *unknownList); /* 545 */", "    int (*tcl_SetEnsembleFlags) (Tcl_Interp *interp, Tcl_Command token, int flags); /* 546 */", "    int (*tcl_GetEnsembleSubcommandList) (Tcl_Interp *interp, Tcl_Command token, Tcl_Obj **subcmdListPtr); /* 547 */", "    int (*tcl_GetEnsembleMappingDict) (Tcl_Interp *interp, Tcl_Command token, Tcl_Obj **mapDictPtr); /* 548 */", "    int (*tcl_GetEnsembleUnknownHandler) (Tcl_Interp *interp, Tcl_Command token, Tcl_Obj **unknownListPtr); /* 549 */", "    int (*tcl_GetEnsembleFlags) (Tcl_Interp *interp, Tcl_Command token, int *flagsPtr); /* 550 */", "    int (*tcl_GetEnsembleNamespace) (Tcl_Interp *interp, Tcl_Command token, Tcl_Namespace **namespacePtrPtr); /* 551 */", "    void (*tcl_SetTimeProc) (Tcl_GetTimeProc *getProc, Tcl_ScaleTimeProc *scaleProc, ClientData clientData); /* 552 */", "    void (*tcl_QueryTimeProc) (Tcl_GetTimeProc **getProc, Tcl_ScaleTimeProc **scaleProc, ClientData *clientData); /* 553 */", "    Tcl_DriverThreadActionProc * (*tcl_ChannelThreadActionProc) (CONST Tcl_ChannelType *chanTypePtr); /* 554 */", "    Tcl_Obj * (*tcl_NewBignumObj) (mp_int *value); /* 555 */", "    Tcl_Obj * (*tcl_DbNewBignumObj) (mp_int *value, CONST char *file, int line); /* 556 */", "    void (*tcl_SetBignumObj) (Tcl_Obj *obj, mp_int *value); /* 557 */", "    int (*tcl_GetBignumFromObj) (Tcl_Interp *interp, Tcl_Obj *obj, mp_int *value); /* 558 */", "    int (*tcl_TakeBignumFromObj) (Tcl_Interp *interp, Tcl_Obj *obj, mp_int *value); /* 559 */", "    int (*tcl_TruncateChannel) (Tcl_Channel chan, Tcl_WideInt length); /* 560 */", "    Tcl_DriverTruncateProc * (*tcl_ChannelTruncateProc) (CONST Tcl_ChannelType *chanTypePtr); /* 561 */", "    void (*tcl_SetChannelErrorInterp) (Tcl_Interp *interp, Tcl_Obj *msg); /* 562 */", "    void (*tcl_GetChannelErrorInterp) (Tcl_Interp *interp, Tcl_Obj **msg); /* 563 */", "    void (*tcl_SetChannelError) (Tcl_Channel chan, Tcl_Obj *msg); /* 564 */", "    void (*tcl_GetChannelError) (Tcl_Channel chan, Tcl_Obj **msg); /* 565 */", "    int (*tcl_InitBignumFromDouble) (Tcl_Interp *interp, double initval, mp_int *toInit); /* 566 */", "    Tcl_Obj * (*tcl_GetNamespaceUnknownHandler) (Tcl_Interp *interp, Tcl_Namespace *nsPtr); /* 567 */", "    int (*tcl_SetNamespaceUnknownHandler) (Tcl_Interp *interp, Tcl_Namespace *nsPtr, Tcl_Obj *handlerPtr); /* 568 */", "    int (*tcl_GetEncodingFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, Tcl_Encoding *encodingPtr); /* 569 */", "    Tcl_Obj * (*tcl_GetEncodingSearchPath) (void); /* 570 */", "    int (*tcl_SetEncodingSearchPath) (Tcl_Obj *searchPath); /* 571 */", "    CONST char * (*tcl_GetEncodingNameFromEnvironment) (Tcl_DString *bufPtr); /* 572 */", "    int (*tcl_PkgRequireProc) (Tcl_Interp *interp, CONST char *name, int objc, Tcl_Obj *CONST objv[], ClientData *clientDataPtr); /* 573 */", "    void (*tcl_AppendObjToErrorInfo) (Tcl_Interp *interp, Tcl_Obj *objPtr); /* 574 */", "    void (*tcl_AppendLimitedToObj) (Tcl_Obj *objPtr, CONST char *bytes, int length, int limit, CONST char *ellipsis); /* 575 */", "    Tcl_Obj * (*tcl_Format) (Tcl_Interp *interp, CONST char *format, int objc, Tcl_Obj *CONST objv[]); /* 576 */", "    int (*tcl_AppendFormatToObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, CONST char *format, int objc, Tcl_Obj *CONST objv[]); /* 577 */", "    Tcl_Obj * (*tcl_ObjPrintf) (CONST char *format, ...); /* 578 */", "    void (*tcl_AppendPrintfToObj) (Tcl_Obj *objPtr, CONST char *format, ...); /* 579 */", "} TclStubs;", "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "extern TclStubs *tclStubsPtr;", "#ifdef __cplusplus", "}", "#endif", "", "#if defined(USE_TCL_STUBS) && !defined(USE_TCL_STUB_PROCS)", "", "/*", " * Inline function declarations:", " */", "", "#ifndef Tcl_PkgProvideEx", "#define Tcl_PkgProvideEx \\", "\t(tclStubsPtr->tcl_PkgProvideEx) /* 0 */", "#endif", "#ifndef Tcl_PkgRequireEx", "#define Tcl_PkgRequireEx \\", "\t(tclStubsPtr->tcl_PkgRequireEx) /* 1 */", "#endif", "#ifndef Tcl_Panic", "#define Tcl_Panic \\", "\t(tclStubsPtr->tcl_Panic) /* 2 */", "#endif", "#ifndef Tcl_Alloc", "#define Tcl_Alloc \\", "\t(tclStubsPtr->tcl_Alloc) /* 3 */", "#endif", "#ifndef Tcl_Free", "#define Tcl_Free \\", "\t(tclStubsPtr->tcl_Free) /* 4 */", "#endif", "#ifndef Tcl_Realloc", "#define Tcl_Realloc \\", "\t(tclStubsPtr->tcl_Realloc) /* 5 */", "#endif", "#ifndef Tcl_DbCkalloc", "#define Tcl_DbCkalloc \\", "\t(tclStubsPtr->tcl_DbCkalloc) /* 6 */", "#endif", "#ifndef Tcl_DbCkfree", "#define Tcl_DbCkfree \\", "\t(tclStubsPtr->tcl_DbCkfree) /* 7 */", "#endif", "#ifndef Tcl_DbCkrealloc", "#define Tcl_DbCkrealloc \\", "\t(tclStubsPtr->tcl_DbCkrealloc) /* 8 */", "#endif", "#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */", "#ifndef Tcl_CreateFileHandler", "#define Tcl_CreateFileHandler \\", "\t(tclStubsPtr->tcl_CreateFileHandler) /* 9 */", "#endif", "#endif /* UNIX */", "#ifdef MAC_OSX_TCL /* MACOSX */", "#ifndef Tcl_CreateFileHandler", "#define Tcl_CreateFileHandler \\", "\t(tclStubsPtr->tcl_CreateFileHandler) /* 9 */", "#endif", "#endif /* MACOSX */", "#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */", "#ifndef Tcl_DeleteFileHandler", "#define Tcl_DeleteFileHandler \\", "\t(tclStubsPtr->tcl_DeleteFileHandler) /* 10 */", "#endif", "#endif /* UNIX */", "#ifdef MAC_OSX_TCL /* MACOSX */", "#ifndef Tcl_DeleteFileHandler", "#define Tcl_DeleteFileHandler \\", "\t(tclStubsPtr->tcl_DeleteFileHandler) /* 10 */", "#endif", "#endif /* MACOSX */", "#ifndef Tcl_SetTimer", "#define Tcl_SetTimer \\", "\t(tclStubsPtr->tcl_SetTimer) /* 11 */", "#endif", "#ifndef Tcl_Sleep", "#define Tcl_Sleep \\", "\t(tclStubsPtr->tcl_Sleep) /* 12 */", "#endif", "#ifndef Tcl_WaitForEvent", "#define Tcl_WaitForEvent \\", "\t(tclStubsPtr->tcl_WaitForEvent) /* 13 */", "#endif", "#ifndef Tcl_AppendAllObjTypes", "#define Tcl_AppendAllObjTypes \\", "\t(tclStubsPtr->tcl_AppendAllObjTypes) /* 14 */", "#endif", "#ifndef Tcl_AppendStringsToObj", "#define Tcl_AppendStringsToObj \\", "\t(tclStubsPtr->tcl_AppendStringsToObj) /* 15 */", "#endif", "#ifndef Tcl_AppendToObj", "#define Tcl_AppendToObj \\", "\t(tclStubsPtr->tcl_AppendToObj) /* 16 */", "#endif", "#ifndef Tcl_ConcatObj", "#define Tcl_ConcatObj \\", "\t(tclStubsPtr->tcl_ConcatObj) /* 17 */", "#endif", "#ifndef Tcl_ConvertToType", "#define Tcl_ConvertToType \\", "\t(tclStubsPtr->tcl_ConvertToType) /* 18 */", "#endif", "#ifndef Tcl_DbDecrRefCount", "#define Tcl_DbDecrRefCount \\", "\t(tclStubsPtr->tcl_DbDecrRefCount) /* 19 */", "#endif", "#ifndef Tcl_DbIncrRefCount", "#define Tcl_DbIncrRefCount \\", "\t(tclStubsPtr->tcl_DbIncrRefCount) /* 20 */", "#endif", "#ifndef Tcl_DbIsShared", "#define Tcl_DbIsShared \\", "\t(tclStubsPtr->tcl_DbIsShared) /* 21 */", "#endif", "#ifndef Tcl_DbNewBooleanObj", "#define Tcl_DbNewBooleanObj \\", "\t(tclStubsPtr->tcl_DbNewBooleanObj) /* 22 */", "#endif", "#ifndef Tcl_DbNewByteArrayObj", "#define Tcl_DbNewByteArrayObj \\", "\t(tclStubsPtr->tcl_DbNewByteArrayObj) /* 23 */", "#endif", "#ifndef Tcl_DbNewDoubleObj", "#define Tcl_DbNewDoubleObj \\", "\t(tclStubsPtr->tcl_DbNewDoubleObj) /* 24 */", "#endif", "#ifndef Tcl_DbNewListObj", "#define Tcl_DbNewListObj \\", "\t(tclStubsPtr->tcl_DbNewListObj) /* 25 */", "#endif", "#ifndef Tcl_DbNewLongObj", "#define Tcl_DbNewLongObj \\", "\t(tclStubsPtr->tcl_DbNewLongObj) /* 26 */", "#endif", "#ifndef Tcl_DbNewObj", "#define Tcl_DbNewObj \\", "\t(tclStubsPtr->tcl_DbNewObj) /* 27 */", "#endif", "#ifndef Tcl_DbNewStringObj", "#define Tcl_DbNewStringObj \\", "\t(tclStubsPtr->tcl_DbNewStringObj) /* 28 */", "#endif", "#ifndef Tcl_DuplicateObj", "#define Tcl_DuplicateObj \\", "\t(tclStubsPtr->tcl_DuplicateObj) /* 29 */", "#endif", "#ifndef TclFreeObj", "#define TclFreeObj \\", "\t(tclStubsPtr->tclFreeObj) /* 30 */", "#endif", "#ifndef Tcl_GetBoolean", "#define Tcl_GetBoolean \\", "\t(tclStubsPtr->tcl_GetBoolean) /* 31 */", "#endif", "#ifndef Tcl_GetBooleanFromObj", "#define Tcl_GetBooleanFromObj \\", "\t(tclStubsPtr->tcl_GetBooleanFromObj) /* 32 */", "#endif", "#ifndef Tcl_GetByteArrayFromObj", "#define Tcl_GetByteArrayFromObj \\", "\t(tclStubsPtr->tcl_GetByteArrayFromObj) /* 33 */", "#endif", "#ifndef Tcl_GetDouble", "#define Tcl_GetDouble \\", "\t(tclStubsPtr->tcl_GetDouble) /* 34 */", "#endif", "#ifndef Tcl_GetDoubleFromObj", "#define Tcl_GetDoubleFromObj \\", "\t(tclStubsPtr->tcl_GetDoubleFromObj) /* 35 */", "#endif", "#ifndef Tcl_GetIndexFromObj", "#define Tcl_GetIndexFromObj \\", "\t(tclStubsPtr->tcl_GetIndexFromObj) /* 36 */", "#endif", "#ifndef Tcl_GetInt", "#define Tcl_GetInt \\", "\t(tclStubsPtr->tcl_GetInt) /* 37 */", "#endif", "#ifndef Tcl_GetIntFromObj", "#define Tcl_GetIntFromObj \\", "\t(tclStubsPtr->tcl_GetIntFromObj) /* 38 */", "#endif", "#ifndef Tcl_GetLongFromObj", "#define Tcl_GetLongFromObj \\", "\t(tclStubsPtr->tcl_GetLongFromObj) /* 39 */", "#endif", "#ifndef Tcl_GetObjType", "#define Tcl_GetObjType \\", "\t(tclStubsPtr->tcl_GetObjType) /* 40 */", "#endif", "#ifndef Tcl_GetStringFromObj", "#define Tcl_GetStringFromObj \\", "\t(tclStubsPtr->tcl_GetStringFromObj) /* 41 */", "#endif", "#ifndef Tcl_InvalidateStringRep", "#define Tcl_InvalidateStringRep \\", "\t(tclStubsPtr->tcl_InvalidateStringRep) /* 42 */", "#endif", "#ifndef Tcl_ListObjAppendList", "#define Tcl_ListObjAppendList \\", "\t(tclStubsPtr->tcl_ListObjAppendList) /* 43 */", "#endif", "#ifndef Tcl_ListObjAppendElement", "#define Tcl_ListObjAppendElement \\", "\t(tclStubsPtr->tcl_ListObjAppendElement) /* 44 */", "#endif", "#ifndef Tcl_ListObjGetElements", "#define Tcl_ListObjGetElements \\", "\t(tclStubsPtr->tcl_ListObjGetElements) /* 45 */", "#endif", "#ifndef Tcl_ListObjIndex", "#define Tcl_ListObjIndex \\", "\t(tclStubsPtr->tcl_ListObjIndex) /* 46 */", "#endif", "#ifndef Tcl_ListObjLength", "#define Tcl_ListObjLength \\", "\t(tclStubsPtr->tcl_ListObjLength) /* 47 */", "#endif", "#ifndef Tcl_ListObjReplace", "#define Tcl_ListObjReplace \\", "\t(tclStubsPtr->tcl_ListObjReplace) /* 48 */", "#endif", "#ifndef Tcl_NewBooleanObj", "#define Tcl_NewBooleanObj \\", "\t(tclStubsPtr->tcl_NewBooleanObj) /* 49 */", "#endif", "#ifndef Tcl_NewByteArrayObj", "#define Tcl_NewByteArrayObj \\", "\t(tclStubsPtr->tcl_NewByteArrayObj) /* 50 */", "#endif", "#ifndef Tcl_NewDoubleObj", "#define Tcl_NewDoubleObj \\", "\t(tclStubsPtr->tcl_NewDoubleObj) /* 51 */", "#endif", "#ifndef Tcl_NewIntObj", "#define Tcl_NewIntObj \\", "\t(tclStubsPtr->tcl_NewIntObj) /* 52 */", "#endif", "#ifndef Tcl_NewListObj", "#define Tcl_NewListObj \\", "\t(tclStubsPtr->tcl_NewListObj) /* 53 */", "#endif", "#ifndef Tcl_NewLongObj", "#define Tcl_NewLongObj \\", "\t(tclStubsPtr->tcl_NewLongObj) /* 54 */", "#endif", "#ifndef Tcl_NewObj", "#define Tcl_NewObj \\", "\t(tclStubsPtr->tcl_NewObj) /* 55 */", "#endif", "#ifndef Tcl_NewStringObj", "#define Tcl_NewStringObj \\", "\t(tclStubsPtr->tcl_NewStringObj) /* 56 */", "#endif", "#ifndef Tcl_SetBooleanObj", "#define Tcl_SetBooleanObj \\", "\t(tclStubsPtr->tcl_SetBooleanObj) /* 57 */", "#endif", "#ifndef Tcl_SetByteArrayLength", "#define Tcl_SetByteArrayLength \\", "\t(tclStubsPtr->tcl_SetByteArrayLength) /* 58 */", "#endif", "#ifndef Tcl_SetByteArrayObj", "#define Tcl_SetByteArrayObj \\", "\t(tclStubsPtr->tcl_SetByteArrayObj) /* 59 */", "#endif", "#ifndef Tcl_SetDoubleObj", "#define Tcl_SetDoubleObj \\", "\t(tclStubsPtr->tcl_SetDoubleObj) /* 60 */", "#endif", "#ifndef Tcl_SetIntObj", "#define Tcl_SetIntObj \\", "\t(tclStubsPtr->tcl_SetIntObj) /* 61 */", "#endif", "#ifndef Tcl_SetListObj", "#define Tcl_SetListObj \\", "\t(tclStubsPtr->tcl_SetListObj) /* 62 */", "#endif", "#ifndef Tcl_SetLongObj", "#define Tcl_SetLongObj \\", "\t(tclStubsPtr->tcl_SetLongObj) /* 63 */", "#endif", "#ifndef Tcl_SetObjLength", "#define Tcl_SetObjLength \\", "\t(tclStubsPtr->tcl_SetObjLength) /* 64 */", "#endif", "#ifndef Tcl_SetStringObj", "#define Tcl_SetStringObj \\", "\t(tclStubsPtr->tcl_SetStringObj) /* 65 */", "#endif", "#ifndef Tcl_AddErrorInfo", "#define Tcl_AddErrorInfo \\", "\t(tclStubsPtr->tcl_AddErrorInfo) /* 66 */", "#endif", "#ifndef Tcl_AddObjErrorInfo", "#define Tcl_AddObjErrorInfo \\", "\t(tclStubsPtr->tcl_AddObjErrorInfo) /* 67 */", "#endif", "#ifndef Tcl_AllowExceptions", "#define Tcl_AllowExceptions \\", "\t(tclStubsPtr->tcl_AllowExceptions) /* 68 */", "#endif", "#ifndef Tcl_AppendElement", "#define Tcl_AppendElement \\", "\t(tclStubsPtr->tcl_AppendElement) /* 69 */", "#endif", "#ifndef Tcl_AppendResult", "#define Tcl_AppendResult \\", "\t(tclStubsPtr->tcl_AppendResult) /* 70 */", "#endif", "#ifndef Tcl_AsyncCreate", "#define Tcl_AsyncCreate \\", "\t(tclStubsPtr->tcl_AsyncCreate) /* 71 */", "#endif", "#ifndef Tcl_AsyncDelete", "#define Tcl_AsyncDelete \\", "\t(tclStubsPtr->tcl_AsyncDelete) /* 72 */", "#endif", "#ifndef Tcl_AsyncInvoke", "#define Tcl_AsyncInvoke \\", "\t(tclStubsPtr->tcl_AsyncInvoke) /* 73 */", "#endif", "#ifndef Tcl_AsyncMark", "#define Tcl_AsyncMark \\", "\t(tclStubsPtr->tcl_AsyncMark) /* 74 */", "#endif", "#ifndef Tcl_AsyncReady", "#define Tcl_AsyncReady \\", "\t(tclStubsPtr->tcl_AsyncReady) /* 75 */", "#endif", "#ifndef Tcl_BackgroundError", "#define Tcl_BackgroundError \\", "\t(tclStubsPtr->tcl_BackgroundError) /* 76 */", "#endif", "#ifndef Tcl_Backslash", "#define Tcl_Backslash \\", "\t(tclStubsPtr->tcl_Backslash) /* 77 */", "#endif", "#ifndef Tcl_BadChannelOption", "#define Tcl_BadChannelOption \\", "\t(tclStubsPtr->tcl_BadChannelOption) /* 78 */", "#endif", "#ifndef Tcl_CallWhenDeleted", "#define Tcl_CallWhenDeleted \\", "\t(tclStubsPtr->tcl_CallWhenDeleted) /* 79 */", "#endif", "#ifndef Tcl_CancelIdleCall", "#define Tcl_CancelIdleCall \\", "\t(tclStubsPtr->tcl_CancelIdleCall) /* 80 */", "#endif", "#ifndef Tcl_Close", "#define Tcl_Close \\", "\t(tclStubsPtr->tcl_Close) /* 81 */", "#endif", "#ifndef Tcl_CommandComplete", "#define Tcl_CommandComplete \\", "\t(tclStubsPtr->tcl_CommandComplete) /* 82 */", "#endif", "#ifndef Tcl_Concat", "#define Tcl_Concat \\", "\t(tclStubsPtr->tcl_Concat) /* 83 */", "#endif", "#ifndef Tcl_ConvertElement", "#define Tcl_ConvertElement \\", "\t(tclStubsPtr->tcl_ConvertElement) /* 84 */", "#endif", "#ifndef Tcl_ConvertCountedElement", "#define Tcl_ConvertCountedElement \\", "\t(tclStubsPtr->tcl_ConvertCountedElement) /* 85 */", "#endif", "#ifndef Tcl_CreateAlias", "#define Tcl_CreateAlias \\", "\t(tclStubsPtr->tcl_CreateAlias) /* 86 */", "#endif", "#ifndef Tcl_CreateAliasObj", "#define Tcl_CreateAliasObj \\", "\t(tclStubsPtr->tcl_CreateAliasObj) /* 87 */", "#endif", "#ifndef Tcl_CreateChannel", "#define Tcl_CreateChannel \\", "\t(tclStubsPtr->tcl_CreateChannel) /* 88 */", "#endif", "#ifndef Tcl_CreateChannelHandler", "#define Tcl_CreateChannelHandler \\", "\t(tclStubsPtr->tcl_CreateChannelHandler) /* 89 */", "#endif", "#ifndef Tcl_CreateCloseHandler", "#define Tcl_CreateCloseHandler \\", "\t(tclStubsPtr->tcl_CreateCloseHandler) /* 90 */", "#endif", "#ifndef Tcl_CreateCommand", "#define Tcl_CreateCommand \\", "\t(tclStubsPtr->tcl_CreateCommand) /* 91 */", "#endif", "#ifndef Tcl_CreateEventSource", "#define Tcl_CreateEventSource \\", "\t(tclStubsPtr->tcl_CreateEventSource) /* 92 */", "#endif", "#ifndef Tcl_CreateExitHandler", "#define Tcl_CreateExitHandler \\", "\t(tclStubsPtr->tcl_CreateExitHandler) /* 93 */", "#endif", "#ifndef Tcl_CreateInterp", "#define Tcl_CreateInterp \\", "\t(tclStubsPtr->tcl_CreateInterp) /* 94 */", "#endif", "#ifndef Tcl_CreateMathFunc", "#define Tcl_CreateMathFunc \\", "\t(tclStubsPtr->tcl_CreateMathFunc) /* 95 */", "#endif", "#ifndef Tcl_CreateObjCommand", "#define Tcl_CreateObjCommand \\", "\t(tclStubsPtr->tcl_CreateObjCommand) /* 96 */", "#endif", "#ifndef Tcl_CreateSlave", "#define Tcl_CreateSlave \\", "\t(tclStubsPtr->tcl_CreateSlave) /* 97 */", "#endif", "#ifndef Tcl_CreateTimerHandler", "#define Tcl_CreateTimerHandler \\", "\t(tclStubsPtr->tcl_CreateTimerHandler) /* 98 */", "#endif", "#ifndef Tcl_CreateTrace", "#define Tcl_CreateTrace \\", "\t(tclStubsPtr->tcl_CreateTrace) /* 99 */", "#endif", "#ifndef Tcl_DeleteAssocData", "#define Tcl_DeleteAssocData \\", "\t(tclStubsPtr->tcl_DeleteAssocData) /* 100 */", "#endif", "#ifndef Tcl_DeleteChannelHandler", "#define Tcl_DeleteChannelHandler \\", "\t(tclStubsPtr->tcl_DeleteChannelHandler) /* 101 */", "#endif", "#ifndef Tcl_DeleteCloseHandler", "#define Tcl_DeleteCloseHandler \\", "\t(tclStubsPtr->tcl_DeleteCloseHandler) /* 102 */", "#endif", "#ifndef Tcl_DeleteCommand", "#define Tcl_DeleteCommand \\", "\t(tclStubsPtr->tcl_DeleteCommand) /* 103 */", "#endif", "#ifndef Tcl_DeleteCommandFromToken", "#define Tcl_DeleteCommandFromToken \\", "\t(tclStubsPtr->tcl_DeleteCommandFromToken) /* 104 */", "#endif", "#ifndef Tcl_DeleteEvents", "#define Tcl_DeleteEvents \\", "\t(tclStubsPtr->tcl_DeleteEvents) /* 105 */", "#endif", "#ifndef Tcl_DeleteEventSource", "#define Tcl_DeleteEventSource \\", "\t(tclStubsPtr->tcl_DeleteEventSource) /* 106 */", "#endif", "#ifndef Tcl_DeleteExitHandler", "#define Tcl_DeleteExitHandler \\", "\t(tclStubsPtr->tcl_DeleteExitHandler) /* 107 */", "#endif", "#ifndef Tcl_DeleteHashEntry", "#define Tcl_DeleteHashEntry \\", "\t(tclStubsPtr->tcl_DeleteHashEntry) /* 108 */", "#endif", "#ifndef Tcl_DeleteHashTable", "#define Tcl_DeleteHashTable \\", "\t(tclStubsPtr->tcl_DeleteHashTable) /* 109 */", "#endif", "#ifndef Tcl_DeleteInterp", "#define Tcl_DeleteInterp \\", "\t(tclStubsPtr->tcl_DeleteInterp) /* 110 */", "#endif", "#ifndef Tcl_DetachPids", "#define Tcl_DetachPids \\", "\t(tclStubsPtr->tcl_DetachPids) /* 111 */", "#endif", "#ifndef Tcl_DeleteTimerHandler", "#define Tcl_DeleteTimerHandler \\", "\t(tclStubsPtr->tcl_DeleteTimerHandler) /* 112 */", "#endif", "#ifndef Tcl_DeleteTrace", "#define Tcl_DeleteTrace \\", "\t(tclStubsPtr->tcl_DeleteTrace) /* 113 */", "#endif", "#ifndef Tcl_DontCallWhenDeleted", "#define Tcl_DontCallWhenDeleted \\", "\t(tclStubsPtr->tcl_DontCallWhenDeleted) /* 114 */", "#endif", "#ifndef Tcl_DoOneEvent", "#define Tcl_DoOneEvent \\", "\t(tclStubsPtr->tcl_DoOneEvent) /* 115 */", "#endif", "#ifndef Tcl_DoWhenIdle", "#define Tcl_DoWhenIdle \\", "\t(tclStubsPtr->tcl_DoWhenIdle) /* 116 */", "#endif", "#ifndef Tcl_DStringAppend", "#define Tcl_DStringAppend \\", "\t(tclStubsPtr->tcl_DStringAppend) /* 117 */", "#endif", "#ifndef Tcl_DStringAppendElement", "#define Tcl_DStringAppendElement \\", "\t(tclStubsPtr->tcl_DStringAppendElement) /* 118 */", "#endif", "#ifndef Tcl_DStringEndSublist", "#define Tcl_DStringEndSublist \\", "\t(tclStubsPtr->tcl_DStringEndSublist) /* 119 */", "#endif", "#ifndef Tcl_DStringFree", "#define Tcl_DStringFree \\", "\t(tclStubsPtr->tcl_DStringFree) /* 120 */", "#endif", "#ifndef Tcl_DStringGetResult", "#define Tcl_DStringGetResult \\", "\t(tclStubsPtr->tcl_DStringGetResult) /* 121 */", "#endif", "#ifndef Tcl_DStringInit", "#define Tcl_DStringInit \\", "\t(tclStubsPtr->tcl_DStringInit) /* 122 */", "#endif", "#ifndef Tcl_DStringResult", "#define Tcl_DStringResult \\", "\t(tclStubsPtr->tcl_DStringResult) /* 123 */", "#endif", "#ifndef Tcl_DStringSetLength", "#define Tcl_DStringSetLength \\", "\t(tclStubsPtr->tcl_DStringSetLength) /* 124 */", "#endif", "#ifndef Tcl_DStringStartSublist", "#define Tcl_DStringStartSublist \\", "\t(tclStubsPtr->tcl_DStringStartSublist) /* 125 */", "#endif", "#ifndef Tcl_Eof", "#define Tcl_Eof \\", "\t(tclStubsPtr->tcl_Eof) /* 126 */", "#endif", "#ifndef Tcl_ErrnoId", "#define Tcl_ErrnoId \\", "\t(tclStubsPtr->tcl_ErrnoId) /* 127 */", "#endif", "#ifndef Tcl_ErrnoMsg", "#define Tcl_ErrnoMsg \\", "\t(tclStubsPtr->tcl_ErrnoMsg) /* 128 */", "#endif", "#ifndef Tcl_Eval", "#define Tcl_Eval \\", "\t(tclStubsPtr->tcl_Eval) /* 129 */", "#endif", "#ifndef Tcl_EvalFile", "#define Tcl_EvalFile \\", "\t(tclStubsPtr->tcl_EvalFile) /* 130 */", "#endif", "#ifndef Tcl_EvalObj", "#define Tcl_EvalObj \\", "\t(tclStubsPtr->tcl_EvalObj) /* 131 */", "#endif", "#ifndef Tcl_EventuallyFree", "#define Tcl_EventuallyFree \\", "\t(tclStubsPtr->tcl_EventuallyFree) /* 132 */", "#endif", "#ifndef Tcl_Exit", "#define Tcl_Exit \\", "\t(tclStubsPtr->tcl_Exit) /* 133 */", "#endif", "#ifndef Tcl_ExposeCommand", "#define Tcl_ExposeCommand \\", "\t(tclStubsPtr->tcl_ExposeCommand) /* 134 */", "#endif", "#ifndef Tcl_ExprBoolean", "#define Tcl_ExprBoolean \\", "\t(tclStubsPtr->tcl_ExprBoolean) /* 135 */", "#endif", "#ifndef Tcl_ExprBooleanObj", "#define Tcl_ExprBooleanObj \\", "\t(tclStubsPtr->tcl_ExprBooleanObj) /* 136 */", "#endif", "#ifndef Tcl_ExprDouble", "#define Tcl_ExprDouble \\", "\t(tclStubsPtr->tcl_ExprDouble) /* 137 */", "#endif", "#ifndef Tcl_ExprDoubleObj", "#define Tcl_ExprDoubleObj \\", "\t(tclStubsPtr->tcl_ExprDoubleObj) /* 138 */", "#endif", "#ifndef Tcl_ExprLong", "#define Tcl_ExprLong \\", "\t(tclStubsPtr->tcl_ExprLong) /* 139 */", "#endif", "#ifndef Tcl_ExprLongObj", "#define Tcl_ExprLongObj \\", "\t(tclStubsPtr->tcl_ExprLongObj) /* 140 */", "#endif", "#ifndef Tcl_ExprObj", "#define Tcl_ExprObj \\", "\t(tclStubsPtr->tcl_ExprObj) /* 141 */", "#endif", "#ifndef Tcl_ExprString", "#define Tcl_ExprString \\", "\t(tclStubsPtr->tcl_ExprString) /* 142 */", "#endif", "#ifndef Tcl_Finalize", "#define Tcl_Finalize \\", "\t(tclStubsPtr->tcl_Finalize) /* 143 */", "#endif", "#ifndef Tcl_FindExecutable", "#define Tcl_FindExecutable \\", "\t(tclStubsPtr->tcl_FindExecutable) /* 144 */", "#endif", "#ifndef Tcl_FirstHashEntry", "#define Tcl_FirstHashEntry \\", "\t(tclStubsPtr->tcl_FirstHashEntry) /* 145 */", "#endif", "#ifndef Tcl_Flush", "#define Tcl_Flush \\", "\t(tclStubsPtr->tcl_Flush) /* 146 */", "#endif", "#ifndef Tcl_FreeResult", "#define Tcl_FreeResult \\", "\t(tclStubsPtr->tcl_FreeResult) /* 147 */", "#endif", "#ifndef Tcl_GetAlias", "#define Tcl_GetAlias \\", "\t(tclStubsPtr->tcl_GetAlias) /* 148 */", "#endif", "#ifndef Tcl_GetAliasObj", "#define Tcl_GetAliasObj \\", "\t(tclStubsPtr->tcl_GetAliasObj) /* 149 */", "#endif", "#ifndef Tcl_GetAssocData", "#define Tcl_GetAssocData \\", "\t(tclStubsPtr->tcl_GetAssocData) /* 150 */", "#endif", "#ifndef Tcl_GetChannel", "#define Tcl_GetChannel \\", "\t(tclStubsPtr->tcl_GetChannel) /* 151 */", "#endif", "#ifndef Tcl_GetChannelBufferSize", "#define Tcl_GetChannelBufferSize \\", "\t(tclStubsPtr->tcl_GetChannelBufferSize) /* 152 */", "#endif", "#ifndef Tcl_GetChannelHandle", "#define Tcl_GetChannelHandle \\", "\t(tclStubsPtr->tcl_GetChannelHandle) /* 153 */", "#endif", "#ifndef Tcl_GetChannelInstanceData", "#define Tcl_GetChannelInstanceData \\", "\t(tclStubsPtr->tcl_GetChannelInstanceData) /* 154 */", "#endif", "#ifndef Tcl_GetChannelMode", "#define Tcl_GetChannelMode \\", "\t(tclStubsPtr->tcl_GetChannelMode) /* 155 */", "#endif", "#ifndef Tcl_GetChannelName", "#define Tcl_GetChannelName \\", "\t(tclStubsPtr->tcl_GetChannelName) /* 156 */", "#endif", "#ifndef Tcl_GetChannelOption", "#define Tcl_GetChannelOption \\", "\t(tclStubsPtr->tcl_GetChannelOption) /* 157 */", "#endif", "#ifndef Tcl_GetChannelType", "#define Tcl_GetChannelType \\", "\t(tclStubsPtr->tcl_GetChannelType) /* 158 */", "#endif", "#ifndef Tcl_GetCommandInfo", "#define Tcl_GetCommandInfo \\", "\t(tclStubsPtr->tcl_GetCommandInfo) /* 159 */", "#endif", "#ifndef Tcl_GetCommandName", "#define Tcl_GetCommandName \\", "\t(tclStubsPtr->tcl_GetCommandName) /* 160 */", "#endif", "#ifndef Tcl_GetErrno", "#define Tcl_GetErrno \\", "\t(tclStubsPtr->tcl_GetErrno) /* 161 */", "#endif", "#ifndef Tcl_GetHostName", "#define Tcl_GetHostName \\", "\t(tclStubsPtr->tcl_GetHostName) /* 162 */", "#endif", "#ifndef Tcl_GetInterpPath", "#define Tcl_GetInterpPath \\", "\t(tclStubsPtr->tcl_GetInterpPath) /* 163 */", "#endif", "#ifndef Tcl_GetMaster", "#define Tcl_GetMaster \\", "\t(tclStubsPtr->tcl_GetMaster) /* 164 */", "#endif", "#ifndef Tcl_GetNameOfExecutable", "#define Tcl_GetNameOfExecutable \\", "\t(tclStubsPtr->tcl_GetNameOfExecutable) /* 165 */", "#endif", "#ifndef Tcl_GetObjResult", "#define Tcl_GetObjResult \\", "\t(tclStubsPtr->tcl_GetObjResult) /* 166 */", "#endif", "#if !defined(__WIN32__) && !defined(MAC_OSX_TCL) /* UNIX */", "#ifndef Tcl_GetOpenFile", "#define Tcl_GetOpenFile \\", "\t(tclStubsPtr->tcl_GetOpenFile) /* 167 */", "#endif", "#endif /* UNIX */", "#ifdef MAC_OSX_TCL /* MACOSX */", "#ifndef Tcl_GetOpenFile", "#define Tcl_GetOpenFile \\", "\t(tclStubsPtr->tcl_GetOpenFile) /* 167 */", "#endif", "#endif /* MACOSX */", "#ifndef Tcl_GetPathType", "#define Tcl_GetPathType \\", "\t(tclStubsPtr->tcl_GetPathType) /* 168 */", "#endif", "#ifndef Tcl_Gets", "#define Tcl_Gets \\", "\t(tclStubsPtr->tcl_Gets) /* 169 */", "#endif", "#ifndef Tcl_GetsObj", "#define Tcl_GetsObj \\", "\t(tclStubsPtr->tcl_GetsObj) /* 170 */", "#endif", "#ifndef Tcl_GetServiceMode", "#define Tcl_GetServiceMode \\", "\t(tclStubsPtr->tcl_GetServiceMode) /* 171 */", "#endif", "#ifndef Tcl_GetSlave", "#define Tcl_GetSlave \\", "\t(tclStubsPtr->tcl_GetSlave) /* 172 */", "#endif", "#ifndef Tcl_GetStdChannel", "#define Tcl_GetStdChannel \\", "\t(tclStubsPtr->tcl_GetStdChannel) /* 173 */", "#endif", "#ifndef Tcl_GetStringResult", "#define Tcl_GetStringResult \\", "\t(tclStubsPtr->tcl_GetStringResult) /* 174 */", "#endif", "#ifndef Tcl_GetVar", "#define Tcl_GetVar \\", "\t(tclStubsPtr->tcl_GetVar) /* 175 */", "#endif", "#ifndef Tcl_GetVar2", "#define Tcl_GetVar2 \\", "\t(tclStubsPtr->tcl_GetVar2) /* 176 */", "#endif", "#ifndef Tcl_GlobalEval", "#define Tcl_GlobalEval \\", "\t(tclStubsPtr->tcl_GlobalEval) /* 177 */", "#endif", "#ifndef Tcl_GlobalEvalObj", "#define Tcl_GlobalEvalObj \\", "\t(tclStubsPtr->tcl_GlobalEvalObj) /* 178 */", "#endif", "#ifndef Tcl_HideCommand", "#define Tcl_HideCommand \\", "\t(tclStubsPtr->tcl_HideCommand) /* 179 */", "#endif", "#ifndef Tcl_Init", "#define Tcl_Init \\", "\t(tclStubsPtr->tcl_Init) /* 180 */", "#endif", "#ifndef Tcl_InitHashTable", "#define Tcl_InitHashTable \\", "\t(tclStubsPtr->tcl_InitHashTable) /* 181 */", "#endif", "#ifndef Tcl_InputBlocked", "#define Tcl_InputBlocked \\", "\t(tclStubsPtr->tcl_InputBlocked) /* 182 */", "#endif", "#ifndef Tcl_InputBuffered", "#define Tcl_InputBuffered \\", "\t(tclStubsPtr->tcl_InputBuffered) /* 183 */", "#endif", "#ifndef Tcl_InterpDeleted", "#define Tcl_InterpDeleted \\", "\t(tclStubsPtr->tcl_InterpDeleted) /* 184 */", "#endif", "#ifndef Tcl_IsSafe", "#define Tcl_IsSafe \\", "\t(tclStubsPtr->tcl_IsSafe) /* 185 */", "#endif", "#ifndef Tcl_JoinPath", "#define Tcl_JoinPath \\", "\t(tclStubsPtr->tcl_JoinPath) /* 186 */", "#endif", "#ifndef Tcl_LinkVar", "#define Tcl_LinkVar \\", "\t(tclStubsPtr->tcl_LinkVar) /* 187 */", "#endif", "/* Slot 188 is reserved */", "#ifndef Tcl_MakeFileChannel", "#define Tcl_MakeFileChannel \\", "\t(tclStubsPtr->tcl_MakeFileChannel) /* 189 */", "#endif", "#ifndef Tcl_MakeSafe", "#define Tcl_MakeSafe \\", "\t(tclStubsPtr->tcl_MakeSafe) /* 190 */", "#endif", "#ifndef Tcl_MakeTcpClientChannel", "#define Tcl_MakeTcpClientChannel \\", "\t(tclStubsPtr->tcl_MakeTcpClientChannel) /* 191 */", "#endif", "#ifndef Tcl_Merge", "#define Tcl_Merge \\", "\t(tclStubsPtr->tcl_Merge) /* 192 */", "#endif", "#ifndef Tcl_NextHashEntry", "#define Tcl_NextHashEntry \\", "\t(tclStubsPtr->tcl_NextHashEntry) /* 193 */", "#endif", "#ifndef Tcl_NotifyChannel", "#define Tcl_NotifyChannel \\", "\t(tclStubsPtr->tcl_NotifyChannel) /* 194 */", "#endif", "#ifndef Tcl_ObjGetVar2", "#define Tcl_ObjGetVar2 \\", "\t(tclStubsPtr->tcl_ObjGetVar2) /* 195 */", "#endif", "#ifndef Tcl_ObjSetVar2", "#define Tcl_ObjSetVar2 \\", "\t(tclStubsPtr->tcl_ObjSetVar2) /* 196 */", "#endif", "#ifndef Tcl_OpenCommandChannel", "#define Tcl_OpenCommandChannel \\", "\t(tclStubsPtr->tcl_OpenCommandChannel) /* 197 */", "#endif", "#ifndef Tcl_OpenFileChannel", "#define Tcl_OpenFileChannel \\", "\t(tclStubsPtr->tcl_OpenFileChannel) /* 198 */", "#endif", "#ifndef Tcl_OpenTcpClient", "#define Tcl_OpenTcpClient \\", "\t(tclStubsPtr->tcl_OpenTcpClient) /* 199 */", "#endif", "#ifndef Tcl_OpenTcpServer", "#define Tcl_OpenTcpServer \\", "\t(tclStubsPtr->tcl_OpenTcpServer) /* 200 */", "#endif", "#ifndef Tcl_Preserve", "#define Tcl_Preserve \\", "\t(tclStubsPtr->tcl_Preserve) /* 201 */", "#endif", "#ifndef Tcl_PrintDouble", "#define Tcl_PrintDouble \\", "\t(tclStubsPtr->tcl_PrintDouble) /* 202 */", "#endif", "#ifndef Tcl_PutEnv", "#define Tcl_PutEnv \\", "\t(tclStubsPtr->tcl_PutEnv) /* 203 */", "#endif", "#ifndef Tcl_PosixError", "#define Tcl_PosixError \\", "\t(tclStubsPtr->tcl_PosixError) /* 204 */", "#endif", "#ifndef Tcl_QueueEvent", "#define Tcl_QueueEvent \\", "\t(tclStubsPtr->tcl_QueueEvent) /* 205 */", "#endif", "#ifndef Tcl_Read", "#define Tcl_Read \\", "\t(tclStubsPtr->tcl_Read) /* 206 */", "#endif", "#ifndef Tcl_ReapDetachedProcs", "#define Tcl_ReapDetachedProcs \\", "\t(tclStubsPtr->tcl_ReapDetachedProcs) /* 207 */", "#endif", "#ifndef Tcl_RecordAndEval", "#define Tcl_RecordAndEval \\", "\t(tclStubsPtr->tcl_RecordAndEval) /* 208 */", "#endif", "#ifndef Tcl_RecordAndEvalObj", "#define Tcl_RecordAndEvalObj \\", "\t(tclStubsPtr->tcl_RecordAndEvalObj) /* 209 */", "#endif", "#ifndef Tcl_RegisterChannel", "#define Tcl_RegisterChannel \\", "\t(tclStubsPtr->tcl_RegisterChannel) /* 210 */", "#endif", "#ifndef Tcl_RegisterObjType", "#define Tcl_RegisterObjType \\", "\t(tclStubsPtr->tcl_RegisterObjType) /* 211 */", "#endif", "#ifndef Tcl_RegExpCompile", "#define Tcl_RegExpCompile \\", "\t(tclStubsPtr->tcl_RegExpCompile) /* 212 */", "#endif", "#ifndef Tcl_RegExpExec", "#define Tcl_RegExpExec \\", "\t(tclStubsPtr->tcl_RegExpExec) /* 213 */", "#endif", "#ifndef Tcl_RegExpMatch", "#define Tcl_RegExpMatch \\", "\t(tclStubsPtr->tcl_RegExpMatch) /* 214 */", "#endif", "#ifndef Tcl_RegExpRange", "#define Tcl_RegExpRange \\", "\t(tclStubsPtr->tcl_RegExpRange) /* 215 */", "#endif", "#ifndef Tcl_Release", "#define Tcl_Release \\", "\t(tclStubsPtr->tcl_Release) /* 216 */", "#endif", "#ifndef Tcl_ResetResult", "#define Tcl_ResetResult \\", "\t(tclStubsPtr->tcl_ResetResult) /* 217 */", "#endif", "#ifndef Tcl_ScanElement", "#define Tcl_ScanElement \\", "\t(tclStubsPtr->tcl_ScanElement) /* 218 */", "#endif", "#ifndef Tcl_ScanCountedElement", "#define Tcl_ScanCountedElement \\", "\t(tclStubsPtr->tcl_ScanCountedElement) /* 219 */", "#endif", "#ifndef Tcl_SeekOld", "#define Tcl_SeekOld \\", "\t(tclStubsPtr->tcl_SeekOld) /* 220 */", "#endif", "#ifndef Tcl_ServiceAll", "#define Tcl_ServiceAll \\", "\t(tclStubsPtr->tcl_ServiceAll) /* 221 */", "#endif", "#ifndef Tcl_ServiceEvent", "#define Tcl_ServiceEvent \\", "\t(tclStubsPtr->tcl_ServiceEvent) /* 222 */", "#endif", "#ifndef Tcl_SetAssocData", "#define Tcl_SetAssocData \\", "\t(tclStubsPtr->tcl_SetAssocData) /* 223 */", "#endif", "#ifndef Tcl_SetChannelBufferSize", "#define Tcl_SetChannelBufferSize \\", "\t(tclStubsPtr->tcl_SetChannelBufferSize) /* 224 */", "#endif", "#ifndef Tcl_SetChannelOption", "#define Tcl_SetChannelOption \\", "\t(tclStubsPtr->tcl_SetChannelOption) /* 225 */", "#endif", "#ifndef Tcl_SetCommandInfo", "#define Tcl_SetCommandInfo \\", "\t(tclStubsPtr->tcl_SetCommandInfo) /* 226 */", "#endif", "#ifndef Tcl_SetErrno", "#define Tcl_SetErrno \\", "\t(tclStubsPtr->tcl_SetErrno) /* 227 */", "#endif", "#ifndef Tcl_SetErrorCode", "#define Tcl_SetErrorCode \\", "\t(tclStubsPtr->tcl_SetErrorCode) /* 228 */", "#endif", "#ifndef Tcl_SetMaxBlockTime", "#define Tcl_SetMaxBlockTime \\", "\t(tclStubsPtr->tcl_SetMaxBlockTime) /* 229 */", "#endif", "#ifndef Tcl_SetPanicProc", "#define Tcl_SetPanicProc \\", "\t(tclStubsPtr->tcl_SetPanicProc) /* 230 */", "#endif", "#ifndef Tcl_SetRecursionLimit", "#define Tcl_SetRecursionLimit \\", "\t(tclStubsPtr->tcl_SetRecursionLimit) /* 231 */", "#endif", "#ifndef Tcl_SetResult", "#define Tcl_SetResult \\", "\t(tclStubsPtr->tcl_SetResult) /* 232 */", "#endif", "#ifndef Tcl_SetServiceMode", "#define Tcl_SetServiceMode \\", "\t(tclStubsPtr->tcl_SetServiceMode) /* 233 */", "#endif", "#ifndef Tcl_SetObjErrorCode", "#define Tcl_SetObjErrorCode \\", "\t(tclStubsPtr->tcl_SetObjErrorCode) /* 234 */", "#endif", "#ifndef Tcl_SetObjResult", "#define Tcl_SetObjResult \\", "\t(tclStubsPtr->tcl_SetObjResult) /* 235 */", "#endif", "#ifndef Tcl_SetStdChannel", "#define Tcl_SetStdChannel \\", "\t(tclStubsPtr->tcl_SetStdChannel) /* 236 */", "#endif", "#ifndef Tcl_SetVar", "#define Tcl_SetVar \\", "\t(tclStubsPtr->tcl_SetVar) /* 237 */", "#endif", "#ifndef Tcl_SetVar2", "#define Tcl_SetVar2 \\", "\t(tclStubsPtr->tcl_SetVar2) /* 238 */", "#endif", "#ifndef Tcl_SignalId", "#define Tcl_SignalId \\", "\t(tclStubsPtr->tcl_SignalId) /* 239 */", "#endif", "#ifndef Tcl_SignalMsg", "#define Tcl_SignalMsg \\", "\t(tclStubsPtr->tcl_SignalMsg) /* 240 */", "#endif", "#ifndef Tcl_SourceRCFile", "#define Tcl_SourceRCFile \\", "\t(tclStubsPtr->tcl_SourceRCFile) /* 241 */", "#endif", "#ifndef Tcl_SplitList", "#define Tcl_SplitList \\", "\t(tclStubsPtr->tcl_SplitList) /* 242 */", "#endif", "#ifndef Tcl_SplitPath", "#define Tcl_SplitPath \\", "\t(tclStubsPtr->tcl_SplitPath) /* 243 */", "#endif", "#ifndef Tcl_StaticPackage", "#define Tcl_StaticPackage \\", "\t(tclStubsPtr->tcl_StaticPackage) /* 244 */", "#endif", "#ifndef Tcl_StringMatch", "#define Tcl_StringMatch \\", "\t(tclStubsPtr->tcl_StringMatch) /* 245 */", "#endif", "#ifndef Tcl_TellOld", "#define Tcl_TellOld \\", "\t(tclStubsPtr->tcl_TellOld) /* 246 */", "#endif", "#ifndef Tcl_TraceVar", "#define Tcl_TraceVar \\", "\t(tclStubsPtr->tcl_TraceVar) /* 247 */", "#endif", "#ifndef Tcl_TraceVar2", "#define Tcl_TraceVar2 \\", "\t(tclStubsPtr->tcl_TraceVar2) /* 248 */", "#endif", "#ifndef Tcl_TranslateFileName", "#define Tcl_TranslateFileName \\", "\t(tclStubsPtr->tcl_TranslateFileName) /* 249 */", "#endif", "#ifndef Tcl_Ungets", "#define Tcl_Ungets \\", "\t(tclStubsPtr->tcl_Ungets) /* 250 */", "#endif", "#ifndef Tcl_UnlinkVar", "#define Tcl_UnlinkVar \\", "\t(tclStubsPtr->tcl_UnlinkVar) /* 251 */", "#endif", "#ifndef Tcl_UnregisterChannel", "#define Tcl_UnregisterChannel \\", "\t(tclStubsPtr->tcl_UnregisterChannel) /* 252 */", "#endif", "#ifndef Tcl_UnsetVar", "#define Tcl_UnsetVar \\", "\t(tclStubsPtr->tcl_UnsetVar) /* 253 */", "#endif", "#ifndef Tcl_UnsetVar2", "#define Tcl_UnsetVar2 \\", "\t(tclStubsPtr->tcl_UnsetVar2) /* 254 */", "#endif", "#ifndef Tcl_UntraceVar", "#define Tcl_UntraceVar \\", "\t(tclStubsPtr->tcl_UntraceVar) /* 255 */", "#endif", "#ifndef Tcl_UntraceVar2", "#define Tcl_UntraceVar2 \\", "\t(tclStubsPtr->tcl_UntraceVar2) /* 256 */", "#endif", "#ifndef Tcl_UpdateLinkedVar", "#define Tcl_UpdateLinkedVar \\", "\t(tclStubsPtr->tcl_UpdateLinkedVar) /* 257 */", "#endif", "#ifndef Tcl_UpVar", "#define Tcl_UpVar \\", "\t(tclStubsPtr->tcl_UpVar) /* 258 */", "#endif", "#ifndef Tcl_UpVar2", "#define Tcl_UpVar2 \\", "\t(tclStubsPtr->tcl_UpVar2) /* 259 */", "#endif", "#ifndef Tcl_VarEval", "#define Tcl_VarEval \\", "\t(tclStubsPtr->tcl_VarEval) /* 260 */", "#endif", "#ifndef Tcl_VarTraceInfo", "#define Tcl_VarTraceInfo \\", "\t(tclStubsPtr->tcl_VarTraceInfo) /* 261 */", "#endif", "#ifndef Tcl_VarTraceInfo2", "#define Tcl_VarTraceInfo2 \\", "\t(tclStubsPtr->tcl_VarTraceInfo2) /* 262 */", "#endif", "#ifndef Tcl_Write", "#define Tcl_Write \\", "\t(tclStubsPtr->tcl_Write) /* 263 */", "#endif", "#ifndef Tcl_WrongNumArgs", "#define Tcl_WrongNumArgs \\", "\t(tclStubsPtr->tcl_WrongNumArgs) /* 264 */", "#endif", "#ifndef Tcl_DumpActiveMemory", "#define Tcl_DumpActiveMemory \\", "\t(tclStubsPtr->tcl_DumpActiveMemory) /* 265 */", "#endif", "#ifndef Tcl_ValidateAllMemory", "#define Tcl_ValidateAllMemory \\", "\t(tclStubsPtr->tcl_ValidateAllMemory) /* 266 */", "#endif", "#ifndef Tcl_AppendResultVA", "#define Tcl_AppendResultVA \\", "\t(tclStubsPtr->tcl_AppendResultVA) /* 267 */", "#endif", "#ifndef Tcl_AppendStringsToObjVA", "#define Tcl_AppendStringsToObjVA \\", "\t(tclStubsPtr->tcl_AppendStringsToObjVA) /* 268 */", "#endif", "#ifndef Tcl_HashStats", "#define Tcl_HashStats \\", "\t(tclStubsPtr->tcl_HashStats) /* 269 */", "#endif", "#ifndef Tcl_ParseVar", "#define Tcl_ParseVar \\", "\t(tclStubsPtr->tcl_ParseVar) /* 270 */", "#endif", "#ifndef Tcl_PkgPresent", "#define Tcl_PkgPresent \\", "\t(tclStubsPtr->tcl_PkgPresent) /* 271 */", "#endif", "#ifndef Tcl_PkgPresentEx", "#define Tcl_PkgPresentEx \\", "\t(tclStubsPtr->tcl_PkgPresentEx) /* 272 */", "#endif", "#ifndef Tcl_PkgProvide", "#define Tcl_PkgProvide \\", "\t(tclStubsPtr->tcl_PkgProvide) /* 273 */", "#endif", "#ifndef Tcl_PkgRequire", "#define Tcl_PkgRequire \\", "\t(tclStubsPtr->tcl_PkgRequire) /* 274 */", "#endif", "#ifndef Tcl_SetErrorCodeVA", "#define Tcl_SetErrorCodeVA \\", "\t(tclStubsPtr->tcl_SetErrorCodeVA) /* 275 */", "#endif", "#ifndef Tcl_VarEvalVA", "#define Tcl_VarEvalVA \\", "\t(tclStubsPtr->tcl_VarEvalVA) /* 276 */", "#endif", "#ifndef Tcl_WaitPid", "#define Tcl_WaitPid \\", "\t(tclStubsPtr->tcl_WaitPid) /* 277 */", "#endif", "#ifndef Tcl_PanicVA", "#define Tcl_PanicVA \\", "\t(tclStubsPtr->tcl_PanicVA) /* 278 */", "#endif", "#ifndef Tcl_GetVersion", "#define Tcl_GetVersion \\", "\t(tclStubsPtr->tcl_GetVersion) /* 279 */", "#endif", "#ifndef Tcl_InitMemory", "#define Tcl_InitMemory \\", "\t(tclStubsPtr->tcl_InitMemory) /* 280 */", "#endif", "#ifndef Tcl_StackChannel", "#define Tcl_StackChannel \\", "\t(tclStubsPtr->tcl_StackChannel) /* 281 */", "#endif", "#ifndef Tcl_UnstackChannel", "#define Tcl_UnstackChannel \\", "\t(tclStubsPtr->tcl_UnstackChannel) /* 282 */", "#endif", "#ifndef Tcl_GetStackedChannel", "#define Tcl_GetStackedChannel \\", "\t(tclStubsPtr->tcl_GetStackedChannel) /* 283 */", "#endif", "#ifndef Tcl_SetMainLoop", "#define Tcl_SetMainLoop \\", "\t(tclStubsPtr->tcl_SetMainLoop) /* 284 */", "#endif", "/* Slot 285 is reserved */", "#ifndef Tcl_AppendObjToObj", "#define Tcl_AppendObjToObj \\", "\t(tclStubsPtr->tcl_AppendObjToObj) /* 286 */", "#endif", "#ifndef Tcl_CreateEncoding", "#define Tcl_CreateEncoding \\", "\t(tclStubsPtr->tcl_CreateEncoding) /* 287 */", "#endif", "#ifndef Tcl_CreateThreadExitHandler", "#define Tcl_CreateThreadExitHandler \\", "\t(tclStubsPtr->tcl_CreateThreadExitHandler) /* 288 */", "#endif", "#ifndef Tcl_DeleteThreadExitHandler", "#define Tcl_DeleteThreadExitHandler \\", "\t(tclStubsPtr->tcl_DeleteThreadExitHandler) /* 289 */", "#endif", "#ifndef Tcl_DiscardResult", "#define Tcl_DiscardResult \\", "\t(tclStubsPtr->tcl_DiscardResult) /* 290 */", "#endif", "#ifndef Tcl_EvalEx", "#define Tcl_EvalEx \\", "\t(tclStubsPtr->tcl_EvalEx) /* 291 */", "#endif", "#ifndef Tcl_EvalObjv", "#define Tcl_EvalObjv \\", "\t(tclStubsPtr->tcl_EvalObjv) /* 292 */", "#endif", "#ifndef Tcl_EvalObjEx", "#define Tcl_EvalObjEx \\", "\t(tclStubsPtr->tcl_EvalObjEx) /* 293 */", "#endif", "#ifndef Tcl_ExitThread", "#define Tcl_ExitThread \\", "\t(tclStubsPtr->tcl_ExitThread) /* 294 */", "#endif", "#ifndef Tcl_ExternalToUtf", "#define Tcl_ExternalToUtf \\", "\t(tclStubsPtr->tcl_ExternalToUtf) /* 295 */", "#endif", "#ifndef Tcl_ExternalToUtfDString", "#define Tcl_ExternalToUtfDString \\", "\t(tclStubsPtr->tcl_ExternalToUtfDString) /* 296 */", "#endif", "#ifndef Tcl_FinalizeThread", "#define Tcl_FinalizeThread \\", "\t(tclStubsPtr->tcl_FinalizeThread) /* 297 */", "#endif", "#ifndef Tcl_FinalizeNotifier", "#define Tcl_FinalizeNotifier \\", "\t(tclStubsPtr->tcl_FinalizeNotifier) /* 298 */", "#endif", "#ifndef Tcl_FreeEncoding", "#define Tcl_FreeEncoding \\", "\t(tclStubsPtr->tcl_FreeEncoding) /* 299 */", "#endif", "#ifndef Tcl_GetCurrentThread", "#define Tcl_GetCurrentThread \\", "\t(tclStubsPtr->tcl_GetCurrentThread) /* 300 */", "#endif", "#ifndef Tcl_GetEncoding", "#define Tcl_GetEncoding \\", "\t(tclStubsPtr->tcl_GetEncoding) /* 301 */", "#endif", "#ifndef Tcl_GetEncodingName", "#define Tcl_GetEncodingName \\", "\t(tclStubsPtr->tcl_GetEncodingName) /* 302 */", "#endif", "#ifndef Tcl_GetEncodingNames", "#define Tcl_GetEncodingNames \\", "\t(tclStubsPtr->tcl_GetEncodingNames) /* 303 */", "#endif", "#ifndef Tcl_GetIndexFromObjStruct", "#define Tcl_GetIndexFromObjStruct \\", "\t(tclStubsPtr->tcl_GetIndexFromObjStruct) /* 304 */", "#endif", "#ifndef Tcl_GetThreadData", "#define Tcl_GetThreadData \\", "\t(tclStubsPtr->tcl_GetThreadData) /* 305 */", "#endif", "#ifndef Tcl_GetVar2Ex", "#define Tcl_GetVar2Ex \\", "\t(tclStubsPtr->tcl_GetVar2Ex) /* 306 */", "#endif", "#ifndef Tcl_InitNotifier", "#define Tcl_InitNotifier \\", "\t(tclStubsPtr->tcl_InitNotifier) /* 307 */", "#endif", "#ifndef Tcl_MutexLock", "#define Tcl_MutexLock \\", "\t(tclStubsPtr->tcl_MutexLock) /* 308 */", "#endif", "#ifndef Tcl_MutexUnlock", "#define Tcl_MutexUnlock \\", "\t(tclStubsPtr->tcl_MutexUnlock) /* 309 */", "#endif", "#ifndef Tcl_ConditionNotify", "#define Tcl_ConditionNotify \\", "\t(tclStubsPtr->tcl_ConditionNotify) /* 310 */", "#endif", "#ifndef Tcl_ConditionWait", "#define Tcl_ConditionWait \\", "\t(tclStubsPtr->tcl_ConditionWait) /* 311 */", "#endif", "#ifndef Tcl_NumUtfChars", "#define Tcl_NumUtfChars \\", "\t(tclStubsPtr->tcl_NumUtfChars) /* 312 */", "#endif", "#ifndef Tcl_ReadChars", "#define Tcl_ReadChars \\", "\t(tclStubsPtr->tcl_ReadChars) /* 313 */", "#endif", "#ifndef Tcl_RestoreResult", "#define Tcl_RestoreResult \\", "\t(tclStubsPtr->tcl_RestoreResult) /* 314 */", "#endif", "#ifndef Tcl_SaveResult", "#define Tcl_SaveResult \\", "\t(tclStubsPtr->tcl_SaveResult) /* 315 */", "#endif", "#ifndef Tcl_SetSystemEncoding", "#define Tcl_SetSystemEncoding \\", "\t(tclStubsPtr->tcl_SetSystemEncoding) /* 316 */", "#endif", "#ifndef Tcl_SetVar2Ex", "#define Tcl_SetVar2Ex \\", "\t(tclStubsPtr->tcl_SetVar2Ex) /* 317 */", "#endif", "#ifndef Tcl_ThreadAlert", "#define Tcl_ThreadAlert \\", "\t(tclStubsPtr->tcl_ThreadAlert) /* 318 */", "#endif", "#ifndef Tcl_ThreadQueueEvent", "#define Tcl_ThreadQueueEvent \\", "\t(tclStubsPtr->tcl_ThreadQueueEvent) /* 319 */", "#endif", "#ifndef Tcl_UniCharAtIndex", "#define Tcl_UniCharAtIndex \\", "\t(tclStubsPtr->tcl_UniCharAtIndex) /* 320 */", "#endif", "#ifndef Tcl_UniCharToLower", "#define Tcl_UniCharToLower \\", "\t(tclStubsPtr->tcl_UniCharToLower) /* 321 */", "#endif", "#ifndef Tcl_UniCharToTitle", "#define Tcl_UniCharToTitle \\", "\t(tclStubsPtr->tcl_UniCharToTitle) /* 322 */", "#endif", "#ifndef Tcl_UniCharToUpper", "#define Tcl_UniCharToUpper \\", "\t(tclStubsPtr->tcl_UniCharToUpper) /* 323 */", "#endif", "#ifndef Tcl_UniCharToUtf", "#define Tcl_UniCharToUtf \\", "\t(tclStubsPtr->tcl_UniCharToUtf) /* 324 */", "#endif", "#ifndef Tcl_UtfAtIndex", "#define Tcl_UtfAtIndex \\", "\t(tclStubsPtr->tcl_UtfAtIndex) /* 325 */", "#endif", "#ifndef Tcl_UtfCharComplete", "#define Tcl_UtfCharComplete \\", "\t(tclStubsPtr->tcl_UtfCharComplete) /* 326 */", "#endif", "#ifndef Tcl_UtfBackslash", "#define Tcl_UtfBackslash \\", "\t(tclStubsPtr->tcl_UtfBackslash) /* 327 */", "#endif", "#ifndef Tcl_UtfFindFirst", "#define Tcl_UtfFindFirst \\", "\t(tclStubsPtr->tcl_UtfFindFirst) /* 328 */", "#endif", "#ifndef Tcl_UtfFindLast", "#define Tcl_UtfFindLast \\", "\t(tclStubsPtr->tcl_UtfFindLast) /* 329 */", "#endif", "#ifndef Tcl_UtfNext", "#define Tcl_UtfNext \\", "\t(tclStubsPtr->tcl_UtfNext) /* 330 */", "#endif", "#ifndef Tcl_UtfPrev", "#define Tcl_UtfPrev \\", "\t(tclStubsPtr->tcl_UtfPrev) /* 331 */", "#endif", "#ifndef Tcl_UtfToExternal", "#define Tcl_UtfToExternal \\", "\t(tclStubsPtr->tcl_UtfToExternal) /* 332 */", "#endif", "#ifndef Tcl_UtfToExternalDString", "#define Tcl_UtfToExternalDString \\", "\t(tclStubsPtr->tcl_UtfToExternalDString) /* 333 */", "#endif", "#ifndef Tcl_UtfToLower", "#define Tcl_UtfToLower \\", "\t(tclStubsPtr->tcl_UtfToLower) /* 334 */", "#endif", "#ifndef Tcl_UtfToTitle", "#define Tcl_UtfToTitle \\", "\t(tclStubsPtr->tcl_UtfToTitle) /* 335 */", "#endif", "#ifndef Tcl_UtfToUniChar", "#define Tcl_UtfToUniChar \\", "\t(tclStubsPtr->tcl_UtfToUniChar) /* 336 */", "#endif", "#ifndef Tcl_UtfToUpper", "#define Tcl_UtfToUpper \\", "\t(tclStubsPtr->tcl_UtfToUpper) /* 337 */", "#endif", "#ifndef Tcl_WriteChars", "#define Tcl_WriteChars \\", "\t(tclStubsPtr->tcl_WriteChars) /* 338 */", "#endif", "#ifndef Tcl_WriteObj", "#define Tcl_WriteObj \\", "\t(tclStubsPtr->tcl_WriteObj) /* 339 */", "#endif", "#ifndef Tcl_GetString", "#define Tcl_GetString \\", "\t(tclStubsPtr->tcl_GetString) /* 340 */", "#endif", "#ifndef Tcl_GetDefaultEncodingDir", "#define Tcl_GetDefaultEncodingDir \\", "\t(tclStubsPtr->tcl_GetDefaultEncodingDir) /* 341 */", "#endif", "#ifndef Tcl_SetDefaultEncodingDir", "#define Tcl_SetDefaultEncodingDir \\", "\t(tclStubsPtr->tcl_SetDefaultEncodingDir) /* 342 */", "#endif", "#ifndef Tcl_AlertNotifier", "#define Tcl_AlertNotifier \\", "\t(tclStubsPtr->tcl_AlertNotifier) /* 343 */", "#endif", "#ifndef Tcl_ServiceModeHook", "#define Tcl_ServiceModeHook \\", "\t(tclStubsPtr->tcl_ServiceModeHook) /* 344 */", "#endif", "#ifndef Tcl_UniCharIsAlnum", "#define Tcl_UniCharIsAlnum \\", "\t(tclStubsPtr->tcl_UniCharIsAlnum) /* 345 */", "#endif", "#ifndef Tcl_UniCharIsAlpha", "#define Tcl_UniCharIsAlpha \\", "\t(tclStubsPtr->tcl_UniCharIsAlpha) /* 346 */", "#endif", "#ifndef Tcl_UniCharIsDigit", "#define Tcl_UniCharIsDigit \\", "\t(tclStubsPtr->tcl_UniCharIsDigit) /* 347 */", "#endif", "#ifndef Tcl_UniCharIsLower", "#define Tcl_UniCharIsLower \\", "\t(tclStubsPtr->tcl_UniCharIsLower) /* 348 */", "#endif", "#ifndef Tcl_UniCharIsSpace", "#define Tcl_UniCharIsSpace \\", "\t(tclStubsPtr->tcl_UniCharIsSpace) /* 349 */", "#endif", "#ifndef Tcl_UniCharIsUpper", "#define Tcl_UniCharIsUpper \\", "\t(tclStubsPtr->tcl_UniCharIsUpper) /* 350 */", "#endif", "#ifndef Tcl_UniCharIsWordChar", "#define Tcl_UniCharIsWordChar \\", "\t(tclStubsPtr->tcl_UniCharIsWordChar) /* 351 */", "#endif", "#ifndef Tcl_UniCharLen", "#define Tcl_UniCharLen \\", "\t(tclStubsPtr->tcl_UniCharLen) /* 352 */", "#endif", "#ifndef Tcl_UniCharNcmp", "#define Tcl_UniCharNcmp \\", "\t(tclStubsPtr->tcl_UniCharNcmp) /* 353 */", "#endif", "#ifndef Tcl_UniCharToUtfDString", "#define Tcl_UniCharToUtfDString \\", "\t(tclStubsPtr->tcl_UniCharToUtfDString) /* 354 */", "#endif", "#ifndef Tcl_UtfToUniCharDString", "#define Tcl_UtfToUniCharDString \\", "\t(tclStubsPtr->tcl_UtfToUniCharDString) /* 355 */", "#endif", "#ifndef Tcl_GetRegExpFromObj", "#define Tcl_GetRegExpFromObj \\", "\t(tclStubsPtr->tcl_GetRegExpFromObj) /* 356 */", "#endif", "#ifndef Tcl_EvalTokens", "#define Tcl_EvalTokens \\", "\t(tclStubsPtr->tcl_EvalTokens) /* 357 */", "#endif", "#ifndef Tcl_FreeParse", "#define Tcl_FreeParse \\", "\t(tclStubsPtr->tcl_FreeParse) /* 358 */", "#endif", "#ifndef Tcl_LogCommandInfo", "#define Tcl_LogCommandInfo \\", "\t(tclStubsPtr->tcl_LogCommandInfo) /* 359 */", "#endif", "#ifndef Tcl_ParseBraces", "#define Tcl_ParseBraces \\", "\t(tclStubsPtr->tcl_ParseBraces) /* 360 */", "#endif", "#ifndef Tcl_ParseCommand", "#define Tcl_ParseCommand \\", "\t(tclStubsPtr->tcl_ParseCommand) /* 361 */", "#endif", "#ifndef Tcl_ParseExpr", "#define Tcl_ParseExpr \\", "\t(tclStubsPtr->tcl_ParseExpr) /* 362 */", "#endif", "#ifndef Tcl_ParseQuotedString", "#define Tcl_ParseQuotedString \\", "\t(tclStubsPtr->tcl_ParseQuotedString) /* 363 */", "#endif", "#ifndef Tcl_ParseVarName", "#define Tcl_ParseVarName \\", "\t(tclStubsPtr->tcl_ParseVarName) /* 364 */", "#endif", "#ifndef Tcl_GetCwd", "#define Tcl_GetCwd \\", "\t(tclStubsPtr->tcl_GetCwd) /* 365 */", "#endif", "#ifndef Tcl_Chdir", "#define Tcl_Chdir \\", "\t(tclStubsPtr->tcl_Chdir) /* 366 */", "#endif", "#ifndef Tcl_Access", "#define Tcl_Access \\", "\t(tclStubsPtr->tcl_Access) /* 367 */", "#endif", "#ifndef Tcl_Stat", "#define Tcl_Stat \\", "\t(tclStubsPtr->tcl_Stat) /* 368 */", "#endif", "#ifndef Tcl_UtfNcmp", "#define Tcl_UtfNcmp \\", "\t(tclStubsPtr->tcl_UtfNcmp) /* 369 */", "#endif", "#ifndef Tcl_UtfNcasecmp", "#define Tcl_UtfNcasecmp \\", "\t(tclStubsPtr->tcl_UtfNcasecmp) /* 370 */", "#endif", "#ifndef Tcl_StringCaseMatch", "#define Tcl_StringCaseMatch \\", "\t(tclStubsPtr->tcl_StringCaseMatch) /* 371 */", "#endif", "#ifndef Tcl_UniCharIsControl", "#define Tcl_UniCharIsControl \\", "\t(tclStubsPtr->tcl_UniCharIsControl) /* 372 */", "#endif", "#ifndef Tcl_UniCharIsGraph", "#define Tcl_UniCharIsGraph \\", "\t(tclStubsPtr->tcl_UniCharIsGraph) /* 373 */", "#endif", "#ifndef Tcl_UniCharIsPrint", "#define Tcl_UniCharIsPrint \\", "\t(tclStubsPtr->tcl_UniCharIsPrint) /* 374 */", "#endif", "#ifndef Tcl_UniCharIsPunct", "#define Tcl_UniCharIsPunct \\", "\t(tclStubsPtr->tcl_UniCharIsPunct) /* 375 */", "#endif", "#ifndef Tcl_RegExpExecObj", "#define Tcl_RegExpExecObj \\", "\t(tclStubsPtr->tcl_RegExpExecObj) /* 376 */", "#endif", "#ifndef Tcl_RegExpGetInfo", "#define Tcl_RegExpGetInfo \\", "\t(tclStubsPtr->tcl_RegExpGetInfo) /* 377 */", "#endif", "#ifndef Tcl_NewUnicodeObj", "#define Tcl_NewUnicodeObj \\", "\t(tclStubsPtr->tcl_NewUnicodeObj) /* 378 */", "#endif", "#ifndef Tcl_SetUnicodeObj", "#define Tcl_SetUnicodeObj \\", "\t(tclStubsPtr->tcl_SetUnicodeObj) /* 379 */", "#endif", "#ifndef Tcl_GetCharLength", "#define Tcl_GetCharLength \\", "\t(tclStubsPtr->tcl_GetCharLength) /* 380 */", "#endif", "#ifndef Tcl_GetUniChar", "#define Tcl_GetUniChar \\", "\t(tclStubsPtr->tcl_GetUniChar) /* 381 */", "#endif", "#ifndef Tcl_GetUnicode", "#define Tcl_GetUnicode \\", "\t(tclStubsPtr->tcl_GetUnicode) /* 382 */", "#endif", "#ifndef Tcl_GetRange", "#define Tcl_GetRange \\", "\t(tclStubsPtr->tcl_GetRange) /* 383 */", "#endif", "#ifndef Tcl_AppendUnicodeToObj", "#define Tcl_AppendUnicodeToObj \\", "\t(tclStubsPtr->tcl_AppendUnicodeToObj) /* 384 */", "#endif", "#ifndef Tcl_RegExpMatchObj", "#define Tcl_RegExpMatchObj \\", "\t(tclStubsPtr->tcl_RegExpMatchObj) /* 385 */", "#endif", "#ifndef Tcl_SetNotifier", "#define Tcl_SetNotifier \\", "\t(tclStubsPtr->tcl_SetNotifier) /* 386 */", "#endif", "#ifndef Tcl_GetAllocMutex", "#define Tcl_GetAllocMutex \\", "\t(tclStubsPtr->tcl_GetAllocMutex) /* 387 */", "#endif", "#ifndef Tcl_GetChannelNames", "#define Tcl_GetChannelNames \\", "\t(tclStubsPtr->tcl_GetChannelNames) /* 388 */", "#endif", "#ifndef Tcl_GetChannelNamesEx", "#define Tcl_GetChannelNamesEx \\", "\t(tclStubsPtr->tcl_GetChannelNamesEx) /* 389 */", "#endif", "#ifndef Tcl_ProcObjCmd", "#define Tcl_ProcObjCmd \\", "\t(tclStubsPtr->tcl_ProcObjCmd) /* 390 */", "#endif", "#ifndef Tcl_ConditionFinalize", "#define Tcl_ConditionFinalize \\", "\t(tclStubsPtr->tcl_ConditionFinalize) /* 391 */", "#endif", "#ifndef Tcl_MutexFinalize", "#define Tcl_MutexFinalize \\", "\t(tclStubsPtr->tcl_MutexFinalize) /* 392 */", "#endif", "#ifndef Tcl_CreateThread", "#define Tcl_CreateThread \\", "\t(tclStubsPtr->tcl_CreateThread) /* 393 */", "#endif", "#ifndef Tcl_ReadRaw", "#define Tcl_ReadRaw \\", "\t(tclStubsPtr->tcl_ReadRaw) /* 394 */", "#endif", "#ifndef Tcl_WriteRaw", "#define Tcl_WriteRaw \\", "\t(tclStubsPtr->tcl_WriteRaw) /* 395 */", "#endif", "#ifndef Tcl_GetTopChannel", "#define Tcl_GetTopChannel \\", "\t(tclStubsPtr->tcl_GetTopChannel) /* 396 */", "#endif", "#ifndef Tcl_ChannelBuffered", "#define Tcl_ChannelBuffered \\", "\t(tclStubsPtr->tcl_ChannelBuffered) /* 397 */", "#endif", "#ifndef Tcl_ChannelName", "#define Tcl_ChannelName \\", "\t(tclStubsPtr->tcl_ChannelName) /* 398 */", "#endif", "#ifndef Tcl_ChannelVersion", "#define Tcl_ChannelVersion \\", "\t(tclStubsPtr->tcl_ChannelVersion) /* 399 */", "#endif", "#ifndef Tcl_ChannelBlockModeProc", "#define Tcl_ChannelBlockModeProc \\", "\t(tclStubsPtr->tcl_ChannelBlockModeProc) /* 400 */", "#endif", "#ifndef Tcl_ChannelCloseProc", "#define Tcl_ChannelCloseProc \\", "\t(tclStubsPtr->tcl_ChannelCloseProc) /* 401 */", "#endif", "#ifndef Tcl_ChannelClose2Proc", "#define Tcl_ChannelClose2Proc \\", "\t(tclStubsPtr->tcl_ChannelClose2Proc) /* 402 */", "#endif", "#ifndef Tcl_ChannelInputProc", "#define Tcl_ChannelInputProc \\", "\t(tclStubsPtr->tcl_ChannelInputProc) /* 403 */", "#endif", "#ifndef Tcl_ChannelOutputProc", "#define Tcl_ChannelOutputProc \\", "\t(tclStubsPtr->tcl_ChannelOutputProc) /* 404 */", "#endif", "#ifndef Tcl_ChannelSeekProc", "#define Tcl_ChannelSeekProc \\", "\t(tclStubsPtr->tcl_ChannelSeekProc) /* 405 */", "#endif", "#ifndef Tcl_ChannelSetOptionProc", "#define Tcl_ChannelSetOptionProc \\", "\t(tclStubsPtr->tcl_ChannelSetOptionProc) /* 406 */", "#endif", "#ifndef Tcl_ChannelGetOptionProc", "#define Tcl_ChannelGetOptionProc \\", "\t(tclStubsPtr->tcl_ChannelGetOptionProc) /* 407 */", "#endif", "#ifndef Tcl_ChannelWatchProc", "#define Tcl_ChannelWatchProc \\", "\t(tclStubsPtr->tcl_ChannelWatchProc) /* 408 */", "#endif", "#ifndef Tcl_ChannelGetHandleProc", "#define Tcl_ChannelGetHandleProc \\", "\t(tclStubsPtr->tcl_ChannelGetHandleProc) /* 409 */", "#endif", "#ifndef Tcl_ChannelFlushProc", "#define Tcl_ChannelFlushProc \\", "\t(tclStubsPtr->tcl_ChannelFlushProc) /* 410 */", "#endif", "#ifndef Tcl_ChannelHandlerProc", "#define Tcl_ChannelHandlerProc \\", "\t(tclStubsPtr->tcl_ChannelHandlerProc) /* 411 */", "#endif", "#ifndef Tcl_JoinThread", "#define Tcl_JoinThread \\", "\t(tclStubsPtr->tcl_JoinThread) /* 412 */", "#endif", "#ifndef Tcl_IsChannelShared", "#define Tcl_IsChannelShared \\", "\t(tclStubsPtr->tcl_IsChannelShared) /* 413 */", "#endif", "#ifndef Tcl_IsChannelRegistered", "#define Tcl_IsChannelRegistered \\", "\t(tclStubsPtr->tcl_IsChannelRegistered) /* 414 */", "#endif", "#ifndef Tcl_CutChannel", "#define Tcl_CutChannel \\", "\t(tclStubsPtr->tcl_CutChannel) /* 415 */", "#endif", "#ifndef Tcl_SpliceChannel", "#define Tcl_SpliceChannel \\", "\t(tclStubsPtr->tcl_SpliceChannel) /* 416 */", "#endif", "#ifndef Tcl_ClearChannelHandlers", "#define Tcl_ClearChannelHandlers \\", "\t(tclStubsPtr->tcl_ClearChannelHandlers) /* 417 */", "#endif", "#ifndef Tcl_IsChannelExisting", "#define Tcl_IsChannelExisting \\", "\t(tclStubsPtr->tcl_IsChannelExisting) /* 418 */", "#endif", "#ifndef Tcl_UniCharNcasecmp", "#define Tcl_UniCharNcasecmp \\", "\t(tclStubsPtr->tcl_UniCharNcasecmp) /* 419 */", "#endif", "#ifndef Tcl_UniCharCaseMatch", "#define Tcl_UniCharCaseMatch \\", "\t(tclStubsPtr->tcl_UniCharCaseMatch) /* 420 */", "#endif", "#ifndef Tcl_FindHashEntry", "#define Tcl_FindHashEntry \\", "\t(tclStubsPtr->tcl_FindHashEntry) /* 421 */", "#endif", "#ifndef Tcl_CreateHashEntry", "#define Tcl_CreateHashEntry \\", "\t(tclStubsPtr->tcl_CreateHashEntry) /* 422 */", "#endif", "#ifndef Tcl_InitCustomHashTable", "#define Tcl_InitCustomHashTable \\", "\t(tclStubsPtr->tcl_InitCustomHashTable) /* 423 */", "#endif", "#ifndef Tcl_InitObjHashTable", "#define Tcl_InitObjHashTable \\", "\t(tclStubsPtr->tcl_InitObjHashTable) /* 424 */", "#endif", "#ifndef Tcl_CommandTraceInfo", "#define Tcl_CommandTraceInfo \\", "\t(tclStubsPtr->tcl_CommandTraceInfo) /* 425 */", "#endif", "#ifndef Tcl_TraceCommand", "#define Tcl_TraceCommand \\", "\t(tclStubsPtr->tcl_TraceCommand) /* 426 */", "#endif", "#ifndef Tcl_UntraceCommand", "#define Tcl_UntraceCommand \\", "\t(tclStubsPtr->tcl_UntraceCommand) /* 427 */", "#endif", "#ifndef Tcl_AttemptAlloc", "#define Tcl_AttemptAlloc \\", "\t(tclStubsPtr->tcl_AttemptAlloc) /* 428 */", "#endif", "#ifndef Tcl_AttemptDbCkalloc", "#define Tcl_AttemptDbCkalloc \\", "\t(tclStubsPtr->tcl_AttemptDbCkalloc) /* 429 */", "#endif", "#ifndef Tcl_AttemptRealloc", "#define Tcl_AttemptRealloc \\", "\t(tclStubsPtr->tcl_AttemptRealloc) /* 430 */", "#endif", "#ifndef Tcl_AttemptDbCkrealloc", "#define Tcl_AttemptDbCkrealloc \\", "\t(tclStubsPtr->tcl_AttemptDbCkrealloc) /* 431 */", "#endif", "#ifndef Tcl_AttemptSetObjLength", "#define Tcl_AttemptSetObjLength \\", "\t(tclStubsPtr->tcl_AttemptSetObjLength) /* 432 */", "#endif", "#ifndef Tcl_GetChannelThread", "#define Tcl_GetChannelThread \\", "\t(tclStubsPtr->tcl_GetChannelThread) /* 433 */", "#endif", "#ifndef Tcl_GetUnicodeFromObj", "#define Tcl_GetUnicodeFromObj \\", "\t(tclStubsPtr->tcl_GetUnicodeFromObj) /* 434 */", "#endif", "#ifndef Tcl_GetMathFuncInfo", "#define Tcl_GetMathFuncInfo \\", "\t(tclStubsPtr->tcl_GetMathFuncInfo) /* 435 */", "#endif", "#ifndef Tcl_ListMathFuncs", "#define Tcl_ListMathFuncs \\", "\t(tclStubsPtr->tcl_ListMathFuncs) /* 436 */", "#endif", "#ifndef Tcl_SubstObj", "#define Tcl_SubstObj \\", "\t(tclStubsPtr->tcl_SubstObj) /* 437 */", "#endif", "#ifndef Tcl_DetachChannel", "#define Tcl_DetachChannel \\", "\t(tclStubsPtr->tcl_DetachChannel) /* 438 */", "#endif", "#ifndef Tcl_IsStandardChannel", "#define Tcl_IsStandardChannel \\", "\t(tclStubsPtr->tcl_IsStandardChannel) /* 439 */", "#endif", "#ifndef Tcl_FSCopyFile", "#define Tcl_FSCopyFile \\", "\t(tclStubsPtr->tcl_FSCopyFile) /* 440 */", "#endif", "#ifndef Tcl_FSCopyDirectory", "#define Tcl_FSCopyDirectory \\", "\t(tclStubsPtr->tcl_FSCopyDirectory) /* 441 */", "#endif", "#ifndef Tcl_FSCreateDirectory", "#define Tcl_FSCreateDirectory \\", "\t(tclStubsPtr->tcl_FSCreateDirectory) /* 442 */", "#endif", "#ifndef Tcl_FSDeleteFile", "#define Tcl_FSDeleteFile \\", "\t(tclStubsPtr->tcl_FSDeleteFile) /* 443 */", "#endif", "#ifndef Tcl_FSLoadFile", "#define Tcl_FSLoadFile \\", "\t(tclStubsPtr->tcl_FSLoadFile) /* 444 */", "#endif", "#ifndef Tcl_FSMatchInDirectory", "#define Tcl_FSMatchInDirectory \\", "\t(tclStubsPtr->tcl_FSMatchInDirectory) /* 445 */", "#endif", "#ifndef Tcl_FSLink", "#define Tcl_FSLink \\", "\t(tclStubsPtr->tcl_FSLink) /* 446 */", "#endif", "#ifndef Tcl_FSRemoveDirectory", "#define Tcl_FSRemoveDirectory \\", "\t(tclStubsPtr->tcl_FSRemoveDirectory) /* 447 */", "#endif", "#ifndef Tcl_FSRenameFile", "#define Tcl_FSRenameFile \\", "\t(tclStubsPtr->tcl_FSRenameFile) /* 448 */", "#endif", "#ifndef Tcl_FSLstat", "#define Tcl_FSLstat \\", "\t(tclStubsPtr->tcl_FSLstat) /* 449 */", "#endif", "#ifndef Tcl_FSUtime", "#define Tcl_FSUtime \\", "\t(tclStubsPtr->tcl_FSUtime) /* 450 */", "#endif", "#ifndef Tcl_FSFileAttrsGet", "#define Tcl_FSFileAttrsGet \\", "\t(tclStubsPtr->tcl_FSFileAttrsGet) /* 451 */", "#endif", "#ifndef Tcl_FSFileAttrsSet", "#define Tcl_FSFileAttrsSet \\", "\t(tclStubsPtr->tcl_FSFileAttrsSet) /* 452 */", "#endif", "#ifndef Tcl_FSFileAttrStrings", "#define Tcl_FSFileAttrStrings \\", "\t(tclStubsPtr->tcl_FSFileAttrStrings) /* 453 */", "#endif", "#ifndef Tcl_FSStat", "#define Tcl_FSStat \\", "\t(tclStubsPtr->tcl_FSStat) /* 454 */", "#endif", "#ifndef Tcl_FSAccess", "#define Tcl_FSAccess \\", "\t(tclStubsPtr->tcl_FSAccess) /* 455 */", "#endif", "#ifndef Tcl_FSOpenFileChannel", "#define Tcl_FSOpenFileChannel \\", "\t(tclStubsPtr->tcl_FSOpenFileChannel) /* 456 */", "#endif", "#ifndef Tcl_FSGetCwd", "#define Tcl_FSGetCwd \\", "\t(tclStubsPtr->tcl_FSGetCwd) /* 457 */", "#endif", "#ifndef Tcl_FSChdir", "#define Tcl_FSChdir \\", "\t(tclStubsPtr->tcl_FSChdir) /* 458 */", "#endif", "#ifndef Tcl_FSConvertToPathType", "#define Tcl_FSConvertToPathType \\", "\t(tclStubsPtr->tcl_FSConvertToPathType) /* 459 */", "#endif", "#ifndef Tcl_FSJoinPath", "#define Tcl_FSJoinPath \\", "\t(tclStubsPtr->tcl_FSJoinPath) /* 460 */", "#endif", "#ifndef Tcl_FSSplitPath", "#define Tcl_FSSplitPath \\", "\t(tclStubsPtr->tcl_FSSplitPath) /* 461 */", "#endif", "#ifndef Tcl_FSEqualPaths", "#define Tcl_FSEqualPaths \\", "\t(tclStubsPtr->tcl_FSEqualPaths) /* 462 */", "#endif", "#ifndef Tcl_FSGetNormalizedPath", "#define Tcl_FSGetNormalizedPath \\", "\t(tclStubsPtr->tcl_FSGetNormalizedPath) /* 463 */", "#endif", "#ifndef Tcl_FSJoinToPath", "#define Tcl_FSJoinToPath \\", "\t(tclStubsPtr->tcl_FSJoinToPath) /* 464 */", "#endif", "#ifndef Tcl_FSGetInternalRep", "#define Tcl_FSGetInternalRep \\", "\t(tclStubsPtr->tcl_FSGetInternalRep) /* 465 */", "#endif", "#ifndef Tcl_FSGetTranslatedPath", "#define Tcl_FSGetTranslatedPath \\", "\t(tclStubsPtr->tcl_FSGetTranslatedPath) /* 466 */", "#endif", "#ifndef Tcl_FSEvalFile", "#define Tcl_FSEvalFile \\", "\t(tclStubsPtr->tcl_FSEvalFile) /* 467 */", "#endif", "#ifndef Tcl_FSNewNativePath", "#define Tcl_FSNewNativePath \\", "\t(tclStubsPtr->tcl_FSNewNativePath) /* 468 */", "#endif", "#ifndef Tcl_FSGetNativePath", "#define Tcl_FSGetNativePath \\", "\t(tclStubsPtr->tcl_FSGetNativePath) /* 469 */", "#endif", "#ifndef Tcl_FSFileSystemInfo", "#define Tcl_FSFileSystemInfo \\", "\t(tclStubsPtr->tcl_FSFileSystemInfo) /* 470 */", "#endif", "#ifndef Tcl_FSPathSeparator", "#define Tcl_FSPathSeparator \\", "\t(tclStubsPtr->tcl_FSPathSeparator) /* 471 */", "#endif", "#ifndef Tcl_FSListVolumes", "#define Tcl_FSListVolumes \\", "\t(tclStubsPtr->tcl_FSListVolumes) /* 472 */", "#endif", "#ifndef Tcl_FSRegister", "#define Tcl_FSRegister \\", "\t(tclStubsPtr->tcl_FSRegister) /* 473 */", "#endif", "#ifndef Tcl_FSUnregister", "#define Tcl_FSUnregister \\", "\t(tclStubsPtr->tcl_FSUnregister) /* 474 */", "#endif", "#ifndef Tcl_FSData", "#define Tcl_FSData \\", "\t(tclStubsPtr->tcl_FSData) /* 475 */", "#endif", "#ifndef Tcl_FSGetTranslatedStringPath", "#define Tcl_FSGetTranslatedStringPath \\", "\t(tclStubsPtr->tcl_FSGetTranslatedStringPath) /* 476 */", "#endif", "#ifndef Tcl_FSGetFileSystemForPath", "#define Tcl_FSGetFileSystemForPath \\", "\t(tclStubsPtr->tcl_FSGetFileSystemForPath) /* 477 */", "#endif", "#ifndef Tcl_FSGetPathType", "#define Tcl_FSGetPathType \\", "\t(tclStubsPtr->tcl_FSGetPathType) /* 478 */", "#endif", "#ifndef Tcl_OutputBuffered", "#define Tcl_OutputBuffered \\", "\t(tclStubsPtr->tcl_OutputBuffered) /* 479 */", "#endif", "#ifndef Tcl_FSMountsChanged", "#define Tcl_FSMountsChanged \\", "\t(tclStubsPtr->tcl_FSMountsChanged) /* 480 */", "#endif", "#ifndef Tcl_EvalTokensStandard", "#define Tcl_EvalTokensStandard \\", "\t(tclStubsPtr->tcl_EvalTokensStandard) /* 481 */", "#endif", "#ifndef Tcl_GetTime", "#define Tcl_GetTime \\", "\t(tclStubsPtr->tcl_GetTime) /* 482 */", "#endif", "#ifndef Tcl_CreateObjTrace", "#define Tcl_CreateObjTrace \\", "\t(tclStubsPtr->tcl_CreateObjTrace) /* 483 */", "#endif", "#ifndef Tcl_GetCommandInfoFromToken", "#define Tcl_GetCommandInfoFromToken \\", "\t(tclStubsPtr->tcl_GetCommandInfoFromToken) /* 484 */", "#endif", "#ifndef Tcl_SetCommandInfoFromToken", "#define Tcl_SetCommandInfoFromToken \\", "\t(tclStubsPtr->tcl_SetCommandInfoFromToken) /* 485 */", "#endif", "#ifndef Tcl_DbNewWideIntObj", "#define Tcl_DbNewWideIntObj \\", "\t(tclStubsPtr->tcl_DbNewWideIntObj) /* 486 */", "#endif", "#ifndef Tcl_GetWideIntFromObj", "#define Tcl_GetWideIntFromObj \\", "\t(tclStubsPtr->tcl_GetWideIntFromObj) /* 487 */", "#endif", "#ifndef Tcl_NewWideIntObj", "#define Tcl_NewWideIntObj \\", "\t(tclStubsPtr->tcl_NewWideIntObj) /* 488 */", "#endif", "#ifndef Tcl_SetWideIntObj", "#define Tcl_SetWideIntObj \\", "\t(tclStubsPtr->tcl_SetWideIntObj) /* 489 */", "#endif", "#ifndef Tcl_AllocStatBuf", "#define Tcl_AllocStatBuf \\", "\t(tclStubsPtr->tcl_AllocStatBuf) /* 490 */", "#endif", "#ifndef Tcl_Seek", "#define Tcl_Seek \\", "\t(tclStubsPtr->tcl_Seek) /* 491 */", "#endif", "#ifndef Tcl_Tell", "#define Tcl_Tell \\", "\t(tclStubsPtr->tcl_Tell) /* 492 */", "#endif", "#ifndef Tcl_ChannelWideSeekProc", "#define Tcl_ChannelWideSeekProc \\", "\t(tclStubsPtr->tcl_ChannelWideSeekProc) /* 493 */", "#endif", "#ifndef Tcl_DictObjPut", "#define Tcl_DictObjPut \\", "\t(tclStubsPtr->tcl_DictObjPut) /* 494 */", "#endif", "#ifndef Tcl_DictObjGet", "#define Tcl_DictObjGet \\", "\t(tclStubsPtr->tcl_DictObjGet) /* 495 */", "#endif", "#ifndef Tcl_DictObjRemove", "#define Tcl_DictObjRemove \\", "\t(tclStubsPtr->tcl_DictObjRemove) /* 496 */", "#endif", "#ifndef Tcl_DictObjSize", "#define Tcl_DictObjSize \\", "\t(tclStubsPtr->tcl_DictObjSize) /* 497 */", "#endif", "#ifndef Tcl_DictObjFirst", "#define Tcl_DictObjFirst \\", "\t(tclStubsPtr->tcl_DictObjFirst) /* 498 */", "#endif", "#ifndef Tcl_DictObjNext", "#define Tcl_DictObjNext \\", "\t(tclStubsPtr->tcl_DictObjNext) /* 499 */", "#endif", "#ifndef Tcl_DictObjDone", "#define Tcl_DictObjDone \\", "\t(tclStubsPtr->tcl_DictObjDone) /* 500 */", "#endif", "#ifndef Tcl_DictObjPutKeyList", "#define Tcl_DictObjPutKeyList \\", "\t(tclStubsPtr->tcl_DictObjPutKeyList) /* 501 */", "#endif", "#ifndef Tcl_DictObjRemoveKeyList", "#define Tcl_DictObjRemoveKeyList \\", "\t(tclStubsPtr->tcl_DictObjRemoveKeyList) /* 502 */", "#endif", "#ifndef Tcl_NewDictObj", "#define Tcl_NewDictObj \\", "\t(tclStubsPtr->tcl_NewDictObj) /* 503 */", "#endif", "#ifndef Tcl_DbNewDictObj", "#define Tcl_DbNewDictObj \\", "\t(tclStubsPtr->tcl_DbNewDictObj) /* 504 */", "#endif", "#ifndef Tcl_RegisterConfig", "#define Tcl_RegisterConfig \\", "\t(tclStubsPtr->tcl_RegisterConfig) /* 505 */", "#endif", "#ifndef Tcl_CreateNamespace", "#define Tcl_CreateNamespace \\", "\t(tclStubsPtr->tcl_CreateNamespace) /* 506 */", "#endif", "#ifndef Tcl_DeleteNamespace", "#define Tcl_DeleteNamespace \\", "\t(tclStubsPtr->tcl_DeleteNamespace) /* 507 */", "#endif", "#ifndef Tcl_AppendExportList", "#define Tcl_AppendExportList \\", "\t(tclStubsPtr->tcl_AppendExportList) /* 508 */", "#endif", "#ifndef Tcl_Export", "#define Tcl_Export \\", "\t(tclStubsPtr->tcl_Export) /* 509 */", "#endif", "#ifndef Tcl_Import", "#define Tcl_Import \\", "\t(tclStubsPtr->tcl_Import) /* 510 */", "#endif", "#ifndef Tcl_ForgetImport", "#define Tcl_ForgetImport \\", "\t(tclStubsPtr->tcl_ForgetImport) /* 511 */", "#endif", "#ifndef Tcl_GetCurrentNamespace", "#define Tcl_GetCurrentNamespace \\", "\t(tclStubsPtr->tcl_GetCurrentNamespace) /* 512 */", "#endif", "#ifndef Tcl_GetGlobalNamespace", "#define Tcl_GetGlobalNamespace \\", "\t(tclStubsPtr->tcl_GetGlobalNamespace) /* 513 */", "#endif", "#ifndef Tcl_FindNamespace", "#define Tcl_FindNamespace \\", "\t(tclStubsPtr->tcl_FindNamespace) /* 514 */", "#endif", "#ifndef Tcl_FindCommand", "#define Tcl_FindCommand \\", "\t(tclStubsPtr->tcl_FindCommand) /* 515 */", "#endif", "#ifndef Tcl_GetCommandFromObj", "#define Tcl_GetCommandFromObj \\", "\t(tclStubsPtr->tcl_GetCommandFromObj) /* 516 */", "#endif", "#ifndef Tcl_GetCommandFullName", "#define Tcl_GetCommandFullName \\", "\t(tclStubsPtr->tcl_GetCommandFullName) /* 517 */", "#endif", "#ifndef Tcl_FSEvalFileEx", "#define Tcl_FSEvalFileEx \\", "\t(tclStubsPtr->tcl_FSEvalFileEx) /* 518 */", "#endif", "#ifndef Tcl_SetExitProc", "#define Tcl_SetExitProc \\", "\t(tclStubsPtr->tcl_SetExitProc) /* 519 */", "#endif", "#ifndef Tcl_LimitAddHandler", "#define Tcl_LimitAddHandler \\", "\t(tclStubsPtr->tcl_LimitAddHandler) /* 520 */", "#endif", "#ifndef Tcl_LimitRemoveHandler", "#define Tcl_LimitRemoveHandler \\", "\t(tclStubsPtr->tcl_LimitRemoveHandler) /* 521 */", "#endif", "#ifndef Tcl_LimitReady", "#define Tcl_LimitReady \\", "\t(tclStubsPtr->tcl_LimitReady) /* 522 */", "#endif", "#ifndef Tcl_LimitCheck", "#define Tcl_LimitCheck \\", "\t(tclStubsPtr->tcl_LimitCheck) /* 523 */", "#endif", "#ifndef Tcl_LimitExceeded", "#define Tcl_LimitExceeded \\", "\t(tclStubsPtr->tcl_LimitExceeded) /* 524 */", "#endif", "#ifndef Tcl_LimitSetCommands", "#define Tcl_LimitSetCommands \\", "\t(tclStubsPtr->tcl_LimitSetCommands) /* 525 */", "#endif", "#ifndef Tcl_LimitSetTime", "#define Tcl_LimitSetTime \\", "\t(tclStubsPtr->tcl_LimitSetTime) /* 526 */", "#endif", "#ifndef Tcl_LimitSetGranularity", "#define Tcl_LimitSetGranularity \\", "\t(tclStubsPtr->tcl_LimitSetGranularity) /* 527 */", "#endif", "#ifndef Tcl_LimitTypeEnabled", "#define Tcl_LimitTypeEnabled \\", "\t(tclStubsPtr->tcl_LimitTypeEnabled) /* 528 */", "#endif", "#ifndef Tcl_LimitTypeExceeded", "#define Tcl_LimitTypeExceeded \\", "\t(tclStubsPtr->tcl_LimitTypeExceeded) /* 529 */", "#endif", "#ifndef Tcl_LimitTypeSet", "#define Tcl_LimitTypeSet \\", "\t(tclStubsPtr->tcl_LimitTypeSet) /* 530 */", "#endif", "#ifndef Tcl_LimitTypeReset", "#define Tcl_LimitTypeReset \\", "\t(tclStubsPtr->tcl_LimitTypeReset) /* 531 */", "#endif", "#ifndef Tcl_LimitGetCommands", "#define Tcl_LimitGetCommands \\", "\t(tclStubsPtr->tcl_LimitGetCommands) /* 532 */", "#endif", "#ifndef Tcl_LimitGetTime", "#define Tcl_LimitGetTime \\", "\t(tclStubsPtr->tcl_LimitGetTime) /* 533 */", "#endif", "#ifndef Tcl_LimitGetGranularity", "#define Tcl_LimitGetGranularity \\", "\t(tclStubsPtr->tcl_LimitGetGranularity) /* 534 */", "#endif", "#ifndef Tcl_SaveInterpState", "#define Tcl_SaveInterpState \\", "\t(tclStubsPtr->tcl_SaveInterpState) /* 535 */", "#endif", "#ifndef Tcl_RestoreInterpState", "#define Tcl_RestoreInterpState \\", "\t(tclStubsPtr->tcl_RestoreInterpState) /* 536 */", "#endif", "#ifndef Tcl_DiscardInterpState", "#define Tcl_DiscardInterpState \\", "\t(tclStubsPtr->tcl_DiscardInterpState) /* 537 */", "#endif", "#ifndef Tcl_SetReturnOptions", "#define Tcl_SetReturnOptions \\", "\t(tclStubsPtr->tcl_SetReturnOptions) /* 538 */", "#endif", "#ifndef Tcl_GetReturnOptions", "#define Tcl_GetReturnOptions \\", "\t(tclStubsPtr->tcl_GetReturnOptions) /* 539 */", "#endif", "#ifndef Tcl_IsEnsemble", "#define Tcl_IsEnsemble \\", "\t(tclStubsPtr->tcl_IsEnsemble) /* 540 */", "#endif", "#ifndef Tcl_CreateEnsemble", "#define Tcl_CreateEnsemble \\", "\t(tclStubsPtr->tcl_CreateEnsemble) /* 541 */", "#endif", "#ifndef Tcl_FindEnsemble", "#define Tcl_FindEnsemble \\", "\t(tclStubsPtr->tcl_FindEnsemble) /* 542 */", "#endif", "#ifndef Tcl_SetEnsembleSubcommandList", "#define Tcl_SetEnsembleSubcommandList \\", "\t(tclStubsPtr->tcl_SetEnsembleSubcommandList) /* 543 */", "#endif", "#ifndef Tcl_SetEnsembleMappingDict", "#define Tcl_SetEnsembleMappingDict \\", "\t(tclStubsPtr->tcl_SetEnsembleMappingDict) /* 544 */", "#endif", "#ifndef Tcl_SetEnsembleUnknownHandler", "#define Tcl_SetEnsembleUnknownHandler \\", "\t(tclStubsPtr->tcl_SetEnsembleUnknownHandler) /* 545 */", "#endif", "#ifndef Tcl_SetEnsembleFlags", "#define Tcl_SetEnsembleFlags \\", "\t(tclStubsPtr->tcl_SetEnsembleFlags) /* 546 */", "#endif", "#ifndef Tcl_GetEnsembleSubcommandList", "#define Tcl_GetEnsembleSubcommandList \\", "\t(tclStubsPtr->tcl_GetEnsembleSubcommandList) /* 547 */", "#endif", "#ifndef Tcl_GetEnsembleMappingDict", "#define Tcl_GetEnsembleMappingDict \\", "\t(tclStubsPtr->tcl_GetEnsembleMappingDict) /* 548 */", "#endif", "#ifndef Tcl_GetEnsembleUnknownHandler", "#define Tcl_GetEnsembleUnknownHandler \\", "\t(tclStubsPtr->tcl_GetEnsembleUnknownHandler) /* 549 */", "#endif", "#ifndef Tcl_GetEnsembleFlags", "#define Tcl_GetEnsembleFlags \\", "\t(tclStubsPtr->tcl_GetEnsembleFlags) /* 550 */", "#endif", "#ifndef Tcl_GetEnsembleNamespace", "#define Tcl_GetEnsembleNamespace \\", "\t(tclStubsPtr->tcl_GetEnsembleNamespace) /* 551 */", "#endif", "#ifndef Tcl_SetTimeProc", "#define Tcl_SetTimeProc \\", "\t(tclStubsPtr->tcl_SetTimeProc) /* 552 */", "#endif", "#ifndef Tcl_QueryTimeProc", "#define Tcl_QueryTimeProc \\", "\t(tclStubsPtr->tcl_QueryTimeProc) /* 553 */", "#endif", "#ifndef Tcl_ChannelThreadActionProc", "#define Tcl_ChannelThreadActionProc \\", "\t(tclStubsPtr->tcl_ChannelThreadActionProc) /* 554 */", "#endif", "#ifndef Tcl_NewBignumObj", "#define Tcl_NewBignumObj \\", "\t(tclStubsPtr->tcl_NewBignumObj) /* 555 */", "#endif", "#ifndef Tcl_DbNewBignumObj", "#define Tcl_DbNewBignumObj \\", "\t(tclStubsPtr->tcl_DbNewBignumObj) /* 556 */", "#endif", "#ifndef Tcl_SetBignumObj", "#define Tcl_SetBignumObj \\", "\t(tclStubsPtr->tcl_SetBignumObj) /* 557 */", "#endif", "#ifndef Tcl_GetBignumFromObj", "#define Tcl_GetBignumFromObj \\", "\t(tclStubsPtr->tcl_GetBignumFromObj) /* 558 */", "#endif", "#ifndef Tcl_TakeBignumFromObj", "#define Tcl_TakeBignumFromObj \\", "\t(tclStubsPtr->tcl_TakeBignumFromObj) /* 559 */", "#endif", "#ifndef Tcl_TruncateChannel", "#define Tcl_TruncateChannel \\", "\t(tclStubsPtr->tcl_TruncateChannel) /* 560 */", "#endif", "#ifndef Tcl_ChannelTruncateProc", "#define Tcl_ChannelTruncateProc \\", "\t(tclStubsPtr->tcl_ChannelTruncateProc) /* 561 */", "#endif", "#ifndef Tcl_SetChannelErrorInterp", "#define Tcl_SetChannelErrorInterp \\", "\t(tclStubsPtr->tcl_SetChannelErrorInterp) /* 562 */", "#endif", "#ifndef Tcl_GetChannelErrorInterp", "#define Tcl_GetChannelErrorInterp \\", "\t(tclStubsPtr->tcl_GetChannelErrorInterp) /* 563 */", "#endif", "#ifndef Tcl_SetChannelError", "#define Tcl_SetChannelError \\", "\t(tclStubsPtr->tcl_SetChannelError) /* 564 */", "#endif", "#ifndef Tcl_GetChannelError", "#define Tcl_GetChannelError \\", "\t(tclStubsPtr->tcl_GetChannelError) /* 565 */", "#endif", "#ifndef Tcl_InitBignumFromDouble", "#define Tcl_InitBignumFromDouble \\", "\t(tclStubsPtr->tcl_InitBignumFromDouble) /* 566 */", "#endif", "#ifndef Tcl_GetNamespaceUnknownHandler", "#define Tcl_GetNamespaceUnknownHandler \\", "\t(tclStubsPtr->tcl_GetNamespaceUnknownHandler) /* 567 */", "#endif", "#ifndef Tcl_SetNamespaceUnknownHandler", "#define Tcl_SetNamespaceUnknownHandler \\", "\t(tclStubsPtr->tcl_SetNamespaceUnknownHandler) /* 568 */", "#endif", "#ifndef Tcl_GetEncodingFromObj", "#define Tcl_GetEncodingFromObj \\", "\t(tclStubsPtr->tcl_GetEncodingFromObj) /* 569 */", "#endif", "#ifndef Tcl_GetEncodingSearchPath", "#define Tcl_GetEncodingSearchPath \\", "\t(tclStubsPtr->tcl_GetEncodingSearchPath) /* 570 */", "#endif", "#ifndef Tcl_SetEncodingSearchPath", "#define Tcl_SetEncodingSearchPath \\", "\t(tclStubsPtr->tcl_SetEncodingSearchPath) /* 571 */", "#endif", "#ifndef Tcl_GetEncodingNameFromEnvironment", "#define Tcl_GetEncodingNameFromEnvironment \\", "\t(tclStubsPtr->tcl_GetEncodingNameFromEnvironment) /* 572 */", "#endif", "#ifndef Tcl_PkgRequireProc", "#define Tcl_PkgRequireProc \\", "\t(tclStubsPtr->tcl_PkgRequireProc) /* 573 */", "#endif", "#ifndef Tcl_AppendObjToErrorInfo", "#define Tcl_AppendObjToErrorInfo \\", "\t(tclStubsPtr->tcl_AppendObjToErrorInfo) /* 574 */", "#endif", "#ifndef Tcl_AppendLimitedToObj", "#define Tcl_AppendLimitedToObj \\", "\t(tclStubsPtr->tcl_AppendLimitedToObj) /* 575 */", "#endif", "#ifndef Tcl_Format", "#define Tcl_Format \\", "\t(tclStubsPtr->tcl_Format) /* 576 */", "#endif", "#ifndef Tcl_AppendFormatToObj", "#define Tcl_AppendFormatToObj \\", "\t(tclStubsPtr->tcl_AppendFormatToObj) /* 577 */", "#endif", "#ifndef Tcl_ObjPrintf", "#define Tcl_ObjPrintf \\", "\t(tclStubsPtr->tcl_ObjPrintf) /* 578 */", "#endif", "#ifndef Tcl_AppendPrintfToObj", "#define Tcl_AppendPrintfToObj \\", "\t(tclStubsPtr->tcl_AppendPrintfToObj) /* 579 */", "#endif", "", "#endif /* defined(USE_TCL_STUBS) && !defined(USE_TCL_STUB_PROCS) */", "", "/* !END!: Do not edit above this line. */", "", "#undef TCL_STORAGE_CLASS", "#define TCL_STORAGE_CLASS DLLIMPORT", "", "#endif /* _TCLDECLS */", "" },
    ["tclPlatDecls.h"] = { "/*", " * tclPlatDecls.h --", " *", " *\tDeclarations of platform specific Tcl APIs.", " *", " * Copyright (c) 1998-1999 by Scriptics Corporation.", " * All rights reserved.", " *", " * RCS: @(#) $Id: tclPlatDecls.h,v 1.27.2.2 2010/05/21 12:18:17 nijtmans Exp $", " */", "", "#ifndef _TCLPLATDECLS", "#define _TCLPLATDECLS", "", "#undef TCL_STORAGE_CLASS", "#ifdef BUILD_tcl", "#   define TCL_STORAGE_CLASS DLLEXPORT", "#else", "#   ifdef USE_TCL_STUBS", "#      define TCL_STORAGE_CLASS", "#   else", "#      define TCL_STORAGE_CLASS DLLIMPORT", "#   endif", "#endif", "", "/*", " *  Pull in the typedef of TCHAR for windows.", " */", "#if defined(__WIN32__) && !defined(_TCHAR_DEFINED)", "#   include <tchar.h>", "#   ifndef _TCHAR_DEFINED", "\t/* Borland seems to forget to set this. */", "\ttypedef _TCHAR TCHAR;", "#\tdefine _TCHAR_DEFINED", "#   endif", "#endif", "", "/* !BEGIN!: Do not edit below this line. */", "", "/*", " * Exported function declarations:", " */", "", "#ifdef __WIN32__ /* WIN */", "#ifndef Tcl_WinUtfToTChar_TCL_DECLARED", "#define Tcl_WinUtfToTChar_TCL_DECLARED", "/* 0 */", "EXTERN TCHAR *\t\tTcl_WinUtfToTChar(CONST char *str, int len,", "\t\t\t\tTcl_DString *dsPtr);", "#endif", "#ifndef Tcl_WinTCharToUtf_TCL_DECLARED", "#define Tcl_WinTCharToUtf_TCL_DECLARED", "/* 1 */", "EXTERN char *\t\tTcl_WinTCharToUtf(CONST TCHAR *str, int len,", "\t\t\t\tTcl_DString *dsPtr);", "#endif", "#endif /* WIN */", "#ifdef MAC_OSX_TCL /* MACOSX */", "#ifndef Tcl_MacOSXOpenBundleResources_TCL_DECLARED", "#define Tcl_MacOSXOpenBundleResources_TCL_DECLARED", "/* 0 */", "EXTERN int\t\tTcl_MacOSXOpenBundleResources(Tcl_Interp *interp,", "\t\t\t\tCONST char *bundleName, int hasResourceFile,", "\t\t\t\tint maxPathLen, char *libraryPath);", "#endif", "#ifndef Tcl_MacOSXOpenVersionedBundleResources_TCL_DECLARED", "#define Tcl_MacOSXOpenVersionedBundleResources_TCL_DECLARED", "/* 1 */", "EXTERN int\t\tTcl_MacOSXOpenVersionedBundleResources(", "\t\t\t\tTcl_Interp *interp, CONST char *bundleName,", "\t\t\t\tCONST char *bundleVersion,", "\t\t\t\tint hasResourceFile, int maxPathLen,", "\t\t\t\tchar *libraryPath);", "#endif", "#endif /* MACOSX */", "", "typedef struct TclPlatStubs {", "    int magic;", "    struct TclPlatStubHooks *hooks;", "", "#ifdef __WIN32__ /* WIN */", "    TCHAR * (*tcl_WinUtfToTChar) (CONST char *str, int len, Tcl_DString *dsPtr); /* 0 */", "    char * (*tcl_WinTCharToUtf) (CONST TCHAR *str, int len, Tcl_DString *dsPtr); /* 1 */", "#endif /* WIN */", "#ifdef MAC_OSX_TCL /* MACOSX */", "    int (*tcl_MacOSXOpenBundleResources) (Tcl_Interp *interp, CONST char *bundleName, int hasResourceFile, int maxPathLen, char *libraryPath); /* 0 */", "    int (*tcl_MacOSXOpenVersionedBundleResources) (Tcl_Interp *interp, CONST char *bundleName, CONST char *bundleVersion, int hasResourceFile, int maxPathLen, char *libraryPath); /* 1 */", "#endif /* MACOSX */", "} TclPlatStubs;", "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "extern TclPlatStubs *tclPlatStubsPtr;", "#ifdef __cplusplus", "}", "#endif", "", "#if defined(USE_TCL_STUBS) && !defined(USE_TCL_STUB_PROCS)", "", "/*", " * Inline function declarations:", " */", "", "#ifdef __WIN32__ /* WIN */", "#ifndef Tcl_WinUtfToTChar", "#define Tcl_WinUtfToTChar \\", "\t(tclPlatStubsPtr->tcl_WinUtfToTChar) /* 0 */", "#endif", "#ifndef Tcl_WinTCharToUtf", "#define Tcl_WinTCharToUtf \\", "\t(tclPlatStubsPtr->tcl_WinTCharToUtf) /* 1 */", "#endif", "#endif /* WIN */", "#ifdef MAC_OSX_TCL /* MACOSX */", "#ifndef Tcl_MacOSXOpenBundleResources", "#define Tcl_MacOSXOpenBundleResources \\", "\t(tclPlatStubsPtr->tcl_MacOSXOpenBundleResources) /* 0 */", "#endif", "#ifndef Tcl_MacOSXOpenVersionedBundleResources", "#define Tcl_MacOSXOpenVersionedBundleResources \\", "\t(tclPlatStubsPtr->tcl_MacOSXOpenVersionedBundleResources) /* 1 */", "#endif", "#endif /* MACOSX */", "", "#endif /* defined(USE_TCL_STUBS) && !defined(USE_TCL_STUB_PROCS) */", "", "/* !END!: Do not edit above this line. */", "", "#undef TCL_STORAGE_CLASS", "#define TCL_STORAGE_CLASS DLLIMPORT", "", "#endif /* _TCLPLATDECLS */", "", "" },
    ["tclTomMath.h"] = { "/* LibTomMath, multiple-precision integer library -- Tom St Denis", " *", " * LibTomMath is a library that provides multiple-precision", " * integer arithmetic as well as number theoretic functionality.", " *", " * The library was designed directly after the MPI library by", " * Michael Fromberger but has been written from scratch with", " * additional optimizations in place.", " *", " * The library is free for all purposes without any express", " * guarantee it works.", " *", " * Tom St Denis, tomstdenis@gmail.com, http://math.libtomcrypt.com", " */", "#ifndef BN_H_", "#define BN_H_", "", "#include <tclTomMathDecls.h>", "#ifndef MODULE_SCOPE", "#define MODULE_SCOPE extern", "#endif", "", "#include <stdio.h>", "#include <string.h>", "#include <stdlib.h>", "#include <ctype.h>", "#include <limits.h>", "", "#ifndef MIN", "   #define MIN(x,y) ((x)<(y)?(x):(y))", "#endif", "", "#ifndef MAX", "   #define MAX(x,y) ((x)>(y)?(x):(y))", "#endif", "", "#ifdef __cplusplus", 'extern "C" {', "", "/* C++ compilers don't like assigning void * to mp_digit * */", "#define  OPT_CAST(x)  (x *)", "", "#else", "", "/* C on the other hand doesn't care */", "#define  OPT_CAST(x)", "", "#endif", "", "", "/* detect 64-bit mode if possible */", "#if defined(NEVER)  /* 128-bit ints fail in too many places */", "   #if !(defined(MP_64BIT) && defined(MP_16BIT) && defined(MP_8BIT))", "      #define MP_64BIT", "   #endif", "#endif", "", "/* some default configurations.", " *", ' * A "mp_digit" must be able to hold DIGIT_BIT + 1 bits', ' * A "mp_word" must be able to hold 2*DIGIT_BIT + 1 bits', " *", " * At the very least a mp_digit must be able to hold 7 bits", " * [any size beyond that is ok provided it doesn't overflow the data type]", " */", "#ifdef MP_8BIT", "#ifndef MP_DIGIT_DECLARED", "   typedef unsigned char      mp_digit;", "#define MP_DIGIT_DECLARED", "#endif", "   typedef unsigned short     mp_word;", "#elif defined(MP_16BIT)", "#ifndef MP_DIGIT_DECLARED", "   typedef unsigned short     mp_digit;", "#define MP_DIGIT_DECLARED", "#endif", "   typedef unsigned long      mp_word;", "#elif defined(MP_64BIT)", "   /* for GCC only on supported platforms */", "#ifndef CRYPT", "   typedef unsigned long long ulong64;", "   typedef signed long long   long64;", "#endif", "", "#ifndef MP_DIGIT_DECLARED", "   typedef unsigned long      mp_digit;", "#define MP_DIGIT_DECLARED", "#endif", "   typedef unsigned long      mp_word __attribute__ ((mode(TI)));", "", "   #define DIGIT_BIT          60", "#else", "   /* this is the default case, 28-bit digits */", "   ", "   /* this is to make porting into LibTomCrypt easier :-) */", "#ifndef CRYPT", "   #if defined(_MSC_VER) || defined(__BORLANDC__) ", "      typedef unsigned __int64   ulong64;", "      typedef signed __int64     long64;", "   #else", "      typedef unsigned long long ulong64;", "      typedef signed long long   long64;", "   #endif", "#endif", "", "#ifndef MP_DIGIT_DECLARED", "   typedef unsigned int      mp_digit;", "#define MP_DIGIT_DECLARED", "#endif", "   typedef ulong64            mp_word;", "", "#ifdef MP_31BIT   ", "   /* this is an extension that uses 31-bit digits */", "   #define DIGIT_BIT          31", "#else", "   /* default case is 28-bit digits, defines MP_28BIT as a handy macro to test */", "   #define DIGIT_BIT          28", "   #define MP_28BIT", "#endif   ", "#endif", "", "/* define heap macros */", "#if 0 /* these are macros in tclTomMathDecls.h */", "#ifndef CRYPT", "   /* default to libc stuff */", "   #ifndef XMALLOC ", "       #define XMALLOC  malloc", "       #define XFREE    free", "       #define XREALLOC realloc", "       #define XCALLOC  calloc", "   #else", "      /* prototypes for our heap functions */", "      extern void *XMALLOC(size_t n);", "      extern void *XREALLOC(void *p, size_t n);", "      extern void *XCALLOC(size_t n, size_t s);", "      extern void XFREE(void *p);", "   #endif", "#endif", "#endif", "", "", "/* otherwise the bits per digit is calculated automatically from the size of a mp_digit */", "#ifndef DIGIT_BIT", "   #define DIGIT_BIT     ((int)((CHAR_BIT * sizeof(mp_digit) - 1)))  /* bits per digit */", "#endif", "", "#define MP_DIGIT_BIT     DIGIT_BIT", "#define MP_MASK          ((((mp_digit)1)<<((mp_digit)DIGIT_BIT))-((mp_digit)1))", "#define MP_DIGIT_MAX     MP_MASK", "", "/* equalities */", "#define MP_LT        -1   /* less than */", "#define MP_EQ         0   /* equal to */", "#define MP_GT         1   /* greater than */", "", "#define MP_ZPOS       0   /* positive integer */", "#define MP_NEG        1   /* negative */", "", "#define MP_OKAY       0   /* ok result */", "#define MP_MEM        -2  /* out of mem */", "#define MP_VAL        -3  /* invalid input */", "#define MP_RANGE      MP_VAL", "", "#define MP_YES        1   /* yes response */", "#define MP_NO         0   /* no response */", "", "/* Primality generation flags */", "#define LTM_PRIME_BBS      0x0001 /* BBS style prime */", "#define LTM_PRIME_SAFE     0x0002 /* Safe prime (p-1)/2 == prime */", "#define LTM_PRIME_2MSB_ON  0x0008 /* force 2nd MSB to 1 */", "", "typedef int           mp_err;", "", "/* you'll have to tune these... */", "#if defined(BUILD_tcl) || !defined(_WIN32)", "MODULE_SCOPE int KARATSUBA_MUL_CUTOFF,", "           KARATSUBA_SQR_CUTOFF,", "           TOOM_MUL_CUTOFF,", "           TOOM_SQR_CUTOFF;", "#endif", "", "/* define this to use lower memory usage routines (exptmods mostly) */", "/* #define MP_LOW_MEM */", "", "/* default precision */", "#ifndef MP_PREC", "   #ifndef MP_LOW_MEM", "      #define MP_PREC                 32     /* default digits of precision */", "   #else", "      #define MP_PREC                 8      /* default digits of precision */", "   #endif   ", "#endif", "", "/* size of comba arrays, should be at least 2 * 2**(BITS_PER_WORD - BITS_PER_DIGIT*2) */", "#define MP_WARRAY               (1 << (sizeof(mp_word) * CHAR_BIT - 2 * DIGIT_BIT + 1))", "", "/* the infamous mp_int structure */", "#ifndef MP_INT_DECLARED", "#define MP_INT_DECLARED", "typedef struct mp_int mp_int;", "#endif", "struct mp_int {", "    int used, alloc, sign;", "    mp_digit *dp;", "};", "", "/* callback for mp_prime_random, should fill dst with random bytes and return how many read [upto len] */", "typedef int ltm_prime_callback(unsigned char *dst, int len, void *dat);", "", "", "#define USED(m)    ((m)->used)", "#define DIGIT(m,k) ((m)->dp[(k)])", "#define SIGN(m)    ((m)->sign)", "", "/* error code to char* string */", "/*", "char *mp_error_to_string(int code);", "*/", "", "/* ---> init and deinit bignum functions <--- */", "/* init a bignum */", "/*", "int mp_init(mp_int *a);", "*/", "", "/* free a bignum */", "/*", "void mp_clear(mp_int *a);", "*/", "", "/* init a null terminated series of arguments */", "/*", "int mp_init_multi(mp_int *mp, ...);", "*/", "", "/* clear a null terminated series of arguments */", "/*", "void mp_clear_multi(mp_int *mp, ...);", "*/", "", "/* exchange two ints */", "/*", "void mp_exch(mp_int *a, mp_int *b);", "*/", "", "/* shrink ram required for a bignum */", "/*", "int mp_shrink(mp_int *a);", "*/", "", "/* grow an int to a given size */", "/*", "int mp_grow(mp_int *a, int size);", "*/", "", "/* init to a given number of digits */", "/*", "int mp_init_size(mp_int *a, int size);", "*/", "", "/* ---> Basic Manipulations <--- */", "#define mp_iszero(a) (((a)->used == 0) ? MP_YES : MP_NO)", "#define mp_iseven(a) (((a)->used == 0 || (((a)->dp[0] & 1) == 0)) ? MP_YES : MP_NO)", "#define mp_isodd(a)  (((a)->used > 0 && (((a)->dp[0] & 1) == 1)) ? MP_YES : MP_NO)", "", "/* set to zero */", "/*", "void mp_zero(mp_int *a);", "*/", "", "/* set to a digit */", "/*", "void mp_set(mp_int *a, mp_digit b);", "*/", "", "/* set a 32-bit const */", "/*", "int mp_set_int(mp_int *a, unsigned long b);", "*/", "", "/* get a 32-bit value */", "unsigned long mp_get_int(mp_int * a);", "", "/* initialize and set a digit */", "/*", "int mp_init_set (mp_int * a, mp_digit b);", "*/", "", "/* initialize and set 32-bit value */", "/*", "int mp_init_set_int (mp_int * a, unsigned long b);", "*/", "", "/* copy, b = a */", "/*", "int mp_copy(mp_int *a, mp_int *b);", "*/", "", "/* inits and copies, a = b */", "/*", "int mp_init_copy(mp_int *a, mp_int *b);", "*/", "", "/* trim unused digits */", "/*", "void mp_clamp(mp_int *a);", "*/", "", "/* ---> digit manipulation <--- */", "", '/* right shift by "b" digits */', "/*", "void mp_rshd(mp_int *a, int b);", "*/", "", '/* left shift by "b" digits */', "/*", "int mp_lshd(mp_int *a, int b);", "*/", "", "/* c = a / 2**b */", "/*", "int mp_div_2d(mp_int *a, int b, mp_int *c, mp_int *d);", "*/", "", "/* b = a/2 */", "/*", "int mp_div_2(mp_int *a, mp_int *b);", "*/", "", "/* c = a * 2**b */", "/*", "int mp_mul_2d(mp_int *a, int b, mp_int *c);", "*/", "", "/* b = a*2 */", "/*", "int mp_mul_2(mp_int *a, mp_int *b);", "*/", "", "/* c = a mod 2**d */", "/*", "int mp_mod_2d(mp_int *a, int b, mp_int *c);", "*/", "", "/* computes a = 2**b */", "/*", "int mp_2expt(mp_int *a, int b);", "*/", "", "/* Counts the number of lsbs which are zero before the first zero bit */", "/*", "int mp_cnt_lsb(mp_int *a);", "*/", "", "/* I Love Earth! */", "", "/* makes a pseudo-random int of a given size */", "/*", "int mp_rand(mp_int *a, int digits);", "*/", "", "/* ---> binary operations <--- */", "/* c = a XOR b  */", "/*", "int mp_xor(mp_int *a, mp_int *b, mp_int *c);", "*/", "", "/* c = a OR b */", "/*", "int mp_or(mp_int *a, mp_int *b, mp_int *c);", "*/", "", "/* c = a AND b */", "/*", "int mp_and(mp_int *a, mp_int *b, mp_int *c);", "*/", "", "/* ---> Basic arithmetic <--- */", "", "/* b = -a */", "/*", "int mp_neg(mp_int *a, mp_int *b);", "*/", "", "/* b = |a| */", "/*", "int mp_abs(mp_int *a, mp_int *b);", "*/", "", "/* compare a to b */", "/*", "int mp_cmp(mp_int *a, mp_int *b);", "*/", "", "/* compare |a| to |b| */", "/*", "int mp_cmp_mag(mp_int *a, mp_int *b);", "*/", "", "/* c = a + b */", "/*", "int mp_add(mp_int *a, mp_int *b, mp_int *c);", "*/", "", "/* c = a - b */", "/*", "int mp_sub(mp_int *a, mp_int *b, mp_int *c);", "*/", "", "/* c = a * b */", "/*", "int mp_mul(mp_int *a, mp_int *b, mp_int *c);", "*/", "", "/* b = a*a  */", "/*", "int mp_sqr(mp_int *a, mp_int *b);", "*/", "", "/* a/b => cb + d == a */", "/*", "int mp_div(mp_int *a, mp_int *b, mp_int *c, mp_int *d);", "*/", "", "/* c = a mod b, 0 <= c < b  */", "/*", "int mp_mod(mp_int *a, mp_int *b, mp_int *c);", "*/", "", "/* ---> single digit functions <--- */", "", "/* compare against a single digit */", "/*", "int mp_cmp_d(mp_int *a, mp_digit b);", "*/", "", "/* c = a + b */", "/*", "int mp_add_d(mp_int *a, mp_digit b, mp_int *c);", "*/", "", "/* c = a - b */", "/*", "int mp_sub_d(mp_int *a, mp_digit b, mp_int *c);", "*/", "", "/* c = a * b */", "/*", "int mp_mul_d(mp_int *a, mp_digit b, mp_int *c);", "*/", "", "/* a/b => cb + d == a */", "/*", "int mp_div_d(mp_int *a, mp_digit b, mp_int *c, mp_digit *d);", "*/", "", "/* a/3 => 3c + d == a */", "/*", "int mp_div_3(mp_int *a, mp_int *c, mp_digit *d);", "*/", "", "/* c = a**b */", "/*", "int mp_expt_d(mp_int *a, mp_digit b, mp_int *c);", "*/", "", "/* c = a mod b, 0 <= c < b  */", "/*", "int mp_mod_d(mp_int *a, mp_digit b, mp_digit *c);", "*/", "", "/* ---> number theory <--- */", "", "/* d = a + b (mod c) */", "/*", "int mp_addmod(mp_int *a, mp_int *b, mp_int *c, mp_int *d);", "*/", "", "/* d = a - b (mod c) */", "/*", "int mp_submod(mp_int *a, mp_int *b, mp_int *c, mp_int *d);", "*/", "", "/* d = a * b (mod c) */", "/*", "int mp_mulmod(mp_int *a, mp_int *b, mp_int *c, mp_int *d);", "*/", "", "/* c = a * a (mod b) */", "/*", "int mp_sqrmod(mp_int *a, mp_int *b, mp_int *c);", "*/", "", "/* c = 1/a (mod b) */", "/*", "int mp_invmod(mp_int *a, mp_int *b, mp_int *c);", "*/", "", "/* c = (a, b) */", "/*", "int mp_gcd(mp_int *a, mp_int *b, mp_int *c);", "*/", "", "/* produces value such that U1*a + U2*b = U3 */", "/*", "int mp_exteuclid(mp_int *a, mp_int *b, mp_int *U1, mp_int *U2, mp_int *U3);", "*/", "", "/* c = [a, b] or (a*b)/(a, b) */", "/*", "int mp_lcm(mp_int *a, mp_int *b, mp_int *c);", "*/", "", "/* finds one of the b'th root of a, such that |c|**b <= |a|", " *", " * returns error if a < 0 and b is even", " */", "/*", "int mp_n_root(mp_int *a, mp_digit b, mp_int *c);", "*/", "", "/* special sqrt algo */", "/*", "int mp_sqrt(mp_int *arg, mp_int *ret);", "*/", "", "/* is number a square? */", "/*", "int mp_is_square(mp_int *arg, int *ret);", "*/", "", "/* computes the jacobi c = (a | n) (or Legendre if b is prime)  */", "/*", "int mp_jacobi(mp_int *a, mp_int *n, int *c);", "*/", "", "/* used to setup the Barrett reduction for a given modulus b */", "/*", "int mp_reduce_setup(mp_int *a, mp_int *b);", "*/", "", "/* Barrett Reduction, computes a (mod b) with a precomputed value c", " *", " * Assumes that 0 < a <= b*b, note if 0 > a > -(b*b) then you can merely", " * compute the reduction as -1 * mp_reduce(mp_abs(a)) [pseudo code].", " */", "/*", "int mp_reduce(mp_int *a, mp_int *b, mp_int *c);", "*/", "", "/* setups the montgomery reduction */", "/*", "int mp_montgomery_setup(mp_int *a, mp_digit *mp);", "*/", "", "/* computes a = B**n mod b without division or multiplication useful for", " * normalizing numbers in a Montgomery system.", " */", "/*", "int mp_montgomery_calc_normalization(mp_int *a, mp_int *b);", "*/", "", "/* computes x/R == x (mod N) via Montgomery Reduction */", "/*", "int mp_montgomery_reduce(mp_int *a, mp_int *m, mp_digit mp);", "*/", "", "/* returns 1 if a is a valid DR modulus */", "/*", "int mp_dr_is_modulus(mp_int *a);", "*/", "", '/* sets the value of "d" required for mp_dr_reduce */', "/*", "void mp_dr_setup(mp_int *a, mp_digit *d);", "*/", "", "/* reduces a modulo b using the Diminished Radix method */", "/*", "int mp_dr_reduce(mp_int *a, mp_int *b, mp_digit mp);", "*/", "", "/* returns true if a can be reduced with mp_reduce_2k */", "/*", "int mp_reduce_is_2k(mp_int *a);", "*/", "", "/* determines k value for 2k reduction */", "/*", "int mp_reduce_2k_setup(mp_int *a, mp_digit *d);", "*/", "", "/* reduces a modulo b where b is of the form 2**p - k [0 <= a] */", "/*", "int mp_reduce_2k(mp_int *a, mp_int *n, mp_digit d);", "*/", "", "/* returns true if a can be reduced with mp_reduce_2k_l */", "/*", "int mp_reduce_is_2k_l(mp_int *a);", "*/", "", "/* determines k value for 2k reduction */", "/*", "int mp_reduce_2k_setup_l(mp_int *a, mp_int *d);", "*/", "", "/* reduces a modulo b where b is of the form 2**p - k [0 <= a] */", "/*", "int mp_reduce_2k_l(mp_int *a, mp_int *n, mp_int *d);", "*/", "", "/* d = a**b (mod c) */", "/*", "int mp_exptmod(mp_int *a, mp_int *b, mp_int *c, mp_int *d);", "*/", "", "/* ---> Primes <--- */", "", "/* number of primes */", "#ifdef MP_8BIT", "   #define PRIME_SIZE      31", "#else", "   #define PRIME_SIZE      256", "#endif", "", "/* table of first PRIME_SIZE primes */", "#if defined(BUILD_tcl) || !defined(_WIN32)", "MODULE_SCOPE const mp_digit ltm_prime_tab[];", "#endif", "", "/* result=1 if a is divisible by one of the first PRIME_SIZE primes */", "/*", "int mp_prime_is_divisible(mp_int *a, int *result);", "*/", "", '/* performs one Fermat test of "a" using base "b".', " * Sets result to 0 if composite or 1 if probable prime", " */", "/*", "int mp_prime_fermat(mp_int *a, mp_int *b, int *result);", "*/", "", '/* performs one Miller-Rabin test of "a" using base "b".', " * Sets result to 0 if composite or 1 if probable prime", " */", "/*", "int mp_prime_miller_rabin(mp_int *a, mp_int *b, int *result);", "*/", "", "/* This gives [for a given bit size] the number of trials required", " * such that Miller-Rabin gives a prob of failure lower than 2^-96 ", " */", "/*", "int mp_prime_rabin_miller_trials(int size);", "*/", "", '/* performs t rounds of Miller-Rabin on "a" using the first', " * t prime bases.  Also performs an initial sieve of trial", ' * division.  Determines if "a" is prime with probability', " * of error no more than (1/4)**t.", " *", " * Sets result to 1 if probably prime, 0 otherwise", " */", "/*", "int mp_prime_is_prime(mp_int *a, int t, int *result);", "*/", "", '/* finds the next prime after the number "a" using "t" trials', " * of Miller-Rabin.", " *", " * bbs_style = 1 means the prime must be congruent to 3 mod 4", " */", "/*", "int mp_prime_next_prime(mp_int *a, int t, int bbs_style);", "*/", "", "/* makes a truly random prime of a given size (bytes),", " * call with bbs = 1 if you want it to be congruent to 3 mod 4 ", " *", ' * You have to supply a callback which fills in a buffer with random bytes.  "dat" is a parameter you can', " * have passed to the callback (e.g. a state or something).  This function doesn't use \"dat\" itself", " * so it can be NULL", " *", " * The prime generated will be larger than 2^(8*size).", " */", "#define mp_prime_random(a, t, size, bbs, cb, dat) mp_prime_random_ex(a, t, ((size) * 8) + 1, (bbs==1)?LTM_PRIME_BBS:0, cb, dat)", "", "/* makes a truly random prime of a given size (bits),", " *", " * Flags are as follows:", " * ", " *   LTM_PRIME_BBS      - make prime congruent to 3 mod 4", " *   LTM_PRIME_SAFE     - make sure (p-1)/2 is prime as well (implies LTM_PRIME_BBS)", " *   LTM_PRIME_2MSB_OFF - make the 2nd highest bit zero", " *   LTM_PRIME_2MSB_ON  - make the 2nd highest bit one", " *", ' * You have to supply a callback which fills in a buffer with random bytes.  "dat" is a parameter you can', " * have passed to the callback (e.g. a state or something).  This function doesn't use \"dat\" itself", " * so it can be NULL", " *", " */", "/*", "int mp_prime_random_ex(mp_int *a, int t, int size, int flags, ltm_prime_callback cb, void *dat);", "*/", "", "/* ---> radix conversion <--- */", "/*", "int mp_count_bits(mp_int *a);", "*/", "", "/*", "int mp_unsigned_bin_size(mp_int *a);", "*/", "/*", "int mp_read_unsigned_bin(mp_int *a, const unsigned char *b, int c);", "*/", "/*", "int mp_to_unsigned_bin(mp_int *a, unsigned char *b);", "*/", "/*", "int mp_to_unsigned_bin_n (mp_int * a, unsigned char *b, unsigned long *outlen);", "*/", "", "/*", "int mp_signed_bin_size(mp_int *a);", "*/", "/*", "int mp_read_signed_bin(mp_int *a, const unsigned char *b, int c);", "*/", "/*", "int mp_to_signed_bin(mp_int *a,  unsigned char *b);", "*/", "/*", "int mp_to_signed_bin_n (mp_int * a, unsigned char *b, unsigned long *outlen);", "*/", "", "/*", "int mp_read_radix(mp_int *a, const char *str, int radix);", "*/", "/*", "int mp_toradix(mp_int *a, char *str, int radix);", "*/", "/*", "int mp_toradix_n(mp_int * a, char *str, int radix, int maxlen);", "*/", "/*", "int mp_radix_size(mp_int *a, int radix, int *size);", "*/", "", "/*", "int mp_fread(mp_int *a, int radix, FILE *stream);", "*/", "/*", "int mp_fwrite(mp_int *a, int radix, FILE *stream);", "*/", "", "#define mp_read_raw(mp, str, len) mp_read_signed_bin((mp), (str), (len))", "#define mp_raw_size(mp)           mp_signed_bin_size(mp)", "#define mp_toraw(mp, str)         mp_to_signed_bin((mp), (str))", "#define mp_read_mag(mp, str, len) mp_read_unsigned_bin((mp), (str), (len))", "#define mp_mag_size(mp)           mp_unsigned_bin_size(mp)", "#define mp_tomag(mp, str)         mp_to_unsigned_bin((mp), (str))", "", "#define mp_tobinary(M, S)  mp_toradix((M), (S), 2)", "#define mp_tooctal(M, S)   mp_toradix((M), (S), 8)", "#define mp_todecimal(M, S) mp_toradix((M), (S), 10)", "#define mp_tohex(M, S)     mp_toradix((M), (S), 16)", "", "/* lowlevel functions, do not call! */", "/*", "int s_mp_add(mp_int *a, mp_int *b, mp_int *c);", "*/", "/*", "int s_mp_sub(mp_int *a, mp_int *b, mp_int *c);", "*/", "#define s_mp_mul(a, b, c) s_mp_mul_digs(a, b, c, (a)->used + (b)->used + 1)", "/*", "int fast_s_mp_mul_digs(mp_int *a, mp_int *b, mp_int *c, int digs);", "*/", "/*", "int s_mp_mul_digs(mp_int *a, mp_int *b, mp_int *c, int digs);", "*/", "/*", "int fast_s_mp_mul_high_digs(mp_int *a, mp_int *b, mp_int *c, int digs);", "*/", "/*", "int s_mp_mul_high_digs(mp_int *a, mp_int *b, mp_int *c, int digs);", "*/", "/*", "int fast_s_mp_sqr(mp_int *a, mp_int *b);", "*/", "/*", "int s_mp_sqr(mp_int *a, mp_int *b);", "*/", "/*", "int mp_karatsuba_mul(mp_int *a, mp_int *b, mp_int *c);", "*/", "/*", "int mp_toom_mul(mp_int *a, mp_int *b, mp_int *c);", "*/", "/*", "int mp_karatsuba_sqr(mp_int *a, mp_int *b);", "*/", "/*", "int mp_toom_sqr(mp_int *a, mp_int *b);", "*/", "/*", "int fast_mp_invmod(mp_int *a, mp_int *b, mp_int *c);", "*/", "/*", "int mp_invmod_slow (mp_int * a, mp_int * b, mp_int * c);", "*/", "/*", "int fast_mp_montgomery_reduce(mp_int *a, mp_int *m, mp_digit mp);", "*/", "/*", "int mp_exptmod_fast(mp_int *G, mp_int *X, mp_int *P, mp_int *Y, int mode);", "*/", "/*", "int s_mp_exptmod (mp_int * G, mp_int * X, mp_int * P, mp_int * Y, int mode);", "*/", "/*", "void bn_reverse(unsigned char *s, int len);", "*/", "", "#if defined(BUILD_tcl) || !defined(_WIN32)", "MODULE_SCOPE const char *mp_s_rmap;", "#endif", "", "#ifdef __cplusplus", "   }", "#endif", "", "#endif", "", "", "/* $Source: /cvsroot/tcl/tcl/generic/tclTomMath.h,v $ */", "/* Based on Tom's version 1.8 */", "/* $Revision: 1.10.4.1 $ */", "/* $Date: 2009/10/06 16:30:39 $ */", "" },
    ["tclTomMathDecls.h"] = { "/*", " *----------------------------------------------------------------------", " *", " * tclTomMathDecls.h --", " *", " *\tThis file contains the declarations for the 'libtommath'", " *\tfunctions that are exported by the Tcl library.", " *", " * Copyright (c) 2005 by Kevin B. Kenny.  All rights reserved.", " *", ' * See the file "license.terms" for information on usage and redistribution', " * of this file, and for a DISCLAIMER OF ALL WARRANTIES.", " *", " * RCS: @(#) $Id: tclTomMathDecls.h,v 1.2.4.1 2010/02/07 22:16:54 nijtmans Exp $", " */", "", "#ifndef _TCLTOMMATHDECLS", "#define _TCLTOMMATHDECLS", "", '#include "tcl.h"', "", "/*", " * Define the version of the Stubs table that's exported for tommath", " */", "", "#define TCLTOMMATH_EPOCH 0", "#define TCLTOMMATH_REVISION 0", "", "#define Tcl_TomMath_InitStubs(interp,version) \\", "    (TclTomMathInitializeStubs((interp),(version),\\", "                               TCLTOMMATH_EPOCH,TCLTOMMATH_REVISION))", "", "/* Define custom memory allocation for libtommath */", "", "/* MODULE_SCOPE void* TclBNAlloc( size_t ); */", "#define TclBNAlloc(s) ((void*)ckalloc((size_t)(s)))", "/* MODULE_SCOPE void* TclBNRealloc( void*, size_t ); */", "#define TclBNRealloc(x,s) ((void*)ckrealloc((char*)(x),(size_t)(s)))", "/* MODULE_SCOPE void  TclBNFree( void* ); */", "#define TclBNFree(x) (ckfree((char*)(x)))", "/* MODULE_SCOPE void* TclBNCalloc( size_t, size_t ); */", "/* unused - no macro */", "", "#define XMALLOC(x) TclBNAlloc(x)", "#define XFREE(x) TclBNFree(x)", "#define XREALLOC(x,n) TclBNRealloc(x,n)", "#define XCALLOC(n,x) TclBNCalloc(n,x)", "", "/* Rename the global symbols in libtommath to avoid linkage conflicts */", "", "#define KARATSUBA_MUL_CUTOFF TclBNKaratsubaMulCutoff", "#define KARATSUBA_SQR_CUTOFF TclBNKaratsubaSqrCutoff", "#define TOOM_MUL_CUTOFF TclBNToomMulCutoff", "#define TOOM_SQR_CUTOFF TclBNToomSqrCutoff", "", "#define bn_reverse TclBN_reverse", "#define fast_s_mp_mul_digs TclBN_fast_s_mp_mul_digs", "#define fast_s_mp_sqr TclBN_fast_s_mp_sqr", "#define mp_add TclBN_mp_add", "#define mp_add_d TclBN_mp_add_d", "#define mp_and TclBN_mp_and", "#define mp_clamp TclBN_mp_clamp", "#define mp_clear TclBN_mp_clear", "#define mp_clear_multi TclBN_mp_clear_multi", "#define mp_cmp TclBN_mp_cmp", "#define mp_cmp_d TclBN_mp_cmp_d", "#define mp_cmp_mag TclBN_mp_cmp_mag", "#define mp_copy TclBN_mp_copy", "#define mp_count_bits TclBN_mp_count_bits", "#define mp_div TclBN_mp_div", "#define mp_div_2 TclBN_mp_div_2", "#define mp_div_2d TclBN_mp_div_2d", "#define mp_div_3 TclBN_mp_div_3", "#define mp_div_d TclBN_mp_div_d", "#define mp_exch TclBN_mp_exch", "#define mp_expt_d TclBN_mp_expt_d", "#define mp_grow TclBN_mp_grow", "#define mp_init TclBN_mp_init", "#define mp_init_copy TclBN_mp_init_copy", "#define mp_init_multi TclBN_mp_init_multi", "#define mp_init_set TclBN_mp_init_set", "#define mp_init_size TclBN_mp_init_size", "#define mp_karatsuba_mul TclBN_mp_karatsuba_mul", "#define mp_karatsuba_sqr TclBN_mp_karatsuba_sqr", "#define mp_lshd TclBN_mp_lshd", "#define mp_mod TclBN_mp_mod", "#define mp_mod_2d TclBN_mp_mod_2d", "#define mp_mul TclBN_mp_mul", "#define mp_mul_2 TclBN_mp_mul_2", "#define mp_mul_2d TclBN_mp_mul_2d", "#define mp_mul_d TclBN_mp_mul_d", "#define mp_neg TclBN_mp_neg", "#define mp_or TclBN_mp_or", "#define mp_radix_size TclBN_mp_radix_size", "#define mp_read_radix TclBN_mp_read_radix", "#define mp_rshd TclBN_mp_rshd", "#define mp_s_rmap TclBNMpSRmap", "#define mp_set TclBN_mp_set", "#define mp_shrink TclBN_mp_shrink", "#define mp_sqr TclBN_mp_sqr", "#define mp_sqrt TclBN_mp_sqrt", "#define mp_sub TclBN_mp_sub", "#define mp_sub_d TclBN_mp_sub_d", "#define mp_to_unsigned_bin TclBN_mp_to_unsigned_bin", "#define mp_to_unsigned_bin_n TclBN_mp_to_unsigned_bin_n", "#define mp_toom_mul TclBN_mp_toom_mul", "#define mp_toom_sqr TclBN_mp_toom_sqr", "#define mp_toradix_n TclBN_mp_toradix_n", "#define mp_unsigned_bin_size TclBN_mp_unsigned_bin_size", "#define mp_xor TclBN_mp_xor", "#define mp_zero TclBN_mp_zero", "#define s_mp_add TclBN_s_mp_add", "#define s_mp_mul_digs TclBN_s_mp_mul_digs", "#define s_mp_sqr TclBN_s_mp_sqr", "#define s_mp_sub TclBN_s_mp_sub", "", "#undef TCL_STORAGE_CLASS", "#ifdef BUILD_tcl", "#   define TCL_STORAGE_CLASS DLLEXPORT", "#else", "#   ifdef USE_TCL_STUBS", "#      define TCL_STORAGE_CLASS", "#   else", "#      define TCL_STORAGE_CLASS DLLIMPORT", "#   endif", "#endif", "", "/*", " * WARNING: This file is automatically generated by the tools/genStubs.tcl", " * script.  Any modifications to the function declarations below should be made", " * in the generic/tclInt.decls script.", " */", "", "/* !BEGIN!: Do not edit below this line. */", "", "/*", " * Exported function declarations:", " */", "", "#ifndef TclBN_epoch_TCL_DECLARED", "#define TclBN_epoch_TCL_DECLARED", "/* 0 */", "EXTERN int\t\tTclBN_epoch(void);", "#endif", "#ifndef TclBN_revision_TCL_DECLARED", "#define TclBN_revision_TCL_DECLARED", "/* 1 */", "EXTERN int\t\tTclBN_revision(void);", "#endif", "#ifndef TclBN_mp_add_TCL_DECLARED", "#define TclBN_mp_add_TCL_DECLARED", "/* 2 */", "EXTERN int\t\tTclBN_mp_add(mp_int *a, mp_int *b, mp_int *c);", "#endif", "#ifndef TclBN_mp_add_d_TCL_DECLARED", "#define TclBN_mp_add_d_TCL_DECLARED", "/* 3 */", "EXTERN int\t\tTclBN_mp_add_d(mp_int *a, mp_digit b, mp_int *c);", "#endif", "#ifndef TclBN_mp_and_TCL_DECLARED", "#define TclBN_mp_and_TCL_DECLARED", "/* 4 */", "EXTERN int\t\tTclBN_mp_and(mp_int *a, mp_int *b, mp_int *c);", "#endif", "#ifndef TclBN_mp_clamp_TCL_DECLARED", "#define TclBN_mp_clamp_TCL_DECLARED", "/* 5 */", "EXTERN void\t\tTclBN_mp_clamp(mp_int *a);", "#endif", "#ifndef TclBN_mp_clear_TCL_DECLARED", "#define TclBN_mp_clear_TCL_DECLARED", "/* 6 */", "EXTERN void\t\tTclBN_mp_clear(mp_int *a);", "#endif", "#ifndef TclBN_mp_clear_multi_TCL_DECLARED", "#define TclBN_mp_clear_multi_TCL_DECLARED", "/* 7 */", "EXTERN void\t\tTclBN_mp_clear_multi(mp_int *a, ...);", "#endif", "#ifndef TclBN_mp_cmp_TCL_DECLARED", "#define TclBN_mp_cmp_TCL_DECLARED", "/* 8 */", "EXTERN int\t\tTclBN_mp_cmp(mp_int *a, mp_int *b);", "#endif", "#ifndef TclBN_mp_cmp_d_TCL_DECLARED", "#define TclBN_mp_cmp_d_TCL_DECLARED", "/* 9 */", "EXTERN int\t\tTclBN_mp_cmp_d(mp_int *a, mp_digit b);", "#endif", "#ifndef TclBN_mp_cmp_mag_TCL_DECLARED", "#define TclBN_mp_cmp_mag_TCL_DECLARED", "/* 10 */", "EXTERN int\t\tTclBN_mp_cmp_mag(mp_int *a, mp_int *b);", "#endif", "#ifndef TclBN_mp_copy_TCL_DECLARED", "#define TclBN_mp_copy_TCL_DECLARED", "/* 11 */", "EXTERN int\t\tTclBN_mp_copy(mp_int *a, mp_int *b);", "#endif", "#ifndef TclBN_mp_count_bits_TCL_DECLARED", "#define TclBN_mp_count_bits_TCL_DECLARED", "/* 12 */", "EXTERN int\t\tTclBN_mp_count_bits(mp_int *a);", "#endif", "#ifndef TclBN_mp_div_TCL_DECLARED", "#define TclBN_mp_div_TCL_DECLARED", "/* 13 */", "EXTERN int\t\tTclBN_mp_div(mp_int *a, mp_int *b, mp_int *q,", "\t\t\t\tmp_int *r);", "#endif", "#ifndef TclBN_mp_div_d_TCL_DECLARED", "#define TclBN_mp_div_d_TCL_DECLARED", "/* 14 */", "EXTERN int\t\tTclBN_mp_div_d(mp_int *a, mp_digit b, mp_int *q,", "\t\t\t\tmp_digit *r);", "#endif", "#ifndef TclBN_mp_div_2_TCL_DECLARED", "#define TclBN_mp_div_2_TCL_DECLARED", "/* 15 */", "EXTERN int\t\tTclBN_mp_div_2(mp_int *a, mp_int *q);", "#endif", "#ifndef TclBN_mp_div_2d_TCL_DECLARED", "#define TclBN_mp_div_2d_TCL_DECLARED", "/* 16 */", "EXTERN int\t\tTclBN_mp_div_2d(mp_int *a, int b, mp_int *q,", "\t\t\t\tmp_int *r);", "#endif", "#ifndef TclBN_mp_div_3_TCL_DECLARED", "#define TclBN_mp_div_3_TCL_DECLARED", "/* 17 */", "EXTERN int\t\tTclBN_mp_div_3(mp_int *a, mp_int *q, mp_digit *r);", "#endif", "#ifndef TclBN_mp_exch_TCL_DECLARED", "#define TclBN_mp_exch_TCL_DECLARED", "/* 18 */", "EXTERN void\t\tTclBN_mp_exch(mp_int *a, mp_int *b);", "#endif", "#ifndef TclBN_mp_expt_d_TCL_DECLARED", "#define TclBN_mp_expt_d_TCL_DECLARED", "/* 19 */", "EXTERN int\t\tTclBN_mp_expt_d(mp_int *a, mp_digit b, mp_int *c);", "#endif", "#ifndef TclBN_mp_grow_TCL_DECLARED", "#define TclBN_mp_grow_TCL_DECLARED", "/* 20 */", "EXTERN int\t\tTclBN_mp_grow(mp_int *a, int size);", "#endif", "#ifndef TclBN_mp_init_TCL_DECLARED", "#define TclBN_mp_init_TCL_DECLARED", "/* 21 */", "EXTERN int\t\tTclBN_mp_init(mp_int *a);", "#endif", "#ifndef TclBN_mp_init_copy_TCL_DECLARED", "#define TclBN_mp_init_copy_TCL_DECLARED", "/* 22 */", "EXTERN int\t\tTclBN_mp_init_copy(mp_int *a, mp_int *b);", "#endif", "#ifndef TclBN_mp_init_multi_TCL_DECLARED", "#define TclBN_mp_init_multi_TCL_DECLARED", "/* 23 */", "EXTERN int\t\tTclBN_mp_init_multi(mp_int *a, ...);", "#endif", "#ifndef TclBN_mp_init_set_TCL_DECLARED", "#define TclBN_mp_init_set_TCL_DECLARED", "/* 24 */", "EXTERN int\t\tTclBN_mp_init_set(mp_int *a, mp_digit b);", "#endif", "#ifndef TclBN_mp_init_size_TCL_DECLARED", "#define TclBN_mp_init_size_TCL_DECLARED", "/* 25 */", "EXTERN int\t\tTclBN_mp_init_size(mp_int *a, int size);", "#endif", "#ifndef TclBN_mp_lshd_TCL_DECLARED", "#define TclBN_mp_lshd_TCL_DECLARED", "/* 26 */", "EXTERN int\t\tTclBN_mp_lshd(mp_int *a, int shift);", "#endif", "#ifndef TclBN_mp_mod_TCL_DECLARED", "#define TclBN_mp_mod_TCL_DECLARED", "/* 27 */", "EXTERN int\t\tTclBN_mp_mod(mp_int *a, mp_int *b, mp_int *r);", "#endif", "#ifndef TclBN_mp_mod_2d_TCL_DECLARED", "#define TclBN_mp_mod_2d_TCL_DECLARED", "/* 28 */", "EXTERN int\t\tTclBN_mp_mod_2d(mp_int *a, int b, mp_int *r);", "#endif", "#ifndef TclBN_mp_mul_TCL_DECLARED", "#define TclBN_mp_mul_TCL_DECLARED", "/* 29 */", "EXTERN int\t\tTclBN_mp_mul(mp_int *a, mp_int *b, mp_int *p);", "#endif", "#ifndef TclBN_mp_mul_d_TCL_DECLARED", "#define TclBN_mp_mul_d_TCL_DECLARED", "/* 30 */", "EXTERN int\t\tTclBN_mp_mul_d(mp_int *a, mp_digit b, mp_int *p);", "#endif", "#ifndef TclBN_mp_mul_2_TCL_DECLARED", "#define TclBN_mp_mul_2_TCL_DECLARED", "/* 31 */", "EXTERN int\t\tTclBN_mp_mul_2(mp_int *a, mp_int *p);", "#endif", "#ifndef TclBN_mp_mul_2d_TCL_DECLARED", "#define TclBN_mp_mul_2d_TCL_DECLARED", "/* 32 */", "EXTERN int\t\tTclBN_mp_mul_2d(mp_int *a, int d, mp_int *p);", "#endif", "#ifndef TclBN_mp_neg_TCL_DECLARED", "#define TclBN_mp_neg_TCL_DECLARED", "/* 33 */", "EXTERN int\t\tTclBN_mp_neg(mp_int *a, mp_int *b);", "#endif", "#ifndef TclBN_mp_or_TCL_DECLARED", "#define TclBN_mp_or_TCL_DECLARED", "/* 34 */", "EXTERN int\t\tTclBN_mp_or(mp_int *a, mp_int *b, mp_int *c);", "#endif", "#ifndef TclBN_mp_radix_size_TCL_DECLARED", "#define TclBN_mp_radix_size_TCL_DECLARED", "/* 35 */", "EXTERN int\t\tTclBN_mp_radix_size(mp_int *a, int radix, int *size);", "#endif", "#ifndef TclBN_mp_read_radix_TCL_DECLARED", "#define TclBN_mp_read_radix_TCL_DECLARED", "/* 36 */", "EXTERN int\t\tTclBN_mp_read_radix(mp_int *a, const char *str,", "\t\t\t\tint radix);", "#endif", "#ifndef TclBN_mp_rshd_TCL_DECLARED", "#define TclBN_mp_rshd_TCL_DECLARED", "/* 37 */", "EXTERN void\t\tTclBN_mp_rshd(mp_int *a, int shift);", "#endif", "#ifndef TclBN_mp_shrink_TCL_DECLARED", "#define TclBN_mp_shrink_TCL_DECLARED", "/* 38 */", "EXTERN int\t\tTclBN_mp_shrink(mp_int *a);", "#endif", "#ifndef TclBN_mp_set_TCL_DECLARED", "#define TclBN_mp_set_TCL_DECLARED", "/* 39 */", "EXTERN void\t\tTclBN_mp_set(mp_int *a, mp_digit b);", "#endif", "#ifndef TclBN_mp_sqr_TCL_DECLARED", "#define TclBN_mp_sqr_TCL_DECLARED", "/* 40 */", "EXTERN int\t\tTclBN_mp_sqr(mp_int *a, mp_int *b);", "#endif", "#ifndef TclBN_mp_sqrt_TCL_DECLARED", "#define TclBN_mp_sqrt_TCL_DECLARED", "/* 41 */", "EXTERN int\t\tTclBN_mp_sqrt(mp_int *a, mp_int *b);", "#endif", "#ifndef TclBN_mp_sub_TCL_DECLARED", "#define TclBN_mp_sub_TCL_DECLARED", "/* 42 */", "EXTERN int\t\tTclBN_mp_sub(mp_int *a, mp_int *b, mp_int *c);", "#endif", "#ifndef TclBN_mp_sub_d_TCL_DECLARED", "#define TclBN_mp_sub_d_TCL_DECLARED", "/* 43 */", "EXTERN int\t\tTclBN_mp_sub_d(mp_int *a, mp_digit b, mp_int *c);", "#endif", "#ifndef TclBN_mp_to_unsigned_bin_TCL_DECLARED", "#define TclBN_mp_to_unsigned_bin_TCL_DECLARED", "/* 44 */", "EXTERN int\t\tTclBN_mp_to_unsigned_bin(mp_int *a, unsigned char *b);", "#endif", "#ifndef TclBN_mp_to_unsigned_bin_n_TCL_DECLARED", "#define TclBN_mp_to_unsigned_bin_n_TCL_DECLARED", "/* 45 */", "EXTERN int\t\tTclBN_mp_to_unsigned_bin_n(mp_int *a,", "\t\t\t\tunsigned char *b, unsigned long *outlen);", "#endif", "#ifndef TclBN_mp_toradix_n_TCL_DECLARED", "#define TclBN_mp_toradix_n_TCL_DECLARED", "/* 46 */", "EXTERN int\t\tTclBN_mp_toradix_n(mp_int *a, char *str, int radix,", "\t\t\t\tint maxlen);", "#endif", "#ifndef TclBN_mp_unsigned_bin_size_TCL_DECLARED", "#define TclBN_mp_unsigned_bin_size_TCL_DECLARED", "/* 47 */", "EXTERN int\t\tTclBN_mp_unsigned_bin_size(mp_int *a);", "#endif", "#ifndef TclBN_mp_xor_TCL_DECLARED", "#define TclBN_mp_xor_TCL_DECLARED", "/* 48 */", "EXTERN int\t\tTclBN_mp_xor(mp_int *a, mp_int *b, mp_int *c);", "#endif", "#ifndef TclBN_mp_zero_TCL_DECLARED", "#define TclBN_mp_zero_TCL_DECLARED", "/* 49 */", "EXTERN void\t\tTclBN_mp_zero(mp_int *a);", "#endif", "#ifndef TclBN_reverse_TCL_DECLARED", "#define TclBN_reverse_TCL_DECLARED", "/* 50 */", "EXTERN void\t\tTclBN_reverse(unsigned char *s, int len);", "#endif", "#ifndef TclBN_fast_s_mp_mul_digs_TCL_DECLARED", "#define TclBN_fast_s_mp_mul_digs_TCL_DECLARED", "/* 51 */", "EXTERN int\t\tTclBN_fast_s_mp_mul_digs(mp_int *a, mp_int *b,", "\t\t\t\tmp_int *c, int digs);", "#endif", "#ifndef TclBN_fast_s_mp_sqr_TCL_DECLARED", "#define TclBN_fast_s_mp_sqr_TCL_DECLARED", "/* 52 */", "EXTERN int\t\tTclBN_fast_s_mp_sqr(mp_int *a, mp_int *b);", "#endif", "#ifndef TclBN_mp_karatsuba_mul_TCL_DECLARED", "#define TclBN_mp_karatsuba_mul_TCL_DECLARED", "/* 53 */", "EXTERN int\t\tTclBN_mp_karatsuba_mul(mp_int *a, mp_int *b,", "\t\t\t\tmp_int *c);", "#endif", "#ifndef TclBN_mp_karatsuba_sqr_TCL_DECLARED", "#define TclBN_mp_karatsuba_sqr_TCL_DECLARED", "/* 54 */", "EXTERN int\t\tTclBN_mp_karatsuba_sqr(mp_int *a, mp_int *b);", "#endif", "#ifndef TclBN_mp_toom_mul_TCL_DECLARED", "#define TclBN_mp_toom_mul_TCL_DECLARED", "/* 55 */", "EXTERN int\t\tTclBN_mp_toom_mul(mp_int *a, mp_int *b, mp_int *c);", "#endif", "#ifndef TclBN_mp_toom_sqr_TCL_DECLARED", "#define TclBN_mp_toom_sqr_TCL_DECLARED", "/* 56 */", "EXTERN int\t\tTclBN_mp_toom_sqr(mp_int *a, mp_int *b);", "#endif", "#ifndef TclBN_s_mp_add_TCL_DECLARED", "#define TclBN_s_mp_add_TCL_DECLARED", "/* 57 */", "EXTERN int\t\tTclBN_s_mp_add(mp_int *a, mp_int *b, mp_int *c);", "#endif", "#ifndef TclBN_s_mp_mul_digs_TCL_DECLARED", "#define TclBN_s_mp_mul_digs_TCL_DECLARED", "/* 58 */", "EXTERN int\t\tTclBN_s_mp_mul_digs(mp_int *a, mp_int *b, mp_int *c,", "\t\t\t\tint digs);", "#endif", "#ifndef TclBN_s_mp_sqr_TCL_DECLARED", "#define TclBN_s_mp_sqr_TCL_DECLARED", "/* 59 */", "EXTERN int\t\tTclBN_s_mp_sqr(mp_int *a, mp_int *b);", "#endif", "#ifndef TclBN_s_mp_sub_TCL_DECLARED", "#define TclBN_s_mp_sub_TCL_DECLARED", "/* 60 */", "EXTERN int\t\tTclBN_s_mp_sub(mp_int *a, mp_int *b, mp_int *c);", "#endif", "", "typedef struct TclTomMathStubs {", "    int magic;", "    struct TclTomMathStubHooks *hooks;", "", "    int (*tclBN_epoch) (void); /* 0 */", "    int (*tclBN_revision) (void); /* 1 */", "    int (*tclBN_mp_add) (mp_int *a, mp_int *b, mp_int *c); /* 2 */", "    int (*tclBN_mp_add_d) (mp_int *a, mp_digit b, mp_int *c); /* 3 */", "    int (*tclBN_mp_and) (mp_int *a, mp_int *b, mp_int *c); /* 4 */", "    void (*tclBN_mp_clamp) (mp_int *a); /* 5 */", "    void (*tclBN_mp_clear) (mp_int *a); /* 6 */", "    void (*tclBN_mp_clear_multi) (mp_int *a, ...); /* 7 */", "    int (*tclBN_mp_cmp) (mp_int *a, mp_int *b); /* 8 */", "    int (*tclBN_mp_cmp_d) (mp_int *a, mp_digit b); /* 9 */", "    int (*tclBN_mp_cmp_mag) (mp_int *a, mp_int *b); /* 10 */", "    int (*tclBN_mp_copy) (mp_int *a, mp_int *b); /* 11 */", "    int (*tclBN_mp_count_bits) (mp_int *a); /* 12 */", "    int (*tclBN_mp_div) (mp_int *a, mp_int *b, mp_int *q, mp_int *r); /* 13 */", "    int (*tclBN_mp_div_d) (mp_int *a, mp_digit b, mp_int *q, mp_digit *r); /* 14 */", "    int (*tclBN_mp_div_2) (mp_int *a, mp_int *q); /* 15 */", "    int (*tclBN_mp_div_2d) (mp_int *a, int b, mp_int *q, mp_int *r); /* 16 */", "    int (*tclBN_mp_div_3) (mp_int *a, mp_int *q, mp_digit *r); /* 17 */", "    void (*tclBN_mp_exch) (mp_int *a, mp_int *b); /* 18 */", "    int (*tclBN_mp_expt_d) (mp_int *a, mp_digit b, mp_int *c); /* 19 */", "    int (*tclBN_mp_grow) (mp_int *a, int size); /* 20 */", "    int (*tclBN_mp_init) (mp_int *a); /* 21 */", "    int (*tclBN_mp_init_copy) (mp_int *a, mp_int *b); /* 22 */", "    int (*tclBN_mp_init_multi) (mp_int *a, ...); /* 23 */", "    int (*tclBN_mp_init_set) (mp_int *a, mp_digit b); /* 24 */", "    int (*tclBN_mp_init_size) (mp_int *a, int size); /* 25 */", "    int (*tclBN_mp_lshd) (mp_int *a, int shift); /* 26 */", "    int (*tclBN_mp_mod) (mp_int *a, mp_int *b, mp_int *r); /* 27 */", "    int (*tclBN_mp_mod_2d) (mp_int *a, int b, mp_int *r); /* 28 */", "    int (*tclBN_mp_mul) (mp_int *a, mp_int *b, mp_int *p); /* 29 */", "    int (*tclBN_mp_mul_d) (mp_int *a, mp_digit b, mp_int *p); /* 30 */", "    int (*tclBN_mp_mul_2) (mp_int *a, mp_int *p); /* 31 */", "    int (*tclBN_mp_mul_2d) (mp_int *a, int d, mp_int *p); /* 32 */", "    int (*tclBN_mp_neg) (mp_int *a, mp_int *b); /* 33 */", "    int (*tclBN_mp_or) (mp_int *a, mp_int *b, mp_int *c); /* 34 */", "    int (*tclBN_mp_radix_size) (mp_int *a, int radix, int *size); /* 35 */", "    int (*tclBN_mp_read_radix) (mp_int *a, const char *str, int radix); /* 36 */", "    void (*tclBN_mp_rshd) (mp_int *a, int shift); /* 37 */", "    int (*tclBN_mp_shrink) (mp_int *a); /* 38 */", "    void (*tclBN_mp_set) (mp_int *a, mp_digit b); /* 39 */", "    int (*tclBN_mp_sqr) (mp_int *a, mp_int *b); /* 40 */", "    int (*tclBN_mp_sqrt) (mp_int *a, mp_int *b); /* 41 */", "    int (*tclBN_mp_sub) (mp_int *a, mp_int *b, mp_int *c); /* 42 */", "    int (*tclBN_mp_sub_d) (mp_int *a, mp_digit b, mp_int *c); /* 43 */", "    int (*tclBN_mp_to_unsigned_bin) (mp_int *a, unsigned char *b); /* 44 */", "    int (*tclBN_mp_to_unsigned_bin_n) (mp_int *a, unsigned char *b, unsigned long *outlen); /* 45 */", "    int (*tclBN_mp_toradix_n) (mp_int *a, char *str, int radix, int maxlen); /* 46 */", "    int (*tclBN_mp_unsigned_bin_size) (mp_int *a); /* 47 */", "    int (*tclBN_mp_xor) (mp_int *a, mp_int *b, mp_int *c); /* 48 */", "    void (*tclBN_mp_zero) (mp_int *a); /* 49 */", "    void (*tclBN_reverse) (unsigned char *s, int len); /* 50 */", "    int (*tclBN_fast_s_mp_mul_digs) (mp_int *a, mp_int *b, mp_int *c, int digs); /* 51 */", "    int (*tclBN_fast_s_mp_sqr) (mp_int *a, mp_int *b); /* 52 */", "    int (*tclBN_mp_karatsuba_mul) (mp_int *a, mp_int *b, mp_int *c); /* 53 */", "    int (*tclBN_mp_karatsuba_sqr) (mp_int *a, mp_int *b); /* 54 */", "    int (*tclBN_mp_toom_mul) (mp_int *a, mp_int *b, mp_int *c); /* 55 */", "    int (*tclBN_mp_toom_sqr) (mp_int *a, mp_int *b); /* 56 */", "    int (*tclBN_s_mp_add) (mp_int *a, mp_int *b, mp_int *c); /* 57 */", "    int (*tclBN_s_mp_mul_digs) (mp_int *a, mp_int *b, mp_int *c, int digs); /* 58 */", "    int (*tclBN_s_mp_sqr) (mp_int *a, mp_int *b); /* 59 */", "    int (*tclBN_s_mp_sub) (mp_int *a, mp_int *b, mp_int *c); /* 60 */", "} TclTomMathStubs;", "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "extern TclTomMathStubs *tclTomMathStubsPtr;", "#ifdef __cplusplus", "}", "#endif", "", "#if defined(USE_TCL_STUBS) && !defined(USE_TCL_STUB_PROCS)", "", "/*", " * Inline function declarations:", " */", "", "#ifndef TclBN_epoch", "#define TclBN_epoch \\", "\t(tclTomMathStubsPtr->tclBN_epoch) /* 0 */", "#endif", "#ifndef TclBN_revision", "#define TclBN_revision \\", "\t(tclTomMathStubsPtr->tclBN_revision) /* 1 */", "#endif", "#ifndef TclBN_mp_add", "#define TclBN_mp_add \\", "\t(tclTomMathStubsPtr->tclBN_mp_add) /* 2 */", "#endif", "#ifndef TclBN_mp_add_d", "#define TclBN_mp_add_d \\", "\t(tclTomMathStubsPtr->tclBN_mp_add_d) /* 3 */", "#endif", "#ifndef TclBN_mp_and", "#define TclBN_mp_and \\", "\t(tclTomMathStubsPtr->tclBN_mp_and) /* 4 */", "#endif", "#ifndef TclBN_mp_clamp", "#define TclBN_mp_clamp \\", "\t(tclTomMathStubsPtr->tclBN_mp_clamp) /* 5 */", "#endif", "#ifndef TclBN_mp_clear", "#define TclBN_mp_clear \\", "\t(tclTomMathStubsPtr->tclBN_mp_clear) /* 6 */", "#endif", "#ifndef TclBN_mp_clear_multi", "#define TclBN_mp_clear_multi \\", "\t(tclTomMathStubsPtr->tclBN_mp_clear_multi) /* 7 */", "#endif", "#ifndef TclBN_mp_cmp", "#define TclBN_mp_cmp \\", "\t(tclTomMathStubsPtr->tclBN_mp_cmp) /* 8 */", "#endif", "#ifndef TclBN_mp_cmp_d", "#define TclBN_mp_cmp_d \\", "\t(tclTomMathStubsPtr->tclBN_mp_cmp_d) /* 9 */", "#endif", "#ifndef TclBN_mp_cmp_mag", "#define TclBN_mp_cmp_mag \\", "\t(tclTomMathStubsPtr->tclBN_mp_cmp_mag) /* 10 */", "#endif", "#ifndef TclBN_mp_copy", "#define TclBN_mp_copy \\", "\t(tclTomMathStubsPtr->tclBN_mp_copy) /* 11 */", "#endif", "#ifndef TclBN_mp_count_bits", "#define TclBN_mp_count_bits \\", "\t(tclTomMathStubsPtr->tclBN_mp_count_bits) /* 12 */", "#endif", "#ifndef TclBN_mp_div", "#define TclBN_mp_div \\", "\t(tclTomMathStubsPtr->tclBN_mp_div) /* 13 */", "#endif", "#ifndef TclBN_mp_div_d", "#define TclBN_mp_div_d \\", "\t(tclTomMathStubsPtr->tclBN_mp_div_d) /* 14 */", "#endif", "#ifndef TclBN_mp_div_2", "#define TclBN_mp_div_2 \\", "\t(tclTomMathStubsPtr->tclBN_mp_div_2) /* 15 */", "#endif", "#ifndef TclBN_mp_div_2d", "#define TclBN_mp_div_2d \\", "\t(tclTomMathStubsPtr->tclBN_mp_div_2d) /* 16 */", "#endif", "#ifndef TclBN_mp_div_3", "#define TclBN_mp_div_3 \\", "\t(tclTomMathStubsPtr->tclBN_mp_div_3) /* 17 */", "#endif", "#ifndef TclBN_mp_exch", "#define TclBN_mp_exch \\", "\t(tclTomMathStubsPtr->tclBN_mp_exch) /* 18 */", "#endif", "#ifndef TclBN_mp_expt_d", "#define TclBN_mp_expt_d \\", "\t(tclTomMathStubsPtr->tclBN_mp_expt_d) /* 19 */", "#endif", "#ifndef TclBN_mp_grow", "#define TclBN_mp_grow \\", "\t(tclTomMathStubsPtr->tclBN_mp_grow) /* 20 */", "#endif", "#ifndef TclBN_mp_init", "#define TclBN_mp_init \\", "\t(tclTomMathStubsPtr->tclBN_mp_init) /* 21 */", "#endif", "#ifndef TclBN_mp_init_copy", "#define TclBN_mp_init_copy \\", "\t(tclTomMathStubsPtr->tclBN_mp_init_copy) /* 22 */", "#endif", "#ifndef TclBN_mp_init_multi", "#define TclBN_mp_init_multi \\", "\t(tclTomMathStubsPtr->tclBN_mp_init_multi) /* 23 */", "#endif", "#ifndef TclBN_mp_init_set", "#define TclBN_mp_init_set \\", "\t(tclTomMathStubsPtr->tclBN_mp_init_set) /* 24 */", "#endif", "#ifndef TclBN_mp_init_size", "#define TclBN_mp_init_size \\", "\t(tclTomMathStubsPtr->tclBN_mp_init_size) /* 25 */", "#endif", "#ifndef TclBN_mp_lshd", "#define TclBN_mp_lshd \\", "\t(tclTomMathStubsPtr->tclBN_mp_lshd) /* 26 */", "#endif", "#ifndef TclBN_mp_mod", "#define TclBN_mp_mod \\", "\t(tclTomMathStubsPtr->tclBN_mp_mod) /* 27 */", "#endif", "#ifndef TclBN_mp_mod_2d", "#define TclBN_mp_mod_2d \\", "\t(tclTomMathStubsPtr->tclBN_mp_mod_2d) /* 28 */", "#endif", "#ifndef TclBN_mp_mul", "#define TclBN_mp_mul \\", "\t(tclTomMathStubsPtr->tclBN_mp_mul) /* 29 */", "#endif", "#ifndef TclBN_mp_mul_d", "#define TclBN_mp_mul_d \\", "\t(tclTomMathStubsPtr->tclBN_mp_mul_d) /* 30 */", "#endif", "#ifndef TclBN_mp_mul_2", "#define TclBN_mp_mul_2 \\", "\t(tclTomMathStubsPtr->tclBN_mp_mul_2) /* 31 */", "#endif", "#ifndef TclBN_mp_mul_2d", "#define TclBN_mp_mul_2d \\", "\t(tclTomMathStubsPtr->tclBN_mp_mul_2d) /* 32 */", "#endif", "#ifndef TclBN_mp_neg", "#define TclBN_mp_neg \\", "\t(tclTomMathStubsPtr->tclBN_mp_neg) /* 33 */", "#endif", "#ifndef TclBN_mp_or", "#define TclBN_mp_or \\", "\t(tclTomMathStubsPtr->tclBN_mp_or) /* 34 */", "#endif", "#ifndef TclBN_mp_radix_size", "#define TclBN_mp_radix_size \\", "\t(tclTomMathStubsPtr->tclBN_mp_radix_size) /* 35 */", "#endif", "#ifndef TclBN_mp_read_radix", "#define TclBN_mp_read_radix \\", "\t(tclTomMathStubsPtr->tclBN_mp_read_radix) /* 36 */", "#endif", "#ifndef TclBN_mp_rshd", "#define TclBN_mp_rshd \\", "\t(tclTomMathStubsPtr->tclBN_mp_rshd) /* 37 */", "#endif", "#ifndef TclBN_mp_shrink", "#define TclBN_mp_shrink \\", "\t(tclTomMathStubsPtr->tclBN_mp_shrink) /* 38 */", "#endif", "#ifndef TclBN_mp_set", "#define TclBN_mp_set \\", "\t(tclTomMathStubsPtr->tclBN_mp_set) /* 39 */", "#endif", "#ifndef TclBN_mp_sqr", "#define TclBN_mp_sqr \\", "\t(tclTomMathStubsPtr->tclBN_mp_sqr) /* 40 */", "#endif", "#ifndef TclBN_mp_sqrt", "#define TclBN_mp_sqrt \\", "\t(tclTomMathStubsPtr->tclBN_mp_sqrt) /* 41 */", "#endif", "#ifndef TclBN_mp_sub", "#define TclBN_mp_sub \\", "\t(tclTomMathStubsPtr->tclBN_mp_sub) /* 42 */", "#endif", "#ifndef TclBN_mp_sub_d", "#define TclBN_mp_sub_d \\", "\t(tclTomMathStubsPtr->tclBN_mp_sub_d) /* 43 */", "#endif", "#ifndef TclBN_mp_to_unsigned_bin", "#define TclBN_mp_to_unsigned_bin \\", "\t(tclTomMathStubsPtr->tclBN_mp_to_unsigned_bin) /* 44 */", "#endif", "#ifndef TclBN_mp_to_unsigned_bin_n", "#define TclBN_mp_to_unsigned_bin_n \\", "\t(tclTomMathStubsPtr->tclBN_mp_to_unsigned_bin_n) /* 45 */", "#endif", "#ifndef TclBN_mp_toradix_n", "#define TclBN_mp_toradix_n \\", "\t(tclTomMathStubsPtr->tclBN_mp_toradix_n) /* 46 */", "#endif", "#ifndef TclBN_mp_unsigned_bin_size", "#define TclBN_mp_unsigned_bin_size \\", "\t(tclTomMathStubsPtr->tclBN_mp_unsigned_bin_size) /* 47 */", "#endif", "#ifndef TclBN_mp_xor", "#define TclBN_mp_xor \\", "\t(tclTomMathStubsPtr->tclBN_mp_xor) /* 48 */", "#endif", "#ifndef TclBN_mp_zero", "#define TclBN_mp_zero \\", "\t(tclTomMathStubsPtr->tclBN_mp_zero) /* 49 */", "#endif", "#ifndef TclBN_reverse", "#define TclBN_reverse \\", "\t(tclTomMathStubsPtr->tclBN_reverse) /* 50 */", "#endif", "#ifndef TclBN_fast_s_mp_mul_digs", "#define TclBN_fast_s_mp_mul_digs \\", "\t(tclTomMathStubsPtr->tclBN_fast_s_mp_mul_digs) /* 51 */", "#endif", "#ifndef TclBN_fast_s_mp_sqr", "#define TclBN_fast_s_mp_sqr \\", "\t(tclTomMathStubsPtr->tclBN_fast_s_mp_sqr) /* 52 */", "#endif", "#ifndef TclBN_mp_karatsuba_mul", "#define TclBN_mp_karatsuba_mul \\", "\t(tclTomMathStubsPtr->tclBN_mp_karatsuba_mul) /* 53 */", "#endif", "#ifndef TclBN_mp_karatsuba_sqr", "#define TclBN_mp_karatsuba_sqr \\", "\t(tclTomMathStubsPtr->tclBN_mp_karatsuba_sqr) /* 54 */", "#endif", "#ifndef TclBN_mp_toom_mul", "#define TclBN_mp_toom_mul \\", "\t(tclTomMathStubsPtr->tclBN_mp_toom_mul) /* 55 */", "#endif", "#ifndef TclBN_mp_toom_sqr", "#define TclBN_mp_toom_sqr \\", "\t(tclTomMathStubsPtr->tclBN_mp_toom_sqr) /* 56 */", "#endif", "#ifndef TclBN_s_mp_add", "#define TclBN_s_mp_add \\", "\t(tclTomMathStubsPtr->tclBN_s_mp_add) /* 57 */", "#endif", "#ifndef TclBN_s_mp_mul_digs", "#define TclBN_s_mp_mul_digs \\", "\t(tclTomMathStubsPtr->tclBN_s_mp_mul_digs) /* 58 */", "#endif", "#ifndef TclBN_s_mp_sqr", "#define TclBN_s_mp_sqr \\", "\t(tclTomMathStubsPtr->tclBN_s_mp_sqr) /* 59 */", "#endif", "#ifndef TclBN_s_mp_sub", "#define TclBN_s_mp_sub \\", "\t(tclTomMathStubsPtr->tclBN_s_mp_sub) /* 60 */", "#endif", "", "#endif /* defined(USE_TCL_STUBS) && !defined(USE_TCL_STUB_PROCS) */", "", "/* !END!: Do not edit above this line. */", "", "#undef TCL_STORAGE_CLASS", "#define TCL_STORAGE_CLASS DLLIMPORT", "", "#endif /* _TCLINTDECLS */" },
    ["term.h"] = { "/****************************************************************************", " * Copyright (c) 1998-2007,2008 Free Software Foundation, Inc.              *", " *                                                                          *", " * Permission is hereby granted, free of charge, to any person obtaining a  *", " * copy of this software and associated documentation files (the            *", ' * "Software"), to deal in the Software without restriction, including      *', " * without limitation the rights to use, copy, modify, merge, publish,      *", " * distribute, distribute with modifications, sublicense, and/or sell       *", " * copies of the Software, and to permit persons to whom the Software is    *", " * furnished to do so, subject to the following conditions:                 *", " *                                                                          *", " * The above copyright notice and this permission notice shall be included  *", " * in all copies or substantial portions of the Software.                   *", " *                                                                          *", ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *', " * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *", " * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *", " * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *", " * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *", " * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *", " * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *", " *                                                                          *", " * Except as contained in this notice, the name(s) of the above copyright   *", " * holders shall not be used in advertising or otherwise to promote the     *", " * sale, use or other dealings in this Software without prior written       *", " * authorization.                                                           *", " ****************************************************************************/", "", "/****************************************************************************/", "/* Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995                */", "/*    and: Eric S. Raymond <esr@snark.thyrsus.com>                          */", "/*    and: Thomas E. Dickey                        1995-on                  */", "/****************************************************************************/", "", "/* $Id: MKterm.h.awk.in,v 1.50 2008/05/24 23:13:59 tom Exp $ */", "", "/*", "**\tterm.h -- Definition of struct term", "*/", "", "#ifndef NCURSES_TERM_H_incl", "#define NCURSES_TERM_H_incl 1", "", "#undef  NCURSES_VERSION", '#define NCURSES_VERSION "5.7"', "", "#include <ncurses_dll.h>", "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "", "/* Make this file self-contained by providing defaults for the HAVE_TERMIO[S]_H", " * definition (based on the system for which this was configured).", " */", "", "#undef  NCURSES_CONST", "#define NCURSES_CONST /*nothing*/", "", "#undef  NCURSES_SBOOL", "#define NCURSES_SBOOL char", "", "#undef  NCURSES_XNAMES", "#define NCURSES_XNAMES 1", "", "/* We will use these symbols to hide differences between", " * termios/termio/sgttyb interfaces.", " */", "#undef  TTY", "#undef  SET_TTY", "#undef  GET_TTY", "", "/* Assume POSIX termio if we have the header and function */", "/* #if HAVE_TERMIOS_H && HAVE_TCGETATTR */", "#if 1 && 1", "", "#undef  TERMIOS", "#define TERMIOS 1", "", "#include <termios.h>", "#define TTY struct termios", "", "#else /* !HAVE_TERMIOS_H */", "", "/* #if HAVE_TERMIO_H */", "#if 0", "", "#undef  TERMIOS", "#define TERMIOS 1", "", "#include <termio.h>", "#define TTY struct termio", "", "/* Add definitions to make termio look like termios.", " * But ifdef it, since there are some implementations", " * that try to do this for us in a fake <termio.h>.", " */", "#ifndef TCSANOW", "#define TCSANOW TCSETA", "#endif", "#ifndef TCSADRAIN", "#define TCSADRAIN TCSETAW", "#endif", "#ifndef TCSAFLUSH", "#define TCSAFLUSH TCSETAF", "#endif", "#ifndef tcsetattr", "#define tcsetattr(fd, cmd, arg) ioctl(fd, cmd, arg)", "#endif", "#ifndef tcgetattr", "#define tcgetattr(fd, arg) ioctl(fd, TCGETA, arg)", "#endif", "#ifndef cfgetospeed", "#define cfgetospeed(t) ((t)->c_cflag & CBAUD)", "#endif", "#ifndef TCIFLUSH ", "#define TCIFLUSH 0", "#endif", "#ifndef TCOFLUSH ", "#define TCOFLUSH 1", "#endif", "#ifndef TCIOFLUSH ", "#define TCIOFLUSH 2", "#endif", "#ifndef tcflush", "#define tcflush(fd, arg) ioctl(fd, TCFLSH, arg)", "#endif", "", "#else /* !HAVE_TERMIO_H */", "", "#undef TERMIOS", "#include <sgtty.h>", "#include <sys/ioctl.h>", "#define TTY struct sgttyb", "", "#endif /* HAVE_TERMIO_H */", "", "#endif /* HAVE_TERMIOS_H */", "", "#ifdef TERMIOS", "#define GET_TTY(fd, buf) tcgetattr(fd, buf)", "#define SET_TTY(fd, buf) tcsetattr(fd, TCSADRAIN, buf)", "#else", "#define GET_TTY(fd, buf) gtty(fd, buf)", "#define SET_TTY(fd, buf) stty(fd, buf)", "#endif", "", "#define NAMESIZE 256", "", "#define CUR cur_term->type.", "", "#define auto_left_margin               CUR Booleans[0]", "#define auto_right_margin              CUR Booleans[1]", "#define no_esc_ctlc                    CUR Booleans[2]", "#define ceol_standout_glitch           CUR Booleans[3]", "#define eat_newline_glitch             CUR Booleans[4]", "#define erase_overstrike               CUR Booleans[5]", "#define generic_type                   CUR Booleans[6]", "#define hard_copy                      CUR Booleans[7]", "#define has_meta_key                   CUR Booleans[8]", "#define has_status_line                CUR Booleans[9]", "#define insert_null_glitch             CUR Booleans[10]", "#define memory_above                   CUR Booleans[11]", "#define memory_below                   CUR Booleans[12]", "#define move_insert_mode               CUR Booleans[13]", "#define move_standout_mode             CUR Booleans[14]", "#define over_strike                    CUR Booleans[15]", "#define status_line_esc_ok             CUR Booleans[16]", "#define dest_tabs_magic_smso           CUR Booleans[17]", "#define tilde_glitch                   CUR Booleans[18]", "#define transparent_underline          CUR Booleans[19]", "#define xon_xoff                       CUR Booleans[20]", "#define needs_xon_xoff                 CUR Booleans[21]", "#define prtr_silent                    CUR Booleans[22]", "#define hard_cursor                    CUR Booleans[23]", "#define non_rev_rmcup                  CUR Booleans[24]", "#define no_pad_char                    CUR Booleans[25]", "#define non_dest_scroll_region         CUR Booleans[26]", "#define can_change                     CUR Booleans[27]", "#define back_color_erase               CUR Booleans[28]", "#define hue_lightness_saturation       CUR Booleans[29]", "#define col_addr_glitch                CUR Booleans[30]", "#define cr_cancels_micro_mode          CUR Booleans[31]", "#define has_print_wheel                CUR Booleans[32]", "#define row_addr_glitch                CUR Booleans[33]", "#define semi_auto_right_margin         CUR Booleans[34]", "#define cpi_changes_res                CUR Booleans[35]", "#define lpi_changes_res                CUR Booleans[36]", "#define columns                        CUR Numbers[0]", "#define init_tabs                      CUR Numbers[1]", "#define lines                          CUR Numbers[2]", "#define lines_of_memory                CUR Numbers[3]", "#define magic_cookie_glitch            CUR Numbers[4]", "#define padding_baud_rate              CUR Numbers[5]", "#define virtual_terminal               CUR Numbers[6]", "#define width_status_line              CUR Numbers[7]", "#define num_labels                     CUR Numbers[8]", "#define label_height                   CUR Numbers[9]", "#define label_width                    CUR Numbers[10]", "#define max_attributes                 CUR Numbers[11]", "#define maximum_windows                CUR Numbers[12]", "#define max_colors                     CUR Numbers[13]", "#define max_pairs                      CUR Numbers[14]", "#define no_color_video                 CUR Numbers[15]", "#define buffer_capacity                CUR Numbers[16]", "#define dot_vert_spacing               CUR Numbers[17]", "#define dot_horz_spacing               CUR Numbers[18]", "#define max_micro_address              CUR Numbers[19]", "#define max_micro_jump                 CUR Numbers[20]", "#define micro_col_size                 CUR Numbers[21]", "#define micro_line_size                CUR Numbers[22]", "#define number_of_pins                 CUR Numbers[23]", "#define output_res_char                CUR Numbers[24]", "#define output_res_line                CUR Numbers[25]", "#define output_res_horz_inch           CUR Numbers[26]", "#define output_res_vert_inch           CUR Numbers[27]", "#define print_rate                     CUR Numbers[28]", "#define wide_char_size                 CUR Numbers[29]", "#define buttons                        CUR Numbers[30]", "#define bit_image_entwining            CUR Numbers[31]", "#define bit_image_type                 CUR Numbers[32]", "#define back_tab                       CUR Strings[0]", "#define bell                           CUR Strings[1]", "#define carriage_return                CUR Strings[2]", "#define change_scroll_region           CUR Strings[3]", "#define clear_all_tabs                 CUR Strings[4]", "#define clear_screen                   CUR Strings[5]", "#define clr_eol                        CUR Strings[6]", "#define clr_eos                        CUR Strings[7]", "#define column_address                 CUR Strings[8]", "#define command_character              CUR Strings[9]", "#define cursor_address                 CUR Strings[10]", "#define cursor_down                    CUR Strings[11]", "#define cursor_home                    CUR Strings[12]", "#define cursor_invisible               CUR Strings[13]", "#define cursor_left                    CUR Strings[14]", "#define cursor_mem_address             CUR Strings[15]", "#define cursor_normal                  CUR Strings[16]", "#define cursor_right                   CUR Strings[17]", "#define cursor_to_ll                   CUR Strings[18]", "#define cursor_up                      CUR Strings[19]", "#define cursor_visible                 CUR Strings[20]", "#define delete_character               CUR Strings[21]", "#define delete_line                    CUR Strings[22]", "#define dis_status_line                CUR Strings[23]", "#define down_half_line                 CUR Strings[24]", "#define enter_alt_charset_mode         CUR Strings[25]", "#define enter_blink_mode               CUR Strings[26]", "#define enter_bold_mode                CUR Strings[27]", "#define enter_ca_mode                  CUR Strings[28]", "#define enter_delete_mode              CUR Strings[29]", "#define enter_dim_mode                 CUR Strings[30]", "#define enter_insert_mode              CUR Strings[31]", "#define enter_secure_mode              CUR Strings[32]", "#define enter_protected_mode           CUR Strings[33]", "#define enter_reverse_mode             CUR Strings[34]", "#define enter_standout_mode            CUR Strings[35]", "#define enter_underline_mode           CUR Strings[36]", "#define erase_chars                    CUR Strings[37]", "#define exit_alt_charset_mode          CUR Strings[38]", "#define exit_attribute_mode            CUR Strings[39]", "#define exit_ca_mode                   CUR Strings[40]", "#define exit_delete_mode               CUR Strings[41]", "#define exit_insert_mode               CUR Strings[42]", "#define exit_standout_mode             CUR Strings[43]", "#define exit_underline_mode            CUR Strings[44]", "#define flash_screen                   CUR Strings[45]", "#define form_feed                      CUR Strings[46]", "#define from_status_line               CUR Strings[47]", "#define init_1string                   CUR Strings[48]", "#define init_2string                   CUR Strings[49]", "#define init_3string                   CUR Strings[50]", "#define init_file                      CUR Strings[51]", "#define insert_character               CUR Strings[52]", "#define insert_line                    CUR Strings[53]", "#define insert_padding                 CUR Strings[54]", "#define key_backspace                  CUR Strings[55]", "#define key_catab                      CUR Strings[56]", "#define key_clear                      CUR Strings[57]", "#define key_ctab                       CUR Strings[58]", "#define key_dc                         CUR Strings[59]", "#define key_dl                         CUR Strings[60]", "#define key_down                       CUR Strings[61]", "#define key_eic                        CUR Strings[62]", "#define key_eol                        CUR Strings[63]", "#define key_eos                        CUR Strings[64]", "#define key_f0                         CUR Strings[65]", "#define key_f1                         CUR Strings[66]", "#define key_f10                        CUR Strings[67]", "#define key_f2                         CUR Strings[68]", "#define key_f3                         CUR Strings[69]", "#define key_f4                         CUR Strings[70]", "#define key_f5                         CUR Strings[71]", "#define key_f6                         CUR Strings[72]", "#define key_f7                         CUR Strings[73]", "#define key_f8                         CUR Strings[74]", "#define key_f9                         CUR Strings[75]", "#define key_home                       CUR Strings[76]", "#define key_ic                         CUR Strings[77]", "#define key_il                         CUR Strings[78]", "#define key_left                       CUR Strings[79]", "#define key_ll                         CUR Strings[80]", "#define key_npage                      CUR Strings[81]", "#define key_ppage                      CUR Strings[82]", "#define key_right                      CUR Strings[83]", "#define key_sf                         CUR Strings[84]", "#define key_sr                         CUR Strings[85]", "#define key_stab                       CUR Strings[86]", "#define key_up                         CUR Strings[87]", "#define keypad_local                   CUR Strings[88]", "#define keypad_xmit                    CUR Strings[89]", "#define lab_f0                         CUR Strings[90]", "#define lab_f1                         CUR Strings[91]", "#define lab_f10                        CUR Strings[92]", "#define lab_f2                         CUR Strings[93]", "#define lab_f3                         CUR Strings[94]", "#define lab_f4                         CUR Strings[95]", "#define lab_f5                         CUR Strings[96]", "#define lab_f6                         CUR Strings[97]", "#define lab_f7                         CUR Strings[98]", "#define lab_f8                         CUR Strings[99]", "#define lab_f9                         CUR Strings[100]", "#define meta_off                       CUR Strings[101]", "#define meta_on                        CUR Strings[102]", "#define newline                        CUR Strings[103]", "#define pad_char                       CUR Strings[104]", "#define parm_dch                       CUR Strings[105]", "#define parm_delete_line               CUR Strings[106]", "#define parm_down_cursor               CUR Strings[107]", "#define parm_ich                       CUR Strings[108]", "#define parm_index                     CUR Strings[109]", "#define parm_insert_line               CUR Strings[110]", "#define parm_left_cursor               CUR Strings[111]", "#define parm_right_cursor              CUR Strings[112]", "#define parm_rindex                    CUR Strings[113]", "#define parm_up_cursor                 CUR Strings[114]", "#define pkey_key                       CUR Strings[115]", "#define pkey_local                     CUR Strings[116]", "#define pkey_xmit                      CUR Strings[117]", "#define print_screen                   CUR Strings[118]", "#define prtr_off                       CUR Strings[119]", "#define prtr_on                        CUR Strings[120]", "#define repeat_char                    CUR Strings[121]", "#define reset_1string                  CUR Strings[122]", "#define reset_2string                  CUR Strings[123]", "#define reset_3string                  CUR Strings[124]", "#define reset_file                     CUR Strings[125]", "#define restore_cursor                 CUR Strings[126]", "#define row_address                    CUR Strings[127]", "#define save_cursor                    CUR Strings[128]", "#define scroll_forward                 CUR Strings[129]", "#define scroll_reverse                 CUR Strings[130]", "#define set_attributes                 CUR Strings[131]", "#define set_tab                        CUR Strings[132]", "#define set_window                     CUR Strings[133]", "#define tab                            CUR Strings[134]", "#define to_status_line                 CUR Strings[135]", "#define underline_char                 CUR Strings[136]", "#define up_half_line                   CUR Strings[137]", "#define init_prog                      CUR Strings[138]", "#define key_a1                         CUR Strings[139]", "#define key_a3                         CUR Strings[140]", "#define key_b2                         CUR Strings[141]", "#define key_c1                         CUR Strings[142]", "#define key_c3                         CUR Strings[143]", "#define prtr_non                       CUR Strings[144]", "#define char_padding                   CUR Strings[145]", "#define acs_chars                      CUR Strings[146]", "#define plab_norm                      CUR Strings[147]", "#define key_btab                       CUR Strings[148]", "#define enter_xon_mode                 CUR Strings[149]", "#define exit_xon_mode                  CUR Strings[150]", "#define enter_am_mode                  CUR Strings[151]", "#define exit_am_mode                   CUR Strings[152]", "#define xon_character                  CUR Strings[153]", "#define xoff_character                 CUR Strings[154]", "#define ena_acs                        CUR Strings[155]", "#define label_on                       CUR Strings[156]", "#define label_off                      CUR Strings[157]", "#define key_beg                        CUR Strings[158]", "#define key_cancel                     CUR Strings[159]", "#define key_close                      CUR Strings[160]", "#define key_command                    CUR Strings[161]", "#define key_copy                       CUR Strings[162]", "#define key_create                     CUR Strings[163]", "#define key_end                        CUR Strings[164]", "#define key_enter                      CUR Strings[165]", "#define key_exit                       CUR Strings[166]", "#define key_find                       CUR Strings[167]", "#define key_help                       CUR Strings[168]", "#define key_mark                       CUR Strings[169]", "#define key_message                    CUR Strings[170]", "#define key_move                       CUR Strings[171]", "#define key_next                       CUR Strings[172]", "#define key_open                       CUR Strings[173]", "#define key_options                    CUR Strings[174]", "#define key_previous                   CUR Strings[175]", "#define key_print                      CUR Strings[176]", "#define key_redo                       CUR Strings[177]", "#define key_reference                  CUR Strings[178]", "#define key_refresh                    CUR Strings[179]", "#define key_replace                    CUR Strings[180]", "#define key_restart                    CUR Strings[181]", "#define key_resume                     CUR Strings[182]", "#define key_save                       CUR Strings[183]", "#define key_suspend                    CUR Strings[184]", "#define key_undo                       CUR Strings[185]", "#define key_sbeg                       CUR Strings[186]", "#define key_scancel                    CUR Strings[187]", "#define key_scommand                   CUR Strings[188]", "#define key_scopy                      CUR Strings[189]", "#define key_screate                    CUR Strings[190]", "#define key_sdc                        CUR Strings[191]", "#define key_sdl                        CUR Strings[192]", "#define key_select                     CUR Strings[193]", "#define key_send                       CUR Strings[194]", "#define key_seol                       CUR Strings[195]", "#define key_sexit                      CUR Strings[196]", "#define key_sfind                      CUR Strings[197]", "#define key_shelp                      CUR Strings[198]", "#define key_shome                      CUR Strings[199]", "#define key_sic                        CUR Strings[200]", "#define key_sleft                      CUR Strings[201]", "#define key_smessage                   CUR Strings[202]", "#define key_smove                      CUR Strings[203]", "#define key_snext                      CUR Strings[204]", "#define key_soptions                   CUR Strings[205]", "#define key_sprevious                  CUR Strings[206]", "#define key_sprint                     CUR Strings[207]", "#define key_sredo                      CUR Strings[208]", "#define key_sreplace                   CUR Strings[209]", "#define key_sright                     CUR Strings[210]", "#define key_srsume                     CUR Strings[211]", "#define key_ssave                      CUR Strings[212]", "#define key_ssuspend                   CUR Strings[213]", "#define key_sundo                      CUR Strings[214]", "#define req_for_input                  CUR Strings[215]", "#define key_f11                        CUR Strings[216]", "#define key_f12                        CUR Strings[217]", "#define key_f13                        CUR Strings[218]", "#define key_f14                        CUR Strings[219]", "#define key_f15                        CUR Strings[220]", "#define key_f16                        CUR Strings[221]", "#define key_f17                        CUR Strings[222]", "#define key_f18                        CUR Strings[223]", "#define key_f19                        CUR Strings[224]", "#define key_f20                        CUR Strings[225]", "#define key_f21                        CUR Strings[226]", "#define key_f22                        CUR Strings[227]", "#define key_f23                        CUR Strings[228]", "#define key_f24                        CUR Strings[229]", "#define key_f25                        CUR Strings[230]", "#define key_f26                        CUR Strings[231]", "#define key_f27                        CUR Strings[232]", "#define key_f28                        CUR Strings[233]", "#define key_f29                        CUR Strings[234]", "#define key_f30                        CUR Strings[235]", "#define key_f31                        CUR Strings[236]", "#define key_f32                        CUR Strings[237]", "#define key_f33                        CUR Strings[238]", "#define key_f34                        CUR Strings[239]", "#define key_f35                        CUR Strings[240]", "#define key_f36                        CUR Strings[241]", "#define key_f37                        CUR Strings[242]", "#define key_f38                        CUR Strings[243]", "#define key_f39                        CUR Strings[244]", "#define key_f40                        CUR Strings[245]", "#define key_f41                        CUR Strings[246]", "#define key_f42                        CUR Strings[247]", "#define key_f43                        CUR Strings[248]", "#define key_f44                        CUR Strings[249]", "#define key_f45                        CUR Strings[250]", "#define key_f46                        CUR Strings[251]", "#define key_f47                        CUR Strings[252]", "#define key_f48                        CUR Strings[253]", "#define key_f49                        CUR Strings[254]", "#define key_f50                        CUR Strings[255]", "#define key_f51                        CUR Strings[256]", "#define key_f52                        CUR Strings[257]", "#define key_f53                        CUR Strings[258]", "#define key_f54                        CUR Strings[259]", "#define key_f55                        CUR Strings[260]", "#define key_f56                        CUR Strings[261]", "#define key_f57                        CUR Strings[262]", "#define key_f58                        CUR Strings[263]", "#define key_f59                        CUR Strings[264]", "#define key_f60                        CUR Strings[265]", "#define key_f61                        CUR Strings[266]", "#define key_f62                        CUR Strings[267]", "#define key_f63                        CUR Strings[268]", "#define clr_bol                        CUR Strings[269]", "#define clear_margins                  CUR Strings[270]", "#define set_left_margin                CUR Strings[271]", "#define set_right_margin               CUR Strings[272]", "#define label_format                   CUR Strings[273]", "#define set_clock                      CUR Strings[274]", "#define display_clock                  CUR Strings[275]", "#define remove_clock                   CUR Strings[276]", "#define create_window                  CUR Strings[277]", "#define goto_window                    CUR Strings[278]", "#define hangup                         CUR Strings[279]", "#define dial_phone                     CUR Strings[280]", "#define quick_dial                     CUR Strings[281]", "#define tone                           CUR Strings[282]", "#define pulse                          CUR Strings[283]", "#define flash_hook                     CUR Strings[284]", "#define fixed_pause                    CUR Strings[285]", "#define wait_tone                      CUR Strings[286]", "#define user0                          CUR Strings[287]", "#define user1                          CUR Strings[288]", "#define user2                          CUR Strings[289]", "#define user3                          CUR Strings[290]", "#define user4                          CUR Strings[291]", "#define user5                          CUR Strings[292]", "#define user6                          CUR Strings[293]", "#define user7                          CUR Strings[294]", "#define user8                          CUR Strings[295]", "#define user9                          CUR Strings[296]", "#define orig_pair                      CUR Strings[297]", "#define orig_colors                    CUR Strings[298]", "#define initialize_color               CUR Strings[299]", "#define initialize_pair                CUR Strings[300]", "#define set_color_pair                 CUR Strings[301]", "#define set_foreground                 CUR Strings[302]", "#define set_background                 CUR Strings[303]", "#define change_char_pitch              CUR Strings[304]", "#define change_line_pitch              CUR Strings[305]", "#define change_res_horz                CUR Strings[306]", "#define change_res_vert                CUR Strings[307]", "#define define_char                    CUR Strings[308]", "#define enter_doublewide_mode          CUR Strings[309]", "#define enter_draft_quality            CUR Strings[310]", "#define enter_italics_mode             CUR Strings[311]", "#define enter_leftward_mode            CUR Strings[312]", "#define enter_micro_mode               CUR Strings[313]", "#define enter_near_letter_quality      CUR Strings[314]", "#define enter_normal_quality           CUR Strings[315]", "#define enter_shadow_mode              CUR Strings[316]", "#define enter_subscript_mode           CUR Strings[317]", "#define enter_superscript_mode         CUR Strings[318]", "#define enter_upward_mode              CUR Strings[319]", "#define exit_doublewide_mode           CUR Strings[320]", "#define exit_italics_mode              CUR Strings[321]", "#define exit_leftward_mode             CUR Strings[322]", "#define exit_micro_mode                CUR Strings[323]", "#define exit_shadow_mode               CUR Strings[324]", "#define exit_subscript_mode            CUR Strings[325]", "#define exit_superscript_mode          CUR Strings[326]", "#define exit_upward_mode               CUR Strings[327]", "#define micro_column_address           CUR Strings[328]", "#define micro_down                     CUR Strings[329]", "#define micro_left                     CUR Strings[330]", "#define micro_right                    CUR Strings[331]", "#define micro_row_address              CUR Strings[332]", "#define micro_up                       CUR Strings[333]", "#define order_of_pins                  CUR Strings[334]", "#define parm_down_micro                CUR Strings[335]", "#define parm_left_micro                CUR Strings[336]", "#define parm_right_micro               CUR Strings[337]", "#define parm_up_micro                  CUR Strings[338]", "#define select_char_set                CUR Strings[339]", "#define set_bottom_margin              CUR Strings[340]", "#define set_bottom_margin_parm         CUR Strings[341]", "#define set_left_margin_parm           CUR Strings[342]", "#define set_right_margin_parm          CUR Strings[343]", "#define set_top_margin                 CUR Strings[344]", "#define set_top_margin_parm            CUR Strings[345]", "#define start_bit_image                CUR Strings[346]", "#define start_char_set_def             CUR Strings[347]", "#define stop_bit_image                 CUR Strings[348]", "#define stop_char_set_def              CUR Strings[349]", "#define subscript_characters           CUR Strings[350]", "#define superscript_characters         CUR Strings[351]", "#define these_cause_cr                 CUR Strings[352]", "#define zero_motion                    CUR Strings[353]", "#define char_set_names                 CUR Strings[354]", "#define key_mouse                      CUR Strings[355]", "#define mouse_info                     CUR Strings[356]", "#define req_mouse_pos                  CUR Strings[357]", "#define get_mouse                      CUR Strings[358]", "#define set_a_foreground               CUR Strings[359]", "#define set_a_background               CUR Strings[360]", "#define pkey_plab                      CUR Strings[361]", "#define device_type                    CUR Strings[362]", "#define code_set_init                  CUR Strings[363]", "#define set0_des_seq                   CUR Strings[364]", "#define set1_des_seq                   CUR Strings[365]", "#define set2_des_seq                   CUR Strings[366]", "#define set3_des_seq                   CUR Strings[367]", "#define set_lr_margin                  CUR Strings[368]", "#define set_tb_margin                  CUR Strings[369]", "#define bit_image_repeat               CUR Strings[370]", "#define bit_image_newline              CUR Strings[371]", "#define bit_image_carriage_return      CUR Strings[372]", "#define color_names                    CUR Strings[373]", "#define define_bit_image_region        CUR Strings[374]", "#define end_bit_image_region           CUR Strings[375]", "#define set_color_band                 CUR Strings[376]", "#define set_page_length                CUR Strings[377]", "#define display_pc_char                CUR Strings[378]", "#define enter_pc_charset_mode          CUR Strings[379]", "#define exit_pc_charset_mode           CUR Strings[380]", "#define enter_scancode_mode            CUR Strings[381]", "#define exit_scancode_mode             CUR Strings[382]", "#define pc_term_options                CUR Strings[383]", "#define scancode_escape                CUR Strings[384]", "#define alt_scancode_esc               CUR Strings[385]", "#define enter_horizontal_hl_mode       CUR Strings[386]", "#define enter_left_hl_mode             CUR Strings[387]", "#define enter_low_hl_mode              CUR Strings[388]", "#define enter_right_hl_mode            CUR Strings[389]", "#define enter_top_hl_mode              CUR Strings[390]", "#define enter_vertical_hl_mode         CUR Strings[391]", "#define set_a_attributes               CUR Strings[392]", "#define set_pglen_inch                 CUR Strings[393]", "", "#define BOOLWRITE 37", "#define NUMWRITE  33", "#define STRWRITE  394", "", "/* older synonyms for some capabilities */", "#define beehive_glitch\tno_esc_ctlc", "#define teleray_glitch\tdest_tabs_magic_smso", "#define micro_char_size micro_col_size", "", "#ifdef __INTERNAL_CAPS_VISIBLE", "#define termcap_init2                  CUR Strings[394]", "#define termcap_reset                  CUR Strings[395]", "#define magic_cookie_glitch_ul         CUR Numbers[33]", "#define backspaces_with_bs             CUR Booleans[37]", "#define crt_no_scrolling               CUR Booleans[38]", "#define no_correctly_working_cr        CUR Booleans[39]", "#define carriage_return_delay          CUR Numbers[34]", "#define new_line_delay                 CUR Numbers[35]", "#define linefeed_if_not_lf             CUR Strings[396]", "#define backspace_if_not_bs            CUR Strings[397]", "#define gnu_has_meta_key               CUR Booleans[40]", "#define linefeed_is_newline            CUR Booleans[41]", "#define backspace_delay                CUR Numbers[36]", "#define horizontal_tab_delay           CUR Numbers[37]", "#define number_of_function_keys        CUR Numbers[38]", "#define other_non_function_keys        CUR Strings[398]", "#define arrow_key_map                  CUR Strings[399]", "#define has_hardware_tabs              CUR Booleans[42]", "#define return_does_clr_eol            CUR Booleans[43]", "#define acs_ulcorner                   CUR Strings[400]", "#define acs_llcorner                   CUR Strings[401]", "#define acs_urcorner                   CUR Strings[402]", "#define acs_lrcorner                   CUR Strings[403]", "#define acs_ltee                       CUR Strings[404]", "#define acs_rtee                       CUR Strings[405]", "#define acs_btee                       CUR Strings[406]", "#define acs_ttee                       CUR Strings[407]", "#define acs_hline                      CUR Strings[408]", "#define acs_vline                      CUR Strings[409]", "#define acs_plus                       CUR Strings[410]", "#define memory_lock                    CUR Strings[411]", "#define memory_unlock                  CUR Strings[412]", "#define box_chars_1                    CUR Strings[413]", "#endif /* __INTERNAL_CAPS_VISIBLE */", "", "", "/*", " * Predefined terminfo array sizes", " */", "#define BOOLCOUNT 44", "#define NUMCOUNT  39", "#define STRCOUNT  414", "", "/* used by code for comparing entries */", "#define acs_chars_index\t 146", "", "typedef struct termtype {\t/* in-core form of terminfo data */", "    char  *term_names;\t\t/* str_table offset of term names */", "    char  *str_table;\t\t/* pointer to string table */", "    NCURSES_SBOOL  *Booleans;\t/* array of boolean values */", "    short *Numbers;\t\t/* array of integer values */", "    char  **Strings;\t\t/* array of string offsets */", "", "#if NCURSES_XNAMES", "    char  *ext_str_table;\t/* pointer to extended string table */", "    char  **ext_Names;\t\t/* corresponding names */", "", "    unsigned short num_Booleans;/* count total Booleans */", "    unsigned short num_Numbers;\t/* count total Numbers */", "    unsigned short num_Strings;\t/* count total Strings */", "", "    unsigned short ext_Booleans;/* count extensions to Booleans */", "    unsigned short ext_Numbers;\t/* count extensions to Numbers */", "    unsigned short ext_Strings;\t/* count extensions to Strings */", "#endif /* NCURSES_XNAMES */", "", "} TERMTYPE;", "", "typedef struct term {\t\t/* describe an actual terminal */", "    TERMTYPE\ttype;\t\t/* terminal type description */", "    short\tFiledes;\t/* file description being written to */", "    TTY\t\tOttyb,\t\t/* original state of the terminal */", "\t\tNttyb;\t\t/* current state of the terminal */", "    int\t\t_baudrate;\t/* used to compute padding */", "    char *      _termname;      /* used for termname() */", "} TERMINAL;", "", "#if 0 || 0", "NCURSES_WRAPPED_VAR(TERMINAL *, cur_term);", "NCURSES_WRAPPED_VAR(NCURSES_CONST char * const *, boolnames);", "NCURSES_WRAPPED_VAR(NCURSES_CONST char * const *, boolcodes);", "NCURSES_WRAPPED_VAR(NCURSES_CONST char * const *, boolfnames);", "NCURSES_WRAPPED_VAR(NCURSES_CONST char * const *, numnames);", "NCURSES_WRAPPED_VAR(NCURSES_CONST char * const *, numcodes);", "NCURSES_WRAPPED_VAR(NCURSES_CONST char * const *, numfnames);", "NCURSES_WRAPPED_VAR(NCURSES_CONST char * const *, strnames);", "NCURSES_WRAPPED_VAR(NCURSES_CONST char * const *, strcodes);", "NCURSES_WRAPPED_VAR(NCURSES_CONST char * const *, strfnames);", "", "#define cur_term   NCURSES_PUBLIC_VAR(cur_term())", "#define boolnames  NCURSES_PUBLIC_VAR(boolnames())", "#define boolcodes  NCURSES_PUBLIC_VAR(boolcodes())", "#define boolfnames NCURSES_PUBLIC_VAR(boolfnames())", "#define numnames   NCURSES_PUBLIC_VAR(numnames())", "#define numcodes   NCURSES_PUBLIC_VAR(numcodes())", "#define numfnames  NCURSES_PUBLIC_VAR(numfnames())", "#define strnames   NCURSES_PUBLIC_VAR(strnames())", "#define strcodes   NCURSES_PUBLIC_VAR(strcodes())", "#define strfnames  NCURSES_PUBLIC_VAR(strfnames())", "", "#else", "", "extern NCURSES_EXPORT_VAR(TERMINAL *) cur_term;", "", "extern NCURSES_EXPORT_VAR(NCURSES_CONST char * const ) boolnames[];", "extern NCURSES_EXPORT_VAR(NCURSES_CONST char * const ) boolcodes[];", "extern NCURSES_EXPORT_VAR(NCURSES_CONST char * const ) boolfnames[];", "extern NCURSES_EXPORT_VAR(NCURSES_CONST char * const ) numnames[];", "extern NCURSES_EXPORT_VAR(NCURSES_CONST char * const ) numcodes[];", "extern NCURSES_EXPORT_VAR(NCURSES_CONST char * const ) numfnames[];", "extern NCURSES_EXPORT_VAR(NCURSES_CONST char * const ) strnames[];", "extern NCURSES_EXPORT_VAR(NCURSES_CONST char * const ) strcodes[];", "extern NCURSES_EXPORT_VAR(NCURSES_CONST char * const ) strfnames[];", "", "#endif", "", "/* internals */", "extern NCURSES_EXPORT(int) _nc_set_tty_mode (TTY *buf);", "extern NCURSES_EXPORT(int) _nc_get_tty_mode (TTY *buf);", "extern NCURSES_EXPORT(int) _nc_read_entry (const char * const, char * const, TERMTYPE *const);", "extern NCURSES_EXPORT(int) _nc_read_file_entry (const char *const, TERMTYPE *);", "extern NCURSES_EXPORT(int) _nc_read_termtype (TERMTYPE *, char *, int);", "extern NCURSES_EXPORT(char *) _nc_first_name (const char *const);", "extern NCURSES_EXPORT(int) _nc_name_match (const char *const, const char *const, const char *const);", "extern NCURSES_EXPORT(const TERMTYPE *) _nc_fallback (const char *);", "", "/* entry points */", "extern NCURSES_EXPORT(TERMINAL *) set_curterm (TERMINAL *);", "extern NCURSES_EXPORT(int) del_curterm (TERMINAL *);", "", "/* miscellaneous entry points */", "extern NCURSES_EXPORT(int) restartterm (NCURSES_CONST char *, int, int *);", "extern NCURSES_EXPORT(int) setupterm (NCURSES_CONST char *,int,int *);", "", "/* terminfo entry points, also declared in curses.h */", "#if !defined(__NCURSES_H)", "extern NCURSES_EXPORT(char *) tigetstr (NCURSES_CONST char *);", "extern NCURSES_EXPORT_VAR(char) ttytype[];", "extern NCURSES_EXPORT(int) putp (const char *);", "extern NCURSES_EXPORT(int) tigetflag (NCURSES_CONST char *);", "extern NCURSES_EXPORT(int) tigetnum (NCURSES_CONST char *);", "", "#if 1 /* NCURSES_TPARM_VARARGS */", "extern NCURSES_EXPORT(char *) tparm (NCURSES_CONST char *, ...);\t/* special */", "#else", "extern NCURSES_EXPORT(char *) tparm (NCURSES_CONST char *, long,long,long,long,long,long,long,long,long);\t/* special */", "extern NCURSES_EXPORT(char *) tparm_varargs (NCURSES_CONST char *, ...);\t/* special */", "#endif", "", "#endif /* __NCURSES_H */", "", "/* termcap database emulation (XPG4 uses const only for 2nd param of tgetent) */", "#if !defined(NCURSES_TERMCAP_H_incl)", "extern NCURSES_EXPORT(char *) tgetstr (NCURSES_CONST char *, char **);", "extern NCURSES_EXPORT(char *) tgoto (const char *, int, int);", "extern NCURSES_EXPORT(int) tgetent (char *, const char *);", "extern NCURSES_EXPORT(int) tgetflag (NCURSES_CONST char *);", "extern NCURSES_EXPORT(int) tgetnum (NCURSES_CONST char *);", "extern NCURSES_EXPORT(int) tputs (const char *, int, int (*)(int));", "#endif /* NCURSES_TERMCAP_H_incl */", "", "#ifdef __cplusplus", "}", "#endif", "", "#endif /* NCURSES_TERM_H_incl */" },
    ["term_entry.h"] = { "/****************************************************************************", " * Copyright (c) 1998-2005,2008 Free Software Foundation, Inc.              *", " *                                                                          *", " * Permission is hereby granted, free of charge, to any person obtaining a  *", " * copy of this software and associated documentation files (the            *", ' * "Software"), to deal in the Software without restriction, including      *', " * without limitation the rights to use, copy, modify, merge, publish,      *", " * distribute, distribute with modifications, sublicense, and/or sell       *", " * copies of the Software, and to permit persons to whom the Software is    *", " * furnished to do so, subject to the following conditions:                 *", " *                                                                          *", " * The above copyright notice and this permission notice shall be included  *", " * in all copies or substantial portions of the Software.                   *", " *                                                                          *", ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *', " * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *", " * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *", " * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *", " * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *", " * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *", " * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *", " *                                                                          *", " * Except as contained in this notice, the name(s) of the above copyright   *", " * holders shall not be used in advertising or otherwise to promote the     *", " * sale, use or other dealings in this Software without prior written       *", " * authorization.                                                           *", " ****************************************************************************/", "", "/****************************************************************************", " *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *", " *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *", " *     and: Thomas E. Dickey                        1998-on                 *", " ****************************************************************************/", "", "/* $Id: term_entry.h,v 1.35 2008/08/16 16:16:03 tom Exp $ */", "", "/*", " *\tterm_entry.h -- interface to entry-manipulation code", " */", "", "#ifndef NCURSES_TERM_ENTRY_H_incl", "#define NCURSES_TERM_ENTRY_H_incl 1", "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "", "#include <term.h>", "", "#define MAX_USES\t32", "#define MAX_CROSSLINKS\t16", "", "typedef struct entry {", "\tTERMTYPE\ttterm;", "\tunsigned\tnuses;", "\tstruct", "        {", "\t    char\t\t*name;", "\t    struct entry\t*link;", "\t    long\t\tline;", "        }", "\tuses[MAX_USES];", "\tint\t\tncrosslinks;", "\tstruct entry\t*crosslinks[MAX_CROSSLINKS];", "\tlong\t\tcstart, cend;", "\tlong\t\tstartline;", "\tstruct entry\t*next;", "\tstruct entry\t*last;", "}", "ENTRY;", "", "#if NCURSES_XNAMES", "#define NUM_BOOLEANS(tp) (tp)->num_Booleans", "#define NUM_NUMBERS(tp)  (tp)->num_Numbers", "#define NUM_STRINGS(tp)  (tp)->num_Strings", "#define EXT_NAMES(tp,i,limit,index,table) (i >= limit) ? tp->ext_Names[index] : table[i]", "#else", "#define NUM_BOOLEANS(tp) BOOLCOUNT", "#define NUM_NUMBERS(tp)  NUMCOUNT", "#define NUM_STRINGS(tp)  STRCOUNT", "#define EXT_NAMES(tp,i,limit,index,table) table[i]", "#endif", "", "#define NUM_EXT_NAMES(tp) ((tp)->ext_Booleans + (tp)->ext_Numbers + (tp)->ext_Strings)", "", "#define for_each_boolean(n,tp) for(n = 0; n < NUM_BOOLEANS(tp); n++)", "#define for_each_number(n,tp)  for(n = 0; n < NUM_NUMBERS(tp);  n++)", "#define for_each_string(n,tp)  for(n = 0; n < NUM_STRINGS(tp);  n++)", "", "#define ExtBoolname(tp,i,names) EXT_NAMES(tp, i, BOOLCOUNT, (i - (tp->num_Booleans - tp->ext_Booleans)), names)", "#define ExtNumname(tp,i,names)  EXT_NAMES(tp, i, NUMCOUNT, (i - (tp->num_Numbers - tp->ext_Numbers)) + tp->ext_Booleans, names)", "#define ExtStrname(tp,i,names)  EXT_NAMES(tp, i, STRCOUNT, (i - (tp->num_Strings - tp->ext_Strings)) + (tp->ext_Numbers + tp->ext_Booleans), names)", "", "extern NCURSES_EXPORT_VAR(ENTRY *) _nc_head;", "extern NCURSES_EXPORT_VAR(ENTRY *) _nc_tail;", "#define for_entry_list(qp)\tfor (qp = _nc_head; qp; qp = qp->next)", "", "#define MAX_LINE\t132", "", "#define NULLHOOK        (bool(*)(ENTRY *))0", "", "/*", " * Note that WANTED and PRESENT are not simple inverses!  If a capability", " * has been explicitly cancelled, it's not considered WANTED.", " */", "#define WANTED(s)\t((s) == ABSENT_STRING)", "#define PRESENT(s)\t(((s) != ABSENT_STRING) && ((s) != CANCELLED_STRING))", "", "#define ANDMISSING(p,q) \\", '\t\t{if (PRESENT(p) && !PRESENT(q)) _nc_warning(#p " but no " #q);}', "", "#define PAIRED(p,q) \\", "\t\t{ \\", "\t\tif (PRESENT(q) && !PRESENT(p)) \\", '\t\t\t_nc_warning(#q " but no " #p); \\', "\t\tif (PRESENT(p) && !PRESENT(q)) \\", '\t\t\t_nc_warning(#p " but no " #q); \\', "\t\t}", "", "/* alloc_entry.c: elementary allocation code */", "extern NCURSES_EXPORT(ENTRY *) _nc_copy_entry (ENTRY *oldp);", "extern NCURSES_EXPORT(char *) _nc_save_str (const char *const);", "extern NCURSES_EXPORT(void) _nc_init_entry (TERMTYPE *const);", "extern NCURSES_EXPORT(void) _nc_merge_entry (TERMTYPE *const, TERMTYPE *const);", "extern NCURSES_EXPORT(void) _nc_wrap_entry (ENTRY *const, bool);", "", "/* alloc_ttype.c: elementary allocation code */", "extern NCURSES_EXPORT(void) _nc_align_termtype (TERMTYPE *, TERMTYPE *);", "extern NCURSES_EXPORT(void) _nc_copy_termtype (TERMTYPE *, TERMTYPE *);", "", "/* free_ttype.c: elementary allocation code */", "extern NCURSES_EXPORT(void) _nc_free_termtype (TERMTYPE *);", "", "/* lib_acs.c */", "extern NCURSES_EXPORT(void) _nc_init_acs (void);\t/* corresponds to traditional 'init_acs()' */", "", "/* lib_termcap.c: trim sgr0 string for termcap users */", "extern NCURSES_EXPORT(char *) _nc_trim_sgr0 (TERMTYPE *);", "", "/* parse_entry.c: entry-parsing code */", "#if NCURSES_XNAMES", "extern NCURSES_EXPORT_VAR(bool) _nc_user_definable;", "extern NCURSES_EXPORT_VAR(bool) _nc_disable_period;", "#endif", "extern NCURSES_EXPORT(int) _nc_parse_entry (ENTRY *, int, bool);", "extern NCURSES_EXPORT(int) _nc_capcmp (const char *, const char *);", "", "/* write_entry.c: writing an entry to the file system */", "extern NCURSES_EXPORT(void) _nc_set_writedir (char *);", "extern NCURSES_EXPORT(void) _nc_write_entry (TERMTYPE *const);", "", "/* comp_parse.c: entry list handling */", "extern NCURSES_EXPORT(void) _nc_read_entry_source (FILE*, char*, int, bool, bool (*)(ENTRY*));", "extern NCURSES_EXPORT(bool) _nc_entry_match (char *, char *);", "extern NCURSES_EXPORT(int) _nc_resolve_uses (bool); /* obs 20040705 */", "extern NCURSES_EXPORT(int) _nc_resolve_uses2 (bool, bool);", "extern NCURSES_EXPORT(void) _nc_free_entries (ENTRY *);", "extern NCURSES_IMPEXP void NCURSES_API (*_nc_check_termtype)(TERMTYPE *); /* obs 20040705 */", "extern NCURSES_IMPEXP void NCURSES_API (*_nc_check_termtype2)(TERMTYPE *, bool);", "", "/* trace_xnames.c */", "extern NCURSES_EXPORT(void) _nc_trace_xnames (TERMTYPE *);", "", "#ifdef __cplusplus", "}", "#endif", "", "#endif /* NCURSES_TERM_ENTRY_H_incl */" },
    ["termcap.h"] = { "/****************************************************************************", " * Copyright (c) 1998,2000 Free Software Foundation, Inc.                   *", " *                                                                          *", " * Permission is hereby granted, free of charge, to any person obtaining a  *", " * copy of this software and associated documentation files (the            *", ' * "Software"), to deal in the Software without restriction, including      *', " * without limitation the rights to use, copy, modify, merge, publish,      *", " * distribute, distribute with modifications, sublicense, and/or sell       *", " * copies of the Software, and to permit persons to whom the Software is    *", " * furnished to do so, subject to the following conditions:                 *", " *                                                                          *", " * The above copyright notice and this permission notice shall be included  *", " * in all copies or substantial portions of the Software.                   *", " *                                                                          *", ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *', " * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *", " * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *", " * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *", " * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *", " * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *", " * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *", " *                                                                          *", " * Except as contained in this notice, the name(s) of the above copyright   *", " * holders shall not be used in advertising or otherwise to promote the     *", " * sale, use or other dealings in this Software without prior written       *", " * authorization.                                                           *", " ****************************************************************************/", "", "/****************************************************************************", " *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *", " *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *", " ****************************************************************************/", "", "/* $Id: termcap.h.in,v 1.16 2001/03/24 21:53:27 tom Exp $ */", "", "#ifndef NCURSES_TERMCAP_H_incl", "#define NCURSES_TERMCAP_H_incl\t1", "", "#undef  NCURSES_VERSION", '#define NCURSES_VERSION "5.7"', "", "#include <ncurses_dll.h>", "", "#ifdef __cplusplus", 'extern "C"', "{", "#endif /* __cplusplus */", "", "#include <sys/types.h>", "", "#undef  NCURSES_CONST ", "#define NCURSES_CONST /*nothing*/ ", "", "#undef  NCURSES_OSPEED ", "#define NCURSES_OSPEED short ", "", "extern NCURSES_EXPORT_VAR(char) PC;", "extern NCURSES_EXPORT_VAR(char *) UP;", "extern NCURSES_EXPORT_VAR(char *) BC;", "extern NCURSES_EXPORT_VAR(NCURSES_OSPEED) ospeed; ", "", "#if !defined(NCURSES_TERM_H_incl)", "extern NCURSES_EXPORT(char *) tgetstr (NCURSES_CONST char *, char **);", "extern NCURSES_EXPORT(char *) tgoto (const char *, int, int);", "extern NCURSES_EXPORT(int) tgetent (char *, const char *);", "extern NCURSES_EXPORT(int) tgetflag (NCURSES_CONST char *);", "extern NCURSES_EXPORT(int) tgetnum (NCURSES_CONST char *);", "extern NCURSES_EXPORT(int) tputs (const char *, int, int (*)(int));", "#endif", "", "#ifdef __cplusplus", "}", "#endif", "", "#endif /* NCURSES_TERMCAP_H_incl */" },
    ["termios.h"] = { "/*", " * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "#ifndef __TERMIOS_H__", "#define __TERMIOS_H__", "", "#include <sys/cdefs.h>", "#include <sys/termios.h>", "#include <_types.h>", "#include <sys/_types/_pid_t.h>", "", "__BEGIN_DECLS", "pid_t\ttcgetsid(int);", "__END_DECLS", "", "#endif /* __TERMIOS_H__ */" },
    ["tic.h"] = { "/****************************************************************************", " * Copyright (c) 1998-2006,2007 Free Software Foundation, Inc.              *", " *                                                                          *", " * Permission is hereby granted, free of charge, to any person obtaining a  *", " * copy of this software and associated documentation files (the            *", ' * "Software"), to deal in the Software without restriction, including      *', " * without limitation the rights to use, copy, modify, merge, publish,      *", " * distribute, distribute with modifications, sublicense, and/or sell       *", " * copies of the Software, and to permit persons to whom the Software is    *", " * furnished to do so, subject to the following conditions:                 *", " *                                                                          *", " * The above copyright notice and this permission notice shall be included  *", " * in all copies or substantial portions of the Software.                   *", " *                                                                          *", ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *', " * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *", " * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *", " * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *", " * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *", " * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *", " * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *", " *                                                                          *", " * Except as contained in this notice, the name(s) of the above copyright   *", " * holders shall not be used in advertising or otherwise to promote the     *", " * sale, use or other dealings in this Software without prior written       *", " * authorization.                                                           *", " ****************************************************************************/", "", "/****************************************************************************", " *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *", " *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *", " *     and: Thomas E. Dickey 1996 on                                        *", " ****************************************************************************/", "", "/*", " * $Id: tic.h,v 1.62 2007/08/11 16:12:43 tom Exp $", " *\ttic.h - Global variables and structures for the terminfo", " *\t\t\tcompiler.", " */", "", "#ifndef __TIC_H", "#define __TIC_H", "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "", "#include <curses.h>\t/* for the _tracef() prototype, ERR/OK, bool defs */", "", "/*", "** The format of compiled terminfo files is as follows:", "**", "**\t\tHeader (12 bytes), containing information given below", "**\t\tNames Section, containing the names of the terminal", "**\t\tBoolean Section, containing the values of all of the", "**\t\t\t\tboolean capabilities", "**\t\t\t\tA null byte may be inserted here to make", "**\t\t\t\tsure that the Number Section begins on an", "**\t\t\t\teven word boundary.", "**\t\tNumber Section, containing the values of all of the numeric", "**\t\t\t\tcapabilities, each as a short integer", "**\t\tString Section, containing short integer offsets into the", "**\t\t\t\tString Table, one per string capability", "**\t\tString Table, containing the actual characters of the string", "**\t\t\t\tcapabilities.", "**", "**\tNOTE that all short integers in the file are stored using VAX/PDP-style", "**\tbyte-order, i.e., least-significant byte first.", "**", "**\tThere is no structure definition here because it would only confuse", "**\tmatters.  Terminfo format is a raw byte layout, not a structure", "**\tdump.  If you happen to be on a little-endian machine with 16-bit", "**\tshorts that requires no padding between short members in a struct,", "**\tthen there is a natural C structure that captures the header, but", "**\tnot very helpfully.", "*/", "", "#define MAGIC\t\t0432\t/* first two bytes of a compiled entry */", "", "#undef  BYTE", "#define BYTE(p,n)\t(unsigned char)((p)[n])", "", "#define IS_NEG1(p)\t((BYTE(p,0) == 0377) && (BYTE(p,1) == 0377))", "#define IS_NEG2(p)\t((BYTE(p,0) == 0376) && (BYTE(p,1) == 0377))", "#define LOW_MSB(p)\t(BYTE(p,0) + 256*BYTE(p,1))", "", "#define IS_TIC_MAGIC(p)\t(LOW_MSB(p) == MAGIC)", "", "/*", ' * The "maximum" here is misleading; XSI guarantees minimum values, which a', " * given implementation may exceed.", " */", "#define MAX_NAME_SIZE\t512\t/* maximum legal name field size (XSI:127) */", "#define MAX_ENTRY_SIZE\t4096\t/* maximum legal entry size */", "", "/*", " * The maximum size of individual name or alias is guaranteed in XSI to be at", " * least 14, since that corresponds to the older filename lengths.  Newer", " * systems allow longer aliases, though not many terminal descriptions are", " * written to use them.  The MAX_ALIAS symbol is used for warnings.", " */", "#if HAVE_LONG_FILE_NAMES", "#define MAX_ALIAS\t32\t/* smaller than POSIX minimum for PATH_MAX */", "#else", "#define MAX_ALIAS\t14\t/* SVr3 filename length */", "#endif", "", "/* location of user's personal info directory */", '#define PRIVATE_INFO\t"%s/.terminfo"\t/* plug getenv("HOME") into %s */', "", "/*", " * Some traces are designed to be used via tic's verbose option (and similar in", " * infocmp and toe) rather than the 'trace()' function.  So we use the bits", " * above the normal trace() parameter as a debug-level.", " */", "", "#define MAX_DEBUG_LEVEL 15", "#define DEBUG_LEVEL(n)\t((n) << TRACE_SHIFT)", "", "#define set_trace_level(n) \\", "\t_nc_tracing &= DEBUG_LEVEL(MAX_DEBUG_LEVEL), \\", "\t_nc_tracing |= DEBUG_LEVEL(n)", "", "#ifdef TRACE", "#define DEBUG(n, a)\tif (_nc_tracing >= DEBUG_LEVEL(n)) _tracef a", "#else", "#define DEBUG(n, a)\t/*nothing*/", "#endif", "", "extern NCURSES_EXPORT_VAR(unsigned) _nc_tracing;", "extern NCURSES_EXPORT(void) _nc_tracef (char *, ...) GCC_PRINTFLIKE(1,2);", "extern NCURSES_EXPORT(const char *) _nc_visbuf (const char *);", "extern NCURSES_EXPORT(const char *) _nc_visbuf2 (int, const char *);", "", "/*", " * These are the types of tokens returned by the scanner.  The first", " * three are also used in the hash table of capability names.  The scanner", " * returns one of these values after loading the specifics into the global", " * structure curr_token.", " */", "", "#define BOOLEAN 0\t\t/* Boolean capability */", "#define NUMBER 1\t\t/* Numeric capability */", "#define STRING 2\t\t/* String-valued capability */", "#define CANCEL 3\t\t/* Capability to be cancelled in following tc's */", "#define NAMES  4\t\t/* The names for a terminal type */", "#define UNDEF  5\t\t/* Undefined */", "", "#define NO_PUSHBACK\t-1\t/* used in pushtype to indicate no pushback */", "", "\t/*", "\t *\tThe global structure in which the specific parts of a", "\t *\tscanned token are returned.", "\t *", "\t */", "", "struct token", "{", "\tchar\t*tk_name;\t\t/* name of capability */", "\tint\ttk_valnumber;\t/* value of capability (if a number) */", "\tchar\t*tk_valstring;\t/* value of capability (if a string) */", "};", "", "extern NCURSES_EXPORT_VAR(struct token)\t_nc_curr_token;", "", "\t/*", "\t * Offsets to string capabilities, with the corresponding functionkey", "\t * codes.", "\t */", "struct tinfo_fkeys {", "\tunsigned offset;", "\tchtype code;", "\t};", "", "#if\tBROKEN_LINKER", "", "#define\t_nc_tinfo_fkeys\t_nc_tinfo_fkeysf()", "extern NCURSES_EXPORT(const struct tinfo_fkeys *) _nc_tinfo_fkeysf (void);", "", "#else", "", "extern NCURSES_EXPORT_VAR(const struct tinfo_fkeys) _nc_tinfo_fkeys[];", "", "#endif", "", "\t/*", "\t * The file comp_captab.c contains an array of these structures, one", "\t * per possible capability.  These are indexed by a hash table array of", "\t * pointers to the same structures for use by the parser.", "\t */", "", "struct name_table_entry", "{", "\tconst char *nte_name;\t/* name to hash on */", "\tint\tnte_type;\t/* BOOLEAN, NUMBER or STRING */", "\tshort\tnte_index;\t/* index of associated variable in its array */", "\tshort\tnte_link;\t/* index in table of next hash, or -1 */", "};", "", "struct alias", "{", "\tconst char\t*from;", "\tconst char\t*to;", "\tconst char\t*source;", "};", "", "extern NCURSES_EXPORT(const struct name_table_entry *) _nc_get_table (bool);", "extern NCURSES_EXPORT(const short *) _nc_get_hash_table (bool);", "extern NCURSES_EXPORT(const struct alias *) _nc_get_alias_table (bool);", "", "#define NOTFOUND\t((struct name_table_entry *) 0)", "", "/* out-of-band values for representing absent capabilities */", "#define ABSENT_BOOLEAN\t\t((signed char)-1)\t/* 255 */", "#define ABSENT_NUMERIC\t\t(-1)", "#define ABSENT_STRING\t\t(char *)0", "", "/* out-of-band values for representing cancels */", "#define CANCELLED_BOOLEAN\t((signed char)-2)\t/* 254 */", "#define CANCELLED_NUMERIC\t(-2)", "#define CANCELLED_STRING\t(char *)(-1)", "", '#define VALID_BOOLEAN(s) ((unsigned char)(s) <= 1) /* reject "-1" */', "#define VALID_NUMERIC(s) ((s) >= 0)", "#define VALID_STRING(s)  ((s) != CANCELLED_STRING && (s) != ABSENT_STRING)", "", "/* termcap entries longer than this may break old binaries */", "#define MAX_TERMCAP_LENGTH\t1023", "", "/* this is a documented limitation of terminfo */", "#define MAX_TERMINFO_LENGTH\t4096", "", "#ifndef TERMINFO", '#define TERMINFO "/usr/share/terminfo"', "#endif", "", "/* access.c */", "extern NCURSES_EXPORT(unsigned) _nc_pathlast (const char *);", "extern NCURSES_EXPORT(bool) _nc_is_abs_path (const char *);", "extern NCURSES_EXPORT(bool) _nc_is_dir_path (const char *);", "extern NCURSES_EXPORT(bool) _nc_is_file_path (const char *);", "extern NCURSES_EXPORT(char *) _nc_basename (char *);", "extern NCURSES_EXPORT(char *) _nc_rootname (char *);", "", "/* comp_hash.c: name lookup */", "extern NCURSES_EXPORT(struct name_table_entry const *) _nc_find_entry", "\t(const char *, const short *);", "extern NCURSES_EXPORT(struct name_table_entry const *) _nc_find_type_entry", "\t(const char *, int, const struct name_table_entry *);", "", "/* comp_scan.c: lexical analysis */", "extern NCURSES_EXPORT(int)  _nc_get_token (bool);", "extern NCURSES_EXPORT(void) _nc_panic_mode (char);", "extern NCURSES_EXPORT(void) _nc_push_token (int);", "extern NCURSES_EXPORT(void) _nc_reset_input (FILE *, char *);", "extern NCURSES_EXPORT_VAR(int) _nc_curr_col;", "extern NCURSES_EXPORT_VAR(int) _nc_curr_line;", "extern NCURSES_EXPORT_VAR(int) _nc_syntax;", "extern NCURSES_EXPORT_VAR(long) _nc_comment_end;", "extern NCURSES_EXPORT_VAR(long) _nc_comment_start;", "extern NCURSES_EXPORT_VAR(long) _nc_curr_file_pos;", "extern NCURSES_EXPORT_VAR(long) _nc_start_line;", "#define SYN_TERMINFO\t0", "#define SYN_TERMCAP\t1", "", "/* comp_error.c: warning & abort messages */", "extern NCURSES_EXPORT(const char *) _nc_get_source (void);", "extern NCURSES_EXPORT(void) _nc_err_abort (const char *const,...) GCC_PRINTFLIKE(1,2) GCC_NORETURN;", "extern NCURSES_EXPORT(void) _nc_get_type (char *name);", "extern NCURSES_EXPORT(void) _nc_set_source (const char *const);", "extern NCURSES_EXPORT(void) _nc_set_type (const char *const);", "extern NCURSES_EXPORT(void) _nc_syserr_abort (const char *const,...) GCC_PRINTFLIKE(1,2) GCC_NORETURN;", "extern NCURSES_EXPORT(void) _nc_warning (const char *const,...) GCC_PRINTFLIKE(1,2);", "extern NCURSES_EXPORT_VAR(bool) _nc_suppress_warnings;", "", "/* comp_expand.c: expand string into readable form */", "extern NCURSES_EXPORT(char *) _nc_tic_expand (const char *, bool, int);", "", "/* comp_scan.c: decode string from readable form */", "extern NCURSES_EXPORT(int) _nc_trans_string (char *, char *);", "", "/* captoinfo.c: capability conversion */", "extern NCURSES_EXPORT(char *) _nc_captoinfo (const char *, const char *, int const);", "extern NCURSES_EXPORT(char *) _nc_infotocap (const char *, const char *, int const);", "", "/* home_terminfo.c */", "extern NCURSES_EXPORT(char *) _nc_home_terminfo (void);", "", "/* lib_tparm.c */", "#define NUM_PARM 9", "", "extern NCURSES_EXPORT_VAR(int) _nc_tparm_err;", "", "extern NCURSES_EXPORT(int) _nc_tparm_analyze(const char *, char **, int *);", "", "/* lib_tputs.c */", "extern NCURSES_EXPORT_VAR(int) _nc_nulls_sent;\t\t/* Add one for every null sent */", "", "/* comp_main.c: compiler main */", "extern const char * _nc_progname;", "", "/* db_iterator.c */", "typedef enum {", "    dbdTIC = 0,", "#if USE_DATABASE", "    dbdEnvOnce,", "    dbdHome,", "    dbdEnvList,", "    dbdCfgList,", "    dbdCfgOnce,", "#endif", "#if USE_TERMCAP", "    dbdEnvOnce2,", "    dbdEnvList2,", "    dbdCfgList2,", "#endif", "    dbdLAST", "} DBDIRS;", "", "extern NCURSES_EXPORT(const char *) _nc_next_db(DBDIRS *, int *);", "extern NCURSES_EXPORT(const char *) _nc_tic_dir (const char *);", "extern NCURSES_EXPORT(void) _nc_first_db(DBDIRS *, int *);", "extern NCURSES_EXPORT(void) _nc_last_db(void);", "", "/* write_entry.c */", "extern NCURSES_EXPORT(int) _nc_tic_written (void);", "", "#ifdef __cplusplus", "}", "#endif", "", "#endif /* __TIC_H */" },
    ["time.h"] = { "/*", " * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/*", " * Copyright (c) 1989, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " * (c) UNIX System Laboratories, Inc.", " * All or some portions of this file are derived from material licensed", " * to the University of California by American Telephone and Telegraph", " * Co. or Unix System Laboratories, Inc. and are reproduced herein with", " * the permission of UNIX System Laboratories, Inc.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)time.h\t8.3 (Berkeley) 1/21/94", " */", "", "#ifndef _TIME_H_", "#define\t_TIME_H_", "", "#include <_types.h>", "", "#define __need_struct_timespec", "#include <_structs.h>", "#include <sys/_types/_null.h>", "#include <sys/_types/_clock_t.h>", "#include <sys/_types/_size_t.h>", "#include <sys/_types/_time_t.h>", "", "struct tm {", "\tint\ttm_sec;\t\t/* seconds after the minute [0-60] */", "\tint\ttm_min;\t\t/* minutes after the hour [0-59] */", "\tint\ttm_hour;\t/* hours since midnight [0-23] */", "\tint\ttm_mday;\t/* day of the month [1-31] */", "\tint\ttm_mon;\t\t/* months since January [0-11] */", "\tint\ttm_year;\t/* years since 1900 */", "\tint\ttm_wday;\t/* days since Sunday [0-6] */", "\tint\ttm_yday;\t/* days since January 1 [0-365] */", "\tint\ttm_isdst;\t/* Daylight Savings Time flag */", "\tlong\ttm_gmtoff;\t/* offset from CUT in seconds */", "\tchar\t*tm_zone;\t/* timezone abbreviation */", "};", "", "#if __DARWIN_UNIX03", "#define CLOCKS_PER_SEC  1000000\t/* [XSI] */", "#else /* !__DARWIN_UNIX03 */", "#include <machine/_limits.h>\t/* Include file containing CLK_TCK. */", "", "#define CLOCKS_PER_SEC  (__DARWIN_CLK_TCK)", "#endif /* __DARWIN_UNIX03 */", "", "#ifndef _ANSI_SOURCE", "extern char *tzname[];", "#endif", "", "extern int getdate_err;", "#if __DARWIN_UNIX03", "extern long timezone __DARWIN_ALIAS(timezone);", "#endif /* __DARWIN_UNIX03 */", "extern int daylight;", "", "__BEGIN_DECLS", "char *asctime(const struct tm *);", "clock_t clock(void) __DARWIN_ALIAS(clock);", "char *ctime(const time_t *);", "double difftime(time_t, time_t);", "struct tm *getdate(const char *);", "struct tm *gmtime(const time_t *);", "struct tm *localtime(const time_t *);", "time_t mktime(struct tm *) __DARWIN_ALIAS(mktime);", "size_t strftime(char * __restrict, size_t, const char * __restrict, const struct tm * __restrict) __DARWIN_ALIAS(strftime);", "char *strptime(const char * __restrict, const char * __restrict, struct tm * __restrict) __DARWIN_ALIAS(strptime);", "time_t time(time_t *);", "", "#ifndef _ANSI_SOURCE", "void tzset(void);", "#endif /* not ANSI */", "", "/* [TSF] Thread safe functions */", "char *asctime_r(const struct tm * __restrict, char * __restrict);", "char *ctime_r(const time_t *, char *);", "struct tm *gmtime_r(const time_t * __restrict, struct tm * __restrict);", "struct tm *localtime_r(const time_t * __restrict, struct tm * __restrict);", "", "#if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))", "time_t posix2time(time_t);", "#if !__DARWIN_UNIX03", "char *timezone(int, int);", "#endif /* !__DARWIN_UNIX03 */", "void tzsetwall(void);", "time_t time2posix(time_t);", "time_t timelocal(struct tm * const);", "time_t timegm(struct tm * const);", "#endif /* neither ANSI nor POSIX */", "", "#if !defined(_ANSI_SOURCE)", "int nanosleep(const struct timespec *, struct timespec *) __DARWIN_ALIAS_C(nanosleep);", "#endif", "__END_DECLS", "", "#ifdef _USE_EXTENDED_LOCALES_", "#include <xlocale/_time.h>", "#endif /* _USE_EXTENDED_LOCALES_ */", "", "#endif /* !_TIME_H_ */" },
    ["timeconv.h"] = { "/*", " * Copyright (c) 1989, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " * (c) UNIX System Laboratories, Inc.", " * All or some portions of this file are derived from material licensed", " * to the University of California by American Telephone and Telegraph", " * Co. or Unix System Laboratories, Inc. and are reproduced herein with", " * the permission of UNIX System Laboratories, Inc.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)time.h\t8.3 (Berkeley) 1/21/94", " */", "", "/*", " * $FreeBSD: /repoman/r/ncvs/src/include/timeconv.h,v 1.2 2002/08/21 16:19:55 mike Exp $", " */", "", "#ifndef _TIMECONV_H_", "#define\t_TIMECONV_H_", "", "#include <sys/cdefs.h>", "#include <sys/types.h>", "", "__BEGIN_DECLS", "time_t _time32_to_time(int32_t t32);", "int32_t _time_to_time32(time_t t);", "time_t _time64_to_time(int64_t t64);", "int64_t _time_to_time64(time_t t);", "long _time_to_long(time_t t);", "time_t _long_to_time(long tlong);", "int _time_to_int(time_t t);", "time_t _int_to_time(int tint);", "__END_DECLS", "", "#endif /* _TIMECONV_H_ */" },
    ["tk.h"] = { "/*", " * tk.h --", " *", " *\tDeclarations for Tk-related things that are visible outside of the Tk", " *\tmodule itself.", " *", " * Copyright (c) 1989-1994 The Regents of the University of California.", " * Copyright (c) 1994 The Australian National University.", " * Copyright (c) 1994-1998 Sun Microsystems, Inc.", " * Copyright (c) 1998-2000 Ajuba Solutions.", " *", ' * See the file "license.terms" for information on usage and redistribution of', " * this file, and for a DISCLAIMER OF ALL WARRANTIES.", " *", " * RCS: @(#) $Id$", " */", "", "#ifndef _TK", "#define _TK", "", "#include <tcl.h>", "#if (TCL_MAJOR_VERSION != 8) || (TCL_MINOR_VERSION != 5)", "#\terror Tk 8.5 must be compiled with tcl.h from Tcl 8.5", "#endif", "", "/*", ' * For C++ compilers, use extern "C"', " */", "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "", "/*", " * When version numbers change here, you must also go into the following files", " * and update the version numbers:", " *", " * library/tk.tcl\t(2 LOC patch)", " * unix/configure.in\t(2 LOC Major, 2 LOC minor, 1 LOC patch)", " * win/configure.in\t(as above)", " * README\t\t(sections 0 and 1)", " * macosx/Wish.xcode/project.pbxproj (not patchlevel) 1 LOC", " * macosx/Wish-Common.xcconfig (not patchlevel) 1 LOC", " * win/README\t\t(not patchlevel)", " * unix/README\t\t(not patchlevel)", " * unix/tk.spec\t\t(1 LOC patch)", " * win/tcl.m4\t\t(not patchlevel)", " *", " * You may also need to update some of these files when the numbers change for", " * the version of Tcl that this release of Tk is compiled against.", " */", "", "#define TK_MAJOR_VERSION\t8", "#define TK_MINOR_VERSION\t5", "#define TK_RELEASE_LEVEL\tTCL_FINAL_RELEASE", "#define TK_RELEASE_SERIAL\t9", "", '#define TK_VERSION\t\t"8.5"', '#define TK_PATCH_LEVEL\t\t"8.5.9"', "", "/*", " * A special definition used to allow this header file to be included from", " * windows or mac resource files so that they can obtain version information.", " * RC_INVOKED is defined by default by the windows RC tool and manually set", " * for macintosh.", " *", " * Resource compilers don't like all the C stuff, like typedefs and procedure", " * declarations, that occur below, so block them out.", " */", "", "#ifndef RC_INVOKED", "", "#ifndef _XLIB_H", "#   if defined(MAC_OSX_TK)", "#\tinclude <X11/Xlib.h>", "#\tinclude <X11/X.h>", "#   else", "#\tinclude <X11/Xlib.h>", "#   endif", "#endif", "#ifdef __STDC__", "#   include <stddef.h>", "#endif", "", "#ifdef BUILD_tk", "# undef TCL_STORAGE_CLASS", "# define TCL_STORAGE_CLASS DLLEXPORT", "#endif", "\f", "/*", " * Decide whether or not to use input methods.", " */", "", "#ifdef XNQueryInputStyle", "#define TK_USE_INPUT_METHODS", "#endif", "", "/*", " * Dummy types that are used by clients:", " */", "", "typedef struct Tk_BindingTable_ *Tk_BindingTable;", "typedef struct Tk_Canvas_ *Tk_Canvas;", "typedef struct Tk_Cursor_ *Tk_Cursor;", "typedef struct Tk_ErrorHandler_ *Tk_ErrorHandler;", "typedef struct Tk_Font_ *Tk_Font;", "typedef struct Tk_Image__ *Tk_Image;", "typedef struct Tk_ImageMaster_ *Tk_ImageMaster;", "typedef struct Tk_OptionTable_ *Tk_OptionTable;", "typedef struct Tk_PostscriptInfo_ *Tk_PostscriptInfo;", "typedef struct Tk_TextLayout_ *Tk_TextLayout;", "typedef struct Tk_Window_ *Tk_Window;", "typedef struct Tk_3DBorder_ *Tk_3DBorder;", "typedef struct Tk_Style_ *Tk_Style;", "typedef struct Tk_StyleEngine_ *Tk_StyleEngine;", "typedef struct Tk_StyledElement_ *Tk_StyledElement;", "", "/*", " * Additional types exported to clients.", " */", "", "typedef const char *Tk_Uid;", "", "/*", " * The enum below defines the valid types for Tk configuration options as", " * implemented by Tk_InitOptions, Tk_SetOptions, etc.", " */", "", "typedef enum {", "    TK_OPTION_BOOLEAN,", "    TK_OPTION_INT,", "    TK_OPTION_DOUBLE,", "    TK_OPTION_STRING,", "    TK_OPTION_STRING_TABLE,", "    TK_OPTION_COLOR,", "    TK_OPTION_FONT,", "    TK_OPTION_BITMAP,", "    TK_OPTION_BORDER,", "    TK_OPTION_RELIEF,", "    TK_OPTION_CURSOR,", "    TK_OPTION_JUSTIFY,", "    TK_OPTION_ANCHOR,", "    TK_OPTION_SYNONYM,", "    TK_OPTION_PIXELS,", "    TK_OPTION_WINDOW,", "    TK_OPTION_END,", "    TK_OPTION_CUSTOM,", "    TK_OPTION_STYLE", "} Tk_OptionType;", "", "/*", " * Structures of the following type are used by widgets to specify their", " * configuration options. Typically each widget has a static array of these", " * structures, where each element of the array describes a single", " * configuration option. The array is passed to Tk_CreateOptionTable.", " */", "", "typedef struct Tk_OptionSpec {", "    Tk_OptionType type;\t\t/* Type of option, such as TK_OPTION_COLOR;", "\t\t\t\t * see definitions above. Last option in table", "\t\t\t\t * must have type TK_OPTION_END. */", "    const char *optionName;\t/* Name used to specify option in Tcl", "\t\t\t\t * commands. */", "    const char *dbName;\t\t/* Name for option in option database. */", "    const char *dbClass;\t/* Class for option in database. */", "    const char *defValue;\t/* Default value for option if not specified", "\t\t\t\t * in command line, the option database, or", "\t\t\t\t * the system. */", "    int objOffset;\t\t/* Where in record to store a Tcl_Obj * that", "\t\t\t\t * holds the value of this option, specified", "\t\t\t\t * as an offset in bytes from the start of the", "\t\t\t\t * record. Use the Tk_Offset macro to generate", "\t\t\t\t * values for this. -1 means don't store the", "\t\t\t\t * Tcl_Obj in the record. */", "    int internalOffset;\t\t/* Where in record to store the internal", "\t\t\t\t * representation of the value of this option,", "\t\t\t\t * such as an int or XColor *. This field is", "\t\t\t\t * specified as an offset in bytes from the", "\t\t\t\t * start of the record. Use the Tk_Offset", "\t\t\t\t * macro to generate values for it. -1 means", "\t\t\t\t * don't store the internal representation in", "\t\t\t\t * the record. */", "    int flags;\t\t\t/* Any combination of the values defined", "\t\t\t\t * below. */", "    ClientData clientData;\t/* An alternate place to put option-specific", "\t\t\t\t * data. Used for the monochrome default value", "\t\t\t\t * for colors, etc. */", "    int typeMask;\t\t/* An arbitrary bit mask defined by the class", "\t\t\t\t * manager; typically bits correspond to", "\t\t\t\t * certain kinds of options such as all those", "\t\t\t\t * that require a redisplay when they change.", "\t\t\t\t * Tk_SetOptions returns the bit-wise OR of", "\t\t\t\t * the typeMasks of all options that were", "\t\t\t\t * changed. */", "} Tk_OptionSpec;", "", "/*", " * Flag values for Tk_OptionSpec structures. These flags are shared by", " * Tk_ConfigSpec structures, so be sure to coordinate any changes carefully.", " */", "", "#define TK_OPTION_NULL_OK\t\t(1 << 0)", "#define TK_OPTION_DONT_SET_DEFAULT\t(1 << 3)", "", "/*", " * The following structure and function types are used by TK_OPTION_CUSTOM", " * options; the structure holds pointers to the functions needed by the Tk", " * option config code to handle a custom option.", " */", "", "typedef int (Tk_CustomOptionSetProc) _ANSI_ARGS_((ClientData clientData,", "\tTcl_Interp *interp, Tk_Window tkwin, Tcl_Obj **value, char *widgRec,", "\tint offset, char *saveInternalPtr, int flags));", "typedef Tcl_Obj *(Tk_CustomOptionGetProc) _ANSI_ARGS_((ClientData clientData,", "\tTk_Window tkwin, char *widgRec, int offset));", "typedef void (Tk_CustomOptionRestoreProc) _ANSI_ARGS_((ClientData clientData,", "\tTk_Window tkwin, char *internalPtr, char *saveInternalPtr));", "typedef void (Tk_CustomOptionFreeProc) _ANSI_ARGS_((ClientData clientData,", "\tTk_Window tkwin, char *internalPtr));", "", "typedef struct Tk_ObjCustomOption {", "    const char *name; /* Name of the custom option. */", "    Tk_CustomOptionSetProc *setProc;", "\t\t\t\t/* Function to use to set a record's option", "\t\t\t\t * value from a Tcl_Obj */", "    Tk_CustomOptionGetProc *getProc;", "\t\t\t\t/* Function to use to get a Tcl_Obj", "\t\t\t\t * representation from an internal", "\t\t\t\t * representation of an option. */", "    Tk_CustomOptionRestoreProc *restoreProc;", "\t\t\t\t/* Function to use to restore a saved value", "\t\t\t\t * for the internal representation. */", "    Tk_CustomOptionFreeProc *freeProc;", "\t\t\t\t/* Function to use to free the internal", "\t\t\t\t * representation of an option. */", "    ClientData clientData;\t/* Arbitrary one-word value passed to the", "\t\t\t\t * handling procs. */", "} Tk_ObjCustomOption;", "", "/*", ' * Macro to use to fill in "offset" fields of the Tk_OptionSpec structure.', " * Computes number of bytes from beginning of structure to a given field.", " */", "", "#ifdef offsetof", "#define Tk_Offset(type, field) ((int) offsetof(type, field))", "#else", "#define Tk_Offset(type, field) ((int) ((char *) &((type *) 0)->field))", "#endif", "", "/*", " * The following two structures are used for error handling. When config", " * options are being modified, the old values are saved in a Tk_SavedOptions", " * structure. If an error occurs, then the contents of the structure can be", " * used to restore all of the old values. The contents of this structure are", " * for the private use Tk. No-one outside Tk should ever read or write any of", " * the fields of these structures.", " */", "", "typedef struct Tk_SavedOption {", "    struct TkOption *optionPtr;\t/* Points to information that describes the", "\t\t\t\t * option. */", "    Tcl_Obj *valuePtr;\t\t/* The old value of the option, in the form of", "\t\t\t\t * a Tcl object; may be NULL if the value was", "\t\t\t\t * not saved as an object. */", "    double internalForm;\t/* The old value of the option, in some", "\t\t\t\t * internal representation such as an int or", "\t\t\t\t * (XColor *). Valid only if the field", "\t\t\t\t * optionPtr->specPtr->objOffset is < 0. The", "\t\t\t\t * space must be large enough to accommodate a", "\t\t\t\t * double, a long, or a pointer; right now it", "\t\t\t\t * looks like a double (i.e., 8 bytes) is big", "\t\t\t\t * enough. Also, using a double guarantees", "\t\t\t\t * that the field is properly aligned for", "\t\t\t\t * storing large values. */", "} Tk_SavedOption;", "", "#ifdef TCL_MEM_DEBUG", "#   define TK_NUM_SAVED_OPTIONS 2", "#else", "#   define TK_NUM_SAVED_OPTIONS 20", "#endif", "", "typedef struct Tk_SavedOptions {", "    char *recordPtr;\t\t/* The data structure in which to restore", "\t\t\t\t * configuration options. */", "    Tk_Window tkwin;\t\t/* Window associated with recordPtr; needed to", "\t\t\t\t * restore certain options. */", "    int numItems;\t\t/* The number of valid items in items field. */", "    Tk_SavedOption items[TK_NUM_SAVED_OPTIONS];", "\t\t\t\t/* Items used to hold old values. */", "    struct Tk_SavedOptions *nextPtr;", "\t\t\t\t/* Points to next structure in list; needed if", "\t\t\t\t * too many options changed to hold all the", "\t\t\t\t * old values in a single structure. NULL", "\t\t\t\t * means no more structures. */", "} Tk_SavedOptions;", "", "/*", " * Structure used to describe application-specific configuration options:", " * indicates procedures to call to parse an option and to return a text string", " * describing an option. THESE ARE DEPRECATED; PLEASE USE THE NEW STRUCTURES", " * LISTED ABOVE.", " */", "", "/*", " * This is a temporary flag used while tkObjConfig and new widgets are in", " * development.", " */", "", "#ifndef __NO_OLD_CONFIG", "", "typedef int (Tk_OptionParseProc) _ANSI_ARGS_((ClientData clientData,", "\tTcl_Interp *interp, Tk_Window tkwin, CONST84 char *value, char *widgRec,", "\tint offset));", "typedef char *(Tk_OptionPrintProc) _ANSI_ARGS_((ClientData clientData,", "\tTk_Window tkwin, char *widgRec, int offset,", "\tTcl_FreeProc **freeProcPtr));", "", "typedef struct Tk_CustomOption {", "    Tk_OptionParseProc *parseProc;", "\t\t\t\t/* Procedure to call to parse an option and", "\t\t\t\t * store it in converted form. */", "    Tk_OptionPrintProc *printProc;", "\t\t\t\t/* Procedure to return a printable string", "\t\t\t\t * describing an existing option. */", "    ClientData clientData;\t/* Arbitrary one-word value used by option", "\t\t\t\t * parser: passed to parseProc and", "\t\t\t\t * printProc. */", "} Tk_CustomOption;", "", "/*", " * Structure used to specify information for Tk_ConfigureWidget. Each", " * structure gives complete information for one option, including how the", " * option is specified on the command line, where it appears in the option", " * database, etc.", " */", "", "typedef struct Tk_ConfigSpec {", "    int type;\t\t\t/* Type of option, such as TK_CONFIG_COLOR;", "\t\t\t\t * see definitions below. Last option in table", "\t\t\t\t * must have type TK_CONFIG_END. */", "    char *argvName;\t\t/* Switch used to specify option in argv. NULL", "\t\t\t\t * means this spec is part of a group. */", "    Tk_Uid dbName;\t\t/* Name for option in option database. */", "    Tk_Uid dbClass;\t\t/* Class for option in database. */", "    Tk_Uid defValue;\t\t/* Default value for option if not specified", "\t\t\t\t * in command line or database. */", "    int offset;\t\t\t/* Where in widget record to store value; use", "\t\t\t\t * Tk_Offset macro to generate values for", "\t\t\t\t * this. */", "    int specFlags;\t\t/* Any combination of the values defined", "\t\t\t\t * below; other bits are used internally by", "\t\t\t\t * tkConfig.c. */", "    Tk_CustomOption *customPtr;\t/* If type is TK_CONFIG_CUSTOM then this is a", "\t\t\t\t * pointer to info about how to parse and", "\t\t\t\t * print the option. Otherwise it is", "\t\t\t\t * irrelevant. */", "} Tk_ConfigSpec;", "", "/*", " * Type values for Tk_ConfigSpec structures. See the user documentation for", " * details.", " */", "", "typedef enum {", "    TK_CONFIG_BOOLEAN, TK_CONFIG_INT, TK_CONFIG_DOUBLE, TK_CONFIG_STRING,", "    TK_CONFIG_UID, TK_CONFIG_COLOR, TK_CONFIG_FONT, TK_CONFIG_BITMAP,", "    TK_CONFIG_BORDER, TK_CONFIG_RELIEF, TK_CONFIG_CURSOR,", "    TK_CONFIG_ACTIVE_CURSOR, TK_CONFIG_JUSTIFY, TK_CONFIG_ANCHOR,", "    TK_CONFIG_SYNONYM, TK_CONFIG_CAP_STYLE, TK_CONFIG_JOIN_STYLE,", "    TK_CONFIG_PIXELS, TK_CONFIG_MM, TK_CONFIG_WINDOW, TK_CONFIG_CUSTOM,", "    TK_CONFIG_END", "} Tk_ConfigTypes;", "", "/*", " * Possible values for flags argument to Tk_ConfigureWidget:", " */", "", "#define TK_CONFIG_ARGV_ONLY\t1", "#define TK_CONFIG_OBJS\t\t0x80", "", "/*", " * Possible flag values for Tk_ConfigSpec structures. Any bits at or above", " * TK_CONFIG_USER_BIT may be used by clients for selecting certain entries.", " * Before changing any values here, coordinate with tkOldConfig.c", " * (internal-use-only flags are defined there).", " */", "", "#define TK_CONFIG_NULL_OK\t\t(1 << 0)", "#define TK_CONFIG_COLOR_ONLY\t\t(1 << 1)", "#define TK_CONFIG_MONO_ONLY\t\t(1 << 2)", "#define TK_CONFIG_DONT_SET_DEFAULT\t(1 << 3)", "#define TK_CONFIG_OPTION_SPECIFIED      (1 << 4)", "#define TK_CONFIG_USER_BIT\t\t0x100", "#endif /* __NO_OLD_CONFIG */", "", "/*", " * Structure used to specify how to handle argv options.", " */", "", "typedef struct {", "    char *key;\t\t\t/* The key string that flags the option in the", "\t\t\t\t * argv array. */", "    int type;\t\t\t/* Indicates option type; see below. */", "    char *src;\t\t\t/* Value to be used in setting dst; usage", "\t\t\t\t * depends on type. */", "    char *dst;\t\t\t/* Address of value to be modified; usage", "\t\t\t\t * depends on type. */", "    char *help;\t\t\t/* Documentation message describing this", "\t\t\t\t * option. */", "} Tk_ArgvInfo;", "", "/*", " * Legal values for the type field of a Tk_ArgvInfo: see the user", " * documentation for details.", " */", "", "#define TK_ARGV_CONSTANT\t\t15", "#define TK_ARGV_INT\t\t\t16", "#define TK_ARGV_STRING\t\t\t17", "#define TK_ARGV_UID\t\t\t18", "#define TK_ARGV_REST\t\t\t19", "#define TK_ARGV_FLOAT\t\t\t20", "#define TK_ARGV_FUNC\t\t\t21", "#define TK_ARGV_GENFUNC\t\t\t22", "#define TK_ARGV_HELP\t\t\t23", "#define TK_ARGV_CONST_OPTION\t\t24", "#define TK_ARGV_OPTION_VALUE\t\t25", "#define TK_ARGV_OPTION_NAME_VALUE\t26", "#define TK_ARGV_END\t\t\t27", "", "/*", " * Flag bits for passing to Tk_ParseArgv:", " */", "", "#define TK_ARGV_NO_DEFAULTS\t\t0x1", "#define TK_ARGV_NO_LEFTOVERS\t\t0x2", "#define TK_ARGV_NO_ABBREV\t\t0x4", "#define TK_ARGV_DONT_SKIP_FIRST_ARG\t0x8", "", "/*", " * Enumerated type for describing actions to be taken in response to a", " * restrictProc established by Tk_RestrictEvents.", " */", "", "typedef enum {", "    TK_DEFER_EVENT, TK_PROCESS_EVENT, TK_DISCARD_EVENT", "} Tk_RestrictAction;", "", "/*", " * Priority levels to pass to Tk_AddOption:", " */", "", "#define TK_WIDGET_DEFAULT_PRIO\t20", "#define TK_STARTUP_FILE_PRIO\t40", "#define TK_USER_DEFAULT_PRIO\t60", "#define TK_INTERACTIVE_PRIO\t80", "#define TK_MAX_PRIO\t\t100", "", "/*", " * Relief values returned by Tk_GetRelief:", " */", "", "#define TK_RELIEF_NULL\t\t-1", "#define TK_RELIEF_FLAT\t\t0", "#define TK_RELIEF_GROOVE\t1", "#define TK_RELIEF_RAISED\t2", "#define TK_RELIEF_RIDGE\t\t3", "#define TK_RELIEF_SOLID\t\t4", "#define TK_RELIEF_SUNKEN\t5", "", "/*", ' * "Which" argument values for Tk_3DBorderGC:', " */", "", "#define TK_3D_FLAT_GC\t\t1", "#define TK_3D_LIGHT_GC\t\t2", "#define TK_3D_DARK_GC\t\t3", "", "/*", ' * Special EnterNotify/LeaveNotify "mode" for use in events generated by', " * tkShare.c. Pick a high enough value that it's unlikely to conflict with", " * existing values (like NotifyNormal) or any new values defined in the", " * future.", " */", "", "#define TK_NOTIFY_SHARE\t\t20", "", "/*", " * Enumerated type for describing a point by which to anchor something:", " */", "", "typedef enum {", "    TK_ANCHOR_N, TK_ANCHOR_NE, TK_ANCHOR_E, TK_ANCHOR_SE,", "    TK_ANCHOR_S, TK_ANCHOR_SW, TK_ANCHOR_W, TK_ANCHOR_NW,", "    TK_ANCHOR_CENTER", "} Tk_Anchor;", "", "/*", " * Enumerated type for describing a style of justification:", " */", "", "typedef enum {", "    TK_JUSTIFY_LEFT, TK_JUSTIFY_RIGHT, TK_JUSTIFY_CENTER", "} Tk_Justify;", "", "/*", " * The following structure is used by Tk_GetFontMetrics() to return", " * information about the properties of a Tk_Font.", " */", "", "typedef struct Tk_FontMetrics {", "    int ascent;\t\t\t/* The amount in pixels that the tallest", "\t\t\t\t * letter sticks up above the baseline, plus", "\t\t\t\t * any extra blank space added by the designer", "\t\t\t\t * of the font. */", "    int descent;\t\t/* The largest amount in pixels that any", "\t\t\t\t * letter sticks below the baseline, plus any", "\t\t\t\t * extra blank space added by the designer of", "\t\t\t\t * the font. */", "    int linespace;\t\t/* The sum of the ascent and descent. How far", "\t\t\t\t * apart two lines of text in the same font", "\t\t\t\t * should be placed so that none of the", "\t\t\t\t * characters in one line overlap any of the", "\t\t\t\t * characters in the other line. */", "} Tk_FontMetrics;", "", "/*", " * Flags passed to Tk_MeasureChars:", " */", "", "#define TK_WHOLE_WORDS\t\t1", "#define TK_AT_LEAST_ONE\t\t2", "#define TK_PARTIAL_OK\t\t4", "", "/*", " * Flags passed to Tk_ComputeTextLayout:", " */", "", "#define TK_IGNORE_TABS\t\t8", "#define TK_IGNORE_NEWLINES\t16", "", "/*", " * Widget class procedures used to implement platform specific widget", " * behavior.", " */", "", "typedef Window (Tk_ClassCreateProc) _ANSI_ARGS_((Tk_Window tkwin,", "\tWindow parent, ClientData instanceData));", "typedef void (Tk_ClassWorldChangedProc) _ANSI_ARGS_((ClientData instanceData));", "typedef void (Tk_ClassModalProc) _ANSI_ARGS_((Tk_Window tkwin,", "\tXEvent *eventPtr));", "", "typedef struct Tk_ClassProcs {", "    unsigned int size;", "    Tk_ClassWorldChangedProc *worldChangedProc;", "\t\t\t\t/* Procedure to invoke when the widget needs", "\t\t\t\t * to respond in some way to a change in the", "\t\t\t\t * world (font changes, etc.) */", "    Tk_ClassCreateProc *createProc;", "\t\t\t\t/* Procedure to invoke when the platform-", "\t\t\t\t * dependent window needs to be created. */", "    Tk_ClassModalProc *modalProc;", "\t\t\t\t/* Procedure to invoke after all bindings on a", "\t\t\t\t * widget have been triggered in order to", "\t\t\t\t * handle a modal loop. */", "} Tk_ClassProcs;", "", "/*", " * Simple accessor for Tk_ClassProcs structure. Checks that the structure is", " * not NULL, then checks the size field and returns either the requested", " * field, if present, or NULL if the structure is too small to have the field", " * (or NULL if the structure is NULL).", " *", " * A more general version of this function may be useful if other", " * size-versioned structure pop up in the future:", " *", " *\t#define Tk_GetField(name, who, which) \\", " *\t    (((who) == NULL) ? NULL :", " *\t    (((who)->size <= Tk_Offset(name, which)) ? NULL :(name)->which))", " */", "", "#define Tk_GetClassProc(procs, which) \\", "    (((procs) == NULL) ? NULL : \\", "    (((procs)->size <= Tk_Offset(Tk_ClassProcs, which)) ? NULL:(procs)->which))", "", "/*", " * Each geometry manager (the packer, the placer, etc.) is represented by a", " * structure of the following form, which indicates procedures to invoke in", " * the geometry manager to carry out certain functions.", " */", "", "typedef void (Tk_GeomRequestProc) _ANSI_ARGS_((ClientData clientData,", "\tTk_Window tkwin));", "typedef void (Tk_GeomLostSlaveProc) _ANSI_ARGS_((ClientData clientData,", "\tTk_Window tkwin));", "", "typedef struct Tk_GeomMgr {", "    const char *name;\t\t/* Name of the geometry manager (command used", "\t\t\t\t * to invoke it, or name of widget class that", "\t\t\t\t * allows embedded widgets). */", "    Tk_GeomRequestProc *requestProc;", "\t\t\t\t/* Procedure to invoke when a slave's", "\t\t\t\t * requested geometry changes. */", "    Tk_GeomLostSlaveProc *lostSlaveProc;", "\t\t\t\t/* Procedure to invoke when a slave is taken", "\t\t\t\t * away from one geometry manager by another.", "\t\t\t\t * NULL means geometry manager doesn't care", "\t\t\t\t * when slaves are lost. */", "} Tk_GeomMgr;", "", "/*", " * Result values returned by Tk_GetScrollInfo:", " */", "", "#define TK_SCROLL_MOVETO\t1", "#define TK_SCROLL_PAGES\t\t2", "#define TK_SCROLL_UNITS\t\t3", "#define TK_SCROLL_ERROR\t\t4", "", "/*", " *---------------------------------------------------------------------------", " *", " * Extensions to the X event set", " *", " *---------------------------------------------------------------------------", " */", "", "#define VirtualEvent\t    (MappingNotify + 1)", "#define ActivateNotify\t    (MappingNotify + 2)", "#define DeactivateNotify    (MappingNotify + 3)", "#define MouseWheelEvent     (MappingNotify + 4)", "#define TK_LASTEVENT\t    (MappingNotify + 5)", "", "#define MouseWheelMask\t    (1L << 28)", "#define ActivateMask\t    (1L << 29)", "#define VirtualEventMask    (1L << 30)", "", "/*", " * A virtual event shares most of its fields with the XKeyEvent and", " * XButtonEvent structures. 99% of the time a virtual event will be an", " * abstraction of a key or button event, so this structure provides the most", " * information to the user. The only difference is the changing of the detail", " * field for a virtual event so that it holds the name of the virtual event", " * being triggered.", " *", " * When using this structure, you should ensure that you zero out all the", " * fields first using memset() or bzero().", " */", "", "typedef struct {", "    int type;", "    unsigned long serial;\t/* # of last request processed by server. */", "    Bool send_event;\t\t/* True if this came from a SendEvent", "\t\t\t\t * request. */", "    Display *display;\t\t/* Display the event was read from. */", "    Window event;\t\t/* Window on which event was requested. */", "    Window root;\t\t/* Root window that the event occured on. */", "    Window subwindow;\t\t/* Child window. */", "    Time time;\t\t\t/* Milliseconds. */", "    int x, y;\t\t\t/* Pointer x, y coordinates in event", "\t\t\t\t * window. */", "    int x_root, y_root;\t\t/* Coordinates relative to root. */", "    unsigned int state;\t\t/* Key or button mask */", "    Tk_Uid name;\t\t/* Name of virtual event. */", "    Bool same_screen;\t\t/* Same screen flag. */", "    Tcl_Obj *user_data;\t\t/* Application-specific data reference; Tk", "\t\t\t\t * will decrement the reference count *once*", "\t\t\t\t * when it has finished processing the", "\t\t\t\t * event. */", "} XVirtualEvent;", "", "typedef struct {", "    int type;", "    unsigned long serial;\t/* # of last request processed by server. */", "    Bool send_event;\t\t/* True if this came from a SendEvent", "\t\t\t\t * request. */", "    Display *display;\t\t/* Display the event was read from. */", "    Window window;\t\t/* Window in which event occurred. */", "} XActivateDeactivateEvent;", "typedef XActivateDeactivateEvent XActivateEvent;", "typedef XActivateDeactivateEvent XDeactivateEvent;", "\f", "/*", " *--------------------------------------------------------------", " *", " * Macros for querying Tk_Window structures. See the manual entries for", " * documentation.", " *", " *--------------------------------------------------------------", " */", "", "#define Tk_Display(tkwin)\t(((Tk_FakeWin *) (tkwin))->display)", "#define Tk_ScreenNumber(tkwin)\t(((Tk_FakeWin *) (tkwin))->screenNum)", "#define Tk_Screen(tkwin) \\", "    (ScreenOfDisplay(Tk_Display(tkwin), Tk_ScreenNumber(tkwin)))", "#define Tk_Depth(tkwin)\t\t(((Tk_FakeWin *) (tkwin))->depth)", "#define Tk_Visual(tkwin)\t(((Tk_FakeWin *) (tkwin))->visual)", "#define Tk_WindowId(tkwin)\t(((Tk_FakeWin *) (tkwin))->window)", "#define Tk_PathName(tkwin) \t(((Tk_FakeWin *) (tkwin))->pathName)", "#define Tk_Name(tkwin)\t\t(((Tk_FakeWin *) (tkwin))->nameUid)", "#define Tk_Class(tkwin) \t(((Tk_FakeWin *) (tkwin))->classUid)", "#define Tk_X(tkwin)\t\t(((Tk_FakeWin *) (tkwin))->changes.x)", "#define Tk_Y(tkwin)\t\t(((Tk_FakeWin *) (tkwin))->changes.y)", "#define Tk_Width(tkwin)\t\t(((Tk_FakeWin *) (tkwin))->changes.width)", "#define Tk_Height(tkwin) \\", "    (((Tk_FakeWin *) (tkwin))->changes.height)", "#define Tk_Changes(tkwin)\t(&((Tk_FakeWin *) (tkwin))->changes)", "#define Tk_Attributes(tkwin)\t(&((Tk_FakeWin *) (tkwin))->atts)", "#define Tk_IsEmbedded(tkwin) \\", "    (((Tk_FakeWin *) (tkwin))->flags & TK_EMBEDDED)", "#define Tk_IsContainer(tkwin) \\", "    (((Tk_FakeWin *) (tkwin))->flags & TK_CONTAINER)", "#define Tk_IsMapped(tkwin) \\", "    (((Tk_FakeWin *) (tkwin))->flags & TK_MAPPED)", "#define Tk_IsTopLevel(tkwin) \\", "    (((Tk_FakeWin *) (tkwin))->flags & TK_TOP_LEVEL)", "#define Tk_HasWrapper(tkwin) \\", "    (((Tk_FakeWin *) (tkwin))->flags & TK_HAS_WRAPPER)", "#define Tk_WinManaged(tkwin) \\", "    (((Tk_FakeWin *) (tkwin))->flags & TK_WIN_MANAGED)", "#define Tk_TopWinHierarchy(tkwin) \\", "    (((Tk_FakeWin *) (tkwin))->flags & TK_TOP_HIERARCHY)", "#define Tk_IsManageable(tkwin) \\", "    (((Tk_FakeWin *) (tkwin))->flags & TK_WM_MANAGEABLE)", "#define Tk_ReqWidth(tkwin)\t(((Tk_FakeWin *) (tkwin))->reqWidth)", "#define Tk_ReqHeight(tkwin)\t(((Tk_FakeWin *) (tkwin))->reqHeight)", "/* Tk_InternalBorderWidth is deprecated */", "#define Tk_InternalBorderWidth(tkwin) \\", "    (((Tk_FakeWin *) (tkwin))->internalBorderLeft)", "#define Tk_InternalBorderLeft(tkwin) \\", "    (((Tk_FakeWin *) (tkwin))->internalBorderLeft)", "#define Tk_InternalBorderRight(tkwin) \\", "    (((Tk_FakeWin *) (tkwin))->internalBorderRight)", "#define Tk_InternalBorderTop(tkwin) \\", "    (((Tk_FakeWin *) (tkwin))->internalBorderTop)", "#define Tk_InternalBorderBottom(tkwin) \\", "    (((Tk_FakeWin *) (tkwin))->internalBorderBottom)", "#define Tk_MinReqWidth(tkwin)\t(((Tk_FakeWin *) (tkwin))->minReqWidth)", "#define Tk_MinReqHeight(tkwin)\t(((Tk_FakeWin *) (tkwin))->minReqHeight)", "#define Tk_Parent(tkwin)\t(((Tk_FakeWin *) (tkwin))->parentPtr)", "#define Tk_Colormap(tkwin)\t(((Tk_FakeWin *) (tkwin))->atts.colormap)", "", "/*", " * The structure below is needed by the macros above so that they can access", " * the fields of a Tk_Window. The fields not needed by the macros are declared", ' * as "dummyX". The structure has its own type in order to prevent apps from', " * accessing Tk_Window fields except using official macros. WARNING!! The", " * structure definition must be kept consistent with the TkWindow structure in", " * tkInt.h. If you change one, then change the other. See the declaration in", " * tkInt.h for documentation on what the fields are used for internally.", " */", "", "typedef struct Tk_FakeWin {", "    Display *display;", "    char *dummy1;\t\t/* dispPtr */", "    int screenNum;", "    Visual *visual;", "    int depth;", "    Window window;", "    char *dummy2;\t\t/* childList */", "    char *dummy3;\t\t/* lastChildPtr */", "    Tk_Window parentPtr;\t/* parentPtr */", "    char *dummy4;\t\t/* nextPtr */", "    char *dummy5;\t\t/* mainPtr */", "    char *pathName;", "    Tk_Uid nameUid;", "    Tk_Uid classUid;", "    XWindowChanges changes;", "    unsigned int dummy6;\t/* dirtyChanges */", "    XSetWindowAttributes atts;", "    unsigned long dummy7;\t/* dirtyAtts */", "    unsigned int flags;", "    char *dummy8;\t\t/* handlerList */", "#ifdef TK_USE_INPUT_METHODS", "    XIC dummy9;\t\t\t/* inputContext */", "#endif /* TK_USE_INPUT_METHODS */", "    ClientData *dummy10;\t/* tagPtr */", "    int dummy11;\t\t/* numTags */", "    int dummy12;\t\t/* optionLevel */", "    char *dummy13;\t\t/* selHandlerList */", "    char *dummy14;\t\t/* geomMgrPtr */", "    ClientData dummy15;\t\t/* geomData */", "    int reqWidth, reqHeight;", "    int internalBorderLeft;", "    char *dummy16;\t\t/* wmInfoPtr */", "    char *dummy17;\t\t/* classProcPtr */", "    ClientData dummy18;\t\t/* instanceData */", "    char *dummy19;\t\t/* privatePtr */", "    int internalBorderRight;", "    int internalBorderTop;", "    int internalBorderBottom;", "    int minReqWidth;", "    int minReqHeight;", "} Tk_FakeWin;", "", "/*", " * Flag values for TkWindow (and Tk_FakeWin) structures are:", " *", " * TK_MAPPED:\t\t\t1 means window is currently mapped,", " *\t\t\t\t0 means unmapped.", " * TK_TOP_LEVEL:\t\t1 means this is a top-level widget.", " * TK_ALREADY_DEAD:\t\t1 means the window is in the process of", " *\t\t\t\tbeing destroyed already.", " * TK_NEED_CONFIG_NOTIFY:\t1 means that the window has been reconfigured", " *\t\t\t\tbefore it was made to exist. At the time of", " *\t\t\t\tmaking it exist a ConfigureNotify event needs", " *\t\t\t\tto be generated.", " * TK_GRAB_FLAG:\t\tUsed to manage grabs. See tkGrab.c for details", " * TK_CHECKED_IC:\t\t1 means we've already tried to get an input", " *\t\t\t\tcontext for this window; if the ic field is", " *\t\t\t\tNULL it means that there isn't a context for", " *\t\t\t\tthe field.", " * TK_DONT_DESTROY_WINDOW:\t1 means that Tk_DestroyWindow should not", " *\t\t\t\tinvoke XDestroyWindow to destroy this widget's", " *\t\t\t\tX window. The flag is set when the window has", " *\t\t\t\talready been destroyed elsewhere (e.g. by", " *\t\t\t\tanother application) or when it will be", " *\t\t\t\tdestroyed later (e.g. by destroying its parent)", " * TK_WM_COLORMAP_WINDOW:\t1 means that this window has at some time", " *\t\t\t\tappeared in the WM_COLORMAP_WINDOWS property", " *\t\t\t\tfor its toplevel, so we have to remove it from", " *\t\t\t\tthat property if the window is deleted and the", " *\t\t\t\ttoplevel isn't.", " * TK_EMBEDDED:\t\t\t1 means that this window (which must be a", " *\t\t\t\ttoplevel) is not a free-standing window but", " *\t\t\t\trather is embedded in some other application.", " * TK_CONTAINER:\t\t1 means that this window is a container, and", " *\t\t\t\tthat some other application (either in this", " *\t\t\t\tprocess or elsewhere) may be embedding itself", " *\t\t\t\tinside the window.", " * TK_BOTH_HALVES:\t\t1 means that this window is used for", " *\t\t\t\tapplication embedding (either as container or", " *\t\t\t\tembedded application), and both the containing", " *\t\t\t\tand embedded halves are associated with", " *\t\t\t\twindows in this particular process.", " * TK_DEFER_MODAL:\t\t1 means that this window has deferred a modal", " *\t\t\t\tloop until all of the bindings for the current", " *\t\t\t\tevent have been invoked.", " * TK_WRAPPER:\t\t\t1 means that this window is the extra wrapper", " *\t\t\t\twindow created around a toplevel to hold the", " *\t\t\t\tmenubar under Unix. See tkUnixWm.c for more", " *\t\t\t\tinformation.", " * TK_REPARENTED:\t\t1 means that this window has been reparented", " *\t\t\t\tso that as far as the window system is", " *\t\t\t\tconcerned it isn't a child of its Tk parent.", " *\t\t\t\tInitially this is used only for special Unix", " *\t\t\t\tmenubar windows.", " * TK_ANONYMOUS_WINDOW:\t\t1 means that this window has no name, and is", " *\t\t\t\tthus not accessible from Tk.", " * TK_HAS_WRAPPER\t\t1 means that this window has a wrapper window", " * TK_WIN_MANAGED\t\t1 means that this window is a child of the root", " *\t\t\t\twindow, and is managed by the window manager.", " * TK_TOP_HIERARCHY\t\t1 means this window is at the top of a physical", " *\t\t\t\twindow hierarchy within this process, i.e. the", " *\t\t\t\twindow's parent either doesn't exist or is not", " *\t\t\t\towned by this Tk application.", " * TK_PROP_PROPCHANGE\t\t1 means that PropertyNotify events in the", " *\t\t\t\twindow's children should propagate up to this", " *\t\t\t\twindow.", " * TK_WM_MANAGEABLE\t\t1 marks a window as capable of being converted", " *\t\t\t\tinto a toplevel using [wm manage].", " */", "", "#define TK_MAPPED\t\t1", "#define TK_TOP_LEVEL\t\t2", "#define TK_ALREADY_DEAD\t\t4", "#define TK_NEED_CONFIG_NOTIFY\t8", "#define TK_GRAB_FLAG\t\t0x10", "#define TK_CHECKED_IC\t\t0x20", "#define TK_DONT_DESTROY_WINDOW\t0x40", "#define TK_WM_COLORMAP_WINDOW\t0x80", "#define TK_EMBEDDED\t\t0x100", "#define TK_CONTAINER\t\t0x200", "#define TK_BOTH_HALVES\t\t0x400", "#define TK_DEFER_MODAL\t\t0x800", "#define TK_WRAPPER\t\t0x1000", "#define TK_REPARENTED\t\t0x2000", "#define TK_ANONYMOUS_WINDOW\t0x4000", "#define TK_HAS_WRAPPER\t\t0x8000", "#define TK_WIN_MANAGED\t\t0x10000", "#define TK_TOP_HIERARCHY\t0x20000", "#define TK_PROP_PROPCHANGE\t0x40000", "#define TK_WM_MANAGEABLE\t0x80000", "\f", "/*", " *--------------------------------------------------------------", " *", " * Procedure prototypes and structures used for defining new canvas items:", " *", " *--------------------------------------------------------------", " */", "", "typedef enum {", "    TK_STATE_NULL = -1, TK_STATE_ACTIVE, TK_STATE_DISABLED,", "    TK_STATE_NORMAL, TK_STATE_HIDDEN", "} Tk_State;", "", "typedef struct Tk_SmoothMethod {", "    char *name;", "    int (*coordProc) _ANSI_ARGS_((Tk_Canvas canvas,", "\t\tdouble *pointPtr, int numPoints, int numSteps,", "\t\tXPoint xPoints[], double dblPoints[]));", "    void (*postscriptProc) _ANSI_ARGS_((Tcl_Interp *interp,", "\t\tTk_Canvas canvas, double *coordPtr,", "\t\tint numPoints, int numSteps));", "} Tk_SmoothMethod;", "", "/*", " * For each item in a canvas widget there exists one record with the following", " * structure. Each actual item is represented by a record with the following", " * stuff at its beginning, plus additional type-specific stuff after that.", " */", "", "#define TK_TAG_SPACE 3", "", "typedef struct Tk_Item {", "    int id;\t\t\t/* Unique identifier for this item (also", "\t\t\t\t * serves as first tag for item). */", "    struct Tk_Item *nextPtr;\t/* Next in display list of all items in this", "\t\t\t\t * canvas. Later items in list are drawn on", "\t\t\t\t * top of earlier ones. */", "    Tk_Uid staticTagSpace[TK_TAG_SPACE];", "\t\t\t\t/* Built-in space for limited # of tags. */", "    Tk_Uid *tagPtr;\t\t/* Pointer to array of tags. Usually points to", "\t\t\t\t * staticTagSpace, but may point to malloc-ed", "\t\t\t\t * space if there are lots of tags. */", "    int tagSpace;\t\t/* Total amount of tag space available at", "\t\t\t\t * tagPtr. */", "    int numTags;\t\t/* Number of tag slots actually used at", "\t\t\t\t * *tagPtr. */", "    struct Tk_ItemType *typePtr;/* Table of procedures that implement this", "\t\t\t\t * type of item. */", "    int x1, y1, x2, y2;\t\t/* Bounding box for item, in integer canvas", "\t\t\t\t * units. Set by item-specific code and", "\t\t\t\t * guaranteed to contain every pixel drawn in", "\t\t\t\t * item. Item area includes x1 and y1 but not", "\t\t\t\t * x2 and y2. */", "    struct Tk_Item *prevPtr;\t/* Previous in display list of all items in", "\t\t\t\t * this canvas. Later items in list are drawn", "\t\t\t\t * just below earlier ones. */", "    Tk_State state;\t\t/* State of item. */", "    char *reserved1;\t\t/* reserved for future use */", "    int redraw_flags;\t\t/* Some flags used in the canvas */", "", "    /*", "     *------------------------------------------------------------------", "     * Starting here is additional type-specific stuff; see the declarations", "     * for individual types to see what is part of each type. The actual space", "     * below is determined by the \"itemInfoSize\" of the type's Tk_ItemType", "     * record.", "     *------------------------------------------------------------------", "     */", "} Tk_Item;", "", "/*", " * Flag bits for canvases (redraw_flags):", " *", " * TK_ITEM_STATE_DEPENDANT -\t1 means that object needs to be redrawn if the", " *\t\t\t\tcanvas state changes.", " * TK_ITEM_DONT_REDRAW - \t1 means that the object redraw is already been", " *\t\t\t\tprepared, so the general canvas code doesn't", " *\t\t\t\tneed to do that any more.", " */", "", "#define TK_ITEM_STATE_DEPENDANT\t\t1", "#define TK_ITEM_DONT_REDRAW\t\t2", "", "/*", " * Records of the following type are used to describe a type of item (e.g.", " * lines, circles, etc.) that can form part of a canvas widget.", " */", "", "#ifdef USE_OLD_CANVAS", "typedef int\tTk_ItemCreateProc _ANSI_ARGS_((Tcl_Interp *interp,", "\t\t    Tk_Canvas canvas, Tk_Item *itemPtr, int argc,", "\t\t    char **argv));", "typedef int\tTk_ItemConfigureProc _ANSI_ARGS_((Tcl_Interp *interp,", "\t\t    Tk_Canvas canvas, Tk_Item *itemPtr, int argc,", "\t\t    char **argv, int flags));", "typedef int\tTk_ItemCoordProc _ANSI_ARGS_((Tcl_Interp *interp,", "\t\t    Tk_Canvas canvas, Tk_Item *itemPtr, int argc,", "\t\t    char **argv));", "#else", "typedef int\tTk_ItemCreateProc _ANSI_ARGS_((Tcl_Interp *interp,", "\t\t    Tk_Canvas canvas, Tk_Item *itemPtr, int argc,", "\t\t    Tcl_Obj *const objv[]));", "typedef int\tTk_ItemConfigureProc _ANSI_ARGS_((Tcl_Interp *interp,", "\t\t    Tk_Canvas canvas, Tk_Item *itemPtr, int argc,", "\t\t    Tcl_Obj *const objv[], int flags));", "typedef int\tTk_ItemCoordProc _ANSI_ARGS_((Tcl_Interp *interp,", "\t\t    Tk_Canvas canvas, Tk_Item *itemPtr, int argc,", "\t\t    Tcl_Obj *const argv[]));", "#endif", "typedef void\tTk_ItemDeleteProc _ANSI_ARGS_((Tk_Canvas canvas,", "\t\t    Tk_Item *itemPtr, Display *display));", "typedef void\tTk_ItemDisplayProc _ANSI_ARGS_((Tk_Canvas canvas,", "\t\t    Tk_Item *itemPtr, Display *display, Drawable dst,", "\t\t    int x, int y, int width, int height));", "typedef double\tTk_ItemPointProc _ANSI_ARGS_((Tk_Canvas canvas,", "\t\t    Tk_Item *itemPtr, double *pointPtr));", "typedef int\tTk_ItemAreaProc _ANSI_ARGS_((Tk_Canvas canvas,", "\t\t    Tk_Item *itemPtr, double *rectPtr));", "typedef int\tTk_ItemPostscriptProc _ANSI_ARGS_((Tcl_Interp *interp,", "\t\t    Tk_Canvas canvas, Tk_Item *itemPtr, int prepass));", "typedef void\tTk_ItemScaleProc _ANSI_ARGS_((Tk_Canvas canvas,", "\t\t    Tk_Item *itemPtr, double originX, double originY,", "\t\t    double scaleX, double scaleY));", "typedef void\tTk_ItemTranslateProc _ANSI_ARGS_((Tk_Canvas canvas,", "\t\t    Tk_Item *itemPtr, double deltaX, double deltaY));", "typedef int\tTk_ItemIndexProc _ANSI_ARGS_((Tcl_Interp *interp,", "\t\t    Tk_Canvas canvas, Tk_Item *itemPtr, char *indexString,", "\t\t    int *indexPtr));", "typedef void\tTk_ItemCursorProc _ANSI_ARGS_((Tk_Canvas canvas,", "\t\t    Tk_Item *itemPtr, int index));", "typedef int\tTk_ItemSelectionProc _ANSI_ARGS_((Tk_Canvas canvas,", "\t\t    Tk_Item *itemPtr, int offset, char *buffer,", "\t\t    int maxBytes));", "typedef void\tTk_ItemInsertProc _ANSI_ARGS_((Tk_Canvas canvas,", "\t\t    Tk_Item *itemPtr, int beforeThis, char *string));", "typedef void\tTk_ItemDCharsProc _ANSI_ARGS_((Tk_Canvas canvas,", "\t\t    Tk_Item *itemPtr, int first, int last));", "", "#ifndef __NO_OLD_CONFIG", "", "typedef struct Tk_ItemType {", "    char *name;\t\t\t/* The name of this type of item, such as", '\t\t\t\t * "line". */', "    int itemSize;\t\t/* Total amount of space needed for item's", "\t\t\t\t * record. */", "    Tk_ItemCreateProc *createProc;", "\t\t\t\t/* Procedure to create a new item of this", "\t\t\t\t * type. */", "    Tk_ConfigSpec *configSpecs;\t/* Pointer to array of configuration specs for", "\t\t\t\t * this type. Used for returning configuration", "\t\t\t\t * info. */", "    Tk_ItemConfigureProc *configProc;", "\t\t\t\t/* Procedure to call to change configuration", "\t\t\t\t * options. */", "    Tk_ItemCoordProc *coordProc;/* Procedure to call to get and set the item's", "\t\t\t\t * coordinates. */", "    Tk_ItemDeleteProc *deleteProc;", "\t\t\t\t/* Procedure to delete existing item of this", "\t\t\t\t * type. */", "    Tk_ItemDisplayProc *displayProc;", "\t\t\t\t/* Procedure to display items of this type. */", "    int alwaysRedraw;\t\t/* Non-zero means displayProc should be called", "\t\t\t\t * even when the item has been moved", "\t\t\t\t * off-screen. */", "    Tk_ItemPointProc *pointProc;/* Computes distance from item to a given", "\t\t\t\t * point. */", "    Tk_ItemAreaProc *areaProc;\t/* Computes whether item is inside, outside,", "\t\t\t\t * or overlapping an area. */", "    Tk_ItemPostscriptProc *postscriptProc;", "\t\t\t\t/* Procedure to write a Postscript description", "\t\t\t\t * for items of this type. */", "    Tk_ItemScaleProc *scaleProc;/* Procedure to rescale items of this type. */", "    Tk_ItemTranslateProc *translateProc;", "\t\t\t\t/* Procedure to translate items of this", "\t\t\t\t * type. */", "    Tk_ItemIndexProc *indexProc;/* Procedure to determine index of indicated", "\t\t\t\t * character. NULL if item doesn't support", "\t\t\t\t * indexing. */", "    Tk_ItemCursorProc *icursorProc;", "\t\t\t\t/* Procedure to set insert cursor posn to just", "\t\t\t\t * before a given position. */", "    Tk_ItemSelectionProc *selectionProc;", "\t\t\t\t/* Procedure to return selection (in STRING", "\t\t\t\t * format) when it is in this item. */", "    Tk_ItemInsertProc *insertProc;", "\t\t\t\t/* Procedure to insert something into an", "\t\t\t\t * item. */", "    Tk_ItemDCharsProc *dCharsProc;", "\t\t\t\t/* Procedure to delete characters from an", "\t\t\t\t * item. */", "    struct Tk_ItemType *nextPtr;/* Used to link types together into a list. */", "    char *reserved1;\t\t/* Reserved for future extension. */", "    int reserved2;\t\t/* Carefully compatible with */", "    char *reserved3;\t\t/* Jan Nijtmans dash patch */", "    char *reserved4;", "} Tk_ItemType;", "", "#endif", "", "/*", " * The following structure provides information about the selection and the", " * insertion cursor. It is needed by only a few items, such as those that", " * display text. It is shared by the generic canvas code and the item-specific", " * code, but most of the fields should be written only by the canvas generic", " * code.", " */", "", "typedef struct Tk_CanvasTextInfo {", "    Tk_3DBorder selBorder;\t/* Border and background for selected", "\t\t\t\t * characters. Read-only to items.*/", "    int selBorderWidth;\t\t/* Width of border around selection. Read-only", "\t\t\t\t * to items. */", "    XColor *selFgColorPtr;\t/* Foreground color for selected text.", "\t\t\t\t * Read-only to items. */", "    Tk_Item *selItemPtr;\t/* Pointer to selected item. NULL means", "\t\t\t\t * selection isn't in this canvas. Writable by", "\t\t\t\t * items. */", "    int selectFirst;\t\t/* Character index of first selected", "\t\t\t\t * character. Writable by items. */", "    int selectLast;\t\t/* Character index of last selected character.", "\t\t\t\t * Writable by items. */", '    Tk_Item *anchorItemPtr;\t/* Item corresponding to "selectAnchor": not', "\t\t\t\t * necessarily selItemPtr. Read-only to", "\t\t\t\t * items. */", "    int selectAnchor;\t\t/* Character index of fixed end of selection", '\t\t\t\t * (i.e. "select to" operation will use this', "\t\t\t\t * as one end of the selection). Writable by", "\t\t\t\t * items. */", "    Tk_3DBorder insertBorder;\t/* Used to draw vertical bar for insertion", "\t\t\t\t * cursor. Read-only to items. */", "    int insertWidth;\t\t/* Total width of insertion cursor. Read-only", "\t\t\t\t * to items. */", "    int insertBorderWidth;\t/* Width of 3-D border around insert cursor.", "\t\t\t\t * Read-only to items. */", "    Tk_Item *focusItemPtr;\t/* Item that currently has the input focus, or", "\t\t\t\t * NULL if no such item. Read-only to items. */", "    int gotFocus;\t\t/* Non-zero means that the canvas widget has", "\t\t\t\t * the input focus. Read-only to items.*/", "    int cursorOn;\t\t/* Non-zero means that an insertion cursor", "\t\t\t\t * should be displayed in focusItemPtr.", "\t\t\t\t * Read-only to items.*/", "} Tk_CanvasTextInfo;", "\f", "/*", " * Structures used for Dashing and Outline.", " */", "", "typedef struct Tk_Dash {", "    int number;", "    union {", "\tchar *pt;", "\tchar array[sizeof(char *)];", "    } pattern;", "} Tk_Dash;", "", "typedef struct Tk_TSOffset {", "    int flags;\t\t\t/* Flags; see below for possible values */", "    int xoffset;\t\t/* x offset */", "    int yoffset;\t\t/* y offset */", "} Tk_TSOffset;", "", "/*", " * Bit fields in Tk_Offset->flags:", " */", "", "#define TK_OFFSET_INDEX\t\t1", "#define TK_OFFSET_RELATIVE\t2", "#define TK_OFFSET_LEFT\t\t4", "#define TK_OFFSET_CENTER\t8", "#define TK_OFFSET_RIGHT\t\t16", "#define TK_OFFSET_TOP\t\t32", "#define TK_OFFSET_MIDDLE\t64", "#define TK_OFFSET_BOTTOM\t128", "", "typedef struct Tk_Outline {", "    GC gc;\t\t\t/* Graphics context. */", "    double width;\t\t/* Width of outline. */", "    double activeWidth;\t\t/* Width of outline. */", "    double disabledWidth;\t/* Width of outline. */", "    int offset;\t\t\t/* Dash offset. */", "    Tk_Dash dash;\t\t/* Dash pattern. */", "    Tk_Dash activeDash;\t\t/* Dash pattern if state is active. */", "    Tk_Dash disabledDash;\t/* Dash pattern if state is disabled. */", "    VOID *reserved1;\t\t/* Reserved for future expansion. */", "    VOID *reserved2;", "    VOID *reserved3;", "    Tk_TSOffset tsoffset;\t/* Stipple offset for outline. */", "    XColor *color;\t\t/* Outline color. */", "    XColor *activeColor;\t/* Outline color if state is active. */", "    XColor *disabledColor;\t/* Outline color if state is disabled. */", "    Pixmap stipple;\t\t/* Outline Stipple pattern. */", "    Pixmap activeStipple;\t/* Outline Stipple pattern if state is", "\t\t\t\t * active. */", "    Pixmap disabledStipple;\t/* Outline Stipple pattern if state is", "\t\t\t\t * disabled. */", "} Tk_Outline;", "\f", "/*", " *--------------------------------------------------------------", " *", " * Procedure prototypes and structures used for managing images:", " *", " *--------------------------------------------------------------", " */", "", "typedef struct Tk_ImageType Tk_ImageType;", "#ifdef USE_OLD_IMAGE", "typedef int (Tk_ImageCreateProc) _ANSI_ARGS_((Tcl_Interp *interp,", "\tchar *name, int argc, char **argv, Tk_ImageType *typePtr,", "\tTk_ImageMaster master, ClientData *masterDataPtr));", "#else", "typedef int (Tk_ImageCreateProc) _ANSI_ARGS_((Tcl_Interp *interp,", "\tchar *name, int objc, Tcl_Obj *const objv[], Tk_ImageType *typePtr,", "\tTk_ImageMaster master, ClientData *masterDataPtr));", "#endif", "typedef ClientData (Tk_ImageGetProc) _ANSI_ARGS_((Tk_Window tkwin,", "\tClientData masterData));", "typedef void (Tk_ImageDisplayProc) _ANSI_ARGS_((ClientData instanceData,", "\tDisplay *display, Drawable drawable, int imageX, int imageY,", "\tint width, int height, int drawableX, int drawableY));", "typedef void (Tk_ImageFreeProc) _ANSI_ARGS_((ClientData instanceData,", "\tDisplay *display));", "typedef void (Tk_ImageDeleteProc) _ANSI_ARGS_((ClientData masterData));", "typedef void (Tk_ImageChangedProc) _ANSI_ARGS_((ClientData clientData,", "\tint x, int y, int width, int height, int imageWidth,", "\tint imageHeight));", "typedef int (Tk_ImagePostscriptProc) _ANSI_ARGS_((ClientData clientData,", "\tTcl_Interp *interp, Tk_Window tkwin, Tk_PostscriptInfo psinfo,", "\tint x, int y, int width, int height, int prepass));", "", "/*", " * The following structure represents a particular type of image (bitmap, xpm", " * image, etc.). It provides information common to all images of that type,", " * such as the type name and a collection of procedures in the image manager", " * that respond to various events. Each image manager is represented by one of", " * these structures.", " */", "", "struct Tk_ImageType {", "    char *name;\t\t\t/* Name of image type. */", "    Tk_ImageCreateProc *createProc;", "\t\t\t\t/* Procedure to call to create a new image of", "\t\t\t\t * this type. */", "    Tk_ImageGetProc *getProc;\t/* Procedure to call the first time", "\t\t\t\t * Tk_GetImage is called in a new way (new", "\t\t\t\t * visual or screen). */", "    Tk_ImageDisplayProc *displayProc;", "\t\t\t\t/* Call to draw image, in response to", "\t\t\t\t * Tk_RedrawImage calls. */", "    Tk_ImageFreeProc *freeProc;\t/* Procedure to call whenever Tk_FreeImage is", "\t\t\t\t * called to release an instance of an", "\t\t\t\t * image. */", "    Tk_ImageDeleteProc *deleteProc;", "\t\t\t\t/* Procedure to call to delete image. It will", "\t\t\t\t * not be called until after freeProc has been", "\t\t\t\t * called for each instance of the image. */", "    Tk_ImagePostscriptProc *postscriptProc;", "\t\t\t\t/* Procedure to call to produce postscript", "\t\t\t\t * output for the image. */", "    struct Tk_ImageType *nextPtr;", "\t\t\t\t/* Next in list of all image types currently", "\t\t\t\t * known. Filled in by Tk, not by image", "\t\t\t\t * manager. */", "    char *reserved;\t\t/* reserved for future expansion */", "};", "\f", "/*", " *--------------------------------------------------------------", " *", ' * Additional definitions used to manage images of type "photo".', " *", " *--------------------------------------------------------------", " */", "", "/*", " * The following type is used to identify a particular photo image to be", " * manipulated:", " */", "", "typedef void *Tk_PhotoHandle;", "", "/*", " * The following structure describes a block of pixels in memory:", " */", "", "typedef struct Tk_PhotoImageBlock {", "    unsigned char *pixelPtr;\t/* Pointer to the first pixel. */", "    int width;\t\t\t/* Width of block, in pixels. */", "    int height;\t\t\t/* Height of block, in pixels. */", "    int pitch;\t\t\t/* Address difference between corresponding", "\t\t\t\t * pixels in successive lines. */", "    int pixelSize;\t\t/* Address difference between successive", "\t\t\t\t * pixels in the same line. */", "    int offset[4];\t\t/* Address differences between the red, green,", "\t\t\t\t * blue and alpha components of the pixel and", "\t\t\t\t * the pixel as a whole. */", "} Tk_PhotoImageBlock;", "", "/*", " * The following values control how blocks are combined into photo images when", " * the alpha component of a pixel is not 255, a.k.a. the compositing rule.", " */", "", "#define TK_PHOTO_COMPOSITE_OVERLAY\t0", "#define TK_PHOTO_COMPOSITE_SET\t\t1", "", "/*", " * Procedure prototypes and structures used in reading and writing photo", " * images:", " */", "", "typedef struct Tk_PhotoImageFormat Tk_PhotoImageFormat;", "#ifdef USE_OLD_IMAGE", "typedef int (Tk_ImageFileMatchProc) _ANSI_ARGS_((Tcl_Channel chan,", "\tchar *fileName, char *formatString, int *widthPtr, int *heightPtr));", "typedef int (Tk_ImageStringMatchProc) _ANSI_ARGS_((char *string,", "\tchar *formatString, int *widthPtr, int *heightPtr));", "typedef int (Tk_ImageFileReadProc) _ANSI_ARGS_((Tcl_Interp *interp,", "\tTcl_Channel chan, char *fileName, char *formatString,", "\tTk_PhotoHandle imageHandle, int destX, int destY,", "\tint width, int height, int srcX, int srcY));", "typedef int (Tk_ImageStringReadProc) _ANSI_ARGS_((Tcl_Interp *interp,", "\tchar *string, char *formatString, Tk_PhotoHandle imageHandle,", "\tint destX, int destY, int width, int height, int srcX, int srcY));", "typedef int (Tk_ImageFileWriteProc) _ANSI_ARGS_((Tcl_Interp *interp,", "\tchar *fileName, char *formatString, Tk_PhotoImageBlock *blockPtr));", "typedef int (Tk_ImageStringWriteProc) _ANSI_ARGS_((Tcl_Interp *interp,", "\tTcl_DString *dataPtr, char *formatString,", "\tTk_PhotoImageBlock *blockPtr));", "#else", "typedef int (Tk_ImageFileMatchProc) _ANSI_ARGS_((Tcl_Channel chan,", "\tconst char *fileName, Tcl_Obj *format, int *widthPtr,", "\tint *heightPtr, Tcl_Interp *interp));", "typedef int (Tk_ImageStringMatchProc) _ANSI_ARGS_((Tcl_Obj *dataObj,", "\tTcl_Obj *format, int *widthPtr, int *heightPtr,", "\tTcl_Interp *interp));", "typedef int (Tk_ImageFileReadProc) _ANSI_ARGS_((Tcl_Interp *interp,", "\tTcl_Channel chan, const char *fileName, Tcl_Obj *format,", "\tTk_PhotoHandle imageHandle, int destX, int destY,", "\tint width, int height, int srcX, int srcY));", "typedef int (Tk_ImageStringReadProc) _ANSI_ARGS_((Tcl_Interp *interp,", "\tTcl_Obj *dataObj, Tcl_Obj *format, Tk_PhotoHandle imageHandle,", "\tint destX, int destY, int width, int height, int srcX, int srcY));", "typedef int (Tk_ImageFileWriteProc) _ANSI_ARGS_((Tcl_Interp *interp,", "\tconst char *fileName, Tcl_Obj *format, Tk_PhotoImageBlock *blockPtr));", "typedef int (Tk_ImageStringWriteProc) _ANSI_ARGS_((Tcl_Interp *interp,", "\tTcl_Obj *format, Tk_PhotoImageBlock *blockPtr));", "#endif", "", "/*", " * The following structure represents a particular file format for storing", " * images (e.g., PPM, GIF, JPEG, etc.). It provides information to allow image", " * files of that format to be recognized and read into a photo image.", " */", "", "struct Tk_PhotoImageFormat {", "    char *name;\t\t\t/* Name of image file format */", "    Tk_ImageFileMatchProc *fileMatchProc;", "\t\t\t\t/* Procedure to call to determine whether an", "\t\t\t\t * image file matches this format. */", "    Tk_ImageStringMatchProc *stringMatchProc;", "\t\t\t\t/* Procedure to call to determine whether the", "\t\t\t\t * data in a string matches this format. */", "    Tk_ImageFileReadProc *fileReadProc;", "\t\t\t\t/* Procedure to call to read data from an", "\t\t\t\t * image file into a photo image. */", "    Tk_ImageStringReadProc *stringReadProc;", "\t\t\t\t/* Procedure to call to read data from a", "\t\t\t\t * string into a photo image. */", "    Tk_ImageFileWriteProc *fileWriteProc;", "\t\t\t\t/* Procedure to call to write data from a", "\t\t\t\t * photo image to a file. */", "    Tk_ImageStringWriteProc *stringWriteProc;", "\t\t\t\t/* Procedure to call to obtain a string", "\t\t\t\t * representation of the data in a photo", "\t\t\t\t * image.*/", "    struct Tk_PhotoImageFormat *nextPtr;", "\t\t\t\t/* Next in list of all photo image formats", "\t\t\t\t * currently known. Filled in by Tk, not by", "\t\t\t\t * image format handler. */", "};", "", "#ifdef USE_OLD_IMAGE", "#define Tk_CreateImageType Tk_CreateOldImageType", "#define Tk_CreatePhotoImageFormat Tk_CreateOldPhotoImageFormat", "#endif", "\f", "/*", " *--------------------------------------------------------------", " *", " * Procedure prototypes and structures used for managing styles:", " *", " *--------------------------------------------------------------", " */", "", "/*", " * Style support version tag.", " */", "", "#define TK_STYLE_VERSION_1      0x1", "#define TK_STYLE_VERSION        TK_STYLE_VERSION_1", "", "/*", " * The following structures and prototypes are used as static templates to", " * declare widget elements.", " */", "", "typedef void (Tk_GetElementSizeProc) _ANSI_ARGS_((ClientData clientData,", "        char *recordPtr, const Tk_OptionSpec **optionsPtr, Tk_Window tkwin,", "        int width, int height, int inner, int *widthPtr, int *heightPtr));", "typedef void (Tk_GetElementBoxProc) _ANSI_ARGS_((ClientData clientData,", "        char *recordPtr, const Tk_OptionSpec **optionsPtr, Tk_Window tkwin,", "        int x, int y, int width, int height, int inner, int *xPtr, int *yPtr,", "        int *widthPtr, int *heightPtr));", "typedef int (Tk_GetElementBorderWidthProc) _ANSI_ARGS_((ClientData clientData,", "        char *recordPtr, const Tk_OptionSpec **optionsPtr, Tk_Window tkwin));", "typedef void (Tk_DrawElementProc) _ANSI_ARGS_((ClientData clientData,", "        char *recordPtr, const Tk_OptionSpec **optionsPtr, Tk_Window tkwin,", "        Drawable d, int x, int y, int width, int height, int state));", "", "typedef struct Tk_ElementOptionSpec {", "    char *name;                 /* Name of the required option. */", "    Tk_OptionType type;         /* Accepted option type. TK_OPTION_END means", "                                 * any. */", "} Tk_ElementOptionSpec;", "", "typedef struct Tk_ElementSpec {", "    int version;                /* Version of the style support. */", "    char *name;                 /* Name of element. */", "    Tk_ElementOptionSpec *options;", "                                /* List of required options. Last one's name", "                                 * must be NULL. */", "    Tk_GetElementSizeProc *getSize;", "                                /* Compute the external (resp. internal) size", "                                 * of the element from its desired internal", "                                 * (resp. external) size. */", "    Tk_GetElementBoxProc *getBox;", "                                /* Compute the inscribed or bounding boxes", "                                 * within a given area. */", "    Tk_GetElementBorderWidthProc *getBorderWidth;", "                                /* Return the element's internal border width.", "                                 * Mostly useful for widgets. */", "    Tk_DrawElementProc *draw;\t/* Draw the element in the given bounding", "\t\t\t\t * box. */", "} Tk_ElementSpec;", "", "/*", " * Element state flags. Can be OR'ed.", " */", "", "#define TK_ELEMENT_STATE_ACTIVE         1<<0", "#define TK_ELEMENT_STATE_DISABLED       1<<1", "#define TK_ELEMENT_STATE_FOCUS          1<<2", "#define TK_ELEMENT_STATE_PRESSED        1<<3", "\f", "/*", " *--------------------------------------------------------------", " *", " * The definitions below provide backward compatibility for functions and", " * types related to event handling that used to be in Tk but have moved to", " * Tcl.", " *", " *--------------------------------------------------------------", " */", "", "#define TK_READABLE\t\tTCL_READABLE", "#define TK_WRITABLE\t\tTCL_WRITABLE", "#define TK_EXCEPTION\t\tTCL_EXCEPTION", "", "#define TK_DONT_WAIT\t\tTCL_DONT_WAIT", "#define TK_X_EVENTS\t\tTCL_WINDOW_EVENTS", "#define TK_WINDOW_EVENTS\tTCL_WINDOW_EVENTS", "#define TK_FILE_EVENTS\t\tTCL_FILE_EVENTS", "#define TK_TIMER_EVENTS\t\tTCL_TIMER_EVENTS", "#define TK_IDLE_EVENTS\t\tTCL_IDLE_EVENTS", "#define TK_ALL_EVENTS\t\tTCL_ALL_EVENTS", "", "#define Tk_IdleProc\t\tTcl_IdleProc", "#define Tk_FileProc\t\tTcl_FileProc", "#define Tk_TimerProc\t\tTcl_TimerProc", "#define Tk_TimerToken\t\tTcl_TimerToken", "", "#define Tk_BackgroundError\tTcl_BackgroundError", "#define Tk_CancelIdleCall\tTcl_CancelIdleCall", "#define Tk_CreateFileHandler\tTcl_CreateFileHandler", "#define Tk_CreateTimerHandler\tTcl_CreateTimerHandler", "#define Tk_DeleteFileHandler\tTcl_DeleteFileHandler", "#define Tk_DeleteTimerHandler\tTcl_DeleteTimerHandler", "#define Tk_DoOneEvent\t\tTcl_DoOneEvent", "#define Tk_DoWhenIdle\t\tTcl_DoWhenIdle", "#define Tk_Sleep\t\tTcl_Sleep", "", "/* Additional stuff that has moved to Tcl: */", "", "#define Tk_EventuallyFree\tTcl_EventuallyFree", "#define Tk_FreeProc\t\tTcl_FreeProc", "#define Tk_Preserve\t\tTcl_Preserve", "#define Tk_Release\t\tTcl_Release", "", "/* Removed Tk_Main, use macro instead */", "#define Tk_Main(argc, argv, proc) \\", "    Tk_MainEx(argc, argv, proc, Tcl_CreateInterp())", "", "const char *\t\tTk_InitStubs _ANSI_ARGS_((Tcl_Interp *interp,", "\t\t\t    const char *version, int exact));", "EXTERN const char *\tTk_PkgInitStubsCheck _ANSI_ARGS_((Tcl_Interp *interp,", "\t\t\t    const char *version, int exact));", "", "#ifndef USE_TK_STUBS", "", "#define Tk_InitStubs(interp, version, exact) \\", "    Tk_PkgInitStubsCheck(interp, version, exact)", "", "#endif", "", "#define Tk_InitImageArgs(interp, argc, argv) /**/", "", "\f", "/*", " *--------------------------------------------------------------", " *", " * Additional procedure types defined by Tk.", " *", " *--------------------------------------------------------------", " */", "", "typedef int (Tk_ErrorProc) _ANSI_ARGS_((ClientData clientData,", "\tXErrorEvent *errEventPtr));", "typedef void (Tk_EventProc) _ANSI_ARGS_((ClientData clientData,", "\tXEvent *eventPtr));", "typedef int (Tk_GenericProc) _ANSI_ARGS_((ClientData clientData,", "\tXEvent *eventPtr));", "typedef int (Tk_ClientMessageProc) _ANSI_ARGS_((Tk_Window tkwin,", "\tXEvent *eventPtr));", "typedef int (Tk_GetSelProc) _ANSI_ARGS_((ClientData clientData,", "\tTcl_Interp *interp, char *portion));", "typedef void (Tk_LostSelProc) _ANSI_ARGS_((ClientData clientData));", "typedef Tk_RestrictAction (Tk_RestrictProc) _ANSI_ARGS_((", "\tClientData clientData, XEvent *eventPtr));", "typedef int (Tk_SelectionProc) _ANSI_ARGS_((ClientData clientData,", "\tint offset, char *buffer, int maxBytes));", "\f", "/*", " *--------------------------------------------------------------", " *", " * Platform independant exported procedures and variables.", " *", " *--------------------------------------------------------------", " */", "", '#include "tkDecls.h"', "", "/*", " * Allow users to say that they don't want to alter their source to add extra", " * arguments to Tk_PhotoPutBlock() et al; DO NOT DEFINE THIS WHEN BUILDING TK.", " *", " * This goes after the inclusion of the stubbed-decls so that the declarations", " * of what is actually there can be correct.", " */", "", "#ifdef USE_COMPOSITELESS_PHOTO_PUT_BLOCK", "#   ifdef Tk_PhotoPutBlock", "#\tundef Tk_PhotoPutBlock", "#   endif", "#   define Tk_PhotoPutBlock\t\tTk_PhotoPutBlock_NoComposite", "#   ifdef Tk_PhotoPutZoomedBlock", "#\tundef Tk_PhotoPutZoomedBlock", "#   endif", "#   define Tk_PhotoPutZoomedBlock\tTk_PhotoPutZoomedBlock_NoComposite", "#   define USE_PANIC_ON_PHOTO_ALLOC_FAILURE", "#else /* !USE_COMPOSITELESS_PHOTO_PUT_BLOCK */", "#   ifdef USE_PANIC_ON_PHOTO_ALLOC_FAILURE", "#\tifdef Tk_PhotoPutBlock", "#\t    undef Tk_PhotoPutBlock", "#\tendif", "#\tdefine Tk_PhotoPutBlock\t\tTk_PhotoPutBlock_Panic", "#\tifdef Tk_PhotoPutZoomedBlock", "#\t    undef Tk_PhotoPutZoomedBlock", "#\tendif", "#\tdefine Tk_PhotoPutZoomedBlock\tTk_PhotoPutZoomedBlock_Panic", "#   endif /* USE_PANIC_ON_PHOTO_ALLOC_FAILURE */", "#endif /* USE_COMPOSITELESS_PHOTO_PUT_BLOCK */", "#ifdef USE_PANIC_ON_PHOTO_ALLOC_FAILURE", "#   ifdef Tk_PhotoExpand", "#\tundef Tk_PhotoExpand", "#   endif", "#   define Tk_PhotoExpand\t\tTk_PhotoExpand_Panic", "#   ifdef Tk_PhotoSetSize", "#\tundef Tk_PhotoSetSize", "#   endif", "#   define Tk_PhotoSetSize\t\tTk_PhotoSetSize_Panic", "#endif /* USE_PANIC_ON_PHOTO_ALLOC_FAILURE */", "", "/*", " * Tcl commands exported by Tk:", " */", "", "#undef TCL_STORAGE_CLASS", "#define TCL_STORAGE_CLASS DLLIMPORT", "", "#endif /* RC_INVOKED */", "", "/*", " * end block for C++", " */", "", "#ifdef __cplusplus", "}", "#endif", "", "#endif /* _TK */", "\f", "/*", " * Local Variables:", " * mode: c", " * c-basic-offset: 4", " * fill-column: 78", " * End:", " */" },
    ["tkDecls.h"] = { "/*", " * tkDecls.h --", " *", " *\tDeclarations of functions in the platform independent public Tcl API.", " *", " * Copyright (c) 1998-1999 by Scriptics Corporation.", " *", ' * See the file "license.terms" for information on usage and redistribution', " * of this file, and for a DISCLAIMER OF ALL WARRANTIES.", " *", " * RCS: @(#) $Id$", " */", "", "#ifndef _TKDECLS", "#define _TKDECLS", "", "#ifdef BUILD_tk", "#undef TCL_STORAGE_CLASS", "#define TCL_STORAGE_CLASS DLLEXPORT", "#endif", "", "/*", " * WARNING: This file is automatically generated by the tools/genStubs.tcl", " * script.  Any modifications to the function declarations below should be made", " * in the generic/tk.decls script.", " */", "", "/* !BEGIN!: Do not edit below this line. */", "", "/*", " * Exported function declarations:", " */", "", "#ifndef Tk_MainLoop_TCL_DECLARED", "#define Tk_MainLoop_TCL_DECLARED", "/* 0 */", "EXTERN void\t\tTk_MainLoop(void);", "#endif", "#ifndef Tk_3DBorderColor_TCL_DECLARED", "#define Tk_3DBorderColor_TCL_DECLARED", "/* 1 */", "EXTERN XColor *\t\tTk_3DBorderColor(Tk_3DBorder border);", "#endif", "#ifndef Tk_3DBorderGC_TCL_DECLARED", "#define Tk_3DBorderGC_TCL_DECLARED", "/* 2 */", "EXTERN GC\t\tTk_3DBorderGC(Tk_Window tkwin, Tk_3DBorder border,", "\t\t\t\tint which);", "#endif", "#ifndef Tk_3DHorizontalBevel_TCL_DECLARED", "#define Tk_3DHorizontalBevel_TCL_DECLARED", "/* 3 */", "EXTERN void\t\tTk_3DHorizontalBevel(Tk_Window tkwin,", "\t\t\t\tDrawable drawable, Tk_3DBorder border, int x,", "\t\t\t\tint y, int width, int height, int leftIn,", "\t\t\t\tint rightIn, int topBevel, int relief);", "#endif", "#ifndef Tk_3DVerticalBevel_TCL_DECLARED", "#define Tk_3DVerticalBevel_TCL_DECLARED", "/* 4 */", "EXTERN void\t\tTk_3DVerticalBevel(Tk_Window tkwin,", "\t\t\t\tDrawable drawable, Tk_3DBorder border, int x,", "\t\t\t\tint y, int width, int height, int leftBevel,", "\t\t\t\tint relief);", "#endif", "#ifndef Tk_AddOption_TCL_DECLARED", "#define Tk_AddOption_TCL_DECLARED", "/* 5 */", "EXTERN void\t\tTk_AddOption(Tk_Window tkwin, CONST char *name,", "\t\t\t\tCONST char *value, int priority);", "#endif", "#ifndef Tk_BindEvent_TCL_DECLARED", "#define Tk_BindEvent_TCL_DECLARED", "/* 6 */", "EXTERN void\t\tTk_BindEvent(Tk_BindingTable bindingTable,", "\t\t\t\tXEvent *eventPtr, Tk_Window tkwin,", "\t\t\t\tint numObjects, ClientData *objectPtr);", "#endif", "#ifndef Tk_CanvasDrawableCoords_TCL_DECLARED", "#define Tk_CanvasDrawableCoords_TCL_DECLARED", "/* 7 */", "EXTERN void\t\tTk_CanvasDrawableCoords(Tk_Canvas canvas, double x,", "\t\t\t\tdouble y, short *drawableXPtr,", "\t\t\t\tshort *drawableYPtr);", "#endif", "#ifndef Tk_CanvasEventuallyRedraw_TCL_DECLARED", "#define Tk_CanvasEventuallyRedraw_TCL_DECLARED", "/* 8 */", "EXTERN void\t\tTk_CanvasEventuallyRedraw(Tk_Canvas canvas, int x1,", "\t\t\t\tint y1, int x2, int y2);", "#endif", "#ifndef Tk_CanvasGetCoord_TCL_DECLARED", "#define Tk_CanvasGetCoord_TCL_DECLARED", "/* 9 */", "EXTERN int\t\tTk_CanvasGetCoord(Tcl_Interp *interp,", "\t\t\t\tTk_Canvas canvas, CONST char *str,", "\t\t\t\tdouble *doublePtr);", "#endif", "#ifndef Tk_CanvasGetTextInfo_TCL_DECLARED", "#define Tk_CanvasGetTextInfo_TCL_DECLARED", "/* 10 */", "EXTERN Tk_CanvasTextInfo * Tk_CanvasGetTextInfo(Tk_Canvas canvas);", "#endif", "#ifndef Tk_CanvasPsBitmap_TCL_DECLARED", "#define Tk_CanvasPsBitmap_TCL_DECLARED", "/* 11 */", "EXTERN int\t\tTk_CanvasPsBitmap(Tcl_Interp *interp,", "\t\t\t\tTk_Canvas canvas, Pixmap bitmap, int x,", "\t\t\t\tint y, int width, int height);", "#endif", "#ifndef Tk_CanvasPsColor_TCL_DECLARED", "#define Tk_CanvasPsColor_TCL_DECLARED", "/* 12 */", "EXTERN int\t\tTk_CanvasPsColor(Tcl_Interp *interp,", "\t\t\t\tTk_Canvas canvas, XColor *colorPtr);", "#endif", "#ifndef Tk_CanvasPsFont_TCL_DECLARED", "#define Tk_CanvasPsFont_TCL_DECLARED", "/* 13 */", "EXTERN int\t\tTk_CanvasPsFont(Tcl_Interp *interp, Tk_Canvas canvas,", "\t\t\t\tTk_Font font);", "#endif", "#ifndef Tk_CanvasPsPath_TCL_DECLARED", "#define Tk_CanvasPsPath_TCL_DECLARED", "/* 14 */", "EXTERN void\t\tTk_CanvasPsPath(Tcl_Interp *interp, Tk_Canvas canvas,", "\t\t\t\tdouble *coordPtr, int numPoints);", "#endif", "#ifndef Tk_CanvasPsStipple_TCL_DECLARED", "#define Tk_CanvasPsStipple_TCL_DECLARED", "/* 15 */", "EXTERN int\t\tTk_CanvasPsStipple(Tcl_Interp *interp,", "\t\t\t\tTk_Canvas canvas, Pixmap bitmap);", "#endif", "#ifndef Tk_CanvasPsY_TCL_DECLARED", "#define Tk_CanvasPsY_TCL_DECLARED", "/* 16 */", "EXTERN double\t\tTk_CanvasPsY(Tk_Canvas canvas, double y);", "#endif", "#ifndef Tk_CanvasSetStippleOrigin_TCL_DECLARED", "#define Tk_CanvasSetStippleOrigin_TCL_DECLARED", "/* 17 */", "EXTERN void\t\tTk_CanvasSetStippleOrigin(Tk_Canvas canvas, GC gc);", "#endif", "#ifndef Tk_CanvasTagsParseProc_TCL_DECLARED", "#define Tk_CanvasTagsParseProc_TCL_DECLARED", "/* 18 */", "EXTERN int\t\tTk_CanvasTagsParseProc(ClientData clientData,", "\t\t\t\tTcl_Interp *interp, Tk_Window tkwin,", "\t\t\t\tCONST char *value, char *widgRec, int offset);", "#endif", "#ifndef Tk_CanvasTagsPrintProc_TCL_DECLARED", "#define Tk_CanvasTagsPrintProc_TCL_DECLARED", "/* 19 */", "EXTERN char *\t\tTk_CanvasTagsPrintProc(ClientData clientData,", "\t\t\t\tTk_Window tkwin, char *widgRec, int offset,", "\t\t\t\tTcl_FreeProc **freeProcPtr);", "#endif", "#ifndef Tk_CanvasTkwin_TCL_DECLARED", "#define Tk_CanvasTkwin_TCL_DECLARED", "/* 20 */", "EXTERN Tk_Window\tTk_CanvasTkwin(Tk_Canvas canvas);", "#endif", "#ifndef Tk_CanvasWindowCoords_TCL_DECLARED", "#define Tk_CanvasWindowCoords_TCL_DECLARED", "/* 21 */", "EXTERN void\t\tTk_CanvasWindowCoords(Tk_Canvas canvas, double x,", "\t\t\t\tdouble y, short *screenXPtr,", "\t\t\t\tshort *screenYPtr);", "#endif", "#ifndef Tk_ChangeWindowAttributes_TCL_DECLARED", "#define Tk_ChangeWindowAttributes_TCL_DECLARED", "/* 22 */", "EXTERN void\t\tTk_ChangeWindowAttributes(Tk_Window tkwin,", "\t\t\t\tunsigned long valueMask,", "\t\t\t\tXSetWindowAttributes *attsPtr);", "#endif", "#ifndef Tk_CharBbox_TCL_DECLARED", "#define Tk_CharBbox_TCL_DECLARED", "/* 23 */", "EXTERN int\t\tTk_CharBbox(Tk_TextLayout layout, int index,", "\t\t\t\tint *xPtr, int *yPtr, int *widthPtr,", "\t\t\t\tint *heightPtr);", "#endif", "#ifndef Tk_ClearSelection_TCL_DECLARED", "#define Tk_ClearSelection_TCL_DECLARED", "/* 24 */", "EXTERN void\t\tTk_ClearSelection(Tk_Window tkwin, Atom selection);", "#endif", "#ifndef Tk_ClipboardAppend_TCL_DECLARED", "#define Tk_ClipboardAppend_TCL_DECLARED", "/* 25 */", "EXTERN int\t\tTk_ClipboardAppend(Tcl_Interp *interp,", "\t\t\t\tTk_Window tkwin, Atom target, Atom format,", "\t\t\t\tchar *buffer);", "#endif", "#ifndef Tk_ClipboardClear_TCL_DECLARED", "#define Tk_ClipboardClear_TCL_DECLARED", "/* 26 */", "EXTERN int\t\tTk_ClipboardClear(Tcl_Interp *interp,", "\t\t\t\tTk_Window tkwin);", "#endif", "#ifndef Tk_ConfigureInfo_TCL_DECLARED", "#define Tk_ConfigureInfo_TCL_DECLARED", "/* 27 */", "EXTERN int\t\tTk_ConfigureInfo(Tcl_Interp *interp, Tk_Window tkwin,", "\t\t\t\tTk_ConfigSpec *specs, char *widgRec,", "\t\t\t\tCONST char *argvName, int flags);", "#endif", "#ifndef Tk_ConfigureValue_TCL_DECLARED", "#define Tk_ConfigureValue_TCL_DECLARED", "/* 28 */", "EXTERN int\t\tTk_ConfigureValue(Tcl_Interp *interp,", "\t\t\t\tTk_Window tkwin, Tk_ConfigSpec *specs,", "\t\t\t\tchar *widgRec, CONST char *argvName,", "\t\t\t\tint flags);", "#endif", "#ifndef Tk_ConfigureWidget_TCL_DECLARED", "#define Tk_ConfigureWidget_TCL_DECLARED", "/* 29 */", "EXTERN int\t\tTk_ConfigureWidget(Tcl_Interp *interp,", "\t\t\t\tTk_Window tkwin, Tk_ConfigSpec *specs,", "\t\t\t\tint argc, CONST84 char **argv, char *widgRec,", "\t\t\t\tint flags);", "#endif", "#ifndef Tk_ConfigureWindow_TCL_DECLARED", "#define Tk_ConfigureWindow_TCL_DECLARED", "/* 30 */", "EXTERN void\t\tTk_ConfigureWindow(Tk_Window tkwin,", "\t\t\t\tunsigned int valueMask,", "\t\t\t\tXWindowChanges *valuePtr);", "#endif", "#ifndef Tk_ComputeTextLayout_TCL_DECLARED", "#define Tk_ComputeTextLayout_TCL_DECLARED", "/* 31 */", "EXTERN Tk_TextLayout\tTk_ComputeTextLayout(Tk_Font font, CONST char *str,", "\t\t\t\tint numChars, int wrapLength,", "\t\t\t\tTk_Justify justify, int flags, int *widthPtr,", "\t\t\t\tint *heightPtr);", "#endif", "#ifndef Tk_CoordsToWindow_TCL_DECLARED", "#define Tk_CoordsToWindow_TCL_DECLARED", "/* 32 */", "EXTERN Tk_Window\tTk_CoordsToWindow(int rootX, int rootY,", "\t\t\t\tTk_Window tkwin);", "#endif", "#ifndef Tk_CreateBinding_TCL_DECLARED", "#define Tk_CreateBinding_TCL_DECLARED", "/* 33 */", "EXTERN unsigned long\tTk_CreateBinding(Tcl_Interp *interp,", "\t\t\t\tTk_BindingTable bindingTable,", "\t\t\t\tClientData object, CONST char *eventStr,", "\t\t\t\tCONST char *command, int append);", "#endif", "#ifndef Tk_CreateBindingTable_TCL_DECLARED", "#define Tk_CreateBindingTable_TCL_DECLARED", "/* 34 */", "EXTERN Tk_BindingTable\tTk_CreateBindingTable(Tcl_Interp *interp);", "#endif", "#ifndef Tk_CreateErrorHandler_TCL_DECLARED", "#define Tk_CreateErrorHandler_TCL_DECLARED", "/* 35 */", "EXTERN Tk_ErrorHandler\tTk_CreateErrorHandler(Display *display, int errNum,", "\t\t\t\tint request, int minorCode,", "\t\t\t\tTk_ErrorProc *errorProc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tk_CreateEventHandler_TCL_DECLARED", "#define Tk_CreateEventHandler_TCL_DECLARED", "/* 36 */", "EXTERN void\t\tTk_CreateEventHandler(Tk_Window token,", "\t\t\t\tunsigned long mask, Tk_EventProc *proc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tk_CreateGenericHandler_TCL_DECLARED", "#define Tk_CreateGenericHandler_TCL_DECLARED", "/* 37 */", "EXTERN void\t\tTk_CreateGenericHandler(Tk_GenericProc *proc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tk_CreateImageType_TCL_DECLARED", "#define Tk_CreateImageType_TCL_DECLARED", "/* 38 */", "EXTERN void\t\tTk_CreateImageType(Tk_ImageType *typePtr);", "#endif", "#ifndef Tk_CreateItemType_TCL_DECLARED", "#define Tk_CreateItemType_TCL_DECLARED", "/* 39 */", "EXTERN void\t\tTk_CreateItemType(Tk_ItemType *typePtr);", "#endif", "#ifndef Tk_CreatePhotoImageFormat_TCL_DECLARED", "#define Tk_CreatePhotoImageFormat_TCL_DECLARED", "/* 40 */", "EXTERN void\t\tTk_CreatePhotoImageFormat(", "\t\t\t\tTk_PhotoImageFormat *formatPtr);", "#endif", "#ifndef Tk_CreateSelHandler_TCL_DECLARED", "#define Tk_CreateSelHandler_TCL_DECLARED", "/* 41 */", "EXTERN void\t\tTk_CreateSelHandler(Tk_Window tkwin, Atom selection,", "\t\t\t\tAtom target, Tk_SelectionProc *proc,", "\t\t\t\tClientData clientData, Atom format);", "#endif", "#ifndef Tk_CreateWindow_TCL_DECLARED", "#define Tk_CreateWindow_TCL_DECLARED", "/* 42 */", "EXTERN Tk_Window\tTk_CreateWindow(Tcl_Interp *interp, Tk_Window parent,", "\t\t\t\tCONST char *name, CONST char *screenName);", "#endif", "#ifndef Tk_CreateWindowFromPath_TCL_DECLARED", "#define Tk_CreateWindowFromPath_TCL_DECLARED", "/* 43 */", "EXTERN Tk_Window\tTk_CreateWindowFromPath(Tcl_Interp *interp,", "\t\t\t\tTk_Window tkwin, CONST char *pathName,", "\t\t\t\tCONST char *screenName);", "#endif", "#ifndef Tk_DefineBitmap_TCL_DECLARED", "#define Tk_DefineBitmap_TCL_DECLARED", "/* 44 */", "EXTERN int\t\tTk_DefineBitmap(Tcl_Interp *interp, CONST char *name,", "\t\t\t\tCONST char *source, int width, int height);", "#endif", "#ifndef Tk_DefineCursor_TCL_DECLARED", "#define Tk_DefineCursor_TCL_DECLARED", "/* 45 */", "EXTERN void\t\tTk_DefineCursor(Tk_Window window, Tk_Cursor cursor);", "#endif", "#ifndef Tk_DeleteAllBindings_TCL_DECLARED", "#define Tk_DeleteAllBindings_TCL_DECLARED", "/* 46 */", "EXTERN void\t\tTk_DeleteAllBindings(Tk_BindingTable bindingTable,", "\t\t\t\tClientData object);", "#endif", "#ifndef Tk_DeleteBinding_TCL_DECLARED", "#define Tk_DeleteBinding_TCL_DECLARED", "/* 47 */", "EXTERN int\t\tTk_DeleteBinding(Tcl_Interp *interp,", "\t\t\t\tTk_BindingTable bindingTable,", "\t\t\t\tClientData object, CONST char *eventStr);", "#endif", "#ifndef Tk_DeleteBindingTable_TCL_DECLARED", "#define Tk_DeleteBindingTable_TCL_DECLARED", "/* 48 */", "EXTERN void\t\tTk_DeleteBindingTable(Tk_BindingTable bindingTable);", "#endif", "#ifndef Tk_DeleteErrorHandler_TCL_DECLARED", "#define Tk_DeleteErrorHandler_TCL_DECLARED", "/* 49 */", "EXTERN void\t\tTk_DeleteErrorHandler(Tk_ErrorHandler handler);", "#endif", "#ifndef Tk_DeleteEventHandler_TCL_DECLARED", "#define Tk_DeleteEventHandler_TCL_DECLARED", "/* 50 */", "EXTERN void\t\tTk_DeleteEventHandler(Tk_Window token,", "\t\t\t\tunsigned long mask, Tk_EventProc *proc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tk_DeleteGenericHandler_TCL_DECLARED", "#define Tk_DeleteGenericHandler_TCL_DECLARED", "/* 51 */", "EXTERN void\t\tTk_DeleteGenericHandler(Tk_GenericProc *proc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tk_DeleteImage_TCL_DECLARED", "#define Tk_DeleteImage_TCL_DECLARED", "/* 52 */", "EXTERN void\t\tTk_DeleteImage(Tcl_Interp *interp, CONST char *name);", "#endif", "#ifndef Tk_DeleteSelHandler_TCL_DECLARED", "#define Tk_DeleteSelHandler_TCL_DECLARED", "/* 53 */", "EXTERN void\t\tTk_DeleteSelHandler(Tk_Window tkwin, Atom selection,", "\t\t\t\tAtom target);", "#endif", "#ifndef Tk_DestroyWindow_TCL_DECLARED", "#define Tk_DestroyWindow_TCL_DECLARED", "/* 54 */", "EXTERN void\t\tTk_DestroyWindow(Tk_Window tkwin);", "#endif", "#ifndef Tk_DisplayName_TCL_DECLARED", "#define Tk_DisplayName_TCL_DECLARED", "/* 55 */", "EXTERN CONST84_RETURN char * Tk_DisplayName(Tk_Window tkwin);", "#endif", "#ifndef Tk_DistanceToTextLayout_TCL_DECLARED", "#define Tk_DistanceToTextLayout_TCL_DECLARED", "/* 56 */", "EXTERN int\t\tTk_DistanceToTextLayout(Tk_TextLayout layout, int x,", "\t\t\t\tint y);", "#endif", "#ifndef Tk_Draw3DPolygon_TCL_DECLARED", "#define Tk_Draw3DPolygon_TCL_DECLARED", "/* 57 */", "EXTERN void\t\tTk_Draw3DPolygon(Tk_Window tkwin, Drawable drawable,", "\t\t\t\tTk_3DBorder border, XPoint *pointPtr,", "\t\t\t\tint numPoints, int borderWidth,", "\t\t\t\tint leftRelief);", "#endif", "#ifndef Tk_Draw3DRectangle_TCL_DECLARED", "#define Tk_Draw3DRectangle_TCL_DECLARED", "/* 58 */", "EXTERN void\t\tTk_Draw3DRectangle(Tk_Window tkwin,", "\t\t\t\tDrawable drawable, Tk_3DBorder border, int x,", "\t\t\t\tint y, int width, int height,", "\t\t\t\tint borderWidth, int relief);", "#endif", "#ifndef Tk_DrawChars_TCL_DECLARED", "#define Tk_DrawChars_TCL_DECLARED", "/* 59 */", "EXTERN void\t\tTk_DrawChars(Display *display, Drawable drawable,", "\t\t\t\tGC gc, Tk_Font tkfont, CONST char *source,", "\t\t\t\tint numBytes, int x, int y);", "#endif", "#ifndef Tk_DrawFocusHighlight_TCL_DECLARED", "#define Tk_DrawFocusHighlight_TCL_DECLARED", "/* 60 */", "EXTERN void\t\tTk_DrawFocusHighlight(Tk_Window tkwin, GC gc,", "\t\t\t\tint width, Drawable drawable);", "#endif", "#ifndef Tk_DrawTextLayout_TCL_DECLARED", "#define Tk_DrawTextLayout_TCL_DECLARED", "/* 61 */", "EXTERN void\t\tTk_DrawTextLayout(Display *display,", "\t\t\t\tDrawable drawable, GC gc,", "\t\t\t\tTk_TextLayout layout, int x, int y,", "\t\t\t\tint firstChar, int lastChar);", "#endif", "#ifndef Tk_Fill3DPolygon_TCL_DECLARED", "#define Tk_Fill3DPolygon_TCL_DECLARED", "/* 62 */", "EXTERN void\t\tTk_Fill3DPolygon(Tk_Window tkwin, Drawable drawable,", "\t\t\t\tTk_3DBorder border, XPoint *pointPtr,", "\t\t\t\tint numPoints, int borderWidth,", "\t\t\t\tint leftRelief);", "#endif", "#ifndef Tk_Fill3DRectangle_TCL_DECLARED", "#define Tk_Fill3DRectangle_TCL_DECLARED", "/* 63 */", "EXTERN void\t\tTk_Fill3DRectangle(Tk_Window tkwin,", "\t\t\t\tDrawable drawable, Tk_3DBorder border, int x,", "\t\t\t\tint y, int width, int height,", "\t\t\t\tint borderWidth, int relief);", "#endif", "#ifndef Tk_FindPhoto_TCL_DECLARED", "#define Tk_FindPhoto_TCL_DECLARED", "/* 64 */", "EXTERN Tk_PhotoHandle\tTk_FindPhoto(Tcl_Interp *interp,", "\t\t\t\tCONST char *imageName);", "#endif", "#ifndef Tk_FontId_TCL_DECLARED", "#define Tk_FontId_TCL_DECLARED", "/* 65 */", "EXTERN Font\t\tTk_FontId(Tk_Font font);", "#endif", "#ifndef Tk_Free3DBorder_TCL_DECLARED", "#define Tk_Free3DBorder_TCL_DECLARED", "/* 66 */", "EXTERN void\t\tTk_Free3DBorder(Tk_3DBorder border);", "#endif", "#ifndef Tk_FreeBitmap_TCL_DECLARED", "#define Tk_FreeBitmap_TCL_DECLARED", "/* 67 */", "EXTERN void\t\tTk_FreeBitmap(Display *display, Pixmap bitmap);", "#endif", "#ifndef Tk_FreeColor_TCL_DECLARED", "#define Tk_FreeColor_TCL_DECLARED", "/* 68 */", "EXTERN void\t\tTk_FreeColor(XColor *colorPtr);", "#endif", "#ifndef Tk_FreeColormap_TCL_DECLARED", "#define Tk_FreeColormap_TCL_DECLARED", "/* 69 */", "EXTERN void\t\tTk_FreeColormap(Display *display, Colormap colormap);", "#endif", "#ifndef Tk_FreeCursor_TCL_DECLARED", "#define Tk_FreeCursor_TCL_DECLARED", "/* 70 */", "EXTERN void\t\tTk_FreeCursor(Display *display, Tk_Cursor cursor);", "#endif", "#ifndef Tk_FreeFont_TCL_DECLARED", "#define Tk_FreeFont_TCL_DECLARED", "/* 71 */", "EXTERN void\t\tTk_FreeFont(Tk_Font f);", "#endif", "#ifndef Tk_FreeGC_TCL_DECLARED", "#define Tk_FreeGC_TCL_DECLARED", "/* 72 */", "EXTERN void\t\tTk_FreeGC(Display *display, GC gc);", "#endif", "#ifndef Tk_FreeImage_TCL_DECLARED", "#define Tk_FreeImage_TCL_DECLARED", "/* 73 */", "EXTERN void\t\tTk_FreeImage(Tk_Image image);", "#endif", "#ifndef Tk_FreeOptions_TCL_DECLARED", "#define Tk_FreeOptions_TCL_DECLARED", "/* 74 */", "EXTERN void\t\tTk_FreeOptions(Tk_ConfigSpec *specs, char *widgRec,", "\t\t\t\tDisplay *display, int needFlags);", "#endif", "#ifndef Tk_FreePixmap_TCL_DECLARED", "#define Tk_FreePixmap_TCL_DECLARED", "/* 75 */", "EXTERN void\t\tTk_FreePixmap(Display *display, Pixmap pixmap);", "#endif", "#ifndef Tk_FreeTextLayout_TCL_DECLARED", "#define Tk_FreeTextLayout_TCL_DECLARED", "/* 76 */", "EXTERN void\t\tTk_FreeTextLayout(Tk_TextLayout textLayout);", "#endif", "#ifndef Tk_FreeXId_TCL_DECLARED", "#define Tk_FreeXId_TCL_DECLARED", "/* 77 */", "EXTERN void\t\tTk_FreeXId(Display *display, XID xid);", "#endif", "#ifndef Tk_GCForColor_TCL_DECLARED", "#define Tk_GCForColor_TCL_DECLARED", "/* 78 */", "EXTERN GC\t\tTk_GCForColor(XColor *colorPtr, Drawable drawable);", "#endif", "#ifndef Tk_GeometryRequest_TCL_DECLARED", "#define Tk_GeometryRequest_TCL_DECLARED", "/* 79 */", "EXTERN void\t\tTk_GeometryRequest(Tk_Window tkwin, int reqWidth,", "\t\t\t\tint reqHeight);", "#endif", "#ifndef Tk_Get3DBorder_TCL_DECLARED", "#define Tk_Get3DBorder_TCL_DECLARED", "/* 80 */", "EXTERN Tk_3DBorder\tTk_Get3DBorder(Tcl_Interp *interp, Tk_Window tkwin,", "\t\t\t\tTk_Uid colorName);", "#endif", "#ifndef Tk_GetAllBindings_TCL_DECLARED", "#define Tk_GetAllBindings_TCL_DECLARED", "/* 81 */", "EXTERN void\t\tTk_GetAllBindings(Tcl_Interp *interp,", "\t\t\t\tTk_BindingTable bindingTable,", "\t\t\t\tClientData object);", "#endif", "#ifndef Tk_GetAnchor_TCL_DECLARED", "#define Tk_GetAnchor_TCL_DECLARED", "/* 82 */", "EXTERN int\t\tTk_GetAnchor(Tcl_Interp *interp, CONST char *str,", "\t\t\t\tTk_Anchor *anchorPtr);", "#endif", "#ifndef Tk_GetAtomName_TCL_DECLARED", "#define Tk_GetAtomName_TCL_DECLARED", "/* 83 */", "EXTERN CONST84_RETURN char * Tk_GetAtomName(Tk_Window tkwin, Atom atom);", "#endif", "#ifndef Tk_GetBinding_TCL_DECLARED", "#define Tk_GetBinding_TCL_DECLARED", "/* 84 */", "EXTERN CONST84_RETURN char * Tk_GetBinding(Tcl_Interp *interp,", "\t\t\t\tTk_BindingTable bindingTable,", "\t\t\t\tClientData object, CONST char *eventStr);", "#endif", "#ifndef Tk_GetBitmap_TCL_DECLARED", "#define Tk_GetBitmap_TCL_DECLARED", "/* 85 */", "EXTERN Pixmap\t\tTk_GetBitmap(Tcl_Interp *interp, Tk_Window tkwin,", "\t\t\t\tCONST char *str);", "#endif", "#ifndef Tk_GetBitmapFromData_TCL_DECLARED", "#define Tk_GetBitmapFromData_TCL_DECLARED", "/* 86 */", "EXTERN Pixmap\t\tTk_GetBitmapFromData(Tcl_Interp *interp,", "\t\t\t\tTk_Window tkwin, CONST char *source,", "\t\t\t\tint width, int height);", "#endif", "#ifndef Tk_GetCapStyle_TCL_DECLARED", "#define Tk_GetCapStyle_TCL_DECLARED", "/* 87 */", "EXTERN int\t\tTk_GetCapStyle(Tcl_Interp *interp, CONST char *str,", "\t\t\t\tint *capPtr);", "#endif", "#ifndef Tk_GetColor_TCL_DECLARED", "#define Tk_GetColor_TCL_DECLARED", "/* 88 */", "EXTERN XColor *\t\tTk_GetColor(Tcl_Interp *interp, Tk_Window tkwin,", "\t\t\t\tTk_Uid name);", "#endif", "#ifndef Tk_GetColorByValue_TCL_DECLARED", "#define Tk_GetColorByValue_TCL_DECLARED", "/* 89 */", "EXTERN XColor *\t\tTk_GetColorByValue(Tk_Window tkwin, XColor *colorPtr);", "#endif", "#ifndef Tk_GetColormap_TCL_DECLARED", "#define Tk_GetColormap_TCL_DECLARED", "/* 90 */", "EXTERN Colormap\t\tTk_GetColormap(Tcl_Interp *interp, Tk_Window tkwin,", "\t\t\t\tCONST char *str);", "#endif", "#ifndef Tk_GetCursor_TCL_DECLARED", "#define Tk_GetCursor_TCL_DECLARED", "/* 91 */", "EXTERN Tk_Cursor\tTk_GetCursor(Tcl_Interp *interp, Tk_Window tkwin,", "\t\t\t\tTk_Uid str);", "#endif", "#ifndef Tk_GetCursorFromData_TCL_DECLARED", "#define Tk_GetCursorFromData_TCL_DECLARED", "/* 92 */", "EXTERN Tk_Cursor\tTk_GetCursorFromData(Tcl_Interp *interp,", "\t\t\t\tTk_Window tkwin, CONST char *source,", "\t\t\t\tCONST char *mask, int width, int height,", "\t\t\t\tint xHot, int yHot, Tk_Uid fg, Tk_Uid bg);", "#endif", "#ifndef Tk_GetFont_TCL_DECLARED", "#define Tk_GetFont_TCL_DECLARED", "/* 93 */", "EXTERN Tk_Font\t\tTk_GetFont(Tcl_Interp *interp, Tk_Window tkwin,", "\t\t\t\tCONST char *str);", "#endif", "#ifndef Tk_GetFontFromObj_TCL_DECLARED", "#define Tk_GetFontFromObj_TCL_DECLARED", "/* 94 */", "EXTERN Tk_Font\t\tTk_GetFontFromObj(Tk_Window tkwin, Tcl_Obj *objPtr);", "#endif", "#ifndef Tk_GetFontMetrics_TCL_DECLARED", "#define Tk_GetFontMetrics_TCL_DECLARED", "/* 95 */", "EXTERN void\t\tTk_GetFontMetrics(Tk_Font font,", "\t\t\t\tTk_FontMetrics *fmPtr);", "#endif", "#ifndef Tk_GetGC_TCL_DECLARED", "#define Tk_GetGC_TCL_DECLARED", "/* 96 */", "EXTERN GC\t\tTk_GetGC(Tk_Window tkwin, unsigned long valueMask,", "\t\t\t\tXGCValues *valuePtr);", "#endif", "#ifndef Tk_GetImage_TCL_DECLARED", "#define Tk_GetImage_TCL_DECLARED", "/* 97 */", "EXTERN Tk_Image\t\tTk_GetImage(Tcl_Interp *interp, Tk_Window tkwin,", "\t\t\t\tCONST char *name,", "\t\t\t\tTk_ImageChangedProc *changeProc,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tk_GetImageMasterData_TCL_DECLARED", "#define Tk_GetImageMasterData_TCL_DECLARED", "/* 98 */", "EXTERN ClientData\tTk_GetImageMasterData(Tcl_Interp *interp,", "\t\t\t\tCONST char *name, Tk_ImageType **typePtrPtr);", "#endif", "#ifndef Tk_GetItemTypes_TCL_DECLARED", "#define Tk_GetItemTypes_TCL_DECLARED", "/* 99 */", "EXTERN Tk_ItemType *\tTk_GetItemTypes(void);", "#endif", "#ifndef Tk_GetJoinStyle_TCL_DECLARED", "#define Tk_GetJoinStyle_TCL_DECLARED", "/* 100 */", "EXTERN int\t\tTk_GetJoinStyle(Tcl_Interp *interp, CONST char *str,", "\t\t\t\tint *joinPtr);", "#endif", "#ifndef Tk_GetJustify_TCL_DECLARED", "#define Tk_GetJustify_TCL_DECLARED", "/* 101 */", "EXTERN int\t\tTk_GetJustify(Tcl_Interp *interp, CONST char *str,", "\t\t\t\tTk_Justify *justifyPtr);", "#endif", "#ifndef Tk_GetNumMainWindows_TCL_DECLARED", "#define Tk_GetNumMainWindows_TCL_DECLARED", "/* 102 */", "EXTERN int\t\tTk_GetNumMainWindows(void);", "#endif", "#ifndef Tk_GetOption_TCL_DECLARED", "#define Tk_GetOption_TCL_DECLARED", "/* 103 */", "EXTERN Tk_Uid\t\tTk_GetOption(Tk_Window tkwin, CONST char *name,", "\t\t\t\tCONST char *className);", "#endif", "#ifndef Tk_GetPixels_TCL_DECLARED", "#define Tk_GetPixels_TCL_DECLARED", "/* 104 */", "EXTERN int\t\tTk_GetPixels(Tcl_Interp *interp, Tk_Window tkwin,", "\t\t\t\tCONST char *str, int *intPtr);", "#endif", "#ifndef Tk_GetPixmap_TCL_DECLARED", "#define Tk_GetPixmap_TCL_DECLARED", "/* 105 */", "EXTERN Pixmap\t\tTk_GetPixmap(Display *display, Drawable d, int width,", "\t\t\t\tint height, int depth);", "#endif", "#ifndef Tk_GetRelief_TCL_DECLARED", "#define Tk_GetRelief_TCL_DECLARED", "/* 106 */", "EXTERN int\t\tTk_GetRelief(Tcl_Interp *interp, CONST char *name,", "\t\t\t\tint *reliefPtr);", "#endif", "#ifndef Tk_GetRootCoords_TCL_DECLARED", "#define Tk_GetRootCoords_TCL_DECLARED", "/* 107 */", "EXTERN void\t\tTk_GetRootCoords(Tk_Window tkwin, int *xPtr,", "\t\t\t\tint *yPtr);", "#endif", "#ifndef Tk_GetScrollInfo_TCL_DECLARED", "#define Tk_GetScrollInfo_TCL_DECLARED", "/* 108 */", "EXTERN int\t\tTk_GetScrollInfo(Tcl_Interp *interp, int argc,", "\t\t\t\tCONST84 char **argv, double *dblPtr,", "\t\t\t\tint *intPtr);", "#endif", "#ifndef Tk_GetScreenMM_TCL_DECLARED", "#define Tk_GetScreenMM_TCL_DECLARED", "/* 109 */", "EXTERN int\t\tTk_GetScreenMM(Tcl_Interp *interp, Tk_Window tkwin,", "\t\t\t\tCONST char *str, double *doublePtr);", "#endif", "#ifndef Tk_GetSelection_TCL_DECLARED", "#define Tk_GetSelection_TCL_DECLARED", "/* 110 */", "EXTERN int\t\tTk_GetSelection(Tcl_Interp *interp, Tk_Window tkwin,", "\t\t\t\tAtom selection, Atom target,", "\t\t\t\tTk_GetSelProc *proc, ClientData clientData);", "#endif", "#ifndef Tk_GetUid_TCL_DECLARED", "#define Tk_GetUid_TCL_DECLARED", "/* 111 */", "EXTERN Tk_Uid\t\tTk_GetUid(CONST char *str);", "#endif", "#ifndef Tk_GetVisual_TCL_DECLARED", "#define Tk_GetVisual_TCL_DECLARED", "/* 112 */", "EXTERN Visual *\t\tTk_GetVisual(Tcl_Interp *interp, Tk_Window tkwin,", "\t\t\t\tCONST char *str, int *depthPtr,", "\t\t\t\tColormap *colormapPtr);", "#endif", "#ifndef Tk_GetVRootGeometry_TCL_DECLARED", "#define Tk_GetVRootGeometry_TCL_DECLARED", "/* 113 */", "EXTERN void\t\tTk_GetVRootGeometry(Tk_Window tkwin, int *xPtr,", "\t\t\t\tint *yPtr, int *widthPtr, int *heightPtr);", "#endif", "#ifndef Tk_Grab_TCL_DECLARED", "#define Tk_Grab_TCL_DECLARED", "/* 114 */", "EXTERN int\t\tTk_Grab(Tcl_Interp *interp, Tk_Window tkwin,", "\t\t\t\tint grabGlobal);", "#endif", "#ifndef Tk_HandleEvent_TCL_DECLARED", "#define Tk_HandleEvent_TCL_DECLARED", "/* 115 */", "EXTERN void\t\tTk_HandleEvent(XEvent *eventPtr);", "#endif", "#ifndef Tk_IdToWindow_TCL_DECLARED", "#define Tk_IdToWindow_TCL_DECLARED", "/* 116 */", "EXTERN Tk_Window\tTk_IdToWindow(Display *display, Window window);", "#endif", "#ifndef Tk_ImageChanged_TCL_DECLARED", "#define Tk_ImageChanged_TCL_DECLARED", "/* 117 */", "EXTERN void\t\tTk_ImageChanged(Tk_ImageMaster master, int x, int y,", "\t\t\t\tint width, int height, int imageWidth,", "\t\t\t\tint imageHeight);", "#endif", "#ifndef Tk_Init_TCL_DECLARED", "#define Tk_Init_TCL_DECLARED", "/* 118 */", "EXTERN int\t\tTk_Init(Tcl_Interp *interp);", "#endif", "#ifndef Tk_InternAtom_TCL_DECLARED", "#define Tk_InternAtom_TCL_DECLARED", "/* 119 */", "EXTERN Atom\t\tTk_InternAtom(Tk_Window tkwin, CONST char *name);", "#endif", "#ifndef Tk_IntersectTextLayout_TCL_DECLARED", "#define Tk_IntersectTextLayout_TCL_DECLARED", "/* 120 */", "EXTERN int\t\tTk_IntersectTextLayout(Tk_TextLayout layout, int x,", "\t\t\t\tint y, int width, int height);", "#endif", "#ifndef Tk_MaintainGeometry_TCL_DECLARED", "#define Tk_MaintainGeometry_TCL_DECLARED", "/* 121 */", "EXTERN void\t\tTk_MaintainGeometry(Tk_Window slave,", "\t\t\t\tTk_Window master, int x, int y, int width,", "\t\t\t\tint height);", "#endif", "#ifndef Tk_MainWindow_TCL_DECLARED", "#define Tk_MainWindow_TCL_DECLARED", "/* 122 */", "EXTERN Tk_Window\tTk_MainWindow(Tcl_Interp *interp);", "#endif", "#ifndef Tk_MakeWindowExist_TCL_DECLARED", "#define Tk_MakeWindowExist_TCL_DECLARED", "/* 123 */", "EXTERN void\t\tTk_MakeWindowExist(Tk_Window tkwin);", "#endif", "#ifndef Tk_ManageGeometry_TCL_DECLARED", "#define Tk_ManageGeometry_TCL_DECLARED", "/* 124 */", "EXTERN void\t\tTk_ManageGeometry(Tk_Window tkwin,", "\t\t\t\tCONST Tk_GeomMgr *mgrPtr,", "\t\t\t\tClientData clientData);", "#endif", "#ifndef Tk_MapWindow_TCL_DECLARED", "#define Tk_MapWindow_TCL_DECLARED", "/* 125 */", "EXTERN void\t\tTk_MapWindow(Tk_Window tkwin);", "#endif", "#ifndef Tk_MeasureChars_TCL_DECLARED", "#define Tk_MeasureChars_TCL_DECLARED", "/* 126 */", "EXTERN int\t\tTk_MeasureChars(Tk_Font tkfont, CONST char *source,", "\t\t\t\tint numBytes, int maxPixels, int flags,", "\t\t\t\tint *lengthPtr);", "#endif", "#ifndef Tk_MoveResizeWindow_TCL_DECLARED", "#define Tk_MoveResizeWindow_TCL_DECLARED", "/* 127 */", "EXTERN void\t\tTk_MoveResizeWindow(Tk_Window tkwin, int x, int y,", "\t\t\t\tint width, int height);", "#endif", "#ifndef Tk_MoveWindow_TCL_DECLARED", "#define Tk_MoveWindow_TCL_DECLARED", "/* 128 */", "EXTERN void\t\tTk_MoveWindow(Tk_Window tkwin, int x, int y);", "#endif", "#ifndef Tk_MoveToplevelWindow_TCL_DECLARED", "#define Tk_MoveToplevelWindow_TCL_DECLARED", "/* 129 */", "EXTERN void\t\tTk_MoveToplevelWindow(Tk_Window tkwin, int x, int y);", "#endif", "#ifndef Tk_NameOf3DBorder_TCL_DECLARED", "#define Tk_NameOf3DBorder_TCL_DECLARED", "/* 130 */", "EXTERN CONST84_RETURN char * Tk_NameOf3DBorder(Tk_3DBorder border);", "#endif", "#ifndef Tk_NameOfAnchor_TCL_DECLARED", "#define Tk_NameOfAnchor_TCL_DECLARED", "/* 131 */", "EXTERN CONST84_RETURN char * Tk_NameOfAnchor(Tk_Anchor anchor);", "#endif", "#ifndef Tk_NameOfBitmap_TCL_DECLARED", "#define Tk_NameOfBitmap_TCL_DECLARED", "/* 132 */", "EXTERN CONST84_RETURN char * Tk_NameOfBitmap(Display *display, Pixmap bitmap);", "#endif", "#ifndef Tk_NameOfCapStyle_TCL_DECLARED", "#define Tk_NameOfCapStyle_TCL_DECLARED", "/* 133 */", "EXTERN CONST84_RETURN char * Tk_NameOfCapStyle(int cap);", "#endif", "#ifndef Tk_NameOfColor_TCL_DECLARED", "#define Tk_NameOfColor_TCL_DECLARED", "/* 134 */", "EXTERN CONST84_RETURN char * Tk_NameOfColor(XColor *colorPtr);", "#endif", "#ifndef Tk_NameOfCursor_TCL_DECLARED", "#define Tk_NameOfCursor_TCL_DECLARED", "/* 135 */", "EXTERN CONST84_RETURN char * Tk_NameOfCursor(Display *display,", "\t\t\t\tTk_Cursor cursor);", "#endif", "#ifndef Tk_NameOfFont_TCL_DECLARED", "#define Tk_NameOfFont_TCL_DECLARED", "/* 136 */", "EXTERN CONST84_RETURN char * Tk_NameOfFont(Tk_Font font);", "#endif", "#ifndef Tk_NameOfImage_TCL_DECLARED", "#define Tk_NameOfImage_TCL_DECLARED", "/* 137 */", "EXTERN CONST84_RETURN char * Tk_NameOfImage(Tk_ImageMaster imageMaster);", "#endif", "#ifndef Tk_NameOfJoinStyle_TCL_DECLARED", "#define Tk_NameOfJoinStyle_TCL_DECLARED", "/* 138 */", "EXTERN CONST84_RETURN char * Tk_NameOfJoinStyle(int join);", "#endif", "#ifndef Tk_NameOfJustify_TCL_DECLARED", "#define Tk_NameOfJustify_TCL_DECLARED", "/* 139 */", "EXTERN CONST84_RETURN char * Tk_NameOfJustify(Tk_Justify justify);", "#endif", "#ifndef Tk_NameOfRelief_TCL_DECLARED", "#define Tk_NameOfRelief_TCL_DECLARED", "/* 140 */", "EXTERN CONST84_RETURN char * Tk_NameOfRelief(int relief);", "#endif", "#ifndef Tk_NameToWindow_TCL_DECLARED", "#define Tk_NameToWindow_TCL_DECLARED", "/* 141 */", "EXTERN Tk_Window\tTk_NameToWindow(Tcl_Interp *interp,", "\t\t\t\tCONST char *pathName, Tk_Window tkwin);", "#endif", "#ifndef Tk_OwnSelection_TCL_DECLARED", "#define Tk_OwnSelection_TCL_DECLARED", "/* 142 */", "EXTERN void\t\tTk_OwnSelection(Tk_Window tkwin, Atom selection,", "\t\t\t\tTk_LostSelProc *proc, ClientData clientData);", "#endif", "#ifndef Tk_ParseArgv_TCL_DECLARED", "#define Tk_ParseArgv_TCL_DECLARED", "/* 143 */", "EXTERN int\t\tTk_ParseArgv(Tcl_Interp *interp, Tk_Window tkwin,", "\t\t\t\tint *argcPtr, CONST84 char **argv,", "\t\t\t\tTk_ArgvInfo *argTable, int flags);", "#endif", "#ifndef Tk_PhotoPutBlock_NoComposite_TCL_DECLARED", "#define Tk_PhotoPutBlock_NoComposite_TCL_DECLARED", "/* 144 */", "EXTERN void\t\tTk_PhotoPutBlock_NoComposite(Tk_PhotoHandle handle,", "\t\t\t\tTk_PhotoImageBlock *blockPtr, int x, int y,", "\t\t\t\tint width, int height);", "#endif", "#ifndef Tk_PhotoPutZoomedBlock_NoComposite_TCL_DECLARED", "#define Tk_PhotoPutZoomedBlock_NoComposite_TCL_DECLARED", "/* 145 */", "EXTERN void\t\tTk_PhotoPutZoomedBlock_NoComposite(", "\t\t\t\tTk_PhotoHandle handle,", "\t\t\t\tTk_PhotoImageBlock *blockPtr, int x, int y,", "\t\t\t\tint width, int height, int zoomX, int zoomY,", "\t\t\t\tint subsampleX, int subsampleY);", "#endif", "#ifndef Tk_PhotoGetImage_TCL_DECLARED", "#define Tk_PhotoGetImage_TCL_DECLARED", "/* 146 */", "EXTERN int\t\tTk_PhotoGetImage(Tk_PhotoHandle handle,", "\t\t\t\tTk_PhotoImageBlock *blockPtr);", "#endif", "#ifndef Tk_PhotoBlank_TCL_DECLARED", "#define Tk_PhotoBlank_TCL_DECLARED", "/* 147 */", "EXTERN void\t\tTk_PhotoBlank(Tk_PhotoHandle handle);", "#endif", "#ifndef Tk_PhotoExpand_Panic_TCL_DECLARED", "#define Tk_PhotoExpand_Panic_TCL_DECLARED", "/* 148 */", "EXTERN void\t\tTk_PhotoExpand_Panic(Tk_PhotoHandle handle,", "\t\t\t\tint width, int height);", "#endif", "#ifndef Tk_PhotoGetSize_TCL_DECLARED", "#define Tk_PhotoGetSize_TCL_DECLARED", "/* 149 */", "EXTERN void\t\tTk_PhotoGetSize(Tk_PhotoHandle handle, int *widthPtr,", "\t\t\t\tint *heightPtr);", "#endif", "#ifndef Tk_PhotoSetSize_Panic_TCL_DECLARED", "#define Tk_PhotoSetSize_Panic_TCL_DECLARED", "/* 150 */", "EXTERN void\t\tTk_PhotoSetSize_Panic(Tk_PhotoHandle handle,", "\t\t\t\tint width, int height);", "#endif", "#ifndef Tk_PointToChar_TCL_DECLARED", "#define Tk_PointToChar_TCL_DECLARED", "/* 151 */", "EXTERN int\t\tTk_PointToChar(Tk_TextLayout layout, int x, int y);", "#endif", "#ifndef Tk_PostscriptFontName_TCL_DECLARED", "#define Tk_PostscriptFontName_TCL_DECLARED", "/* 152 */", "EXTERN int\t\tTk_PostscriptFontName(Tk_Font tkfont,", "\t\t\t\tTcl_DString *dsPtr);", "#endif", "#ifndef Tk_PreserveColormap_TCL_DECLARED", "#define Tk_PreserveColormap_TCL_DECLARED", "/* 153 */", "EXTERN void\t\tTk_PreserveColormap(Display *display,", "\t\t\t\tColormap colormap);", "#endif", "#ifndef Tk_QueueWindowEvent_TCL_DECLARED", "#define Tk_QueueWindowEvent_TCL_DECLARED", "/* 154 */", "EXTERN void\t\tTk_QueueWindowEvent(XEvent *eventPtr,", "\t\t\t\tTcl_QueuePosition position);", "#endif", "#ifndef Tk_RedrawImage_TCL_DECLARED", "#define Tk_RedrawImage_TCL_DECLARED", "/* 155 */", "EXTERN void\t\tTk_RedrawImage(Tk_Image image, int imageX,", "\t\t\t\tint imageY, int width, int height,", "\t\t\t\tDrawable drawable, int drawableX,", "\t\t\t\tint drawableY);", "#endif", "#ifndef Tk_ResizeWindow_TCL_DECLARED", "#define Tk_ResizeWindow_TCL_DECLARED", "/* 156 */", "EXTERN void\t\tTk_ResizeWindow(Tk_Window tkwin, int width,", "\t\t\t\tint height);", "#endif", "#ifndef Tk_RestackWindow_TCL_DECLARED", "#define Tk_RestackWindow_TCL_DECLARED", "/* 157 */", "EXTERN int\t\tTk_RestackWindow(Tk_Window tkwin, int aboveBelow,", "\t\t\t\tTk_Window other);", "#endif", "#ifndef Tk_RestrictEvents_TCL_DECLARED", "#define Tk_RestrictEvents_TCL_DECLARED", "/* 158 */", "EXTERN Tk_RestrictProc * Tk_RestrictEvents(Tk_RestrictProc *proc,", "\t\t\t\tClientData arg, ClientData *prevArgPtr);", "#endif", "#ifndef Tk_SafeInit_TCL_DECLARED", "#define Tk_SafeInit_TCL_DECLARED", "/* 159 */", "EXTERN int\t\tTk_SafeInit(Tcl_Interp *interp);", "#endif", "#ifndef Tk_SetAppName_TCL_DECLARED", "#define Tk_SetAppName_TCL_DECLARED", "/* 160 */", "EXTERN CONST char *\tTk_SetAppName(Tk_Window tkwin, CONST char *name);", "#endif", "#ifndef Tk_SetBackgroundFromBorder_TCL_DECLARED", "#define Tk_SetBackgroundFromBorder_TCL_DECLARED", "/* 161 */", "EXTERN void\t\tTk_SetBackgroundFromBorder(Tk_Window tkwin,", "\t\t\t\tTk_3DBorder border);", "#endif", "#ifndef Tk_SetClass_TCL_DECLARED", "#define Tk_SetClass_TCL_DECLARED", "/* 162 */", "EXTERN void\t\tTk_SetClass(Tk_Window tkwin, CONST char *className);", "#endif", "#ifndef Tk_SetGrid_TCL_DECLARED", "#define Tk_SetGrid_TCL_DECLARED", "/* 163 */", "EXTERN void\t\tTk_SetGrid(Tk_Window tkwin, int reqWidth,", "\t\t\t\tint reqHeight, int gridWidth, int gridHeight);", "#endif", "#ifndef Tk_SetInternalBorder_TCL_DECLARED", "#define Tk_SetInternalBorder_TCL_DECLARED", "/* 164 */", "EXTERN void\t\tTk_SetInternalBorder(Tk_Window tkwin, int width);", "#endif", "#ifndef Tk_SetWindowBackground_TCL_DECLARED", "#define Tk_SetWindowBackground_TCL_DECLARED", "/* 165 */", "EXTERN void\t\tTk_SetWindowBackground(Tk_Window tkwin,", "\t\t\t\tunsigned long pixel);", "#endif", "#ifndef Tk_SetWindowBackgroundPixmap_TCL_DECLARED", "#define Tk_SetWindowBackgroundPixmap_TCL_DECLARED", "/* 166 */", "EXTERN void\t\tTk_SetWindowBackgroundPixmap(Tk_Window tkwin,", "\t\t\t\tPixmap pixmap);", "#endif", "#ifndef Tk_SetWindowBorder_TCL_DECLARED", "#define Tk_SetWindowBorder_TCL_DECLARED", "/* 167 */", "EXTERN void\t\tTk_SetWindowBorder(Tk_Window tkwin,", "\t\t\t\tunsigned long pixel);", "#endif", "#ifndef Tk_SetWindowBorderWidth_TCL_DECLARED", "#define Tk_SetWindowBorderWidth_TCL_DECLARED", "/* 168 */", "EXTERN void\t\tTk_SetWindowBorderWidth(Tk_Window tkwin, int width);", "#endif", "#ifndef Tk_SetWindowBorderPixmap_TCL_DECLARED", "#define Tk_SetWindowBorderPixmap_TCL_DECLARED", "/* 169 */", "EXTERN void\t\tTk_SetWindowBorderPixmap(Tk_Window tkwin,", "\t\t\t\tPixmap pixmap);", "#endif", "#ifndef Tk_SetWindowColormap_TCL_DECLARED", "#define Tk_SetWindowColormap_TCL_DECLARED", "/* 170 */", "EXTERN void\t\tTk_SetWindowColormap(Tk_Window tkwin,", "\t\t\t\tColormap colormap);", "#endif", "#ifndef Tk_SetWindowVisual_TCL_DECLARED", "#define Tk_SetWindowVisual_TCL_DECLARED", "/* 171 */", "EXTERN int\t\tTk_SetWindowVisual(Tk_Window tkwin, Visual *visual,", "\t\t\t\tint depth, Colormap colormap);", "#endif", "#ifndef Tk_SizeOfBitmap_TCL_DECLARED", "#define Tk_SizeOfBitmap_TCL_DECLARED", "/* 172 */", "EXTERN void\t\tTk_SizeOfBitmap(Display *display, Pixmap bitmap,", "\t\t\t\tint *widthPtr, int *heightPtr);", "#endif", "#ifndef Tk_SizeOfImage_TCL_DECLARED", "#define Tk_SizeOfImage_TCL_DECLARED", "/* 173 */", "EXTERN void\t\tTk_SizeOfImage(Tk_Image image, int *widthPtr,", "\t\t\t\tint *heightPtr);", "#endif", "#ifndef Tk_StrictMotif_TCL_DECLARED", "#define Tk_StrictMotif_TCL_DECLARED", "/* 174 */", "EXTERN int\t\tTk_StrictMotif(Tk_Window tkwin);", "#endif", "#ifndef Tk_TextLayoutToPostscript_TCL_DECLARED", "#define Tk_TextLayoutToPostscript_TCL_DECLARED", "/* 175 */", "EXTERN void\t\tTk_TextLayoutToPostscript(Tcl_Interp *interp,", "\t\t\t\tTk_TextLayout layout);", "#endif", "#ifndef Tk_TextWidth_TCL_DECLARED", "#define Tk_TextWidth_TCL_DECLARED", "/* 176 */", "EXTERN int\t\tTk_TextWidth(Tk_Font font, CONST char *str,", "\t\t\t\tint numBytes);", "#endif", "#ifndef Tk_UndefineCursor_TCL_DECLARED", "#define Tk_UndefineCursor_TCL_DECLARED", "/* 177 */", "EXTERN void\t\tTk_UndefineCursor(Tk_Window window);", "#endif", "#ifndef Tk_UnderlineChars_TCL_DECLARED", "#define Tk_UnderlineChars_TCL_DECLARED", "/* 178 */", "EXTERN void\t\tTk_UnderlineChars(Display *display,", "\t\t\t\tDrawable drawable, GC gc, Tk_Font tkfont,", "\t\t\t\tCONST char *source, int x, int y,", "\t\t\t\tint firstByte, int lastByte);", "#endif", "#ifndef Tk_UnderlineTextLayout_TCL_DECLARED", "#define Tk_UnderlineTextLayout_TCL_DECLARED", "/* 179 */", "EXTERN void\t\tTk_UnderlineTextLayout(Display *display,", "\t\t\t\tDrawable drawable, GC gc,", "\t\t\t\tTk_TextLayout layout, int x, int y,", "\t\t\t\tint underline);", "#endif", "#ifndef Tk_Ungrab_TCL_DECLARED", "#define Tk_Ungrab_TCL_DECLARED", "/* 180 */", "EXTERN void\t\tTk_Ungrab(Tk_Window tkwin);", "#endif", "#ifndef Tk_UnmaintainGeometry_TCL_DECLARED", "#define Tk_UnmaintainGeometry_TCL_DECLARED", "/* 181 */", "EXTERN void\t\tTk_UnmaintainGeometry(Tk_Window slave,", "\t\t\t\tTk_Window master);", "#endif", "#ifndef Tk_UnmapWindow_TCL_DECLARED", "#define Tk_UnmapWindow_TCL_DECLARED", "/* 182 */", "EXTERN void\t\tTk_UnmapWindow(Tk_Window tkwin);", "#endif", "#ifndef Tk_UnsetGrid_TCL_DECLARED", "#define Tk_UnsetGrid_TCL_DECLARED", "/* 183 */", "EXTERN void\t\tTk_UnsetGrid(Tk_Window tkwin);", "#endif", "#ifndef Tk_UpdatePointer_TCL_DECLARED", "#define Tk_UpdatePointer_TCL_DECLARED", "/* 184 */", "EXTERN void\t\tTk_UpdatePointer(Tk_Window tkwin, int x, int y,", "\t\t\t\tint state);", "#endif", "#ifndef Tk_AllocBitmapFromObj_TCL_DECLARED", "#define Tk_AllocBitmapFromObj_TCL_DECLARED", "/* 185 */", "EXTERN Pixmap\t\tTk_AllocBitmapFromObj(Tcl_Interp *interp,", "\t\t\t\tTk_Window tkwin, Tcl_Obj *objPtr);", "#endif", "#ifndef Tk_Alloc3DBorderFromObj_TCL_DECLARED", "#define Tk_Alloc3DBorderFromObj_TCL_DECLARED", "/* 186 */", "EXTERN Tk_3DBorder\tTk_Alloc3DBorderFromObj(Tcl_Interp *interp,", "\t\t\t\tTk_Window tkwin, Tcl_Obj *objPtr);", "#endif", "#ifndef Tk_AllocColorFromObj_TCL_DECLARED", "#define Tk_AllocColorFromObj_TCL_DECLARED", "/* 187 */", "EXTERN XColor *\t\tTk_AllocColorFromObj(Tcl_Interp *interp,", "\t\t\t\tTk_Window tkwin, Tcl_Obj *objPtr);", "#endif", "#ifndef Tk_AllocCursorFromObj_TCL_DECLARED", "#define Tk_AllocCursorFromObj_TCL_DECLARED", "/* 188 */", "EXTERN Tk_Cursor\tTk_AllocCursorFromObj(Tcl_Interp *interp,", "\t\t\t\tTk_Window tkwin, Tcl_Obj *objPtr);", "#endif", "#ifndef Tk_AllocFontFromObj_TCL_DECLARED", "#define Tk_AllocFontFromObj_TCL_DECLARED", "/* 189 */", "EXTERN Tk_Font\t\tTk_AllocFontFromObj(Tcl_Interp *interp,", "\t\t\t\tTk_Window tkwin, Tcl_Obj *objPtr);", "#endif", "#ifndef Tk_CreateOptionTable_TCL_DECLARED", "#define Tk_CreateOptionTable_TCL_DECLARED", "/* 190 */", "EXTERN Tk_OptionTable\tTk_CreateOptionTable(Tcl_Interp *interp,", "\t\t\t\tCONST Tk_OptionSpec *templatePtr);", "#endif", "#ifndef Tk_DeleteOptionTable_TCL_DECLARED", "#define Tk_DeleteOptionTable_TCL_DECLARED", "/* 191 */", "EXTERN void\t\tTk_DeleteOptionTable(Tk_OptionTable optionTable);", "#endif", "#ifndef Tk_Free3DBorderFromObj_TCL_DECLARED", "#define Tk_Free3DBorderFromObj_TCL_DECLARED", "/* 192 */", "EXTERN void\t\tTk_Free3DBorderFromObj(Tk_Window tkwin,", "\t\t\t\tTcl_Obj *objPtr);", "#endif", "#ifndef Tk_FreeBitmapFromObj_TCL_DECLARED", "#define Tk_FreeBitmapFromObj_TCL_DECLARED", "/* 193 */", "EXTERN void\t\tTk_FreeBitmapFromObj(Tk_Window tkwin,", "\t\t\t\tTcl_Obj *objPtr);", "#endif", "#ifndef Tk_FreeColorFromObj_TCL_DECLARED", "#define Tk_FreeColorFromObj_TCL_DECLARED", "/* 194 */", "EXTERN void\t\tTk_FreeColorFromObj(Tk_Window tkwin, Tcl_Obj *objPtr);", "#endif", "#ifndef Tk_FreeConfigOptions_TCL_DECLARED", "#define Tk_FreeConfigOptions_TCL_DECLARED", "/* 195 */", "EXTERN void\t\tTk_FreeConfigOptions(char *recordPtr,", "\t\t\t\tTk_OptionTable optionToken, Tk_Window tkwin);", "#endif", "#ifndef Tk_FreeSavedOptions_TCL_DECLARED", "#define Tk_FreeSavedOptions_TCL_DECLARED", "/* 196 */", "EXTERN void\t\tTk_FreeSavedOptions(Tk_SavedOptions *savePtr);", "#endif", "#ifndef Tk_FreeCursorFromObj_TCL_DECLARED", "#define Tk_FreeCursorFromObj_TCL_DECLARED", "/* 197 */", "EXTERN void\t\tTk_FreeCursorFromObj(Tk_Window tkwin,", "\t\t\t\tTcl_Obj *objPtr);", "#endif", "#ifndef Tk_FreeFontFromObj_TCL_DECLARED", "#define Tk_FreeFontFromObj_TCL_DECLARED", "/* 198 */", "EXTERN void\t\tTk_FreeFontFromObj(Tk_Window tkwin, Tcl_Obj *objPtr);", "#endif", "#ifndef Tk_Get3DBorderFromObj_TCL_DECLARED", "#define Tk_Get3DBorderFromObj_TCL_DECLARED", "/* 199 */", "EXTERN Tk_3DBorder\tTk_Get3DBorderFromObj(Tk_Window tkwin,", "\t\t\t\tTcl_Obj *objPtr);", "#endif", "#ifndef Tk_GetAnchorFromObj_TCL_DECLARED", "#define Tk_GetAnchorFromObj_TCL_DECLARED", "/* 200 */", "EXTERN int\t\tTk_GetAnchorFromObj(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *objPtr, Tk_Anchor *anchorPtr);", "#endif", "#ifndef Tk_GetBitmapFromObj_TCL_DECLARED", "#define Tk_GetBitmapFromObj_TCL_DECLARED", "/* 201 */", "EXTERN Pixmap\t\tTk_GetBitmapFromObj(Tk_Window tkwin, Tcl_Obj *objPtr);", "#endif", "#ifndef Tk_GetColorFromObj_TCL_DECLARED", "#define Tk_GetColorFromObj_TCL_DECLARED", "/* 202 */", "EXTERN XColor *\t\tTk_GetColorFromObj(Tk_Window tkwin, Tcl_Obj *objPtr);", "#endif", "#ifndef Tk_GetCursorFromObj_TCL_DECLARED", "#define Tk_GetCursorFromObj_TCL_DECLARED", "/* 203 */", "EXTERN Tk_Cursor\tTk_GetCursorFromObj(Tk_Window tkwin, Tcl_Obj *objPtr);", "#endif", "#ifndef Tk_GetOptionInfo_TCL_DECLARED", "#define Tk_GetOptionInfo_TCL_DECLARED", "/* 204 */", "EXTERN Tcl_Obj *\tTk_GetOptionInfo(Tcl_Interp *interp, char *recordPtr,", "\t\t\t\tTk_OptionTable optionTable, Tcl_Obj *namePtr,", "\t\t\t\tTk_Window tkwin);", "#endif", "#ifndef Tk_GetOptionValue_TCL_DECLARED", "#define Tk_GetOptionValue_TCL_DECLARED", "/* 205 */", "EXTERN Tcl_Obj *\tTk_GetOptionValue(Tcl_Interp *interp,", "\t\t\t\tchar *recordPtr, Tk_OptionTable optionTable,", "\t\t\t\tTcl_Obj *namePtr, Tk_Window tkwin);", "#endif", "#ifndef Tk_GetJustifyFromObj_TCL_DECLARED", "#define Tk_GetJustifyFromObj_TCL_DECLARED", "/* 206 */", "EXTERN int\t\tTk_GetJustifyFromObj(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *objPtr, Tk_Justify *justifyPtr);", "#endif", "#ifndef Tk_GetMMFromObj_TCL_DECLARED", "#define Tk_GetMMFromObj_TCL_DECLARED", "/* 207 */", "EXTERN int\t\tTk_GetMMFromObj(Tcl_Interp *interp, Tk_Window tkwin,", "\t\t\t\tTcl_Obj *objPtr, double *doublePtr);", "#endif", "#ifndef Tk_GetPixelsFromObj_TCL_DECLARED", "#define Tk_GetPixelsFromObj_TCL_DECLARED", "/* 208 */", "EXTERN int\t\tTk_GetPixelsFromObj(Tcl_Interp *interp,", "\t\t\t\tTk_Window tkwin, Tcl_Obj *objPtr,", "\t\t\t\tint *intPtr);", "#endif", "#ifndef Tk_GetReliefFromObj_TCL_DECLARED", "#define Tk_GetReliefFromObj_TCL_DECLARED", "/* 209 */", "EXTERN int\t\tTk_GetReliefFromObj(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *objPtr, int *resultPtr);", "#endif", "#ifndef Tk_GetScrollInfoObj_TCL_DECLARED", "#define Tk_GetScrollInfoObj_TCL_DECLARED", "/* 210 */", "EXTERN int\t\tTk_GetScrollInfoObj(Tcl_Interp *interp, int objc,", "\t\t\t\tTcl_Obj *CONST objv[], double *dblPtr,", "\t\t\t\tint *intPtr);", "#endif", "#ifndef Tk_InitOptions_TCL_DECLARED", "#define Tk_InitOptions_TCL_DECLARED", "/* 211 */", "EXTERN int\t\tTk_InitOptions(Tcl_Interp *interp, char *recordPtr,", "\t\t\t\tTk_OptionTable optionToken, Tk_Window tkwin);", "#endif", "#ifndef Tk_MainEx_TCL_DECLARED", "#define Tk_MainEx_TCL_DECLARED", "/* 212 */", "EXTERN void\t\tTk_MainEx(int argc, char **argv,", "\t\t\t\tTcl_AppInitProc *appInitProc,", "\t\t\t\tTcl_Interp *interp);", "#endif", "#ifndef Tk_RestoreSavedOptions_TCL_DECLARED", "#define Tk_RestoreSavedOptions_TCL_DECLARED", "/* 213 */", "EXTERN void\t\tTk_RestoreSavedOptions(Tk_SavedOptions *savePtr);", "#endif", "#ifndef Tk_SetOptions_TCL_DECLARED", "#define Tk_SetOptions_TCL_DECLARED", "/* 214 */", "EXTERN int\t\tTk_SetOptions(Tcl_Interp *interp, char *recordPtr,", "\t\t\t\tTk_OptionTable optionTable, int objc,", "\t\t\t\tTcl_Obj *CONST objv[], Tk_Window tkwin,", "\t\t\t\tTk_SavedOptions *savePtr, int *maskPtr);", "#endif", "#ifndef Tk_InitConsoleChannels_TCL_DECLARED", "#define Tk_InitConsoleChannels_TCL_DECLARED", "/* 215 */", "EXTERN void\t\tTk_InitConsoleChannels(Tcl_Interp *interp);", "#endif", "#ifndef Tk_CreateConsoleWindow_TCL_DECLARED", "#define Tk_CreateConsoleWindow_TCL_DECLARED", "/* 216 */", "EXTERN int\t\tTk_CreateConsoleWindow(Tcl_Interp *interp);", "#endif", "#ifndef Tk_CreateSmoothMethod_TCL_DECLARED", "#define Tk_CreateSmoothMethod_TCL_DECLARED", "/* 217 */", "EXTERN void\t\tTk_CreateSmoothMethod(Tcl_Interp *interp,", "\t\t\t\tTk_SmoothMethod *method);", "#endif", "/* Slot 218 is reserved */", "/* Slot 219 is reserved */", "#ifndef Tk_GetDash_TCL_DECLARED", "#define Tk_GetDash_TCL_DECLARED", "/* 220 */", "EXTERN int\t\tTk_GetDash(Tcl_Interp *interp, CONST char *value,", "\t\t\t\tTk_Dash *dash);", "#endif", "#ifndef Tk_CreateOutline_TCL_DECLARED", "#define Tk_CreateOutline_TCL_DECLARED", "/* 221 */", "EXTERN void\t\tTk_CreateOutline(Tk_Outline *outline);", "#endif", "#ifndef Tk_DeleteOutline_TCL_DECLARED", "#define Tk_DeleteOutline_TCL_DECLARED", "/* 222 */", "EXTERN void\t\tTk_DeleteOutline(Display *display,", "\t\t\t\tTk_Outline *outline);", "#endif", "#ifndef Tk_ConfigOutlineGC_TCL_DECLARED", "#define Tk_ConfigOutlineGC_TCL_DECLARED", "/* 223 */", "EXTERN int\t\tTk_ConfigOutlineGC(XGCValues *gcValues,", "\t\t\t\tTk_Canvas canvas, Tk_Item *item,", "\t\t\t\tTk_Outline *outline);", "#endif", "#ifndef Tk_ChangeOutlineGC_TCL_DECLARED", "#define Tk_ChangeOutlineGC_TCL_DECLARED", "/* 224 */", "EXTERN int\t\tTk_ChangeOutlineGC(Tk_Canvas canvas, Tk_Item *item,", "\t\t\t\tTk_Outline *outline);", "#endif", "#ifndef Tk_ResetOutlineGC_TCL_DECLARED", "#define Tk_ResetOutlineGC_TCL_DECLARED", "/* 225 */", "EXTERN int\t\tTk_ResetOutlineGC(Tk_Canvas canvas, Tk_Item *item,", "\t\t\t\tTk_Outline *outline);", "#endif", "#ifndef Tk_CanvasPsOutline_TCL_DECLARED", "#define Tk_CanvasPsOutline_TCL_DECLARED", "/* 226 */", "EXTERN int\t\tTk_CanvasPsOutline(Tk_Canvas canvas, Tk_Item *item,", "\t\t\t\tTk_Outline *outline);", "#endif", "#ifndef Tk_SetTSOrigin_TCL_DECLARED", "#define Tk_SetTSOrigin_TCL_DECLARED", "/* 227 */", "EXTERN void\t\tTk_SetTSOrigin(Tk_Window tkwin, GC gc, int x, int y);", "#endif", "#ifndef Tk_CanvasGetCoordFromObj_TCL_DECLARED", "#define Tk_CanvasGetCoordFromObj_TCL_DECLARED", "/* 228 */", "EXTERN int\t\tTk_CanvasGetCoordFromObj(Tcl_Interp *interp,", "\t\t\t\tTk_Canvas canvas, Tcl_Obj *obj,", "\t\t\t\tdouble *doublePtr);", "#endif", "#ifndef Tk_CanvasSetOffset_TCL_DECLARED", "#define Tk_CanvasSetOffset_TCL_DECLARED", "/* 229 */", "EXTERN void\t\tTk_CanvasSetOffset(Tk_Canvas canvas, GC gc,", "\t\t\t\tTk_TSOffset *offset);", "#endif", "#ifndef Tk_DitherPhoto_TCL_DECLARED", "#define Tk_DitherPhoto_TCL_DECLARED", "/* 230 */", "EXTERN void\t\tTk_DitherPhoto(Tk_PhotoHandle handle, int x, int y,", "\t\t\t\tint width, int height);", "#endif", "#ifndef Tk_PostscriptBitmap_TCL_DECLARED", "#define Tk_PostscriptBitmap_TCL_DECLARED", "/* 231 */", "EXTERN int\t\tTk_PostscriptBitmap(Tcl_Interp *interp,", "\t\t\t\tTk_Window tkwin, Tk_PostscriptInfo psInfo,", "\t\t\t\tPixmap bitmap, int startX, int startY,", "\t\t\t\tint width, int height);", "#endif", "#ifndef Tk_PostscriptColor_TCL_DECLARED", "#define Tk_PostscriptColor_TCL_DECLARED", "/* 232 */", "EXTERN int\t\tTk_PostscriptColor(Tcl_Interp *interp,", "\t\t\t\tTk_PostscriptInfo psInfo, XColor *colorPtr);", "#endif", "#ifndef Tk_PostscriptFont_TCL_DECLARED", "#define Tk_PostscriptFont_TCL_DECLARED", "/* 233 */", "EXTERN int\t\tTk_PostscriptFont(Tcl_Interp *interp,", "\t\t\t\tTk_PostscriptInfo psInfo, Tk_Font font);", "#endif", "#ifndef Tk_PostscriptImage_TCL_DECLARED", "#define Tk_PostscriptImage_TCL_DECLARED", "/* 234 */", "EXTERN int\t\tTk_PostscriptImage(Tk_Image image,", "\t\t\t\tTcl_Interp *interp, Tk_Window tkwin,", "\t\t\t\tTk_PostscriptInfo psinfo, int x, int y,", "\t\t\t\tint width, int height, int prepass);", "#endif", "#ifndef Tk_PostscriptPath_TCL_DECLARED", "#define Tk_PostscriptPath_TCL_DECLARED", "/* 235 */", "EXTERN void\t\tTk_PostscriptPath(Tcl_Interp *interp,", "\t\t\t\tTk_PostscriptInfo psInfo, double *coordPtr,", "\t\t\t\tint numPoints);", "#endif", "#ifndef Tk_PostscriptStipple_TCL_DECLARED", "#define Tk_PostscriptStipple_TCL_DECLARED", "/* 236 */", "EXTERN int\t\tTk_PostscriptStipple(Tcl_Interp *interp,", "\t\t\t\tTk_Window tkwin, Tk_PostscriptInfo psInfo,", "\t\t\t\tPixmap bitmap);", "#endif", "#ifndef Tk_PostscriptY_TCL_DECLARED", "#define Tk_PostscriptY_TCL_DECLARED", "/* 237 */", "EXTERN double\t\tTk_PostscriptY(double y, Tk_PostscriptInfo psInfo);", "#endif", "#ifndef Tk_PostscriptPhoto_TCL_DECLARED", "#define Tk_PostscriptPhoto_TCL_DECLARED", "/* 238 */", "EXTERN int\t\tTk_PostscriptPhoto(Tcl_Interp *interp,", "\t\t\t\tTk_PhotoImageBlock *blockPtr,", "\t\t\t\tTk_PostscriptInfo psInfo, int width,", "\t\t\t\tint height);", "#endif", "#ifndef Tk_CreateClientMessageHandler_TCL_DECLARED", "#define Tk_CreateClientMessageHandler_TCL_DECLARED", "/* 239 */", "EXTERN void\t\tTk_CreateClientMessageHandler(", "\t\t\t\tTk_ClientMessageProc *proc);", "#endif", "#ifndef Tk_DeleteClientMessageHandler_TCL_DECLARED", "#define Tk_DeleteClientMessageHandler_TCL_DECLARED", "/* 240 */", "EXTERN void\t\tTk_DeleteClientMessageHandler(", "\t\t\t\tTk_ClientMessageProc *proc);", "#endif", "#ifndef Tk_CreateAnonymousWindow_TCL_DECLARED", "#define Tk_CreateAnonymousWindow_TCL_DECLARED", "/* 241 */", "EXTERN Tk_Window\tTk_CreateAnonymousWindow(Tcl_Interp *interp,", "\t\t\t\tTk_Window parent, CONST char *screenName);", "#endif", "#ifndef Tk_SetClassProcs_TCL_DECLARED", "#define Tk_SetClassProcs_TCL_DECLARED", "/* 242 */", "EXTERN void\t\tTk_SetClassProcs(Tk_Window tkwin,", "\t\t\t\tTk_ClassProcs *procs,", "\t\t\t\tClientData instanceData);", "#endif", "#ifndef Tk_SetInternalBorderEx_TCL_DECLARED", "#define Tk_SetInternalBorderEx_TCL_DECLARED", "/* 243 */", "EXTERN void\t\tTk_SetInternalBorderEx(Tk_Window tkwin, int left,", "\t\t\t\tint right, int top, int bottom);", "#endif", "#ifndef Tk_SetMinimumRequestSize_TCL_DECLARED", "#define Tk_SetMinimumRequestSize_TCL_DECLARED", "/* 244 */", "EXTERN void\t\tTk_SetMinimumRequestSize(Tk_Window tkwin,", "\t\t\t\tint minWidth, int minHeight);", "#endif", "#ifndef Tk_SetCaretPos_TCL_DECLARED", "#define Tk_SetCaretPos_TCL_DECLARED", "/* 245 */", "EXTERN void\t\tTk_SetCaretPos(Tk_Window tkwin, int x, int y,", "\t\t\t\tint height);", "#endif", "#ifndef Tk_PhotoPutBlock_Panic_TCL_DECLARED", "#define Tk_PhotoPutBlock_Panic_TCL_DECLARED", "/* 246 */", "EXTERN void\t\tTk_PhotoPutBlock_Panic(Tk_PhotoHandle handle,", "\t\t\t\tTk_PhotoImageBlock *blockPtr, int x, int y,", "\t\t\t\tint width, int height, int compRule);", "#endif", "#ifndef Tk_PhotoPutZoomedBlock_Panic_TCL_DECLARED", "#define Tk_PhotoPutZoomedBlock_Panic_TCL_DECLARED", "/* 247 */", "EXTERN void\t\tTk_PhotoPutZoomedBlock_Panic(Tk_PhotoHandle handle,", "\t\t\t\tTk_PhotoImageBlock *blockPtr, int x, int y,", "\t\t\t\tint width, int height, int zoomX, int zoomY,", "\t\t\t\tint subsampleX, int subsampleY, int compRule);", "#endif", "#ifndef Tk_CollapseMotionEvents_TCL_DECLARED", "#define Tk_CollapseMotionEvents_TCL_DECLARED", "/* 248 */", "EXTERN int\t\tTk_CollapseMotionEvents(Display *display,", "\t\t\t\tint collapse);", "#endif", "#ifndef Tk_RegisterStyleEngine_TCL_DECLARED", "#define Tk_RegisterStyleEngine_TCL_DECLARED", "/* 249 */", "EXTERN Tk_StyleEngine\tTk_RegisterStyleEngine(CONST char *name,", "\t\t\t\tTk_StyleEngine parent);", "#endif", "#ifndef Tk_GetStyleEngine_TCL_DECLARED", "#define Tk_GetStyleEngine_TCL_DECLARED", "/* 250 */", "EXTERN Tk_StyleEngine\tTk_GetStyleEngine(CONST char *name);", "#endif", "#ifndef Tk_RegisterStyledElement_TCL_DECLARED", "#define Tk_RegisterStyledElement_TCL_DECLARED", "/* 251 */", "EXTERN int\t\tTk_RegisterStyledElement(Tk_StyleEngine engine,", "\t\t\t\tTk_ElementSpec *templatePtr);", "#endif", "#ifndef Tk_GetElementId_TCL_DECLARED", "#define Tk_GetElementId_TCL_DECLARED", "/* 252 */", "EXTERN int\t\tTk_GetElementId(CONST char *name);", "#endif", "#ifndef Tk_CreateStyle_TCL_DECLARED", "#define Tk_CreateStyle_TCL_DECLARED", "/* 253 */", "EXTERN Tk_Style\t\tTk_CreateStyle(CONST char *name,", "\t\t\t\tTk_StyleEngine engine, ClientData clientData);", "#endif", "#ifndef Tk_GetStyle_TCL_DECLARED", "#define Tk_GetStyle_TCL_DECLARED", "/* 254 */", "EXTERN Tk_Style\t\tTk_GetStyle(Tcl_Interp *interp, CONST char *name);", "#endif", "#ifndef Tk_FreeStyle_TCL_DECLARED", "#define Tk_FreeStyle_TCL_DECLARED", "/* 255 */", "EXTERN void\t\tTk_FreeStyle(Tk_Style style);", "#endif", "#ifndef Tk_NameOfStyle_TCL_DECLARED", "#define Tk_NameOfStyle_TCL_DECLARED", "/* 256 */", "EXTERN CONST char *\tTk_NameOfStyle(Tk_Style style);", "#endif", "#ifndef Tk_AllocStyleFromObj_TCL_DECLARED", "#define Tk_AllocStyleFromObj_TCL_DECLARED", "/* 257 */", "EXTERN Tk_Style\t\tTk_AllocStyleFromObj(Tcl_Interp *interp,", "\t\t\t\tTcl_Obj *objPtr);", "#endif", "#ifndef Tk_GetStyleFromObj_TCL_DECLARED", "#define Tk_GetStyleFromObj_TCL_DECLARED", "/* 258 */", "EXTERN Tk_Style\t\tTk_GetStyleFromObj(Tcl_Obj *objPtr);", "#endif", "#ifndef Tk_FreeStyleFromObj_TCL_DECLARED", "#define Tk_FreeStyleFromObj_TCL_DECLARED", "/* 259 */", "EXTERN void\t\tTk_FreeStyleFromObj(Tcl_Obj *objPtr);", "#endif", "#ifndef Tk_GetStyledElement_TCL_DECLARED", "#define Tk_GetStyledElement_TCL_DECLARED", "/* 260 */", "EXTERN Tk_StyledElement\t Tk_GetStyledElement(Tk_Style style, int elementId,", "\t\t\t\tTk_OptionTable optionTable);", "#endif", "#ifndef Tk_GetElementSize_TCL_DECLARED", "#define Tk_GetElementSize_TCL_DECLARED", "/* 261 */", "EXTERN void\t\tTk_GetElementSize(Tk_Style style,", "\t\t\t\tTk_StyledElement element, char *recordPtr,", "\t\t\t\tTk_Window tkwin, int width, int height,", "\t\t\t\tint inner, int *widthPtr, int *heightPtr);", "#endif", "#ifndef Tk_GetElementBox_TCL_DECLARED", "#define Tk_GetElementBox_TCL_DECLARED", "/* 262 */", "EXTERN void\t\tTk_GetElementBox(Tk_Style style,", "\t\t\t\tTk_StyledElement element, char *recordPtr,", "\t\t\t\tTk_Window tkwin, int x, int y, int width,", "\t\t\t\tint height, int inner, int *xPtr, int *yPtr,", "\t\t\t\tint *widthPtr, int *heightPtr);", "#endif", "#ifndef Tk_GetElementBorderWidth_TCL_DECLARED", "#define Tk_GetElementBorderWidth_TCL_DECLARED", "/* 263 */", "EXTERN int\t\tTk_GetElementBorderWidth(Tk_Style style,", "\t\t\t\tTk_StyledElement element, char *recordPtr,", "\t\t\t\tTk_Window tkwin);", "#endif", "#ifndef Tk_DrawElement_TCL_DECLARED", "#define Tk_DrawElement_TCL_DECLARED", "/* 264 */", "EXTERN void\t\tTk_DrawElement(Tk_Style style,", "\t\t\t\tTk_StyledElement element, char *recordPtr,", "\t\t\t\tTk_Window tkwin, Drawable d, int x, int y,", "\t\t\t\tint width, int height, int state);", "#endif", "#ifndef Tk_PhotoExpand_TCL_DECLARED", "#define Tk_PhotoExpand_TCL_DECLARED", "/* 265 */", "EXTERN int\t\tTk_PhotoExpand(Tcl_Interp *interp,", "\t\t\t\tTk_PhotoHandle handle, int width, int height);", "#endif", "#ifndef Tk_PhotoPutBlock_TCL_DECLARED", "#define Tk_PhotoPutBlock_TCL_DECLARED", "/* 266 */", "EXTERN int\t\tTk_PhotoPutBlock(Tcl_Interp *interp,", "\t\t\t\tTk_PhotoHandle handle,", "\t\t\t\tTk_PhotoImageBlock *blockPtr, int x, int y,", "\t\t\t\tint width, int height, int compRule);", "#endif", "#ifndef Tk_PhotoPutZoomedBlock_TCL_DECLARED", "#define Tk_PhotoPutZoomedBlock_TCL_DECLARED", "/* 267 */", "EXTERN int\t\tTk_PhotoPutZoomedBlock(Tcl_Interp *interp,", "\t\t\t\tTk_PhotoHandle handle,", "\t\t\t\tTk_PhotoImageBlock *blockPtr, int x, int y,", "\t\t\t\tint width, int height, int zoomX, int zoomY,", "\t\t\t\tint subsampleX, int subsampleY, int compRule);", "#endif", "#ifndef Tk_PhotoSetSize_TCL_DECLARED", "#define Tk_PhotoSetSize_TCL_DECLARED", "/* 268 */", "EXTERN int\t\tTk_PhotoSetSize(Tcl_Interp *interp,", "\t\t\t\tTk_PhotoHandle handle, int width, int height);", "#endif", "#ifndef Tk_GetUserInactiveTime_TCL_DECLARED", "#define Tk_GetUserInactiveTime_TCL_DECLARED", "/* 269 */", "EXTERN long\t\tTk_GetUserInactiveTime(Display *dpy);", "#endif", "#ifndef Tk_ResetUserInactiveTime_TCL_DECLARED", "#define Tk_ResetUserInactiveTime_TCL_DECLARED", "/* 270 */", "EXTERN void\t\tTk_ResetUserInactiveTime(Display *dpy);", "#endif", "#ifndef Tk_Interp_TCL_DECLARED", "#define Tk_Interp_TCL_DECLARED", "/* 271 */", "EXTERN Tcl_Interp *\tTk_Interp(Tk_Window tkwin);", "#endif", "#ifndef Tk_CreateOldImageType_TCL_DECLARED", "#define Tk_CreateOldImageType_TCL_DECLARED", "/* 272 */", "EXTERN void\t\tTk_CreateOldImageType(Tk_ImageType *typePtr);", "#endif", "#ifndef Tk_CreateOldPhotoImageFormat_TCL_DECLARED", "#define Tk_CreateOldPhotoImageFormat_TCL_DECLARED", "/* 273 */", "EXTERN void\t\tTk_CreateOldPhotoImageFormat(", "\t\t\t\tTk_PhotoImageFormat *formatPtr);", "#endif", "", "typedef struct TkStubHooks {", "    struct TkPlatStubs *tkPlatStubs;", "    struct TkIntStubs *tkIntStubs;", "    struct TkIntPlatStubs *tkIntPlatStubs;", "    struct TkIntXlibStubs *tkIntXlibStubs;", "} TkStubHooks;", "", "typedef struct TkStubs {", "    int magic;", "    struct TkStubHooks *hooks;", "", "    void (*tk_MainLoop) (void); /* 0 */", "    XColor * (*tk_3DBorderColor) (Tk_3DBorder border); /* 1 */", "    GC (*tk_3DBorderGC) (Tk_Window tkwin, Tk_3DBorder border, int which); /* 2 */", "    void (*tk_3DHorizontalBevel) (Tk_Window tkwin, Drawable drawable, Tk_3DBorder border, int x, int y, int width, int height, int leftIn, int rightIn, int topBevel, int relief); /* 3 */", "    void (*tk_3DVerticalBevel) (Tk_Window tkwin, Drawable drawable, Tk_3DBorder border, int x, int y, int width, int height, int leftBevel, int relief); /* 4 */", "    void (*tk_AddOption) (Tk_Window tkwin, CONST char *name, CONST char *value, int priority); /* 5 */", "    void (*tk_BindEvent) (Tk_BindingTable bindingTable, XEvent *eventPtr, Tk_Window tkwin, int numObjects, ClientData *objectPtr); /* 6 */", "    void (*tk_CanvasDrawableCoords) (Tk_Canvas canvas, double x, double y, short *drawableXPtr, short *drawableYPtr); /* 7 */", "    void (*tk_CanvasEventuallyRedraw) (Tk_Canvas canvas, int x1, int y1, int x2, int y2); /* 8 */", "    int (*tk_CanvasGetCoord) (Tcl_Interp *interp, Tk_Canvas canvas, CONST char *str, double *doublePtr); /* 9 */", "    Tk_CanvasTextInfo * (*tk_CanvasGetTextInfo) (Tk_Canvas canvas); /* 10 */", "    int (*tk_CanvasPsBitmap) (Tcl_Interp *interp, Tk_Canvas canvas, Pixmap bitmap, int x, int y, int width, int height); /* 11 */", "    int (*tk_CanvasPsColor) (Tcl_Interp *interp, Tk_Canvas canvas, XColor *colorPtr); /* 12 */", "    int (*tk_CanvasPsFont) (Tcl_Interp *interp, Tk_Canvas canvas, Tk_Font font); /* 13 */", "    void (*tk_CanvasPsPath) (Tcl_Interp *interp, Tk_Canvas canvas, double *coordPtr, int numPoints); /* 14 */", "    int (*tk_CanvasPsStipple) (Tcl_Interp *interp, Tk_Canvas canvas, Pixmap bitmap); /* 15 */", "    double (*tk_CanvasPsY) (Tk_Canvas canvas, double y); /* 16 */", "    void (*tk_CanvasSetStippleOrigin) (Tk_Canvas canvas, GC gc); /* 17 */", "    int (*tk_CanvasTagsParseProc) (ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin, CONST char *value, char *widgRec, int offset); /* 18 */", "    char * (*tk_CanvasTagsPrintProc) (ClientData clientData, Tk_Window tkwin, char *widgRec, int offset, Tcl_FreeProc **freeProcPtr); /* 19 */", "    Tk_Window (*tk_CanvasTkwin) (Tk_Canvas canvas); /* 20 */", "    void (*tk_CanvasWindowCoords) (Tk_Canvas canvas, double x, double y, short *screenXPtr, short *screenYPtr); /* 21 */", "    void (*tk_ChangeWindowAttributes) (Tk_Window tkwin, unsigned long valueMask, XSetWindowAttributes *attsPtr); /* 22 */", "    int (*tk_CharBbox) (Tk_TextLayout layout, int index, int *xPtr, int *yPtr, int *widthPtr, int *heightPtr); /* 23 */", "    void (*tk_ClearSelection) (Tk_Window tkwin, Atom selection); /* 24 */", "    int (*tk_ClipboardAppend) (Tcl_Interp *interp, Tk_Window tkwin, Atom target, Atom format, char *buffer); /* 25 */", "    int (*tk_ClipboardClear) (Tcl_Interp *interp, Tk_Window tkwin); /* 26 */", "    int (*tk_ConfigureInfo) (Tcl_Interp *interp, Tk_Window tkwin, Tk_ConfigSpec *specs, char *widgRec, CONST char *argvName, int flags); /* 27 */", "    int (*tk_ConfigureValue) (Tcl_Interp *interp, Tk_Window tkwin, Tk_ConfigSpec *specs, char *widgRec, CONST char *argvName, int flags); /* 28 */", "    int (*tk_ConfigureWidget) (Tcl_Interp *interp, Tk_Window tkwin, Tk_ConfigSpec *specs, int argc, CONST84 char **argv, char *widgRec, int flags); /* 29 */", "    void (*tk_ConfigureWindow) (Tk_Window tkwin, unsigned int valueMask, XWindowChanges *valuePtr); /* 30 */", "    Tk_TextLayout (*tk_ComputeTextLayout) (Tk_Font font, CONST char *str, int numChars, int wrapLength, Tk_Justify justify, int flags, int *widthPtr, int *heightPtr); /* 31 */", "    Tk_Window (*tk_CoordsToWindow) (int rootX, int rootY, Tk_Window tkwin); /* 32 */", "    unsigned long (*tk_CreateBinding) (Tcl_Interp *interp, Tk_BindingTable bindingTable, ClientData object, CONST char *eventStr, CONST char *command, int append); /* 33 */", "    Tk_BindingTable (*tk_CreateBindingTable) (Tcl_Interp *interp); /* 34 */", "    Tk_ErrorHandler (*tk_CreateErrorHandler) (Display *display, int errNum, int request, int minorCode, Tk_ErrorProc *errorProc, ClientData clientData); /* 35 */", "    void (*tk_CreateEventHandler) (Tk_Window token, unsigned long mask, Tk_EventProc *proc, ClientData clientData); /* 36 */", "    void (*tk_CreateGenericHandler) (Tk_GenericProc *proc, ClientData clientData); /* 37 */", "    void (*tk_CreateImageType) (Tk_ImageType *typePtr); /* 38 */", "    void (*tk_CreateItemType) (Tk_ItemType *typePtr); /* 39 */", "    void (*tk_CreatePhotoImageFormat) (Tk_PhotoImageFormat *formatPtr); /* 40 */", "    void (*tk_CreateSelHandler) (Tk_Window tkwin, Atom selection, Atom target, Tk_SelectionProc *proc, ClientData clientData, Atom format); /* 41 */", "    Tk_Window (*tk_CreateWindow) (Tcl_Interp *interp, Tk_Window parent, CONST char *name, CONST char *screenName); /* 42 */", "    Tk_Window (*tk_CreateWindowFromPath) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *pathName, CONST char *screenName); /* 43 */", "    int (*tk_DefineBitmap) (Tcl_Interp *interp, CONST char *name, CONST char *source, int width, int height); /* 44 */", "    void (*tk_DefineCursor) (Tk_Window window, Tk_Cursor cursor); /* 45 */", "    void (*tk_DeleteAllBindings) (Tk_BindingTable bindingTable, ClientData object); /* 46 */", "    int (*tk_DeleteBinding) (Tcl_Interp *interp, Tk_BindingTable bindingTable, ClientData object, CONST char *eventStr); /* 47 */", "    void (*tk_DeleteBindingTable) (Tk_BindingTable bindingTable); /* 48 */", "    void (*tk_DeleteErrorHandler) (Tk_ErrorHandler handler); /* 49 */", "    void (*tk_DeleteEventHandler) (Tk_Window token, unsigned long mask, Tk_EventProc *proc, ClientData clientData); /* 50 */", "    void (*tk_DeleteGenericHandler) (Tk_GenericProc *proc, ClientData clientData); /* 51 */", "    void (*tk_DeleteImage) (Tcl_Interp *interp, CONST char *name); /* 52 */", "    void (*tk_DeleteSelHandler) (Tk_Window tkwin, Atom selection, Atom target); /* 53 */", "    void (*tk_DestroyWindow) (Tk_Window tkwin); /* 54 */", "    CONST84_RETURN char * (*tk_DisplayName) (Tk_Window tkwin); /* 55 */", "    int (*tk_DistanceToTextLayout) (Tk_TextLayout layout, int x, int y); /* 56 */", "    void (*tk_Draw3DPolygon) (Tk_Window tkwin, Drawable drawable, Tk_3DBorder border, XPoint *pointPtr, int numPoints, int borderWidth, int leftRelief); /* 57 */", "    void (*tk_Draw3DRectangle) (Tk_Window tkwin, Drawable drawable, Tk_3DBorder border, int x, int y, int width, int height, int borderWidth, int relief); /* 58 */", "    void (*tk_DrawChars) (Display *display, Drawable drawable, GC gc, Tk_Font tkfont, CONST char *source, int numBytes, int x, int y); /* 59 */", "    void (*tk_DrawFocusHighlight) (Tk_Window tkwin, GC gc, int width, Drawable drawable); /* 60 */", "    void (*tk_DrawTextLayout) (Display *display, Drawable drawable, GC gc, Tk_TextLayout layout, int x, int y, int firstChar, int lastChar); /* 61 */", "    void (*tk_Fill3DPolygon) (Tk_Window tkwin, Drawable drawable, Tk_3DBorder border, XPoint *pointPtr, int numPoints, int borderWidth, int leftRelief); /* 62 */", "    void (*tk_Fill3DRectangle) (Tk_Window tkwin, Drawable drawable, Tk_3DBorder border, int x, int y, int width, int height, int borderWidth, int relief); /* 63 */", "    Tk_PhotoHandle (*tk_FindPhoto) (Tcl_Interp *interp, CONST char *imageName); /* 64 */", "    Font (*tk_FontId) (Tk_Font font); /* 65 */", "    void (*tk_Free3DBorder) (Tk_3DBorder border); /* 66 */", "    void (*tk_FreeBitmap) (Display *display, Pixmap bitmap); /* 67 */", "    void (*tk_FreeColor) (XColor *colorPtr); /* 68 */", "    void (*tk_FreeColormap) (Display *display, Colormap colormap); /* 69 */", "    void (*tk_FreeCursor) (Display *display, Tk_Cursor cursor); /* 70 */", "    void (*tk_FreeFont) (Tk_Font f); /* 71 */", "    void (*tk_FreeGC) (Display *display, GC gc); /* 72 */", "    void (*tk_FreeImage) (Tk_Image image); /* 73 */", "    void (*tk_FreeOptions) (Tk_ConfigSpec *specs, char *widgRec, Display *display, int needFlags); /* 74 */", "    void (*tk_FreePixmap) (Display *display, Pixmap pixmap); /* 75 */", "    void (*tk_FreeTextLayout) (Tk_TextLayout textLayout); /* 76 */", "    void (*tk_FreeXId) (Display *display, XID xid); /* 77 */", "    GC (*tk_GCForColor) (XColor *colorPtr, Drawable drawable); /* 78 */", "    void (*tk_GeometryRequest) (Tk_Window tkwin, int reqWidth, int reqHeight); /* 79 */", "    Tk_3DBorder (*tk_Get3DBorder) (Tcl_Interp *interp, Tk_Window tkwin, Tk_Uid colorName); /* 80 */", "    void (*tk_GetAllBindings) (Tcl_Interp *interp, Tk_BindingTable bindingTable, ClientData object); /* 81 */", "    int (*tk_GetAnchor) (Tcl_Interp *interp, CONST char *str, Tk_Anchor *anchorPtr); /* 82 */", "    CONST84_RETURN char * (*tk_GetAtomName) (Tk_Window tkwin, Atom atom); /* 83 */", "    CONST84_RETURN char * (*tk_GetBinding) (Tcl_Interp *interp, Tk_BindingTable bindingTable, ClientData object, CONST char *eventStr); /* 84 */", "    Pixmap (*tk_GetBitmap) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *str); /* 85 */", "    Pixmap (*tk_GetBitmapFromData) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *source, int width, int height); /* 86 */", "    int (*tk_GetCapStyle) (Tcl_Interp *interp, CONST char *str, int *capPtr); /* 87 */", "    XColor * (*tk_GetColor) (Tcl_Interp *interp, Tk_Window tkwin, Tk_Uid name); /* 88 */", "    XColor * (*tk_GetColorByValue) (Tk_Window tkwin, XColor *colorPtr); /* 89 */", "    Colormap (*tk_GetColormap) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *str); /* 90 */", "    Tk_Cursor (*tk_GetCursor) (Tcl_Interp *interp, Tk_Window tkwin, Tk_Uid str); /* 91 */", "    Tk_Cursor (*tk_GetCursorFromData) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *source, CONST char *mask, int width, int height, int xHot, int yHot, Tk_Uid fg, Tk_Uid bg); /* 92 */", "    Tk_Font (*tk_GetFont) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *str); /* 93 */", "    Tk_Font (*tk_GetFontFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr); /* 94 */", "    void (*tk_GetFontMetrics) (Tk_Font font, Tk_FontMetrics *fmPtr); /* 95 */", "    GC (*tk_GetGC) (Tk_Window tkwin, unsigned long valueMask, XGCValues *valuePtr); /* 96 */", "    Tk_Image (*tk_GetImage) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *name, Tk_ImageChangedProc *changeProc, ClientData clientData); /* 97 */", "    ClientData (*tk_GetImageMasterData) (Tcl_Interp *interp, CONST char *name, Tk_ImageType **typePtrPtr); /* 98 */", "    Tk_ItemType * (*tk_GetItemTypes) (void); /* 99 */", "    int (*tk_GetJoinStyle) (Tcl_Interp *interp, CONST char *str, int *joinPtr); /* 100 */", "    int (*tk_GetJustify) (Tcl_Interp *interp, CONST char *str, Tk_Justify *justifyPtr); /* 101 */", "    int (*tk_GetNumMainWindows) (void); /* 102 */", "    Tk_Uid (*tk_GetOption) (Tk_Window tkwin, CONST char *name, CONST char *className); /* 103 */", "    int (*tk_GetPixels) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *str, int *intPtr); /* 104 */", "    Pixmap (*tk_GetPixmap) (Display *display, Drawable d, int width, int height, int depth); /* 105 */", "    int (*tk_GetRelief) (Tcl_Interp *interp, CONST char *name, int *reliefPtr); /* 106 */", "    void (*tk_GetRootCoords) (Tk_Window tkwin, int *xPtr, int *yPtr); /* 107 */", "    int (*tk_GetScrollInfo) (Tcl_Interp *interp, int argc, CONST84 char **argv, double *dblPtr, int *intPtr); /* 108 */", "    int (*tk_GetScreenMM) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *str, double *doublePtr); /* 109 */", "    int (*tk_GetSelection) (Tcl_Interp *interp, Tk_Window tkwin, Atom selection, Atom target, Tk_GetSelProc *proc, ClientData clientData); /* 110 */", "    Tk_Uid (*tk_GetUid) (CONST char *str); /* 111 */", "    Visual * (*tk_GetVisual) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *str, int *depthPtr, Colormap *colormapPtr); /* 112 */", "    void (*tk_GetVRootGeometry) (Tk_Window tkwin, int *xPtr, int *yPtr, int *widthPtr, int *heightPtr); /* 113 */", "    int (*tk_Grab) (Tcl_Interp *interp, Tk_Window tkwin, int grabGlobal); /* 114 */", "    void (*tk_HandleEvent) (XEvent *eventPtr); /* 115 */", "    Tk_Window (*tk_IdToWindow) (Display *display, Window window); /* 116 */", "    void (*tk_ImageChanged) (Tk_ImageMaster master, int x, int y, int width, int height, int imageWidth, int imageHeight); /* 117 */", "    int (*tk_Init) (Tcl_Interp *interp); /* 118 */", "    Atom (*tk_InternAtom) (Tk_Window tkwin, CONST char *name); /* 119 */", "    int (*tk_IntersectTextLayout) (Tk_TextLayout layout, int x, int y, int width, int height); /* 120 */", "    void (*tk_MaintainGeometry) (Tk_Window slave, Tk_Window master, int x, int y, int width, int height); /* 121 */", "    Tk_Window (*tk_MainWindow) (Tcl_Interp *interp); /* 122 */", "    void (*tk_MakeWindowExist) (Tk_Window tkwin); /* 123 */", "    void (*tk_ManageGeometry) (Tk_Window tkwin, CONST Tk_GeomMgr *mgrPtr, ClientData clientData); /* 124 */", "    void (*tk_MapWindow) (Tk_Window tkwin); /* 125 */", "    int (*tk_MeasureChars) (Tk_Font tkfont, CONST char *source, int numBytes, int maxPixels, int flags, int *lengthPtr); /* 126 */", "    void (*tk_MoveResizeWindow) (Tk_Window tkwin, int x, int y, int width, int height); /* 127 */", "    void (*tk_MoveWindow) (Tk_Window tkwin, int x, int y); /* 128 */", "    void (*tk_MoveToplevelWindow) (Tk_Window tkwin, int x, int y); /* 129 */", "    CONST84_RETURN char * (*tk_NameOf3DBorder) (Tk_3DBorder border); /* 130 */", "    CONST84_RETURN char * (*tk_NameOfAnchor) (Tk_Anchor anchor); /* 131 */", "    CONST84_RETURN char * (*tk_NameOfBitmap) (Display *display, Pixmap bitmap); /* 132 */", "    CONST84_RETURN char * (*tk_NameOfCapStyle) (int cap); /* 133 */", "    CONST84_RETURN char * (*tk_NameOfColor) (XColor *colorPtr); /* 134 */", "    CONST84_RETURN char * (*tk_NameOfCursor) (Display *display, Tk_Cursor cursor); /* 135 */", "    CONST84_RETURN char * (*tk_NameOfFont) (Tk_Font font); /* 136 */", "    CONST84_RETURN char * (*tk_NameOfImage) (Tk_ImageMaster imageMaster); /* 137 */", "    CONST84_RETURN char * (*tk_NameOfJoinStyle) (int join); /* 138 */", "    CONST84_RETURN char * (*tk_NameOfJustify) (Tk_Justify justify); /* 139 */", "    CONST84_RETURN char * (*tk_NameOfRelief) (int relief); /* 140 */", "    Tk_Window (*tk_NameToWindow) (Tcl_Interp *interp, CONST char *pathName, Tk_Window tkwin); /* 141 */", "    void (*tk_OwnSelection) (Tk_Window tkwin, Atom selection, Tk_LostSelProc *proc, ClientData clientData); /* 142 */", "    int (*tk_ParseArgv) (Tcl_Interp *interp, Tk_Window tkwin, int *argcPtr, CONST84 char **argv, Tk_ArgvInfo *argTable, int flags); /* 143 */", "    void (*tk_PhotoPutBlock_NoComposite) (Tk_PhotoHandle handle, Tk_PhotoImageBlock *blockPtr, int x, int y, int width, int height); /* 144 */", "    void (*tk_PhotoPutZoomedBlock_NoComposite) (Tk_PhotoHandle handle, Tk_PhotoImageBlock *blockPtr, int x, int y, int width, int height, int zoomX, int zoomY, int subsampleX, int subsampleY); /* 145 */", "    int (*tk_PhotoGetImage) (Tk_PhotoHandle handle, Tk_PhotoImageBlock *blockPtr); /* 146 */", "    void (*tk_PhotoBlank) (Tk_PhotoHandle handle); /* 147 */", "    void (*tk_PhotoExpand_Panic) (Tk_PhotoHandle handle, int width, int height); /* 148 */", "    void (*tk_PhotoGetSize) (Tk_PhotoHandle handle, int *widthPtr, int *heightPtr); /* 149 */", "    void (*tk_PhotoSetSize_Panic) (Tk_PhotoHandle handle, int width, int height); /* 150 */", "    int (*tk_PointToChar) (Tk_TextLayout layout, int x, int y); /* 151 */", "    int (*tk_PostscriptFontName) (Tk_Font tkfont, Tcl_DString *dsPtr); /* 152 */", "    void (*tk_PreserveColormap) (Display *display, Colormap colormap); /* 153 */", "    void (*tk_QueueWindowEvent) (XEvent *eventPtr, Tcl_QueuePosition position); /* 154 */", "    void (*tk_RedrawImage) (Tk_Image image, int imageX, int imageY, int width, int height, Drawable drawable, int drawableX, int drawableY); /* 155 */", "    void (*tk_ResizeWindow) (Tk_Window tkwin, int width, int height); /* 156 */", "    int (*tk_RestackWindow) (Tk_Window tkwin, int aboveBelow, Tk_Window other); /* 157 */", "    Tk_RestrictProc * (*tk_RestrictEvents) (Tk_RestrictProc *proc, ClientData arg, ClientData *prevArgPtr); /* 158 */", "    int (*tk_SafeInit) (Tcl_Interp *interp); /* 159 */", "    CONST char * (*tk_SetAppName) (Tk_Window tkwin, CONST char *name); /* 160 */", "    void (*tk_SetBackgroundFromBorder) (Tk_Window tkwin, Tk_3DBorder border); /* 161 */", "    void (*tk_SetClass) (Tk_Window tkwin, CONST char *className); /* 162 */", "    void (*tk_SetGrid) (Tk_Window tkwin, int reqWidth, int reqHeight, int gridWidth, int gridHeight); /* 163 */", "    void (*tk_SetInternalBorder) (Tk_Window tkwin, int width); /* 164 */", "    void (*tk_SetWindowBackground) (Tk_Window tkwin, unsigned long pixel); /* 165 */", "    void (*tk_SetWindowBackgroundPixmap) (Tk_Window tkwin, Pixmap pixmap); /* 166 */", "    void (*tk_SetWindowBorder) (Tk_Window tkwin, unsigned long pixel); /* 167 */", "    void (*tk_SetWindowBorderWidth) (Tk_Window tkwin, int width); /* 168 */", "    void (*tk_SetWindowBorderPixmap) (Tk_Window tkwin, Pixmap pixmap); /* 169 */", "    void (*tk_SetWindowColormap) (Tk_Window tkwin, Colormap colormap); /* 170 */", "    int (*tk_SetWindowVisual) (Tk_Window tkwin, Visual *visual, int depth, Colormap colormap); /* 171 */", "    void (*tk_SizeOfBitmap) (Display *display, Pixmap bitmap, int *widthPtr, int *heightPtr); /* 172 */", "    void (*tk_SizeOfImage) (Tk_Image image, int *widthPtr, int *heightPtr); /* 173 */", "    int (*tk_StrictMotif) (Tk_Window tkwin); /* 174 */", "    void (*tk_TextLayoutToPostscript) (Tcl_Interp *interp, Tk_TextLayout layout); /* 175 */", "    int (*tk_TextWidth) (Tk_Font font, CONST char *str, int numBytes); /* 176 */", "    void (*tk_UndefineCursor) (Tk_Window window); /* 177 */", "    void (*tk_UnderlineChars) (Display *display, Drawable drawable, GC gc, Tk_Font tkfont, CONST char *source, int x, int y, int firstByte, int lastByte); /* 178 */", "    void (*tk_UnderlineTextLayout) (Display *display, Drawable drawable, GC gc, Tk_TextLayout layout, int x, int y, int underline); /* 179 */", "    void (*tk_Ungrab) (Tk_Window tkwin); /* 180 */", "    void (*tk_UnmaintainGeometry) (Tk_Window slave, Tk_Window master); /* 181 */", "    void (*tk_UnmapWindow) (Tk_Window tkwin); /* 182 */", "    void (*tk_UnsetGrid) (Tk_Window tkwin); /* 183 */", "    void (*tk_UpdatePointer) (Tk_Window tkwin, int x, int y, int state); /* 184 */", "    Pixmap (*tk_AllocBitmapFromObj) (Tcl_Interp *interp, Tk_Window tkwin, Tcl_Obj *objPtr); /* 185 */", "    Tk_3DBorder (*tk_Alloc3DBorderFromObj) (Tcl_Interp *interp, Tk_Window tkwin, Tcl_Obj *objPtr); /* 186 */", "    XColor * (*tk_AllocColorFromObj) (Tcl_Interp *interp, Tk_Window tkwin, Tcl_Obj *objPtr); /* 187 */", "    Tk_Cursor (*tk_AllocCursorFromObj) (Tcl_Interp *interp, Tk_Window tkwin, Tcl_Obj *objPtr); /* 188 */", "    Tk_Font (*tk_AllocFontFromObj) (Tcl_Interp *interp, Tk_Window tkwin, Tcl_Obj *objPtr); /* 189 */", "    Tk_OptionTable (*tk_CreateOptionTable) (Tcl_Interp *interp, CONST Tk_OptionSpec *templatePtr); /* 190 */", "    void (*tk_DeleteOptionTable) (Tk_OptionTable optionTable); /* 191 */", "    void (*tk_Free3DBorderFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr); /* 192 */", "    void (*tk_FreeBitmapFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr); /* 193 */", "    void (*tk_FreeColorFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr); /* 194 */", "    void (*tk_FreeConfigOptions) (char *recordPtr, Tk_OptionTable optionToken, Tk_Window tkwin); /* 195 */", "    void (*tk_FreeSavedOptions) (Tk_SavedOptions *savePtr); /* 196 */", "    void (*tk_FreeCursorFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr); /* 197 */", "    void (*tk_FreeFontFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr); /* 198 */", "    Tk_3DBorder (*tk_Get3DBorderFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr); /* 199 */", "    int (*tk_GetAnchorFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, Tk_Anchor *anchorPtr); /* 200 */", "    Pixmap (*tk_GetBitmapFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr); /* 201 */", "    XColor * (*tk_GetColorFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr); /* 202 */", "    Tk_Cursor (*tk_GetCursorFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr); /* 203 */", "    Tcl_Obj * (*tk_GetOptionInfo) (Tcl_Interp *interp, char *recordPtr, Tk_OptionTable optionTable, Tcl_Obj *namePtr, Tk_Window tkwin); /* 204 */", "    Tcl_Obj * (*tk_GetOptionValue) (Tcl_Interp *interp, char *recordPtr, Tk_OptionTable optionTable, Tcl_Obj *namePtr, Tk_Window tkwin); /* 205 */", "    int (*tk_GetJustifyFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, Tk_Justify *justifyPtr); /* 206 */", "    int (*tk_GetMMFromObj) (Tcl_Interp *interp, Tk_Window tkwin, Tcl_Obj *objPtr, double *doublePtr); /* 207 */", "    int (*tk_GetPixelsFromObj) (Tcl_Interp *interp, Tk_Window tkwin, Tcl_Obj *objPtr, int *intPtr); /* 208 */", "    int (*tk_GetReliefFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, int *resultPtr); /* 209 */", "    int (*tk_GetScrollInfoObj) (Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[], double *dblPtr, int *intPtr); /* 210 */", "    int (*tk_InitOptions) (Tcl_Interp *interp, char *recordPtr, Tk_OptionTable optionToken, Tk_Window tkwin); /* 211 */", "    void (*tk_MainEx) (int argc, char **argv, Tcl_AppInitProc *appInitProc, Tcl_Interp *interp); /* 212 */", "    void (*tk_RestoreSavedOptions) (Tk_SavedOptions *savePtr); /* 213 */", "    int (*tk_SetOptions) (Tcl_Interp *interp, char *recordPtr, Tk_OptionTable optionTable, int objc, Tcl_Obj *CONST objv[], Tk_Window tkwin, Tk_SavedOptions *savePtr, int *maskPtr); /* 214 */", "    void (*tk_InitConsoleChannels) (Tcl_Interp *interp); /* 215 */", "    int (*tk_CreateConsoleWindow) (Tcl_Interp *interp); /* 216 */", "    void (*tk_CreateSmoothMethod) (Tcl_Interp *interp, Tk_SmoothMethod *method); /* 217 */", "    void *reserved218;", "    void *reserved219;", "    int (*tk_GetDash) (Tcl_Interp *interp, CONST char *value, Tk_Dash *dash); /* 220 */", "    void (*tk_CreateOutline) (Tk_Outline *outline); /* 221 */", "    void (*tk_DeleteOutline) (Display *display, Tk_Outline *outline); /* 222 */", "    int (*tk_ConfigOutlineGC) (XGCValues *gcValues, Tk_Canvas canvas, Tk_Item *item, Tk_Outline *outline); /* 223 */", "    int (*tk_ChangeOutlineGC) (Tk_Canvas canvas, Tk_Item *item, Tk_Outline *outline); /* 224 */", "    int (*tk_ResetOutlineGC) (Tk_Canvas canvas, Tk_Item *item, Tk_Outline *outline); /* 225 */", "    int (*tk_CanvasPsOutline) (Tk_Canvas canvas, Tk_Item *item, Tk_Outline *outline); /* 226 */", "    void (*tk_SetTSOrigin) (Tk_Window tkwin, GC gc, int x, int y); /* 227 */", "    int (*tk_CanvasGetCoordFromObj) (Tcl_Interp *interp, Tk_Canvas canvas, Tcl_Obj *obj, double *doublePtr); /* 228 */", "    void (*tk_CanvasSetOffset) (Tk_Canvas canvas, GC gc, Tk_TSOffset *offset); /* 229 */", "    void (*tk_DitherPhoto) (Tk_PhotoHandle handle, int x, int y, int width, int height); /* 230 */", "    int (*tk_PostscriptBitmap) (Tcl_Interp *interp, Tk_Window tkwin, Tk_PostscriptInfo psInfo, Pixmap bitmap, int startX, int startY, int width, int height); /* 231 */", "    int (*tk_PostscriptColor) (Tcl_Interp *interp, Tk_PostscriptInfo psInfo, XColor *colorPtr); /* 232 */", "    int (*tk_PostscriptFont) (Tcl_Interp *interp, Tk_PostscriptInfo psInfo, Tk_Font font); /* 233 */", "    int (*tk_PostscriptImage) (Tk_Image image, Tcl_Interp *interp, Tk_Window tkwin, Tk_PostscriptInfo psinfo, int x, int y, int width, int height, int prepass); /* 234 */", "    void (*tk_PostscriptPath) (Tcl_Interp *interp, Tk_PostscriptInfo psInfo, double *coordPtr, int numPoints); /* 235 */", "    int (*tk_PostscriptStipple) (Tcl_Interp *interp, Tk_Window tkwin, Tk_PostscriptInfo psInfo, Pixmap bitmap); /* 236 */", "    double (*tk_PostscriptY) (double y, Tk_PostscriptInfo psInfo); /* 237 */", "    int (*tk_PostscriptPhoto) (Tcl_Interp *interp, Tk_PhotoImageBlock *blockPtr, Tk_PostscriptInfo psInfo, int width, int height); /* 238 */", "    void (*tk_CreateClientMessageHandler) (Tk_ClientMessageProc *proc); /* 239 */", "    void (*tk_DeleteClientMessageHandler) (Tk_ClientMessageProc *proc); /* 240 */", "    Tk_Window (*tk_CreateAnonymousWindow) (Tcl_Interp *interp, Tk_Window parent, CONST char *screenName); /* 241 */", "    void (*tk_SetClassProcs) (Tk_Window tkwin, Tk_ClassProcs *procs, ClientData instanceData); /* 242 */", "    void (*tk_SetInternalBorderEx) (Tk_Window tkwin, int left, int right, int top, int bottom); /* 243 */", "    void (*tk_SetMinimumRequestSize) (Tk_Window tkwin, int minWidth, int minHeight); /* 244 */", "    void (*tk_SetCaretPos) (Tk_Window tkwin, int x, int y, int height); /* 245 */", "    void (*tk_PhotoPutBlock_Panic) (Tk_PhotoHandle handle, Tk_PhotoImageBlock *blockPtr, int x, int y, int width, int height, int compRule); /* 246 */", "    void (*tk_PhotoPutZoomedBlock_Panic) (Tk_PhotoHandle handle, Tk_PhotoImageBlock *blockPtr, int x, int y, int width, int height, int zoomX, int zoomY, int subsampleX, int subsampleY, int compRule); /* 247 */", "    int (*tk_CollapseMotionEvents) (Display *display, int collapse); /* 248 */", "    Tk_StyleEngine (*tk_RegisterStyleEngine) (CONST char *name, Tk_StyleEngine parent); /* 249 */", "    Tk_StyleEngine (*tk_GetStyleEngine) (CONST char *name); /* 250 */", "    int (*tk_RegisterStyledElement) (Tk_StyleEngine engine, Tk_ElementSpec *templatePtr); /* 251 */", "    int (*tk_GetElementId) (CONST char *name); /* 252 */", "    Tk_Style (*tk_CreateStyle) (CONST char *name, Tk_StyleEngine engine, ClientData clientData); /* 253 */", "    Tk_Style (*tk_GetStyle) (Tcl_Interp *interp, CONST char *name); /* 254 */", "    void (*tk_FreeStyle) (Tk_Style style); /* 255 */", "    CONST char * (*tk_NameOfStyle) (Tk_Style style); /* 256 */", "    Tk_Style (*tk_AllocStyleFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr); /* 257 */", "    Tk_Style (*tk_GetStyleFromObj) (Tcl_Obj *objPtr); /* 258 */", "    void (*tk_FreeStyleFromObj) (Tcl_Obj *objPtr); /* 259 */", "    Tk_StyledElement (*tk_GetStyledElement) (Tk_Style style, int elementId, Tk_OptionTable optionTable); /* 260 */", "    void (*tk_GetElementSize) (Tk_Style style, Tk_StyledElement element, char *recordPtr, Tk_Window tkwin, int width, int height, int inner, int *widthPtr, int *heightPtr); /* 261 */", "    void (*tk_GetElementBox) (Tk_Style style, Tk_StyledElement element, char *recordPtr, Tk_Window tkwin, int x, int y, int width, int height, int inner, int *xPtr, int *yPtr, int *widthPtr, int *heightPtr); /* 262 */", "    int (*tk_GetElementBorderWidth) (Tk_Style style, Tk_StyledElement element, char *recordPtr, Tk_Window tkwin); /* 263 */", "    void (*tk_DrawElement) (Tk_Style style, Tk_StyledElement element, char *recordPtr, Tk_Window tkwin, Drawable d, int x, int y, int width, int height, int state); /* 264 */", "    int (*tk_PhotoExpand) (Tcl_Interp *interp, Tk_PhotoHandle handle, int width, int height); /* 265 */", "    int (*tk_PhotoPutBlock) (Tcl_Interp *interp, Tk_PhotoHandle handle, Tk_PhotoImageBlock *blockPtr, int x, int y, int width, int height, int compRule); /* 266 */", "    int (*tk_PhotoPutZoomedBlock) (Tcl_Interp *interp, Tk_PhotoHandle handle, Tk_PhotoImageBlock *blockPtr, int x, int y, int width, int height, int zoomX, int zoomY, int subsampleX, int subsampleY, int compRule); /* 267 */", "    int (*tk_PhotoSetSize) (Tcl_Interp *interp, Tk_PhotoHandle handle, int width, int height); /* 268 */", "    long (*tk_GetUserInactiveTime) (Display *dpy); /* 269 */", "    void (*tk_ResetUserInactiveTime) (Display *dpy); /* 270 */", "    Tcl_Interp * (*tk_Interp) (Tk_Window tkwin); /* 271 */", "    void (*tk_CreateOldImageType) (Tk_ImageType *typePtr); /* 272 */", "    void (*tk_CreateOldPhotoImageFormat) (Tk_PhotoImageFormat *formatPtr); /* 273 */", "} TkStubs;", "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "extern TkStubs *tkStubsPtr;", "#ifdef __cplusplus", "}", "#endif", "", "#if defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS)", "", "/*", " * Inline function declarations:", " */", "", "#ifndef Tk_MainLoop", "#define Tk_MainLoop \\", "\t(tkStubsPtr->tk_MainLoop) /* 0 */", "#endif", "#ifndef Tk_3DBorderColor", "#define Tk_3DBorderColor \\", "\t(tkStubsPtr->tk_3DBorderColor) /* 1 */", "#endif", "#ifndef Tk_3DBorderGC", "#define Tk_3DBorderGC \\", "\t(tkStubsPtr->tk_3DBorderGC) /* 2 */", "#endif", "#ifndef Tk_3DHorizontalBevel", "#define Tk_3DHorizontalBevel \\", "\t(tkStubsPtr->tk_3DHorizontalBevel) /* 3 */", "#endif", "#ifndef Tk_3DVerticalBevel", "#define Tk_3DVerticalBevel \\", "\t(tkStubsPtr->tk_3DVerticalBevel) /* 4 */", "#endif", "#ifndef Tk_AddOption", "#define Tk_AddOption \\", "\t(tkStubsPtr->tk_AddOption) /* 5 */", "#endif", "#ifndef Tk_BindEvent", "#define Tk_BindEvent \\", "\t(tkStubsPtr->tk_BindEvent) /* 6 */", "#endif", "#ifndef Tk_CanvasDrawableCoords", "#define Tk_CanvasDrawableCoords \\", "\t(tkStubsPtr->tk_CanvasDrawableCoords) /* 7 */", "#endif", "#ifndef Tk_CanvasEventuallyRedraw", "#define Tk_CanvasEventuallyRedraw \\", "\t(tkStubsPtr->tk_CanvasEventuallyRedraw) /* 8 */", "#endif", "#ifndef Tk_CanvasGetCoord", "#define Tk_CanvasGetCoord \\", "\t(tkStubsPtr->tk_CanvasGetCoord) /* 9 */", "#endif", "#ifndef Tk_CanvasGetTextInfo", "#define Tk_CanvasGetTextInfo \\", "\t(tkStubsPtr->tk_CanvasGetTextInfo) /* 10 */", "#endif", "#ifndef Tk_CanvasPsBitmap", "#define Tk_CanvasPsBitmap \\", "\t(tkStubsPtr->tk_CanvasPsBitmap) /* 11 */", "#endif", "#ifndef Tk_CanvasPsColor", "#define Tk_CanvasPsColor \\", "\t(tkStubsPtr->tk_CanvasPsColor) /* 12 */", "#endif", "#ifndef Tk_CanvasPsFont", "#define Tk_CanvasPsFont \\", "\t(tkStubsPtr->tk_CanvasPsFont) /* 13 */", "#endif", "#ifndef Tk_CanvasPsPath", "#define Tk_CanvasPsPath \\", "\t(tkStubsPtr->tk_CanvasPsPath) /* 14 */", "#endif", "#ifndef Tk_CanvasPsStipple", "#define Tk_CanvasPsStipple \\", "\t(tkStubsPtr->tk_CanvasPsStipple) /* 15 */", "#endif", "#ifndef Tk_CanvasPsY", "#define Tk_CanvasPsY \\", "\t(tkStubsPtr->tk_CanvasPsY) /* 16 */", "#endif", "#ifndef Tk_CanvasSetStippleOrigin", "#define Tk_CanvasSetStippleOrigin \\", "\t(tkStubsPtr->tk_CanvasSetStippleOrigin) /* 17 */", "#endif", "#ifndef Tk_CanvasTagsParseProc", "#define Tk_CanvasTagsParseProc \\", "\t(tkStubsPtr->tk_CanvasTagsParseProc) /* 18 */", "#endif", "#ifndef Tk_CanvasTagsPrintProc", "#define Tk_CanvasTagsPrintProc \\", "\t(tkStubsPtr->tk_CanvasTagsPrintProc) /* 19 */", "#endif", "#ifndef Tk_CanvasTkwin", "#define Tk_CanvasTkwin \\", "\t(tkStubsPtr->tk_CanvasTkwin) /* 20 */", "#endif", "#ifndef Tk_CanvasWindowCoords", "#define Tk_CanvasWindowCoords \\", "\t(tkStubsPtr->tk_CanvasWindowCoords) /* 21 */", "#endif", "#ifndef Tk_ChangeWindowAttributes", "#define Tk_ChangeWindowAttributes \\", "\t(tkStubsPtr->tk_ChangeWindowAttributes) /* 22 */", "#endif", "#ifndef Tk_CharBbox", "#define Tk_CharBbox \\", "\t(tkStubsPtr->tk_CharBbox) /* 23 */", "#endif", "#ifndef Tk_ClearSelection", "#define Tk_ClearSelection \\", "\t(tkStubsPtr->tk_ClearSelection) /* 24 */", "#endif", "#ifndef Tk_ClipboardAppend", "#define Tk_ClipboardAppend \\", "\t(tkStubsPtr->tk_ClipboardAppend) /* 25 */", "#endif", "#ifndef Tk_ClipboardClear", "#define Tk_ClipboardClear \\", "\t(tkStubsPtr->tk_ClipboardClear) /* 26 */", "#endif", "#ifndef Tk_ConfigureInfo", "#define Tk_ConfigureInfo \\", "\t(tkStubsPtr->tk_ConfigureInfo) /* 27 */", "#endif", "#ifndef Tk_ConfigureValue", "#define Tk_ConfigureValue \\", "\t(tkStubsPtr->tk_ConfigureValue) /* 28 */", "#endif", "#ifndef Tk_ConfigureWidget", "#define Tk_ConfigureWidget \\", "\t(tkStubsPtr->tk_ConfigureWidget) /* 29 */", "#endif", "#ifndef Tk_ConfigureWindow", "#define Tk_ConfigureWindow \\", "\t(tkStubsPtr->tk_ConfigureWindow) /* 30 */", "#endif", "#ifndef Tk_ComputeTextLayout", "#define Tk_ComputeTextLayout \\", "\t(tkStubsPtr->tk_ComputeTextLayout) /* 31 */", "#endif", "#ifndef Tk_CoordsToWindow", "#define Tk_CoordsToWindow \\", "\t(tkStubsPtr->tk_CoordsToWindow) /* 32 */", "#endif", "#ifndef Tk_CreateBinding", "#define Tk_CreateBinding \\", "\t(tkStubsPtr->tk_CreateBinding) /* 33 */", "#endif", "#ifndef Tk_CreateBindingTable", "#define Tk_CreateBindingTable \\", "\t(tkStubsPtr->tk_CreateBindingTable) /* 34 */", "#endif", "#ifndef Tk_CreateErrorHandler", "#define Tk_CreateErrorHandler \\", "\t(tkStubsPtr->tk_CreateErrorHandler) /* 35 */", "#endif", "#ifndef Tk_CreateEventHandler", "#define Tk_CreateEventHandler \\", "\t(tkStubsPtr->tk_CreateEventHandler) /* 36 */", "#endif", "#ifndef Tk_CreateGenericHandler", "#define Tk_CreateGenericHandler \\", "\t(tkStubsPtr->tk_CreateGenericHandler) /* 37 */", "#endif", "#ifndef Tk_CreateImageType", "#define Tk_CreateImageType \\", "\t(tkStubsPtr->tk_CreateImageType) /* 38 */", "#endif", "#ifndef Tk_CreateItemType", "#define Tk_CreateItemType \\", "\t(tkStubsPtr->tk_CreateItemType) /* 39 */", "#endif", "#ifndef Tk_CreatePhotoImageFormat", "#define Tk_CreatePhotoImageFormat \\", "\t(tkStubsPtr->tk_CreatePhotoImageFormat) /* 40 */", "#endif", "#ifndef Tk_CreateSelHandler", "#define Tk_CreateSelHandler \\", "\t(tkStubsPtr->tk_CreateSelHandler) /* 41 */", "#endif", "#ifndef Tk_CreateWindow", "#define Tk_CreateWindow \\", "\t(tkStubsPtr->tk_CreateWindow) /* 42 */", "#endif", "#ifndef Tk_CreateWindowFromPath", "#define Tk_CreateWindowFromPath \\", "\t(tkStubsPtr->tk_CreateWindowFromPath) /* 43 */", "#endif", "#ifndef Tk_DefineBitmap", "#define Tk_DefineBitmap \\", "\t(tkStubsPtr->tk_DefineBitmap) /* 44 */", "#endif", "#ifndef Tk_DefineCursor", "#define Tk_DefineCursor \\", "\t(tkStubsPtr->tk_DefineCursor) /* 45 */", "#endif", "#ifndef Tk_DeleteAllBindings", "#define Tk_DeleteAllBindings \\", "\t(tkStubsPtr->tk_DeleteAllBindings) /* 46 */", "#endif", "#ifndef Tk_DeleteBinding", "#define Tk_DeleteBinding \\", "\t(tkStubsPtr->tk_DeleteBinding) /* 47 */", "#endif", "#ifndef Tk_DeleteBindingTable", "#define Tk_DeleteBindingTable \\", "\t(tkStubsPtr->tk_DeleteBindingTable) /* 48 */", "#endif", "#ifndef Tk_DeleteErrorHandler", "#define Tk_DeleteErrorHandler \\", "\t(tkStubsPtr->tk_DeleteErrorHandler) /* 49 */", "#endif", "#ifndef Tk_DeleteEventHandler", "#define Tk_DeleteEventHandler \\", "\t(tkStubsPtr->tk_DeleteEventHandler) /* 50 */", "#endif", "#ifndef Tk_DeleteGenericHandler", "#define Tk_DeleteGenericHandler \\", "\t(tkStubsPtr->tk_DeleteGenericHandler) /* 51 */", "#endif", "#ifndef Tk_DeleteImage", "#define Tk_DeleteImage \\", "\t(tkStubsPtr->tk_DeleteImage) /* 52 */", "#endif", "#ifndef Tk_DeleteSelHandler", "#define Tk_DeleteSelHandler \\", "\t(tkStubsPtr->tk_DeleteSelHandler) /* 53 */", "#endif", "#ifndef Tk_DestroyWindow", "#define Tk_DestroyWindow \\", "\t(tkStubsPtr->tk_DestroyWindow) /* 54 */", "#endif", "#ifndef Tk_DisplayName", "#define Tk_DisplayName \\", "\t(tkStubsPtr->tk_DisplayName) /* 55 */", "#endif", "#ifndef Tk_DistanceToTextLayout", "#define Tk_DistanceToTextLayout \\", "\t(tkStubsPtr->tk_DistanceToTextLayout) /* 56 */", "#endif", "#ifndef Tk_Draw3DPolygon", "#define Tk_Draw3DPolygon \\", "\t(tkStubsPtr->tk_Draw3DPolygon) /* 57 */", "#endif", "#ifndef Tk_Draw3DRectangle", "#define Tk_Draw3DRectangle \\", "\t(tkStubsPtr->tk_Draw3DRectangle) /* 58 */", "#endif", "#ifndef Tk_DrawChars", "#define Tk_DrawChars \\", "\t(tkStubsPtr->tk_DrawChars) /* 59 */", "#endif", "#ifndef Tk_DrawFocusHighlight", "#define Tk_DrawFocusHighlight \\", "\t(tkStubsPtr->tk_DrawFocusHighlight) /* 60 */", "#endif", "#ifndef Tk_DrawTextLayout", "#define Tk_DrawTextLayout \\", "\t(tkStubsPtr->tk_DrawTextLayout) /* 61 */", "#endif", "#ifndef Tk_Fill3DPolygon", "#define Tk_Fill3DPolygon \\", "\t(tkStubsPtr->tk_Fill3DPolygon) /* 62 */", "#endif", "#ifndef Tk_Fill3DRectangle", "#define Tk_Fill3DRectangle \\", "\t(tkStubsPtr->tk_Fill3DRectangle) /* 63 */", "#endif", "#ifndef Tk_FindPhoto", "#define Tk_FindPhoto \\", "\t(tkStubsPtr->tk_FindPhoto) /* 64 */", "#endif", "#ifndef Tk_FontId", "#define Tk_FontId \\", "\t(tkStubsPtr->tk_FontId) /* 65 */", "#endif", "#ifndef Tk_Free3DBorder", "#define Tk_Free3DBorder \\", "\t(tkStubsPtr->tk_Free3DBorder) /* 66 */", "#endif", "#ifndef Tk_FreeBitmap", "#define Tk_FreeBitmap \\", "\t(tkStubsPtr->tk_FreeBitmap) /* 67 */", "#endif", "#ifndef Tk_FreeColor", "#define Tk_FreeColor \\", "\t(tkStubsPtr->tk_FreeColor) /* 68 */", "#endif", "#ifndef Tk_FreeColormap", "#define Tk_FreeColormap \\", "\t(tkStubsPtr->tk_FreeColormap) /* 69 */", "#endif", "#ifndef Tk_FreeCursor", "#define Tk_FreeCursor \\", "\t(tkStubsPtr->tk_FreeCursor) /* 70 */", "#endif", "#ifndef Tk_FreeFont", "#define Tk_FreeFont \\", "\t(tkStubsPtr->tk_FreeFont) /* 71 */", "#endif", "#ifndef Tk_FreeGC", "#define Tk_FreeGC \\", "\t(tkStubsPtr->tk_FreeGC) /* 72 */", "#endif", "#ifndef Tk_FreeImage", "#define Tk_FreeImage \\", "\t(tkStubsPtr->tk_FreeImage) /* 73 */", "#endif", "#ifndef Tk_FreeOptions", "#define Tk_FreeOptions \\", "\t(tkStubsPtr->tk_FreeOptions) /* 74 */", "#endif", "#ifndef Tk_FreePixmap", "#define Tk_FreePixmap \\", "\t(tkStubsPtr->tk_FreePixmap) /* 75 */", "#endif", "#ifndef Tk_FreeTextLayout", "#define Tk_FreeTextLayout \\", "\t(tkStubsPtr->tk_FreeTextLayout) /* 76 */", "#endif", "#ifndef Tk_FreeXId", "#define Tk_FreeXId \\", "\t(tkStubsPtr->tk_FreeXId) /* 77 */", "#endif", "#ifndef Tk_GCForColor", "#define Tk_GCForColor \\", "\t(tkStubsPtr->tk_GCForColor) /* 78 */", "#endif", "#ifndef Tk_GeometryRequest", "#define Tk_GeometryRequest \\", "\t(tkStubsPtr->tk_GeometryRequest) /* 79 */", "#endif", "#ifndef Tk_Get3DBorder", "#define Tk_Get3DBorder \\", "\t(tkStubsPtr->tk_Get3DBorder) /* 80 */", "#endif", "#ifndef Tk_GetAllBindings", "#define Tk_GetAllBindings \\", "\t(tkStubsPtr->tk_GetAllBindings) /* 81 */", "#endif", "#ifndef Tk_GetAnchor", "#define Tk_GetAnchor \\", "\t(tkStubsPtr->tk_GetAnchor) /* 82 */", "#endif", "#ifndef Tk_GetAtomName", "#define Tk_GetAtomName \\", "\t(tkStubsPtr->tk_GetAtomName) /* 83 */", "#endif", "#ifndef Tk_GetBinding", "#define Tk_GetBinding \\", "\t(tkStubsPtr->tk_GetBinding) /* 84 */", "#endif", "#ifndef Tk_GetBitmap", "#define Tk_GetBitmap \\", "\t(tkStubsPtr->tk_GetBitmap) /* 85 */", "#endif", "#ifndef Tk_GetBitmapFromData", "#define Tk_GetBitmapFromData \\", "\t(tkStubsPtr->tk_GetBitmapFromData) /* 86 */", "#endif", "#ifndef Tk_GetCapStyle", "#define Tk_GetCapStyle \\", "\t(tkStubsPtr->tk_GetCapStyle) /* 87 */", "#endif", "#ifndef Tk_GetColor", "#define Tk_GetColor \\", "\t(tkStubsPtr->tk_GetColor) /* 88 */", "#endif", "#ifndef Tk_GetColorByValue", "#define Tk_GetColorByValue \\", "\t(tkStubsPtr->tk_GetColorByValue) /* 89 */", "#endif", "#ifndef Tk_GetColormap", "#define Tk_GetColormap \\", "\t(tkStubsPtr->tk_GetColormap) /* 90 */", "#endif", "#ifndef Tk_GetCursor", "#define Tk_GetCursor \\", "\t(tkStubsPtr->tk_GetCursor) /* 91 */", "#endif", "#ifndef Tk_GetCursorFromData", "#define Tk_GetCursorFromData \\", "\t(tkStubsPtr->tk_GetCursorFromData) /* 92 */", "#endif", "#ifndef Tk_GetFont", "#define Tk_GetFont \\", "\t(tkStubsPtr->tk_GetFont) /* 93 */", "#endif", "#ifndef Tk_GetFontFromObj", "#define Tk_GetFontFromObj \\", "\t(tkStubsPtr->tk_GetFontFromObj) /* 94 */", "#endif", "#ifndef Tk_GetFontMetrics", "#define Tk_GetFontMetrics \\", "\t(tkStubsPtr->tk_GetFontMetrics) /* 95 */", "#endif", "#ifndef Tk_GetGC", "#define Tk_GetGC \\", "\t(tkStubsPtr->tk_GetGC) /* 96 */", "#endif", "#ifndef Tk_GetImage", "#define Tk_GetImage \\", "\t(tkStubsPtr->tk_GetImage) /* 97 */", "#endif", "#ifndef Tk_GetImageMasterData", "#define Tk_GetImageMasterData \\", "\t(tkStubsPtr->tk_GetImageMasterData) /* 98 */", "#endif", "#ifndef Tk_GetItemTypes", "#define Tk_GetItemTypes \\", "\t(tkStubsPtr->tk_GetItemTypes) /* 99 */", "#endif", "#ifndef Tk_GetJoinStyle", "#define Tk_GetJoinStyle \\", "\t(tkStubsPtr->tk_GetJoinStyle) /* 100 */", "#endif", "#ifndef Tk_GetJustify", "#define Tk_GetJustify \\", "\t(tkStubsPtr->tk_GetJustify) /* 101 */", "#endif", "#ifndef Tk_GetNumMainWindows", "#define Tk_GetNumMainWindows \\", "\t(tkStubsPtr->tk_GetNumMainWindows) /* 102 */", "#endif", "#ifndef Tk_GetOption", "#define Tk_GetOption \\", "\t(tkStubsPtr->tk_GetOption) /* 103 */", "#endif", "#ifndef Tk_GetPixels", "#define Tk_GetPixels \\", "\t(tkStubsPtr->tk_GetPixels) /* 104 */", "#endif", "#ifndef Tk_GetPixmap", "#define Tk_GetPixmap \\", "\t(tkStubsPtr->tk_GetPixmap) /* 105 */", "#endif", "#ifndef Tk_GetRelief", "#define Tk_GetRelief \\", "\t(tkStubsPtr->tk_GetRelief) /* 106 */", "#endif", "#ifndef Tk_GetRootCoords", "#define Tk_GetRootCoords \\", "\t(tkStubsPtr->tk_GetRootCoords) /* 107 */", "#endif", "#ifndef Tk_GetScrollInfo", "#define Tk_GetScrollInfo \\", "\t(tkStubsPtr->tk_GetScrollInfo) /* 108 */", "#endif", "#ifndef Tk_GetScreenMM", "#define Tk_GetScreenMM \\", "\t(tkStubsPtr->tk_GetScreenMM) /* 109 */", "#endif", "#ifndef Tk_GetSelection", "#define Tk_GetSelection \\", "\t(tkStubsPtr->tk_GetSelection) /* 110 */", "#endif", "#ifndef Tk_GetUid", "#define Tk_GetUid \\", "\t(tkStubsPtr->tk_GetUid) /* 111 */", "#endif", "#ifndef Tk_GetVisual", "#define Tk_GetVisual \\", "\t(tkStubsPtr->tk_GetVisual) /* 112 */", "#endif", "#ifndef Tk_GetVRootGeometry", "#define Tk_GetVRootGeometry \\", "\t(tkStubsPtr->tk_GetVRootGeometry) /* 113 */", "#endif", "#ifndef Tk_Grab", "#define Tk_Grab \\", "\t(tkStubsPtr->tk_Grab) /* 114 */", "#endif", "#ifndef Tk_HandleEvent", "#define Tk_HandleEvent \\", "\t(tkStubsPtr->tk_HandleEvent) /* 115 */", "#endif", "#ifndef Tk_IdToWindow", "#define Tk_IdToWindow \\", "\t(tkStubsPtr->tk_IdToWindow) /* 116 */", "#endif", "#ifndef Tk_ImageChanged", "#define Tk_ImageChanged \\", "\t(tkStubsPtr->tk_ImageChanged) /* 117 */", "#endif", "#ifndef Tk_Init", "#define Tk_Init \\", "\t(tkStubsPtr->tk_Init) /* 118 */", "#endif", "#ifndef Tk_InternAtom", "#define Tk_InternAtom \\", "\t(tkStubsPtr->tk_InternAtom) /* 119 */", "#endif", "#ifndef Tk_IntersectTextLayout", "#define Tk_IntersectTextLayout \\", "\t(tkStubsPtr->tk_IntersectTextLayout) /* 120 */", "#endif", "#ifndef Tk_MaintainGeometry", "#define Tk_MaintainGeometry \\", "\t(tkStubsPtr->tk_MaintainGeometry) /* 121 */", "#endif", "#ifndef Tk_MainWindow", "#define Tk_MainWindow \\", "\t(tkStubsPtr->tk_MainWindow) /* 122 */", "#endif", "#ifndef Tk_MakeWindowExist", "#define Tk_MakeWindowExist \\", "\t(tkStubsPtr->tk_MakeWindowExist) /* 123 */", "#endif", "#ifndef Tk_ManageGeometry", "#define Tk_ManageGeometry \\", "\t(tkStubsPtr->tk_ManageGeometry) /* 124 */", "#endif", "#ifndef Tk_MapWindow", "#define Tk_MapWindow \\", "\t(tkStubsPtr->tk_MapWindow) /* 125 */", "#endif", "#ifndef Tk_MeasureChars", "#define Tk_MeasureChars \\", "\t(tkStubsPtr->tk_MeasureChars) /* 126 */", "#endif", "#ifndef Tk_MoveResizeWindow", "#define Tk_MoveResizeWindow \\", "\t(tkStubsPtr->tk_MoveResizeWindow) /* 127 */", "#endif", "#ifndef Tk_MoveWindow", "#define Tk_MoveWindow \\", "\t(tkStubsPtr->tk_MoveWindow) /* 128 */", "#endif", "#ifndef Tk_MoveToplevelWindow", "#define Tk_MoveToplevelWindow \\", "\t(tkStubsPtr->tk_MoveToplevelWindow) /* 129 */", "#endif", "#ifndef Tk_NameOf3DBorder", "#define Tk_NameOf3DBorder \\", "\t(tkStubsPtr->tk_NameOf3DBorder) /* 130 */", "#endif", "#ifndef Tk_NameOfAnchor", "#define Tk_NameOfAnchor \\", "\t(tkStubsPtr->tk_NameOfAnchor) /* 131 */", "#endif", "#ifndef Tk_NameOfBitmap", "#define Tk_NameOfBitmap \\", "\t(tkStubsPtr->tk_NameOfBitmap) /* 132 */", "#endif", "#ifndef Tk_NameOfCapStyle", "#define Tk_NameOfCapStyle \\", "\t(tkStubsPtr->tk_NameOfCapStyle) /* 133 */", "#endif", "#ifndef Tk_NameOfColor", "#define Tk_NameOfColor \\", "\t(tkStubsPtr->tk_NameOfColor) /* 134 */", "#endif", "#ifndef Tk_NameOfCursor", "#define Tk_NameOfCursor \\", "\t(tkStubsPtr->tk_NameOfCursor) /* 135 */", "#endif", "#ifndef Tk_NameOfFont", "#define Tk_NameOfFont \\", "\t(tkStubsPtr->tk_NameOfFont) /* 136 */", "#endif", "#ifndef Tk_NameOfImage", "#define Tk_NameOfImage \\", "\t(tkStubsPtr->tk_NameOfImage) /* 137 */", "#endif", "#ifndef Tk_NameOfJoinStyle", "#define Tk_NameOfJoinStyle \\", "\t(tkStubsPtr->tk_NameOfJoinStyle) /* 138 */", "#endif", "#ifndef Tk_NameOfJustify", "#define Tk_NameOfJustify \\", "\t(tkStubsPtr->tk_NameOfJustify) /* 139 */", "#endif", "#ifndef Tk_NameOfRelief", "#define Tk_NameOfRelief \\", "\t(tkStubsPtr->tk_NameOfRelief) /* 140 */", "#endif", "#ifndef Tk_NameToWindow", "#define Tk_NameToWindow \\", "\t(tkStubsPtr->tk_NameToWindow) /* 141 */", "#endif", "#ifndef Tk_OwnSelection", "#define Tk_OwnSelection \\", "\t(tkStubsPtr->tk_OwnSelection) /* 142 */", "#endif", "#ifndef Tk_ParseArgv", "#define Tk_ParseArgv \\", "\t(tkStubsPtr->tk_ParseArgv) /* 143 */", "#endif", "#ifndef Tk_PhotoPutBlock_NoComposite", "#define Tk_PhotoPutBlock_NoComposite \\", "\t(tkStubsPtr->tk_PhotoPutBlock_NoComposite) /* 144 */", "#endif", "#ifndef Tk_PhotoPutZoomedBlock_NoComposite", "#define Tk_PhotoPutZoomedBlock_NoComposite \\", "\t(tkStubsPtr->tk_PhotoPutZoomedBlock_NoComposite) /* 145 */", "#endif", "#ifndef Tk_PhotoGetImage", "#define Tk_PhotoGetImage \\", "\t(tkStubsPtr->tk_PhotoGetImage) /* 146 */", "#endif", "#ifndef Tk_PhotoBlank", "#define Tk_PhotoBlank \\", "\t(tkStubsPtr->tk_PhotoBlank) /* 147 */", "#endif", "#ifndef Tk_PhotoExpand_Panic", "#define Tk_PhotoExpand_Panic \\", "\t(tkStubsPtr->tk_PhotoExpand_Panic) /* 148 */", "#endif", "#ifndef Tk_PhotoGetSize", "#define Tk_PhotoGetSize \\", "\t(tkStubsPtr->tk_PhotoGetSize) /* 149 */", "#endif", "#ifndef Tk_PhotoSetSize_Panic", "#define Tk_PhotoSetSize_Panic \\", "\t(tkStubsPtr->tk_PhotoSetSize_Panic) /* 150 */", "#endif", "#ifndef Tk_PointToChar", "#define Tk_PointToChar \\", "\t(tkStubsPtr->tk_PointToChar) /* 151 */", "#endif", "#ifndef Tk_PostscriptFontName", "#define Tk_PostscriptFontName \\", "\t(tkStubsPtr->tk_PostscriptFontName) /* 152 */", "#endif", "#ifndef Tk_PreserveColormap", "#define Tk_PreserveColormap \\", "\t(tkStubsPtr->tk_PreserveColormap) /* 153 */", "#endif", "#ifndef Tk_QueueWindowEvent", "#define Tk_QueueWindowEvent \\", "\t(tkStubsPtr->tk_QueueWindowEvent) /* 154 */", "#endif", "#ifndef Tk_RedrawImage", "#define Tk_RedrawImage \\", "\t(tkStubsPtr->tk_RedrawImage) /* 155 */", "#endif", "#ifndef Tk_ResizeWindow", "#define Tk_ResizeWindow \\", "\t(tkStubsPtr->tk_ResizeWindow) /* 156 */", "#endif", "#ifndef Tk_RestackWindow", "#define Tk_RestackWindow \\", "\t(tkStubsPtr->tk_RestackWindow) /* 157 */", "#endif", "#ifndef Tk_RestrictEvents", "#define Tk_RestrictEvents \\", "\t(tkStubsPtr->tk_RestrictEvents) /* 158 */", "#endif", "#ifndef Tk_SafeInit", "#define Tk_SafeInit \\", "\t(tkStubsPtr->tk_SafeInit) /* 159 */", "#endif", "#ifndef Tk_SetAppName", "#define Tk_SetAppName \\", "\t(tkStubsPtr->tk_SetAppName) /* 160 */", "#endif", "#ifndef Tk_SetBackgroundFromBorder", "#define Tk_SetBackgroundFromBorder \\", "\t(tkStubsPtr->tk_SetBackgroundFromBorder) /* 161 */", "#endif", "#ifndef Tk_SetClass", "#define Tk_SetClass \\", "\t(tkStubsPtr->tk_SetClass) /* 162 */", "#endif", "#ifndef Tk_SetGrid", "#define Tk_SetGrid \\", "\t(tkStubsPtr->tk_SetGrid) /* 163 */", "#endif", "#ifndef Tk_SetInternalBorder", "#define Tk_SetInternalBorder \\", "\t(tkStubsPtr->tk_SetInternalBorder) /* 164 */", "#endif", "#ifndef Tk_SetWindowBackground", "#define Tk_SetWindowBackground \\", "\t(tkStubsPtr->tk_SetWindowBackground) /* 165 */", "#endif", "#ifndef Tk_SetWindowBackgroundPixmap", "#define Tk_SetWindowBackgroundPixmap \\", "\t(tkStubsPtr->tk_SetWindowBackgroundPixmap) /* 166 */", "#endif", "#ifndef Tk_SetWindowBorder", "#define Tk_SetWindowBorder \\", "\t(tkStubsPtr->tk_SetWindowBorder) /* 167 */", "#endif", "#ifndef Tk_SetWindowBorderWidth", "#define Tk_SetWindowBorderWidth \\", "\t(tkStubsPtr->tk_SetWindowBorderWidth) /* 168 */", "#endif", "#ifndef Tk_SetWindowBorderPixmap", "#define Tk_SetWindowBorderPixmap \\", "\t(tkStubsPtr->tk_SetWindowBorderPixmap) /* 169 */", "#endif", "#ifndef Tk_SetWindowColormap", "#define Tk_SetWindowColormap \\", "\t(tkStubsPtr->tk_SetWindowColormap) /* 170 */", "#endif", "#ifndef Tk_SetWindowVisual", "#define Tk_SetWindowVisual \\", "\t(tkStubsPtr->tk_SetWindowVisual) /* 171 */", "#endif", "#ifndef Tk_SizeOfBitmap", "#define Tk_SizeOfBitmap \\", "\t(tkStubsPtr->tk_SizeOfBitmap) /* 172 */", "#endif", "#ifndef Tk_SizeOfImage", "#define Tk_SizeOfImage \\", "\t(tkStubsPtr->tk_SizeOfImage) /* 173 */", "#endif", "#ifndef Tk_StrictMotif", "#define Tk_StrictMotif \\", "\t(tkStubsPtr->tk_StrictMotif) /* 174 */", "#endif", "#ifndef Tk_TextLayoutToPostscript", "#define Tk_TextLayoutToPostscript \\", "\t(tkStubsPtr->tk_TextLayoutToPostscript) /* 175 */", "#endif", "#ifndef Tk_TextWidth", "#define Tk_TextWidth \\", "\t(tkStubsPtr->tk_TextWidth) /* 176 */", "#endif", "#ifndef Tk_UndefineCursor", "#define Tk_UndefineCursor \\", "\t(tkStubsPtr->tk_UndefineCursor) /* 177 */", "#endif", "#ifndef Tk_UnderlineChars", "#define Tk_UnderlineChars \\", "\t(tkStubsPtr->tk_UnderlineChars) /* 178 */", "#endif", "#ifndef Tk_UnderlineTextLayout", "#define Tk_UnderlineTextLayout \\", "\t(tkStubsPtr->tk_UnderlineTextLayout) /* 179 */", "#endif", "#ifndef Tk_Ungrab", "#define Tk_Ungrab \\", "\t(tkStubsPtr->tk_Ungrab) /* 180 */", "#endif", "#ifndef Tk_UnmaintainGeometry", "#define Tk_UnmaintainGeometry \\", "\t(tkStubsPtr->tk_UnmaintainGeometry) /* 181 */", "#endif", "#ifndef Tk_UnmapWindow", "#define Tk_UnmapWindow \\", "\t(tkStubsPtr->tk_UnmapWindow) /* 182 */", "#endif", "#ifndef Tk_UnsetGrid", "#define Tk_UnsetGrid \\", "\t(tkStubsPtr->tk_UnsetGrid) /* 183 */", "#endif", "#ifndef Tk_UpdatePointer", "#define Tk_UpdatePointer \\", "\t(tkStubsPtr->tk_UpdatePointer) /* 184 */", "#endif", "#ifndef Tk_AllocBitmapFromObj", "#define Tk_AllocBitmapFromObj \\", "\t(tkStubsPtr->tk_AllocBitmapFromObj) /* 185 */", "#endif", "#ifndef Tk_Alloc3DBorderFromObj", "#define Tk_Alloc3DBorderFromObj \\", "\t(tkStubsPtr->tk_Alloc3DBorderFromObj) /* 186 */", "#endif", "#ifndef Tk_AllocColorFromObj", "#define Tk_AllocColorFromObj \\", "\t(tkStubsPtr->tk_AllocColorFromObj) /* 187 */", "#endif", "#ifndef Tk_AllocCursorFromObj", "#define Tk_AllocCursorFromObj \\", "\t(tkStubsPtr->tk_AllocCursorFromObj) /* 188 */", "#endif", "#ifndef Tk_AllocFontFromObj", "#define Tk_AllocFontFromObj \\", "\t(tkStubsPtr->tk_AllocFontFromObj) /* 189 */", "#endif", "#ifndef Tk_CreateOptionTable", "#define Tk_CreateOptionTable \\", "\t(tkStubsPtr->tk_CreateOptionTable) /* 190 */", "#endif", "#ifndef Tk_DeleteOptionTable", "#define Tk_DeleteOptionTable \\", "\t(tkStubsPtr->tk_DeleteOptionTable) /* 191 */", "#endif", "#ifndef Tk_Free3DBorderFromObj", "#define Tk_Free3DBorderFromObj \\", "\t(tkStubsPtr->tk_Free3DBorderFromObj) /* 192 */", "#endif", "#ifndef Tk_FreeBitmapFromObj", "#define Tk_FreeBitmapFromObj \\", "\t(tkStubsPtr->tk_FreeBitmapFromObj) /* 193 */", "#endif", "#ifndef Tk_FreeColorFromObj", "#define Tk_FreeColorFromObj \\", "\t(tkStubsPtr->tk_FreeColorFromObj) /* 194 */", "#endif", "#ifndef Tk_FreeConfigOptions", "#define Tk_FreeConfigOptions \\", "\t(tkStubsPtr->tk_FreeConfigOptions) /* 195 */", "#endif", "#ifndef Tk_FreeSavedOptions", "#define Tk_FreeSavedOptions \\", "\t(tkStubsPtr->tk_FreeSavedOptions) /* 196 */", "#endif", "#ifndef Tk_FreeCursorFromObj", "#define Tk_FreeCursorFromObj \\", "\t(tkStubsPtr->tk_FreeCursorFromObj) /* 197 */", "#endif", "#ifndef Tk_FreeFontFromObj", "#define Tk_FreeFontFromObj \\", "\t(tkStubsPtr->tk_FreeFontFromObj) /* 198 */", "#endif", "#ifndef Tk_Get3DBorderFromObj", "#define Tk_Get3DBorderFromObj \\", "\t(tkStubsPtr->tk_Get3DBorderFromObj) /* 199 */", "#endif", "#ifndef Tk_GetAnchorFromObj", "#define Tk_GetAnchorFromObj \\", "\t(tkStubsPtr->tk_GetAnchorFromObj) /* 200 */", "#endif", "#ifndef Tk_GetBitmapFromObj", "#define Tk_GetBitmapFromObj \\", "\t(tkStubsPtr->tk_GetBitmapFromObj) /* 201 */", "#endif", "#ifndef Tk_GetColorFromObj", "#define Tk_GetColorFromObj \\", "\t(tkStubsPtr->tk_GetColorFromObj) /* 202 */", "#endif", "#ifndef Tk_GetCursorFromObj", "#define Tk_GetCursorFromObj \\", "\t(tkStubsPtr->tk_GetCursorFromObj) /* 203 */", "#endif", "#ifndef Tk_GetOptionInfo", "#define Tk_GetOptionInfo \\", "\t(tkStubsPtr->tk_GetOptionInfo) /* 204 */", "#endif", "#ifndef Tk_GetOptionValue", "#define Tk_GetOptionValue \\", "\t(tkStubsPtr->tk_GetOptionValue) /* 205 */", "#endif", "#ifndef Tk_GetJustifyFromObj", "#define Tk_GetJustifyFromObj \\", "\t(tkStubsPtr->tk_GetJustifyFromObj) /* 206 */", "#endif", "#ifndef Tk_GetMMFromObj", "#define Tk_GetMMFromObj \\", "\t(tkStubsPtr->tk_GetMMFromObj) /* 207 */", "#endif", "#ifndef Tk_GetPixelsFromObj", "#define Tk_GetPixelsFromObj \\", "\t(tkStubsPtr->tk_GetPixelsFromObj) /* 208 */", "#endif", "#ifndef Tk_GetReliefFromObj", "#define Tk_GetReliefFromObj \\", "\t(tkStubsPtr->tk_GetReliefFromObj) /* 209 */", "#endif", "#ifndef Tk_GetScrollInfoObj", "#define Tk_GetScrollInfoObj \\", "\t(tkStubsPtr->tk_GetScrollInfoObj) /* 210 */", "#endif", "#ifndef Tk_InitOptions", "#define Tk_InitOptions \\", "\t(tkStubsPtr->tk_InitOptions) /* 211 */", "#endif", "#ifndef Tk_MainEx", "#define Tk_MainEx \\", "\t(tkStubsPtr->tk_MainEx) /* 212 */", "#endif", "#ifndef Tk_RestoreSavedOptions", "#define Tk_RestoreSavedOptions \\", "\t(tkStubsPtr->tk_RestoreSavedOptions) /* 213 */", "#endif", "#ifndef Tk_SetOptions", "#define Tk_SetOptions \\", "\t(tkStubsPtr->tk_SetOptions) /* 214 */", "#endif", "#ifndef Tk_InitConsoleChannels", "#define Tk_InitConsoleChannels \\", "\t(tkStubsPtr->tk_InitConsoleChannels) /* 215 */", "#endif", "#ifndef Tk_CreateConsoleWindow", "#define Tk_CreateConsoleWindow \\", "\t(tkStubsPtr->tk_CreateConsoleWindow) /* 216 */", "#endif", "#ifndef Tk_CreateSmoothMethod", "#define Tk_CreateSmoothMethod \\", "\t(tkStubsPtr->tk_CreateSmoothMethod) /* 217 */", "#endif", "/* Slot 218 is reserved */", "/* Slot 219 is reserved */", "#ifndef Tk_GetDash", "#define Tk_GetDash \\", "\t(tkStubsPtr->tk_GetDash) /* 220 */", "#endif", "#ifndef Tk_CreateOutline", "#define Tk_CreateOutline \\", "\t(tkStubsPtr->tk_CreateOutline) /* 221 */", "#endif", "#ifndef Tk_DeleteOutline", "#define Tk_DeleteOutline \\", "\t(tkStubsPtr->tk_DeleteOutline) /* 222 */", "#endif", "#ifndef Tk_ConfigOutlineGC", "#define Tk_ConfigOutlineGC \\", "\t(tkStubsPtr->tk_ConfigOutlineGC) /* 223 */", "#endif", "#ifndef Tk_ChangeOutlineGC", "#define Tk_ChangeOutlineGC \\", "\t(tkStubsPtr->tk_ChangeOutlineGC) /* 224 */", "#endif", "#ifndef Tk_ResetOutlineGC", "#define Tk_ResetOutlineGC \\", "\t(tkStubsPtr->tk_ResetOutlineGC) /* 225 */", "#endif", "#ifndef Tk_CanvasPsOutline", "#define Tk_CanvasPsOutline \\", "\t(tkStubsPtr->tk_CanvasPsOutline) /* 226 */", "#endif", "#ifndef Tk_SetTSOrigin", "#define Tk_SetTSOrigin \\", "\t(tkStubsPtr->tk_SetTSOrigin) /* 227 */", "#endif", "#ifndef Tk_CanvasGetCoordFromObj", "#define Tk_CanvasGetCoordFromObj \\", "\t(tkStubsPtr->tk_CanvasGetCoordFromObj) /* 228 */", "#endif", "#ifndef Tk_CanvasSetOffset", "#define Tk_CanvasSetOffset \\", "\t(tkStubsPtr->tk_CanvasSetOffset) /* 229 */", "#endif", "#ifndef Tk_DitherPhoto", "#define Tk_DitherPhoto \\", "\t(tkStubsPtr->tk_DitherPhoto) /* 230 */", "#endif", "#ifndef Tk_PostscriptBitmap", "#define Tk_PostscriptBitmap \\", "\t(tkStubsPtr->tk_PostscriptBitmap) /* 231 */", "#endif", "#ifndef Tk_PostscriptColor", "#define Tk_PostscriptColor \\", "\t(tkStubsPtr->tk_PostscriptColor) /* 232 */", "#endif", "#ifndef Tk_PostscriptFont", "#define Tk_PostscriptFont \\", "\t(tkStubsPtr->tk_PostscriptFont) /* 233 */", "#endif", "#ifndef Tk_PostscriptImage", "#define Tk_PostscriptImage \\", "\t(tkStubsPtr->tk_PostscriptImage) /* 234 */", "#endif", "#ifndef Tk_PostscriptPath", "#define Tk_PostscriptPath \\", "\t(tkStubsPtr->tk_PostscriptPath) /* 235 */", "#endif", "#ifndef Tk_PostscriptStipple", "#define Tk_PostscriptStipple \\", "\t(tkStubsPtr->tk_PostscriptStipple) /* 236 */", "#endif", "#ifndef Tk_PostscriptY", "#define Tk_PostscriptY \\", "\t(tkStubsPtr->tk_PostscriptY) /* 237 */", "#endif", "#ifndef Tk_PostscriptPhoto", "#define Tk_PostscriptPhoto \\", "\t(tkStubsPtr->tk_PostscriptPhoto) /* 238 */", "#endif", "#ifndef Tk_CreateClientMessageHandler", "#define Tk_CreateClientMessageHandler \\", "\t(tkStubsPtr->tk_CreateClientMessageHandler) /* 239 */", "#endif", "#ifndef Tk_DeleteClientMessageHandler", "#define Tk_DeleteClientMessageHandler \\", "\t(tkStubsPtr->tk_DeleteClientMessageHandler) /* 240 */", "#endif", "#ifndef Tk_CreateAnonymousWindow", "#define Tk_CreateAnonymousWindow \\", "\t(tkStubsPtr->tk_CreateAnonymousWindow) /* 241 */", "#endif", "#ifndef Tk_SetClassProcs", "#define Tk_SetClassProcs \\", "\t(tkStubsPtr->tk_SetClassProcs) /* 242 */", "#endif", "#ifndef Tk_SetInternalBorderEx", "#define Tk_SetInternalBorderEx \\", "\t(tkStubsPtr->tk_SetInternalBorderEx) /* 243 */", "#endif", "#ifndef Tk_SetMinimumRequestSize", "#define Tk_SetMinimumRequestSize \\", "\t(tkStubsPtr->tk_SetMinimumRequestSize) /* 244 */", "#endif", "#ifndef Tk_SetCaretPos", "#define Tk_SetCaretPos \\", "\t(tkStubsPtr->tk_SetCaretPos) /* 245 */", "#endif", "#ifndef Tk_PhotoPutBlock_Panic", "#define Tk_PhotoPutBlock_Panic \\", "\t(tkStubsPtr->tk_PhotoPutBlock_Panic) /* 246 */", "#endif", "#ifndef Tk_PhotoPutZoomedBlock_Panic", "#define Tk_PhotoPutZoomedBlock_Panic \\", "\t(tkStubsPtr->tk_PhotoPutZoomedBlock_Panic) /* 247 */", "#endif", "#ifndef Tk_CollapseMotionEvents", "#define Tk_CollapseMotionEvents \\", "\t(tkStubsPtr->tk_CollapseMotionEvents) /* 248 */", "#endif", "#ifndef Tk_RegisterStyleEngine", "#define Tk_RegisterStyleEngine \\", "\t(tkStubsPtr->tk_RegisterStyleEngine) /* 249 */", "#endif", "#ifndef Tk_GetStyleEngine", "#define Tk_GetStyleEngine \\", "\t(tkStubsPtr->tk_GetStyleEngine) /* 250 */", "#endif", "#ifndef Tk_RegisterStyledElement", "#define Tk_RegisterStyledElement \\", "\t(tkStubsPtr->tk_RegisterStyledElement) /* 251 */", "#endif", "#ifndef Tk_GetElementId", "#define Tk_GetElementId \\", "\t(tkStubsPtr->tk_GetElementId) /* 252 */", "#endif", "#ifndef Tk_CreateStyle", "#define Tk_CreateStyle \\", "\t(tkStubsPtr->tk_CreateStyle) /* 253 */", "#endif", "#ifndef Tk_GetStyle", "#define Tk_GetStyle \\", "\t(tkStubsPtr->tk_GetStyle) /* 254 */", "#endif", "#ifndef Tk_FreeStyle", "#define Tk_FreeStyle \\", "\t(tkStubsPtr->tk_FreeStyle) /* 255 */", "#endif", "#ifndef Tk_NameOfStyle", "#define Tk_NameOfStyle \\", "\t(tkStubsPtr->tk_NameOfStyle) /* 256 */", "#endif", "#ifndef Tk_AllocStyleFromObj", "#define Tk_AllocStyleFromObj \\", "\t(tkStubsPtr->tk_AllocStyleFromObj) /* 257 */", "#endif", "#ifndef Tk_GetStyleFromObj", "#define Tk_GetStyleFromObj \\", "\t(tkStubsPtr->tk_GetStyleFromObj) /* 258 */", "#endif", "#ifndef Tk_FreeStyleFromObj", "#define Tk_FreeStyleFromObj \\", "\t(tkStubsPtr->tk_FreeStyleFromObj) /* 259 */", "#endif", "#ifndef Tk_GetStyledElement", "#define Tk_GetStyledElement \\", "\t(tkStubsPtr->tk_GetStyledElement) /* 260 */", "#endif", "#ifndef Tk_GetElementSize", "#define Tk_GetElementSize \\", "\t(tkStubsPtr->tk_GetElementSize) /* 261 */", "#endif", "#ifndef Tk_GetElementBox", "#define Tk_GetElementBox \\", "\t(tkStubsPtr->tk_GetElementBox) /* 262 */", "#endif", "#ifndef Tk_GetElementBorderWidth", "#define Tk_GetElementBorderWidth \\", "\t(tkStubsPtr->tk_GetElementBorderWidth) /* 263 */", "#endif", "#ifndef Tk_DrawElement", "#define Tk_DrawElement \\", "\t(tkStubsPtr->tk_DrawElement) /* 264 */", "#endif", "#ifndef Tk_PhotoExpand", "#define Tk_PhotoExpand \\", "\t(tkStubsPtr->tk_PhotoExpand) /* 265 */", "#endif", "#ifndef Tk_PhotoPutBlock", "#define Tk_PhotoPutBlock \\", "\t(tkStubsPtr->tk_PhotoPutBlock) /* 266 */", "#endif", "#ifndef Tk_PhotoPutZoomedBlock", "#define Tk_PhotoPutZoomedBlock \\", "\t(tkStubsPtr->tk_PhotoPutZoomedBlock) /* 267 */", "#endif", "#ifndef Tk_PhotoSetSize", "#define Tk_PhotoSetSize \\", "\t(tkStubsPtr->tk_PhotoSetSize) /* 268 */", "#endif", "#ifndef Tk_GetUserInactiveTime", "#define Tk_GetUserInactiveTime \\", "\t(tkStubsPtr->tk_GetUserInactiveTime) /* 269 */", "#endif", "#ifndef Tk_ResetUserInactiveTime", "#define Tk_ResetUserInactiveTime \\", "\t(tkStubsPtr->tk_ResetUserInactiveTime) /* 270 */", "#endif", "#ifndef Tk_Interp", "#define Tk_Interp \\", "\t(tkStubsPtr->tk_Interp) /* 271 */", "#endif", "#ifndef Tk_CreateOldImageType", "#define Tk_CreateOldImageType \\", "\t(tkStubsPtr->tk_CreateOldImageType) /* 272 */", "#endif", "#ifndef Tk_CreateOldPhotoImageFormat", "#define Tk_CreateOldPhotoImageFormat \\", "\t(tkStubsPtr->tk_CreateOldPhotoImageFormat) /* 273 */", "#endif", "", "#endif /* defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS) */", "", "/* !END!: Do not edit above this line. */", "", "#undef TCL_STORAGE_CLASS", "#define TCL_STORAGE_CLASS DLLIMPORT", "", "#endif /* _TKDECLS */", "" },
    ["tkIntXlibDecls.h"] = { "/*", " * tkIntXlibDecls.h --", " *", " *\tThis file contains the declarations for all platform dependent", " *\tunsupported functions that are exported by the Tk library.  These", " *\tinterfaces are not guaranteed to remain the same between", " *\tversions.  Use at your own risk.", " *", " * Copyright (c) 1998-1999 by Scriptics Corporation.", " * All rights reserved.", " *", " * RCS: @(#) $Id$", " */", "", "#ifndef _TKINTXLIBDECLS", "#define _TKINTXLIBDECLS", "", '#include "X11/Xutil.h"', "", "#ifdef BUILD_tk", "#undef TCL_STORAGE_CLASS", "#define TCL_STORAGE_CLASS DLLEXPORT", "#endif", "", "/*", " * WARNING: This file is automatically generated by the tools/genStubs.tcl", " * script.  Any modifications to the function declarations below should be made", " * in the generic/tkInt.decls script.", " */", "", "/* !BEGIN!: Do not edit below this line. */", "", "/*", " * Exported function declarations:", " */", "", "#ifdef __WIN32__ /* WIN */", "#ifndef XSetDashes_TCL_DECLARED", "#define XSetDashes_TCL_DECLARED", "/* 0 */", "EXTERN void\t\tXSetDashes(Display *display, GC gc, int dash_offset,", "\t\t\t\t_Xconst char *dash_list, int n);", "#endif", "#ifndef XGetModifierMapping_TCL_DECLARED", "#define XGetModifierMapping_TCL_DECLARED", "/* 1 */", "EXTERN XModifierKeymap * XGetModifierMapping(Display *d);", "#endif", "#ifndef XCreateImage_TCL_DECLARED", "#define XCreateImage_TCL_DECLARED", "/* 2 */", "EXTERN XImage *\t\tXCreateImage(Display *d, Visual *v, unsigned int ui1,", "\t\t\t\tint i1, int i2, char *cp, unsigned int ui2,", "\t\t\t\tunsigned int ui3, int i3, int i4);", "#endif", "#ifndef XGetImage_TCL_DECLARED", "#define XGetImage_TCL_DECLARED", "/* 3 */", "EXTERN XImage *\t\tXGetImage(Display *d, Drawable dr, int i1, int i2,", "\t\t\t\tunsigned int ui1, unsigned int ui2,", "\t\t\t\tunsigned long ul, int i3);", "#endif", "#ifndef XGetAtomName_TCL_DECLARED", "#define XGetAtomName_TCL_DECLARED", "/* 4 */", "EXTERN char *\t\tXGetAtomName(Display *d, Atom a);", "#endif", "#ifndef XKeysymToString_TCL_DECLARED", "#define XKeysymToString_TCL_DECLARED", "/* 5 */", "EXTERN char *\t\tXKeysymToString(KeySym k);", "#endif", "#ifndef XCreateColormap_TCL_DECLARED", "#define XCreateColormap_TCL_DECLARED", "/* 6 */", "EXTERN Colormap\t\tXCreateColormap(Display *d, Window w, Visual *v,", "\t\t\t\tint i);", "#endif", "#ifndef XCreatePixmapCursor_TCL_DECLARED", "#define XCreatePixmapCursor_TCL_DECLARED", "/* 7 */", "EXTERN Cursor\t\tXCreatePixmapCursor(Display *d, Pixmap p1, Pixmap p2,", "\t\t\t\tXColor *x1, XColor *x2, unsigned int ui1,", "\t\t\t\tunsigned int ui2);", "#endif", "#ifndef XCreateGlyphCursor_TCL_DECLARED", "#define XCreateGlyphCursor_TCL_DECLARED", "/* 8 */", "EXTERN Cursor\t\tXCreateGlyphCursor(Display *d, Font f1, Font f2,", "\t\t\t\tunsigned int ui1, unsigned int ui2,", "\t\t\t\tXColor *x1, XColor *x2);", "#endif", "#ifndef XGContextFromGC_TCL_DECLARED", "#define XGContextFromGC_TCL_DECLARED", "/* 9 */", "EXTERN GContext\t\tXGContextFromGC(GC g);", "#endif", "#ifndef XListHosts_TCL_DECLARED", "#define XListHosts_TCL_DECLARED", "/* 10 */", "EXTERN XHostAddress *\tXListHosts(Display *d, int *i, Bool *b);", "#endif", "#ifndef XKeycodeToKeysym_TCL_DECLARED", "#define XKeycodeToKeysym_TCL_DECLARED", "/* 11 */", "EXTERN KeySym\t\tXKeycodeToKeysym(Display *d, unsigned int k, int i);", "#endif", "#ifndef XStringToKeysym_TCL_DECLARED", "#define XStringToKeysym_TCL_DECLARED", "/* 12 */", "EXTERN KeySym\t\tXStringToKeysym(_Xconst char *c);", "#endif", "#ifndef XRootWindow_TCL_DECLARED", "#define XRootWindow_TCL_DECLARED", "/* 13 */", "EXTERN Window\t\tXRootWindow(Display *d, int i);", "#endif", "#ifndef XSetErrorHandler_TCL_DECLARED", "#define XSetErrorHandler_TCL_DECLARED", "/* 14 */", "EXTERN XErrorHandler\tXSetErrorHandler(XErrorHandler x);", "#endif", "#ifndef XIconifyWindow_TCL_DECLARED", "#define XIconifyWindow_TCL_DECLARED", "/* 15 */", "EXTERN Status\t\tXIconifyWindow(Display *d, Window w, int i);", "#endif", "#ifndef XWithdrawWindow_TCL_DECLARED", "#define XWithdrawWindow_TCL_DECLARED", "/* 16 */", "EXTERN Status\t\tXWithdrawWindow(Display *d, Window w, int i);", "#endif", "#ifndef XGetWMColormapWindows_TCL_DECLARED", "#define XGetWMColormapWindows_TCL_DECLARED", "/* 17 */", "EXTERN Status\t\tXGetWMColormapWindows(Display *d, Window w,", "\t\t\t\tWindow **wpp, int *ip);", "#endif", "#ifndef XAllocColor_TCL_DECLARED", "#define XAllocColor_TCL_DECLARED", "/* 18 */", "EXTERN Status\t\tXAllocColor(Display *d, Colormap c, XColor *xp);", "#endif", "#ifndef XBell_TCL_DECLARED", "#define XBell_TCL_DECLARED", "/* 19 */", "EXTERN void\t\tXBell(Display *d, int i);", "#endif", "#ifndef XChangeProperty_TCL_DECLARED", "#define XChangeProperty_TCL_DECLARED", "/* 20 */", "EXTERN void\t\tXChangeProperty(Display *d, Window w, Atom a1,", "\t\t\t\tAtom a2, int i1, int i2,", "\t\t\t\t_Xconst unsigned char *c, int i3);", "#endif", "#ifndef XChangeWindowAttributes_TCL_DECLARED", "#define XChangeWindowAttributes_TCL_DECLARED", "/* 21 */", "EXTERN void\t\tXChangeWindowAttributes(Display *d, Window w,", "\t\t\t\tunsigned long ul, XSetWindowAttributes *x);", "#endif", "#ifndef XClearWindow_TCL_DECLARED", "#define XClearWindow_TCL_DECLARED", "/* 22 */", "EXTERN void\t\tXClearWindow(Display *d, Window w);", "#endif", "#ifndef XConfigureWindow_TCL_DECLARED", "#define XConfigureWindow_TCL_DECLARED", "/* 23 */", "EXTERN void\t\tXConfigureWindow(Display *d, Window w,", "\t\t\t\tunsigned int i, XWindowChanges *x);", "#endif", "#ifndef XCopyArea_TCL_DECLARED", "#define XCopyArea_TCL_DECLARED", "/* 24 */", "EXTERN void\t\tXCopyArea(Display *d, Drawable dr1, Drawable dr2,", "\t\t\t\tGC g, int i1, int i2, unsigned int ui1,", "\t\t\t\tunsigned int ui2, int i3, int i4);", "#endif", "#ifndef XCopyPlane_TCL_DECLARED", "#define XCopyPlane_TCL_DECLARED", "/* 25 */", "EXTERN void\t\tXCopyPlane(Display *d, Drawable dr1, Drawable dr2,", "\t\t\t\tGC g, int i1, int i2, unsigned int ui1,", "\t\t\t\tunsigned int ui2, int i3, int i4,", "\t\t\t\tunsigned long ul);", "#endif", "#ifndef XCreateBitmapFromData_TCL_DECLARED", "#define XCreateBitmapFromData_TCL_DECLARED", "/* 26 */", "EXTERN Pixmap\t\tXCreateBitmapFromData(Display *display, Drawable d,", "\t\t\t\t_Xconst char *data, unsigned int width,", "\t\t\t\tunsigned int height);", "#endif", "#ifndef XDefineCursor_TCL_DECLARED", "#define XDefineCursor_TCL_DECLARED", "/* 27 */", "EXTERN void\t\tXDefineCursor(Display *d, Window w, Cursor c);", "#endif", "#ifndef XDeleteProperty_TCL_DECLARED", "#define XDeleteProperty_TCL_DECLARED", "/* 28 */", "EXTERN void\t\tXDeleteProperty(Display *d, Window w, Atom a);", "#endif", "#ifndef XDestroyWindow_TCL_DECLARED", "#define XDestroyWindow_TCL_DECLARED", "/* 29 */", "EXTERN void\t\tXDestroyWindow(Display *d, Window w);", "#endif", "#ifndef XDrawArc_TCL_DECLARED", "#define XDrawArc_TCL_DECLARED", "/* 30 */", "EXTERN void\t\tXDrawArc(Display *d, Drawable dr, GC g, int i1,", "\t\t\t\tint i2, unsigned int ui1, unsigned int ui2,", "\t\t\t\tint i3, int i4);", "#endif", "#ifndef XDrawLines_TCL_DECLARED", "#define XDrawLines_TCL_DECLARED", "/* 31 */", "EXTERN void\t\tXDrawLines(Display *d, Drawable dr, GC g, XPoint *x,", "\t\t\t\tint i1, int i2);", "#endif", "#ifndef XDrawRectangle_TCL_DECLARED", "#define XDrawRectangle_TCL_DECLARED", "/* 32 */", "EXTERN void\t\tXDrawRectangle(Display *d, Drawable dr, GC g, int i1,", "\t\t\t\tint i2, unsigned int ui1, unsigned int ui2);", "#endif", "#ifndef XFillArc_TCL_DECLARED", "#define XFillArc_TCL_DECLARED", "/* 33 */", "EXTERN void\t\tXFillArc(Display *d, Drawable dr, GC g, int i1,", "\t\t\t\tint i2, unsigned int ui1, unsigned int ui2,", "\t\t\t\tint i3, int i4);", "#endif", "#ifndef XFillPolygon_TCL_DECLARED", "#define XFillPolygon_TCL_DECLARED", "/* 34 */", "EXTERN void\t\tXFillPolygon(Display *d, Drawable dr, GC g,", "\t\t\t\tXPoint *x, int i1, int i2, int i3);", "#endif", "#ifndef XFillRectangles_TCL_DECLARED", "#define XFillRectangles_TCL_DECLARED", "/* 35 */", "EXTERN void\t\tXFillRectangles(Display *d, Drawable dr, GC g,", "\t\t\t\tXRectangle *x, int i);", "#endif", "#ifndef XForceScreenSaver_TCL_DECLARED", "#define XForceScreenSaver_TCL_DECLARED", "/* 36 */", "EXTERN void\t\tXForceScreenSaver(Display *d, int i);", "#endif", "#ifndef XFreeColormap_TCL_DECLARED", "#define XFreeColormap_TCL_DECLARED", "/* 37 */", "EXTERN void\t\tXFreeColormap(Display *d, Colormap c);", "#endif", "#ifndef XFreeColors_TCL_DECLARED", "#define XFreeColors_TCL_DECLARED", "/* 38 */", "EXTERN void\t\tXFreeColors(Display *d, Colormap c,", "\t\t\t\tunsigned long *ulp, int i, unsigned long ul);", "#endif", "#ifndef XFreeCursor_TCL_DECLARED", "#define XFreeCursor_TCL_DECLARED", "/* 39 */", "EXTERN void\t\tXFreeCursor(Display *d, Cursor c);", "#endif", "#ifndef XFreeModifiermap_TCL_DECLARED", "#define XFreeModifiermap_TCL_DECLARED", "/* 40 */", "EXTERN void\t\tXFreeModifiermap(XModifierKeymap *x);", "#endif", "#ifndef XGetGeometry_TCL_DECLARED", "#define XGetGeometry_TCL_DECLARED", "/* 41 */", "EXTERN Status\t\tXGetGeometry(Display *d, Drawable dr, Window *w,", "\t\t\t\tint *i1, int *i2, unsigned int *ui1,", "\t\t\t\tunsigned int *ui2, unsigned int *ui3,", "\t\t\t\tunsigned int *ui4);", "#endif", "#ifndef XGetInputFocus_TCL_DECLARED", "#define XGetInputFocus_TCL_DECLARED", "/* 42 */", "EXTERN void\t\tXGetInputFocus(Display *d, Window *w, int *i);", "#endif", "#ifndef XGetWindowProperty_TCL_DECLARED", "#define XGetWindowProperty_TCL_DECLARED", "/* 43 */", "EXTERN int\t\tXGetWindowProperty(Display *d, Window w, Atom a1,", "\t\t\t\tlong l1, long l2, Bool b, Atom a2, Atom *ap,", "\t\t\t\tint *ip, unsigned long *ulp1,", "\t\t\t\tunsigned long *ulp2, unsigned char **cpp);", "#endif", "#ifndef XGetWindowAttributes_TCL_DECLARED", "#define XGetWindowAttributes_TCL_DECLARED", "/* 44 */", "EXTERN Status\t\tXGetWindowAttributes(Display *d, Window w,", "\t\t\t\tXWindowAttributes *x);", "#endif", "#ifndef XGrabKeyboard_TCL_DECLARED", "#define XGrabKeyboard_TCL_DECLARED", "/* 45 */", "EXTERN int\t\tXGrabKeyboard(Display *d, Window w, Bool b, int i1,", "\t\t\t\tint i2, Time t);", "#endif", "#ifndef XGrabPointer_TCL_DECLARED", "#define XGrabPointer_TCL_DECLARED", "/* 46 */", "EXTERN int\t\tXGrabPointer(Display *d, Window w1, Bool b,", "\t\t\t\tunsigned int ui, int i1, int i2, Window w2,", "\t\t\t\tCursor c, Time t);", "#endif", "#ifndef XKeysymToKeycode_TCL_DECLARED", "#define XKeysymToKeycode_TCL_DECLARED", "/* 47 */", "EXTERN KeyCode\t\tXKeysymToKeycode(Display *d, KeySym k);", "#endif", "#ifndef XLookupColor_TCL_DECLARED", "#define XLookupColor_TCL_DECLARED", "/* 48 */", "EXTERN Status\t\tXLookupColor(Display *d, Colormap c1,", "\t\t\t\t_Xconst char *c2, XColor *x1, XColor *x2);", "#endif", "#ifndef XMapWindow_TCL_DECLARED", "#define XMapWindow_TCL_DECLARED", "/* 49 */", "EXTERN void\t\tXMapWindow(Display *d, Window w);", "#endif", "#ifndef XMoveResizeWindow_TCL_DECLARED", "#define XMoveResizeWindow_TCL_DECLARED", "/* 50 */", "EXTERN void\t\tXMoveResizeWindow(Display *d, Window w, int i1,", "\t\t\t\tint i2, unsigned int ui1, unsigned int ui2);", "#endif", "#ifndef XMoveWindow_TCL_DECLARED", "#define XMoveWindow_TCL_DECLARED", "/* 51 */", "EXTERN void\t\tXMoveWindow(Display *d, Window w, int i1, int i2);", "#endif", "#ifndef XNextEvent_TCL_DECLARED", "#define XNextEvent_TCL_DECLARED", "/* 52 */", "EXTERN void\t\tXNextEvent(Display *d, XEvent *x);", "#endif", "#ifndef XPutBackEvent_TCL_DECLARED", "#define XPutBackEvent_TCL_DECLARED", "/* 53 */", "EXTERN void\t\tXPutBackEvent(Display *d, XEvent *x);", "#endif", "#ifndef XQueryColors_TCL_DECLARED", "#define XQueryColors_TCL_DECLARED", "/* 54 */", "EXTERN void\t\tXQueryColors(Display *d, Colormap c, XColor *x,", "\t\t\t\tint i);", "#endif", "#ifndef XQueryPointer_TCL_DECLARED", "#define XQueryPointer_TCL_DECLARED", "/* 55 */", "EXTERN Bool\t\tXQueryPointer(Display *d, Window w1, Window *w2,", "\t\t\t\tWindow *w3, int *i1, int *i2, int *i3,", "\t\t\t\tint *i4, unsigned int *ui);", "#endif", "#ifndef XQueryTree_TCL_DECLARED", "#define XQueryTree_TCL_DECLARED", "/* 56 */", "EXTERN Status\t\tXQueryTree(Display *d, Window w1, Window *w2,", "\t\t\t\tWindow *w3, Window **w4, unsigned int *ui);", "#endif", "#ifndef XRaiseWindow_TCL_DECLARED", "#define XRaiseWindow_TCL_DECLARED", "/* 57 */", "EXTERN void\t\tXRaiseWindow(Display *d, Window w);", "#endif", "#ifndef XRefreshKeyboardMapping_TCL_DECLARED", "#define XRefreshKeyboardMapping_TCL_DECLARED", "/* 58 */", "EXTERN void\t\tXRefreshKeyboardMapping(XMappingEvent *x);", "#endif", "#ifndef XResizeWindow_TCL_DECLARED", "#define XResizeWindow_TCL_DECLARED", "/* 59 */", "EXTERN void\t\tXResizeWindow(Display *d, Window w, unsigned int ui1,", "\t\t\t\tunsigned int ui2);", "#endif", "#ifndef XSelectInput_TCL_DECLARED", "#define XSelectInput_TCL_DECLARED", "/* 60 */", "EXTERN void\t\tXSelectInput(Display *d, Window w, long l);", "#endif", "#ifndef XSendEvent_TCL_DECLARED", "#define XSendEvent_TCL_DECLARED", "/* 61 */", "EXTERN Status\t\tXSendEvent(Display *d, Window w, Bool b, long l,", "\t\t\t\tXEvent *x);", "#endif", "#ifndef XSetCommand_TCL_DECLARED", "#define XSetCommand_TCL_DECLARED", "/* 62 */", "EXTERN void\t\tXSetCommand(Display *d, Window w, CONST char **c,", "\t\t\t\tint i);", "#endif", "#ifndef XSetIconName_TCL_DECLARED", "#define XSetIconName_TCL_DECLARED", "/* 63 */", "EXTERN void\t\tXSetIconName(Display *d, Window w, _Xconst char *c);", "#endif", "#ifndef XSetInputFocus_TCL_DECLARED", "#define XSetInputFocus_TCL_DECLARED", "/* 64 */", "EXTERN void\t\tXSetInputFocus(Display *d, Window w, int i, Time t);", "#endif", "#ifndef XSetSelectionOwner_TCL_DECLARED", "#define XSetSelectionOwner_TCL_DECLARED", "/* 65 */", "EXTERN void\t\tXSetSelectionOwner(Display *d, Atom a, Window w,", "\t\t\t\tTime t);", "#endif", "#ifndef XSetWindowBackground_TCL_DECLARED", "#define XSetWindowBackground_TCL_DECLARED", "/* 66 */", "EXTERN void\t\tXSetWindowBackground(Display *d, Window w,", "\t\t\t\tunsigned long ul);", "#endif", "#ifndef XSetWindowBackgroundPixmap_TCL_DECLARED", "#define XSetWindowBackgroundPixmap_TCL_DECLARED", "/* 67 */", "EXTERN void\t\tXSetWindowBackgroundPixmap(Display *d, Window w,", "\t\t\t\tPixmap p);", "#endif", "#ifndef XSetWindowBorder_TCL_DECLARED", "#define XSetWindowBorder_TCL_DECLARED", "/* 68 */", "EXTERN void\t\tXSetWindowBorder(Display *d, Window w,", "\t\t\t\tunsigned long ul);", "#endif", "#ifndef XSetWindowBorderPixmap_TCL_DECLARED", "#define XSetWindowBorderPixmap_TCL_DECLARED", "/* 69 */", "EXTERN void\t\tXSetWindowBorderPixmap(Display *d, Window w,", "\t\t\t\tPixmap p);", "#endif", "#ifndef XSetWindowBorderWidth_TCL_DECLARED", "#define XSetWindowBorderWidth_TCL_DECLARED", "/* 70 */", "EXTERN void\t\tXSetWindowBorderWidth(Display *d, Window w,", "\t\t\t\tunsigned int ui);", "#endif", "#ifndef XSetWindowColormap_TCL_DECLARED", "#define XSetWindowColormap_TCL_DECLARED", "/* 71 */", "EXTERN void\t\tXSetWindowColormap(Display *d, Window w, Colormap c);", "#endif", "#ifndef XTranslateCoordinates_TCL_DECLARED", "#define XTranslateCoordinates_TCL_DECLARED", "/* 72 */", "EXTERN Bool\t\tXTranslateCoordinates(Display *d, Window w1,", "\t\t\t\tWindow w2, int i1, int i2, int *i3, int *i4,", "\t\t\t\tWindow *w3);", "#endif", "#ifndef XUngrabKeyboard_TCL_DECLARED", "#define XUngrabKeyboard_TCL_DECLARED", "/* 73 */", "EXTERN void\t\tXUngrabKeyboard(Display *d, Time t);", "#endif", "#ifndef XUngrabPointer_TCL_DECLARED", "#define XUngrabPointer_TCL_DECLARED", "/* 74 */", "EXTERN void\t\tXUngrabPointer(Display *d, Time t);", "#endif", "#ifndef XUnmapWindow_TCL_DECLARED", "#define XUnmapWindow_TCL_DECLARED", "/* 75 */", "EXTERN void\t\tXUnmapWindow(Display *d, Window w);", "#endif", "#ifndef XWindowEvent_TCL_DECLARED", "#define XWindowEvent_TCL_DECLARED", "/* 76 */", "EXTERN void\t\tXWindowEvent(Display *d, Window w, long l, XEvent *x);", "#endif", "#ifndef XDestroyIC_TCL_DECLARED", "#define XDestroyIC_TCL_DECLARED", "/* 77 */", "EXTERN void\t\tXDestroyIC(XIC x);", "#endif", "#ifndef XFilterEvent_TCL_DECLARED", "#define XFilterEvent_TCL_DECLARED", "/* 78 */", "EXTERN Bool\t\tXFilterEvent(XEvent *x, Window w);", "#endif", "#ifndef XmbLookupString_TCL_DECLARED", "#define XmbLookupString_TCL_DECLARED", "/* 79 */", "EXTERN int\t\tXmbLookupString(XIC xi, XKeyPressedEvent *xk,", "\t\t\t\tchar *c, int i, KeySym *k, Status *s);", "#endif", "#ifndef TkPutImage_TCL_DECLARED", "#define TkPutImage_TCL_DECLARED", "/* 80 */", "EXTERN void\t\tTkPutImage(unsigned long *colors, int ncolors,", "\t\t\t\tDisplay *display, Drawable d, GC gc,", "\t\t\t\tXImage *image, int src_x, int src_y,", "\t\t\t\tint dest_x, int dest_y, unsigned int width,", "\t\t\t\tunsigned int height);", "#endif", "/* Slot 81 is reserved */", "#ifndef XParseColor_TCL_DECLARED", "#define XParseColor_TCL_DECLARED", "/* 82 */", "EXTERN Status\t\tXParseColor(Display *display, Colormap map,", "\t\t\t\t_Xconst char *spec, XColor *colorPtr);", "#endif", "#ifndef XCreateGC_TCL_DECLARED", "#define XCreateGC_TCL_DECLARED", "/* 83 */", "EXTERN GC\t\tXCreateGC(Display *display, Drawable d,", "\t\t\t\tunsigned long valuemask, XGCValues *values);", "#endif", "#ifndef XFreeGC_TCL_DECLARED", "#define XFreeGC_TCL_DECLARED", "/* 84 */", "EXTERN void\t\tXFreeGC(Display *display, GC gc);", "#endif", "#ifndef XInternAtom_TCL_DECLARED", "#define XInternAtom_TCL_DECLARED", "/* 85 */", "EXTERN Atom\t\tXInternAtom(Display *display,", "\t\t\t\t_Xconst char *atom_name, Bool only_if_exists);", "#endif", "#ifndef XSetBackground_TCL_DECLARED", "#define XSetBackground_TCL_DECLARED", "/* 86 */", "EXTERN void\t\tXSetBackground(Display *display, GC gc,", "\t\t\t\tunsigned long foreground);", "#endif", "#ifndef XSetForeground_TCL_DECLARED", "#define XSetForeground_TCL_DECLARED", "/* 87 */", "EXTERN void\t\tXSetForeground(Display *display, GC gc,", "\t\t\t\tunsigned long foreground);", "#endif", "#ifndef XSetClipMask_TCL_DECLARED", "#define XSetClipMask_TCL_DECLARED", "/* 88 */", "EXTERN void\t\tXSetClipMask(Display *display, GC gc, Pixmap pixmap);", "#endif", "#ifndef XSetClipOrigin_TCL_DECLARED", "#define XSetClipOrigin_TCL_DECLARED", "/* 89 */", "EXTERN void\t\tXSetClipOrigin(Display *display, GC gc,", "\t\t\t\tint clip_x_origin, int clip_y_origin);", "#endif", "#ifndef XSetTSOrigin_TCL_DECLARED", "#define XSetTSOrigin_TCL_DECLARED", "/* 90 */", "EXTERN void\t\tXSetTSOrigin(Display *display, GC gc,", "\t\t\t\tint ts_x_origin, int ts_y_origin);", "#endif", "#ifndef XChangeGC_TCL_DECLARED", "#define XChangeGC_TCL_DECLARED", "/* 91 */", "EXTERN void\t\tXChangeGC(Display *d, GC gc, unsigned long mask,", "\t\t\t\tXGCValues *values);", "#endif", "#ifndef XSetFont_TCL_DECLARED", "#define XSetFont_TCL_DECLARED", "/* 92 */", "EXTERN void\t\tXSetFont(Display *display, GC gc, Font font);", "#endif", "#ifndef XSetArcMode_TCL_DECLARED", "#define XSetArcMode_TCL_DECLARED", "/* 93 */", "EXTERN void\t\tXSetArcMode(Display *display, GC gc, int arc_mode);", "#endif", "#ifndef XSetStipple_TCL_DECLARED", "#define XSetStipple_TCL_DECLARED", "/* 94 */", "EXTERN void\t\tXSetStipple(Display *display, GC gc, Pixmap stipple);", "#endif", "#ifndef XSetFillRule_TCL_DECLARED", "#define XSetFillRule_TCL_DECLARED", "/* 95 */", "EXTERN void\t\tXSetFillRule(Display *display, GC gc, int fill_rule);", "#endif", "#ifndef XSetFillStyle_TCL_DECLARED", "#define XSetFillStyle_TCL_DECLARED", "/* 96 */", "EXTERN void\t\tXSetFillStyle(Display *display, GC gc,", "\t\t\t\tint fill_style);", "#endif", "#ifndef XSetFunction_TCL_DECLARED", "#define XSetFunction_TCL_DECLARED", "/* 97 */", "EXTERN void\t\tXSetFunction(Display *display, GC gc, int function);", "#endif", "#ifndef XSetLineAttributes_TCL_DECLARED", "#define XSetLineAttributes_TCL_DECLARED", "/* 98 */", "EXTERN void\t\tXSetLineAttributes(Display *display, GC gc,", "\t\t\t\tunsigned int line_width, int line_style,", "\t\t\t\tint cap_style, int join_style);", "#endif", "#ifndef _XInitImageFuncPtrs_TCL_DECLARED", "#define _XInitImageFuncPtrs_TCL_DECLARED", "/* 99 */", "EXTERN int\t\t_XInitImageFuncPtrs(XImage *image);", "#endif", "#ifndef XCreateIC_TCL_DECLARED", "#define XCreateIC_TCL_DECLARED", "/* 100 */", "EXTERN XIC\t\tXCreateIC(void);", "#endif", "#ifndef XGetVisualInfo_TCL_DECLARED", "#define XGetVisualInfo_TCL_DECLARED", "/* 101 */", "EXTERN XVisualInfo *\tXGetVisualInfo(Display *display, long vinfo_mask,", "\t\t\t\tXVisualInfo *vinfo_template,", "\t\t\t\tint *nitems_return);", "#endif", "#ifndef XSetWMClientMachine_TCL_DECLARED", "#define XSetWMClientMachine_TCL_DECLARED", "/* 102 */", "EXTERN void\t\tXSetWMClientMachine(Display *display, Window w,", "\t\t\t\tXTextProperty *text_prop);", "#endif", "#ifndef XStringListToTextProperty_TCL_DECLARED", "#define XStringListToTextProperty_TCL_DECLARED", "/* 103 */", "EXTERN Status\t\tXStringListToTextProperty(char **list, int count,", "\t\t\t\tXTextProperty *text_prop_return);", "#endif", "#ifndef XDrawLine_TCL_DECLARED", "#define XDrawLine_TCL_DECLARED", "/* 104 */", "EXTERN void\t\tXDrawLine(Display *d, Drawable dr, GC g, int x1,", "\t\t\t\tint y1, int x2, int y2);", "#endif", "#ifndef XWarpPointer_TCL_DECLARED", "#define XWarpPointer_TCL_DECLARED", "/* 105 */", "EXTERN void\t\tXWarpPointer(Display *d, Window s, Window dw, int sx,", "\t\t\t\tint sy, unsigned int sw, unsigned int sh,", "\t\t\t\tint dx, int dy);", "#endif", "#ifndef XFillRectangle_TCL_DECLARED", "#define XFillRectangle_TCL_DECLARED", "/* 106 */", "EXTERN void\t\tXFillRectangle(Display *display, Drawable d, GC gc,", "\t\t\t\tint x, int y, unsigned int width,", "\t\t\t\tunsigned int height);", "#endif", "#endif /* WIN */", "#ifdef MAC_OSX_TK /* AQUA */", "#ifndef XSetDashes_TCL_DECLARED", "#define XSetDashes_TCL_DECLARED", "/* 0 */", "EXTERN void\t\tXSetDashes(Display *display, GC gc, int dash_offset,", "\t\t\t\t_Xconst char *dash_list, int n);", "#endif", "#ifndef XGetModifierMapping_TCL_DECLARED", "#define XGetModifierMapping_TCL_DECLARED", "/* 1 */", "EXTERN XModifierKeymap * XGetModifierMapping(Display *d);", "#endif", "#ifndef XCreateImage_TCL_DECLARED", "#define XCreateImage_TCL_DECLARED", "/* 2 */", "EXTERN XImage *\t\tXCreateImage(Display *d, Visual *v, unsigned int ui1,", "\t\t\t\tint i1, int i2, char *cp, unsigned int ui2,", "\t\t\t\tunsigned int ui3, int i3, int i4);", "#endif", "#ifndef XGetImage_TCL_DECLARED", "#define XGetImage_TCL_DECLARED", "/* 3 */", "EXTERN XImage *\t\tXGetImage(Display *d, Drawable dr, int i1, int i2,", "\t\t\t\tunsigned int ui1, unsigned int ui2,", "\t\t\t\tunsigned long ul, int i3);", "#endif", "#ifndef XGetAtomName_TCL_DECLARED", "#define XGetAtomName_TCL_DECLARED", "/* 4 */", "EXTERN char *\t\tXGetAtomName(Display *d, Atom a);", "#endif", "#ifndef XKeysymToString_TCL_DECLARED", "#define XKeysymToString_TCL_DECLARED", "/* 5 */", "EXTERN char *\t\tXKeysymToString(KeySym k);", "#endif", "#ifndef XCreateColormap_TCL_DECLARED", "#define XCreateColormap_TCL_DECLARED", "/* 6 */", "EXTERN Colormap\t\tXCreateColormap(Display *d, Window w, Visual *v,", "\t\t\t\tint i);", "#endif", "#ifndef XGContextFromGC_TCL_DECLARED", "#define XGContextFromGC_TCL_DECLARED", "/* 7 */", "EXTERN GContext\t\tXGContextFromGC(GC g);", "#endif", "#ifndef XKeycodeToKeysym_TCL_DECLARED", "#define XKeycodeToKeysym_TCL_DECLARED", "/* 8 */", "EXTERN KeySym\t\tXKeycodeToKeysym(Display *d, KeyCode k, int i);", "#endif", "#ifndef XStringToKeysym_TCL_DECLARED", "#define XStringToKeysym_TCL_DECLARED", "/* 9 */", "EXTERN KeySym\t\tXStringToKeysym(_Xconst char *c);", "#endif", "#ifndef XRootWindow_TCL_DECLARED", "#define XRootWindow_TCL_DECLARED", "/* 10 */", "EXTERN Window\t\tXRootWindow(Display *d, int i);", "#endif", "#ifndef XSetErrorHandler_TCL_DECLARED", "#define XSetErrorHandler_TCL_DECLARED", "/* 11 */", "EXTERN XErrorHandler\tXSetErrorHandler(XErrorHandler x);", "#endif", "#ifndef XAllocColor_TCL_DECLARED", "#define XAllocColor_TCL_DECLARED", "/* 12 */", "EXTERN Status\t\tXAllocColor(Display *d, Colormap c, XColor *xp);", "#endif", "#ifndef XBell_TCL_DECLARED", "#define XBell_TCL_DECLARED", "/* 13 */", "EXTERN void\t\tXBell(Display *d, int i);", "#endif", "#ifndef XChangeProperty_TCL_DECLARED", "#define XChangeProperty_TCL_DECLARED", "/* 14 */", "EXTERN void\t\tXChangeProperty(Display *d, Window w, Atom a1,", "\t\t\t\tAtom a2, int i1, int i2,", "\t\t\t\t_Xconst unsigned char *c, int i3);", "#endif", "#ifndef XChangeWindowAttributes_TCL_DECLARED", "#define XChangeWindowAttributes_TCL_DECLARED", "/* 15 */", "EXTERN void\t\tXChangeWindowAttributes(Display *d, Window w,", "\t\t\t\tunsigned long ul, XSetWindowAttributes *x);", "#endif", "#ifndef XConfigureWindow_TCL_DECLARED", "#define XConfigureWindow_TCL_DECLARED", "/* 16 */", "EXTERN void\t\tXConfigureWindow(Display *d, Window w,", "\t\t\t\tunsigned int i, XWindowChanges *x);", "#endif", "#ifndef XCopyArea_TCL_DECLARED", "#define XCopyArea_TCL_DECLARED", "/* 17 */", "EXTERN void\t\tXCopyArea(Display *d, Drawable dr1, Drawable dr2,", "\t\t\t\tGC g, int i1, int i2, unsigned int ui1,", "\t\t\t\tunsigned int ui2, int i3, int i4);", "#endif", "#ifndef XCopyPlane_TCL_DECLARED", "#define XCopyPlane_TCL_DECLARED", "/* 18 */", "EXTERN void\t\tXCopyPlane(Display *d, Drawable dr1, Drawable dr2,", "\t\t\t\tGC g, int i1, int i2, unsigned int ui1,", "\t\t\t\tunsigned int ui2, int i3, int i4,", "\t\t\t\tunsigned long ul);", "#endif", "#ifndef XCreateBitmapFromData_TCL_DECLARED", "#define XCreateBitmapFromData_TCL_DECLARED", "/* 19 */", "EXTERN Pixmap\t\tXCreateBitmapFromData(Display *display, Drawable d,", "\t\t\t\t_Xconst char *data, unsigned int width,", "\t\t\t\tunsigned int height);", "#endif", "#ifndef XDefineCursor_TCL_DECLARED", "#define XDefineCursor_TCL_DECLARED", "/* 20 */", "EXTERN void\t\tXDefineCursor(Display *d, Window w, Cursor c);", "#endif", "#ifndef XDestroyWindow_TCL_DECLARED", "#define XDestroyWindow_TCL_DECLARED", "/* 21 */", "EXTERN void\t\tXDestroyWindow(Display *d, Window w);", "#endif", "#ifndef XDrawArc_TCL_DECLARED", "#define XDrawArc_TCL_DECLARED", "/* 22 */", "EXTERN void\t\tXDrawArc(Display *d, Drawable dr, GC g, int i1,", "\t\t\t\tint i2, unsigned int ui1, unsigned int ui2,", "\t\t\t\tint i3, int i4);", "#endif", "#ifndef XDrawLines_TCL_DECLARED", "#define XDrawLines_TCL_DECLARED", "/* 23 */", "EXTERN void\t\tXDrawLines(Display *d, Drawable dr, GC g, XPoint *x,", "\t\t\t\tint i1, int i2);", "#endif", "#ifndef XDrawRectangle_TCL_DECLARED", "#define XDrawRectangle_TCL_DECLARED", "/* 24 */", "EXTERN void\t\tXDrawRectangle(Display *d, Drawable dr, GC g, int i1,", "\t\t\t\tint i2, unsigned int ui1, unsigned int ui2);", "#endif", "#ifndef XFillArc_TCL_DECLARED", "#define XFillArc_TCL_DECLARED", "/* 25 */", "EXTERN void\t\tXFillArc(Display *d, Drawable dr, GC g, int i1,", "\t\t\t\tint i2, unsigned int ui1, unsigned int ui2,", "\t\t\t\tint i3, int i4);", "#endif", "#ifndef XFillPolygon_TCL_DECLARED", "#define XFillPolygon_TCL_DECLARED", "/* 26 */", "EXTERN void\t\tXFillPolygon(Display *d, Drawable dr, GC g,", "\t\t\t\tXPoint *x, int i1, int i2, int i3);", "#endif", "#ifndef XFillRectangles_TCL_DECLARED", "#define XFillRectangles_TCL_DECLARED", "/* 27 */", "EXTERN void\t\tXFillRectangles(Display *d, Drawable dr, GC g,", "\t\t\t\tXRectangle *x, int i);", "#endif", "#ifndef XFreeColormap_TCL_DECLARED", "#define XFreeColormap_TCL_DECLARED", "/* 28 */", "EXTERN void\t\tXFreeColormap(Display *d, Colormap c);", "#endif", "#ifndef XFreeColors_TCL_DECLARED", "#define XFreeColors_TCL_DECLARED", "/* 29 */", "EXTERN void\t\tXFreeColors(Display *d, Colormap c,", "\t\t\t\tunsigned long *ulp, int i, unsigned long ul);", "#endif", "#ifndef XFreeModifiermap_TCL_DECLARED", "#define XFreeModifiermap_TCL_DECLARED", "/* 30 */", "EXTERN void\t\tXFreeModifiermap(XModifierKeymap *x);", "#endif", "#ifndef XGetGeometry_TCL_DECLARED", "#define XGetGeometry_TCL_DECLARED", "/* 31 */", "EXTERN Status\t\tXGetGeometry(Display *d, Drawable dr, Window *w,", "\t\t\t\tint *i1, int *i2, unsigned int *ui1,", "\t\t\t\tunsigned int *ui2, unsigned int *ui3,", "\t\t\t\tunsigned int *ui4);", "#endif", "#ifndef XGetWindowProperty_TCL_DECLARED", "#define XGetWindowProperty_TCL_DECLARED", "/* 32 */", "EXTERN int\t\tXGetWindowProperty(Display *d, Window w, Atom a1,", "\t\t\t\tlong l1, long l2, Bool b, Atom a2, Atom *ap,", "\t\t\t\tint *ip, unsigned long *ulp1,", "\t\t\t\tunsigned long *ulp2, unsigned char **cpp);", "#endif", "#ifndef XGrabKeyboard_TCL_DECLARED", "#define XGrabKeyboard_TCL_DECLARED", "/* 33 */", "EXTERN int\t\tXGrabKeyboard(Display *d, Window w, Bool b, int i1,", "\t\t\t\tint i2, Time t);", "#endif", "#ifndef XGrabPointer_TCL_DECLARED", "#define XGrabPointer_TCL_DECLARED", "/* 34 */", "EXTERN int\t\tXGrabPointer(Display *d, Window w1, Bool b,", "\t\t\t\tunsigned int ui, int i1, int i2, Window w2,", "\t\t\t\tCursor c, Time t);", "#endif", "#ifndef XKeysymToKeycode_TCL_DECLARED", "#define XKeysymToKeycode_TCL_DECLARED", "/* 35 */", "EXTERN KeyCode\t\tXKeysymToKeycode(Display *d, KeySym k);", "#endif", "#ifndef XMapWindow_TCL_DECLARED", "#define XMapWindow_TCL_DECLARED", "/* 36 */", "EXTERN void\t\tXMapWindow(Display *d, Window w);", "#endif", "#ifndef XMoveResizeWindow_TCL_DECLARED", "#define XMoveResizeWindow_TCL_DECLARED", "/* 37 */", "EXTERN void\t\tXMoveResizeWindow(Display *d, Window w, int i1,", "\t\t\t\tint i2, unsigned int ui1, unsigned int ui2);", "#endif", "#ifndef XMoveWindow_TCL_DECLARED", "#define XMoveWindow_TCL_DECLARED", "/* 38 */", "EXTERN void\t\tXMoveWindow(Display *d, Window w, int i1, int i2);", "#endif", "#ifndef XQueryPointer_TCL_DECLARED", "#define XQueryPointer_TCL_DECLARED", "/* 39 */", "EXTERN Bool\t\tXQueryPointer(Display *d, Window w1, Window *w2,", "\t\t\t\tWindow *w3, int *i1, int *i2, int *i3,", "\t\t\t\tint *i4, unsigned int *ui);", "#endif", "#ifndef XRaiseWindow_TCL_DECLARED", "#define XRaiseWindow_TCL_DECLARED", "/* 40 */", "EXTERN void\t\tXRaiseWindow(Display *d, Window w);", "#endif", "#ifndef XRefreshKeyboardMapping_TCL_DECLARED", "#define XRefreshKeyboardMapping_TCL_DECLARED", "/* 41 */", "EXTERN void\t\tXRefreshKeyboardMapping(XMappingEvent *x);", "#endif", "#ifndef XResizeWindow_TCL_DECLARED", "#define XResizeWindow_TCL_DECLARED", "/* 42 */", "EXTERN void\t\tXResizeWindow(Display *d, Window w, unsigned int ui1,", "\t\t\t\tunsigned int ui2);", "#endif", "#ifndef XSelectInput_TCL_DECLARED", "#define XSelectInput_TCL_DECLARED", "/* 43 */", "EXTERN void\t\tXSelectInput(Display *d, Window w, long l);", "#endif", "#ifndef XSendEvent_TCL_DECLARED", "#define XSendEvent_TCL_DECLARED", "/* 44 */", "EXTERN Status\t\tXSendEvent(Display *d, Window w, Bool b, long l,", "\t\t\t\tXEvent *x);", "#endif", "#ifndef XSetIconName_TCL_DECLARED", "#define XSetIconName_TCL_DECLARED", "/* 45 */", "EXTERN void\t\tXSetIconName(Display *d, Window w, _Xconst char *c);", "#endif", "#ifndef XSetInputFocus_TCL_DECLARED", "#define XSetInputFocus_TCL_DECLARED", "/* 46 */", "EXTERN void\t\tXSetInputFocus(Display *d, Window w, int i, Time t);", "#endif", "#ifndef XSetSelectionOwner_TCL_DECLARED", "#define XSetSelectionOwner_TCL_DECLARED", "/* 47 */", "EXTERN void\t\tXSetSelectionOwner(Display *d, Atom a, Window w,", "\t\t\t\tTime t);", "#endif", "#ifndef XSetWindowBackground_TCL_DECLARED", "#define XSetWindowBackground_TCL_DECLARED", "/* 48 */", "EXTERN void\t\tXSetWindowBackground(Display *d, Window w,", "\t\t\t\tunsigned long ul);", "#endif", "#ifndef XSetWindowBackgroundPixmap_TCL_DECLARED", "#define XSetWindowBackgroundPixmap_TCL_DECLARED", "/* 49 */", "EXTERN void\t\tXSetWindowBackgroundPixmap(Display *d, Window w,", "\t\t\t\tPixmap p);", "#endif", "#ifndef XSetWindowBorder_TCL_DECLARED", "#define XSetWindowBorder_TCL_DECLARED", "/* 50 */", "EXTERN void\t\tXSetWindowBorder(Display *d, Window w,", "\t\t\t\tunsigned long ul);", "#endif", "#ifndef XSetWindowBorderPixmap_TCL_DECLARED", "#define XSetWindowBorderPixmap_TCL_DECLARED", "/* 51 */", "EXTERN void\t\tXSetWindowBorderPixmap(Display *d, Window w,", "\t\t\t\tPixmap p);", "#endif", "#ifndef XSetWindowBorderWidth_TCL_DECLARED", "#define XSetWindowBorderWidth_TCL_DECLARED", "/* 52 */", "EXTERN void\t\tXSetWindowBorderWidth(Display *d, Window w,", "\t\t\t\tunsigned int ui);", "#endif", "#ifndef XSetWindowColormap_TCL_DECLARED", "#define XSetWindowColormap_TCL_DECLARED", "/* 53 */", "EXTERN void\t\tXSetWindowColormap(Display *d, Window w, Colormap c);", "#endif", "#ifndef XUngrabKeyboard_TCL_DECLARED", "#define XUngrabKeyboard_TCL_DECLARED", "/* 54 */", "EXTERN void\t\tXUngrabKeyboard(Display *d, Time t);", "#endif", "#ifndef XUngrabPointer_TCL_DECLARED", "#define XUngrabPointer_TCL_DECLARED", "/* 55 */", "EXTERN void\t\tXUngrabPointer(Display *d, Time t);", "#endif", "#ifndef XUnmapWindow_TCL_DECLARED", "#define XUnmapWindow_TCL_DECLARED", "/* 56 */", "EXTERN void\t\tXUnmapWindow(Display *d, Window w);", "#endif", "#ifndef TkPutImage_TCL_DECLARED", "#define TkPutImage_TCL_DECLARED", "/* 57 */", "EXTERN void\t\tTkPutImage(unsigned long *colors, int ncolors,", "\t\t\t\tDisplay *display, Drawable d, GC gc,", "\t\t\t\tXImage *image, int src_x, int src_y,", "\t\t\t\tint dest_x, int dest_y, unsigned int width,", "\t\t\t\tunsigned int height);", "#endif", "#ifndef XParseColor_TCL_DECLARED", "#define XParseColor_TCL_DECLARED", "/* 58 */", "EXTERN Status\t\tXParseColor(Display *display, Colormap map,", "\t\t\t\t_Xconst char *spec, XColor *colorPtr);", "#endif", "#ifndef XCreateGC_TCL_DECLARED", "#define XCreateGC_TCL_DECLARED", "/* 59 */", "EXTERN GC\t\tXCreateGC(Display *display, Drawable d,", "\t\t\t\tunsigned long valuemask, XGCValues *values);", "#endif", "#ifndef XFreeGC_TCL_DECLARED", "#define XFreeGC_TCL_DECLARED", "/* 60 */", "EXTERN void\t\tXFreeGC(Display *display, GC gc);", "#endif", "#ifndef XInternAtom_TCL_DECLARED", "#define XInternAtom_TCL_DECLARED", "/* 61 */", "EXTERN Atom\t\tXInternAtom(Display *display,", "\t\t\t\t_Xconst char *atom_name, Bool only_if_exists);", "#endif", "#ifndef XSetBackground_TCL_DECLARED", "#define XSetBackground_TCL_DECLARED", "/* 62 */", "EXTERN void\t\tXSetBackground(Display *display, GC gc,", "\t\t\t\tunsigned long foreground);", "#endif", "#ifndef XSetForeground_TCL_DECLARED", "#define XSetForeground_TCL_DECLARED", "/* 63 */", "EXTERN void\t\tXSetForeground(Display *display, GC gc,", "\t\t\t\tunsigned long foreground);", "#endif", "#ifndef XSetClipMask_TCL_DECLARED", "#define XSetClipMask_TCL_DECLARED", "/* 64 */", "EXTERN void\t\tXSetClipMask(Display *display, GC gc, Pixmap pixmap);", "#endif", "#ifndef XSetClipOrigin_TCL_DECLARED", "#define XSetClipOrigin_TCL_DECLARED", "/* 65 */", "EXTERN void\t\tXSetClipOrigin(Display *display, GC gc,", "\t\t\t\tint clip_x_origin, int clip_y_origin);", "#endif", "#ifndef XSetTSOrigin_TCL_DECLARED", "#define XSetTSOrigin_TCL_DECLARED", "/* 66 */", "EXTERN void\t\tXSetTSOrigin(Display *display, GC gc,", "\t\t\t\tint ts_x_origin, int ts_y_origin);", "#endif", "#ifndef XChangeGC_TCL_DECLARED", "#define XChangeGC_TCL_DECLARED", "/* 67 */", "EXTERN void\t\tXChangeGC(Display *d, GC gc, unsigned long mask,", "\t\t\t\tXGCValues *values);", "#endif", "#ifndef XSetFont_TCL_DECLARED", "#define XSetFont_TCL_DECLARED", "/* 68 */", "EXTERN void\t\tXSetFont(Display *display, GC gc, Font font);", "#endif", "#ifndef XSetArcMode_TCL_DECLARED", "#define XSetArcMode_TCL_DECLARED", "/* 69 */", "EXTERN void\t\tXSetArcMode(Display *display, GC gc, int arc_mode);", "#endif", "#ifndef XSetStipple_TCL_DECLARED", "#define XSetStipple_TCL_DECLARED", "/* 70 */", "EXTERN void\t\tXSetStipple(Display *display, GC gc, Pixmap stipple);", "#endif", "#ifndef XSetFillRule_TCL_DECLARED", "#define XSetFillRule_TCL_DECLARED", "/* 71 */", "EXTERN void\t\tXSetFillRule(Display *display, GC gc, int fill_rule);", "#endif", "#ifndef XSetFillStyle_TCL_DECLARED", "#define XSetFillStyle_TCL_DECLARED", "/* 72 */", "EXTERN void\t\tXSetFillStyle(Display *display, GC gc,", "\t\t\t\tint fill_style);", "#endif", "#ifndef XSetFunction_TCL_DECLARED", "#define XSetFunction_TCL_DECLARED", "/* 73 */", "EXTERN void\t\tXSetFunction(Display *display, GC gc, int function);", "#endif", "#ifndef XSetLineAttributes_TCL_DECLARED", "#define XSetLineAttributes_TCL_DECLARED", "/* 74 */", "EXTERN void\t\tXSetLineAttributes(Display *display, GC gc,", "\t\t\t\tunsigned int line_width, int line_style,", "\t\t\t\tint cap_style, int join_style);", "#endif", "#ifndef _XInitImageFuncPtrs_TCL_DECLARED", "#define _XInitImageFuncPtrs_TCL_DECLARED", "/* 75 */", "EXTERN int\t\t_XInitImageFuncPtrs(XImage *image);", "#endif", "#ifndef XCreateIC_TCL_DECLARED", "#define XCreateIC_TCL_DECLARED", "/* 76 */", "EXTERN XIC\t\tXCreateIC(void);", "#endif", "#ifndef XGetVisualInfo_TCL_DECLARED", "#define XGetVisualInfo_TCL_DECLARED", "/* 77 */", "EXTERN XVisualInfo *\tXGetVisualInfo(Display *display, long vinfo_mask,", "\t\t\t\tXVisualInfo *vinfo_template,", "\t\t\t\tint *nitems_return);", "#endif", "#ifndef XSetWMClientMachine_TCL_DECLARED", "#define XSetWMClientMachine_TCL_DECLARED", "/* 78 */", "EXTERN void\t\tXSetWMClientMachine(Display *display, Window w,", "\t\t\t\tXTextProperty *text_prop);", "#endif", "#ifndef XStringListToTextProperty_TCL_DECLARED", "#define XStringListToTextProperty_TCL_DECLARED", "/* 79 */", "EXTERN Status\t\tXStringListToTextProperty(char **list, int count,", "\t\t\t\tXTextProperty *text_prop_return);", "#endif", "#ifndef XDrawSegments_TCL_DECLARED", "#define XDrawSegments_TCL_DECLARED", "/* 80 */", "EXTERN void\t\tXDrawSegments(Display *display, Drawable d, GC gc,", "\t\t\t\tXSegment *segments, int nsegments);", "#endif", "#ifndef XForceScreenSaver_TCL_DECLARED", "#define XForceScreenSaver_TCL_DECLARED", "/* 81 */", "EXTERN void\t\tXForceScreenSaver(Display *display, int mode);", "#endif", "#ifndef XDrawLine_TCL_DECLARED", "#define XDrawLine_TCL_DECLARED", "/* 82 */", "EXTERN void\t\tXDrawLine(Display *d, Drawable dr, GC g, int x1,", "\t\t\t\tint y1, int x2, int y2);", "#endif", "#ifndef XFillRectangle_TCL_DECLARED", "#define XFillRectangle_TCL_DECLARED", "/* 83 */", "EXTERN void\t\tXFillRectangle(Display *display, Drawable d, GC gc,", "\t\t\t\tint x, int y, unsigned int width,", "\t\t\t\tunsigned int height);", "#endif", "#ifndef XClearWindow_TCL_DECLARED", "#define XClearWindow_TCL_DECLARED", "/* 84 */", "EXTERN void\t\tXClearWindow(Display *d, Window w);", "#endif", "#ifndef XDrawPoint_TCL_DECLARED", "#define XDrawPoint_TCL_DECLARED", "/* 85 */", "EXTERN void\t\tXDrawPoint(Display *display, Drawable d, GC gc,", "\t\t\t\tint x, int y);", "#endif", "#ifndef XDrawPoints_TCL_DECLARED", "#define XDrawPoints_TCL_DECLARED", "/* 86 */", "EXTERN void\t\tXDrawPoints(Display *display, Drawable d, GC gc,", "\t\t\t\tXPoint *points, int npoints, int mode);", "#endif", "#ifndef XWarpPointer_TCL_DECLARED", "#define XWarpPointer_TCL_DECLARED", "/* 87 */", "EXTERN void\t\tXWarpPointer(Display *display, Window src_w,", "\t\t\t\tWindow dest_w, int src_x, int src_y,", "\t\t\t\tunsigned int src_width,", "\t\t\t\tunsigned int src_height, int dest_x,", "\t\t\t\tint dest_y);", "#endif", "#ifndef XQueryColor_TCL_DECLARED", "#define XQueryColor_TCL_DECLARED", "/* 88 */", "EXTERN void\t\tXQueryColor(Display *display, Colormap colormap,", "\t\t\t\tXColor *def_in_out);", "#endif", "#ifndef XQueryColors_TCL_DECLARED", "#define XQueryColors_TCL_DECLARED", "/* 89 */", "EXTERN void\t\tXQueryColors(Display *display, Colormap colormap,", "\t\t\t\tXColor *defs_in_out, int ncolors);", "#endif", "#ifndef XQueryTree_TCL_DECLARED", "#define XQueryTree_TCL_DECLARED", "/* 90 */", "EXTERN Status\t\tXQueryTree(Display *d, Window w1, Window *w2,", "\t\t\t\tWindow *w3, Window **w4, unsigned int *ui);", "#endif", "#ifndef XSync_TCL_DECLARED", "#define XSync_TCL_DECLARED", "/* 91 */", "EXTERN int\t\tXSync(Display *display, Bool flag);", "#endif", "#endif /* AQUA */", "", "typedef struct TkIntXlibStubs {", "    int magic;", "    struct TkIntXlibStubHooks *hooks;", "", "#ifdef __WIN32__ /* WIN */", "    void (*xSetDashes) (Display *display, GC gc, int dash_offset, _Xconst char *dash_list, int n); /* 0 */", "    XModifierKeymap * (*xGetModifierMapping) (Display *d); /* 1 */", "    XImage * (*xCreateImage) (Display *d, Visual *v, unsigned int ui1, int i1, int i2, char *cp, unsigned int ui2, unsigned int ui3, int i3, int i4); /* 2 */", "    XImage * (*xGetImage) (Display *d, Drawable dr, int i1, int i2, unsigned int ui1, unsigned int ui2, unsigned long ul, int i3); /* 3 */", "    char * (*xGetAtomName) (Display *d, Atom a); /* 4 */", "    char * (*xKeysymToString) (KeySym k); /* 5 */", "    Colormap (*xCreateColormap) (Display *d, Window w, Visual *v, int i); /* 6 */", "    Cursor (*xCreatePixmapCursor) (Display *d, Pixmap p1, Pixmap p2, XColor *x1, XColor *x2, unsigned int ui1, unsigned int ui2); /* 7 */", "    Cursor (*xCreateGlyphCursor) (Display *d, Font f1, Font f2, unsigned int ui1, unsigned int ui2, XColor *x1, XColor *x2); /* 8 */", "    GContext (*xGContextFromGC) (GC g); /* 9 */", "    XHostAddress * (*xListHosts) (Display *d, int *i, Bool *b); /* 10 */", "    KeySym (*xKeycodeToKeysym) (Display *d, unsigned int k, int i); /* 11 */", "    KeySym (*xStringToKeysym) (_Xconst char *c); /* 12 */", "    Window (*xRootWindow) (Display *d, int i); /* 13 */", "    XErrorHandler (*xSetErrorHandler) (XErrorHandler x); /* 14 */", "    Status (*xIconifyWindow) (Display *d, Window w, int i); /* 15 */", "    Status (*xWithdrawWindow) (Display *d, Window w, int i); /* 16 */", "    Status (*xGetWMColormapWindows) (Display *d, Window w, Window **wpp, int *ip); /* 17 */", "    Status (*xAllocColor) (Display *d, Colormap c, XColor *xp); /* 18 */", "    void (*xBell) (Display *d, int i); /* 19 */", "    void (*xChangeProperty) (Display *d, Window w, Atom a1, Atom a2, int i1, int i2, _Xconst unsigned char *c, int i3); /* 20 */", "    void (*xChangeWindowAttributes) (Display *d, Window w, unsigned long ul, XSetWindowAttributes *x); /* 21 */", "    void (*xClearWindow) (Display *d, Window w); /* 22 */", "    void (*xConfigureWindow) (Display *d, Window w, unsigned int i, XWindowChanges *x); /* 23 */", "    void (*xCopyArea) (Display *d, Drawable dr1, Drawable dr2, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4); /* 24 */", "    void (*xCopyPlane) (Display *d, Drawable dr1, Drawable dr2, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4, unsigned long ul); /* 25 */", "    Pixmap (*xCreateBitmapFromData) (Display *display, Drawable d, _Xconst char *data, unsigned int width, unsigned int height); /* 26 */", "    void (*xDefineCursor) (Display *d, Window w, Cursor c); /* 27 */", "    void (*xDeleteProperty) (Display *d, Window w, Atom a); /* 28 */", "    void (*xDestroyWindow) (Display *d, Window w); /* 29 */", "    void (*xDrawArc) (Display *d, Drawable dr, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4); /* 30 */", "    void (*xDrawLines) (Display *d, Drawable dr, GC g, XPoint *x, int i1, int i2); /* 31 */", "    void (*xDrawRectangle) (Display *d, Drawable dr, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2); /* 32 */", "    void (*xFillArc) (Display *d, Drawable dr, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4); /* 33 */", "    void (*xFillPolygon) (Display *d, Drawable dr, GC g, XPoint *x, int i1, int i2, int i3); /* 34 */", "    void (*xFillRectangles) (Display *d, Drawable dr, GC g, XRectangle *x, int i); /* 35 */", "    void (*xForceScreenSaver) (Display *d, int i); /* 36 */", "    void (*xFreeColormap) (Display *d, Colormap c); /* 37 */", "    void (*xFreeColors) (Display *d, Colormap c, unsigned long *ulp, int i, unsigned long ul); /* 38 */", "    void (*xFreeCursor) (Display *d, Cursor c); /* 39 */", "    void (*xFreeModifiermap) (XModifierKeymap *x); /* 40 */", "    Status (*xGetGeometry) (Display *d, Drawable dr, Window *w, int *i1, int *i2, unsigned int *ui1, unsigned int *ui2, unsigned int *ui3, unsigned int *ui4); /* 41 */", "    void (*xGetInputFocus) (Display *d, Window *w, int *i); /* 42 */", "    int (*xGetWindowProperty) (Display *d, Window w, Atom a1, long l1, long l2, Bool b, Atom a2, Atom *ap, int *ip, unsigned long *ulp1, unsigned long *ulp2, unsigned char **cpp); /* 43 */", "    Status (*xGetWindowAttributes) (Display *d, Window w, XWindowAttributes *x); /* 44 */", "    int (*xGrabKeyboard) (Display *d, Window w, Bool b, int i1, int i2, Time t); /* 45 */", "    int (*xGrabPointer) (Display *d, Window w1, Bool b, unsigned int ui, int i1, int i2, Window w2, Cursor c, Time t); /* 46 */", "    KeyCode (*xKeysymToKeycode) (Display *d, KeySym k); /* 47 */", "    Status (*xLookupColor) (Display *d, Colormap c1, _Xconst char *c2, XColor *x1, XColor *x2); /* 48 */", "    void (*xMapWindow) (Display *d, Window w); /* 49 */", "    void (*xMoveResizeWindow) (Display *d, Window w, int i1, int i2, unsigned int ui1, unsigned int ui2); /* 50 */", "    void (*xMoveWindow) (Display *d, Window w, int i1, int i2); /* 51 */", "    void (*xNextEvent) (Display *d, XEvent *x); /* 52 */", "    void (*xPutBackEvent) (Display *d, XEvent *x); /* 53 */", "    void (*xQueryColors) (Display *d, Colormap c, XColor *x, int i); /* 54 */", "    Bool (*xQueryPointer) (Display *d, Window w1, Window *w2, Window *w3, int *i1, int *i2, int *i3, int *i4, unsigned int *ui); /* 55 */", "    Status (*xQueryTree) (Display *d, Window w1, Window *w2, Window *w3, Window **w4, unsigned int *ui); /* 56 */", "    void (*xRaiseWindow) (Display *d, Window w); /* 57 */", "    void (*xRefreshKeyboardMapping) (XMappingEvent *x); /* 58 */", "    void (*xResizeWindow) (Display *d, Window w, unsigned int ui1, unsigned int ui2); /* 59 */", "    void (*xSelectInput) (Display *d, Window w, long l); /* 60 */", "    Status (*xSendEvent) (Display *d, Window w, Bool b, long l, XEvent *x); /* 61 */", "    void (*xSetCommand) (Display *d, Window w, CONST char **c, int i); /* 62 */", "    void (*xSetIconName) (Display *d, Window w, _Xconst char *c); /* 63 */", "    void (*xSetInputFocus) (Display *d, Window w, int i, Time t); /* 64 */", "    void (*xSetSelectionOwner) (Display *d, Atom a, Window w, Time t); /* 65 */", "    void (*xSetWindowBackground) (Display *d, Window w, unsigned long ul); /* 66 */", "    void (*xSetWindowBackgroundPixmap) (Display *d, Window w, Pixmap p); /* 67 */", "    void (*xSetWindowBorder) (Display *d, Window w, unsigned long ul); /* 68 */", "    void (*xSetWindowBorderPixmap) (Display *d, Window w, Pixmap p); /* 69 */", "    void (*xSetWindowBorderWidth) (Display *d, Window w, unsigned int ui); /* 70 */", "    void (*xSetWindowColormap) (Display *d, Window w, Colormap c); /* 71 */", "    Bool (*xTranslateCoordinates) (Display *d, Window w1, Window w2, int i1, int i2, int *i3, int *i4, Window *w3); /* 72 */", "    void (*xUngrabKeyboard) (Display *d, Time t); /* 73 */", "    void (*xUngrabPointer) (Display *d, Time t); /* 74 */", "    void (*xUnmapWindow) (Display *d, Window w); /* 75 */", "    void (*xWindowEvent) (Display *d, Window w, long l, XEvent *x); /* 76 */", "    void (*xDestroyIC) (XIC x); /* 77 */", "    Bool (*xFilterEvent) (XEvent *x, Window w); /* 78 */", "    int (*xmbLookupString) (XIC xi, XKeyPressedEvent *xk, char *c, int i, KeySym *k, Status *s); /* 79 */", "    void (*tkPutImage) (unsigned long *colors, int ncolors, Display *display, Drawable d, GC gc, XImage *image, int src_x, int src_y, int dest_x, int dest_y, unsigned int width, unsigned int height); /* 80 */", "    void *reserved81;", "    Status (*xParseColor) (Display *display, Colormap map, _Xconst char *spec, XColor *colorPtr); /* 82 */", "    GC (*xCreateGC) (Display *display, Drawable d, unsigned long valuemask, XGCValues *values); /* 83 */", "    void (*xFreeGC) (Display *display, GC gc); /* 84 */", "    Atom (*xInternAtom) (Display *display, _Xconst char *atom_name, Bool only_if_exists); /* 85 */", "    void (*xSetBackground) (Display *display, GC gc, unsigned long foreground); /* 86 */", "    void (*xSetForeground) (Display *display, GC gc, unsigned long foreground); /* 87 */", "    void (*xSetClipMask) (Display *display, GC gc, Pixmap pixmap); /* 88 */", "    void (*xSetClipOrigin) (Display *display, GC gc, int clip_x_origin, int clip_y_origin); /* 89 */", "    void (*xSetTSOrigin) (Display *display, GC gc, int ts_x_origin, int ts_y_origin); /* 90 */", "    void (*xChangeGC) (Display *d, GC gc, unsigned long mask, XGCValues *values); /* 91 */", "    void (*xSetFont) (Display *display, GC gc, Font font); /* 92 */", "    void (*xSetArcMode) (Display *display, GC gc, int arc_mode); /* 93 */", "    void (*xSetStipple) (Display *display, GC gc, Pixmap stipple); /* 94 */", "    void (*xSetFillRule) (Display *display, GC gc, int fill_rule); /* 95 */", "    void (*xSetFillStyle) (Display *display, GC gc, int fill_style); /* 96 */", "    void (*xSetFunction) (Display *display, GC gc, int function); /* 97 */", "    void (*xSetLineAttributes) (Display *display, GC gc, unsigned int line_width, int line_style, int cap_style, int join_style); /* 98 */", "    int (*_XInitImageFuncPtrs) (XImage *image); /* 99 */", "    XIC (*xCreateIC) (void); /* 100 */", "    XVisualInfo * (*xGetVisualInfo) (Display *display, long vinfo_mask, XVisualInfo *vinfo_template, int *nitems_return); /* 101 */", "    void (*xSetWMClientMachine) (Display *display, Window w, XTextProperty *text_prop); /* 102 */", "    Status (*xStringListToTextProperty) (char **list, int count, XTextProperty *text_prop_return); /* 103 */", "    void (*xDrawLine) (Display *d, Drawable dr, GC g, int x1, int y1, int x2, int y2); /* 104 */", "    void (*xWarpPointer) (Display *d, Window s, Window dw, int sx, int sy, unsigned int sw, unsigned int sh, int dx, int dy); /* 105 */", "    void (*xFillRectangle) (Display *display, Drawable d, GC gc, int x, int y, unsigned int width, unsigned int height); /* 106 */", "#endif /* WIN */", "#ifdef MAC_OSX_TK /* AQUA */", "    void (*xSetDashes) (Display *display, GC gc, int dash_offset, _Xconst char *dash_list, int n); /* 0 */", "    XModifierKeymap * (*xGetModifierMapping) (Display *d); /* 1 */", "    XImage * (*xCreateImage) (Display *d, Visual *v, unsigned int ui1, int i1, int i2, char *cp, unsigned int ui2, unsigned int ui3, int i3, int i4); /* 2 */", "    XImage * (*xGetImage) (Display *d, Drawable dr, int i1, int i2, unsigned int ui1, unsigned int ui2, unsigned long ul, int i3); /* 3 */", "    char * (*xGetAtomName) (Display *d, Atom a); /* 4 */", "    char * (*xKeysymToString) (KeySym k); /* 5 */", "    Colormap (*xCreateColormap) (Display *d, Window w, Visual *v, int i); /* 6 */", "    GContext (*xGContextFromGC) (GC g); /* 7 */", "    KeySym (*xKeycodeToKeysym) (Display *d, KeyCode k, int i); /* 8 */", "    KeySym (*xStringToKeysym) (_Xconst char *c); /* 9 */", "    Window (*xRootWindow) (Display *d, int i); /* 10 */", "    XErrorHandler (*xSetErrorHandler) (XErrorHandler x); /* 11 */", "    Status (*xAllocColor) (Display *d, Colormap c, XColor *xp); /* 12 */", "    void (*xBell) (Display *d, int i); /* 13 */", "    void (*xChangeProperty) (Display *d, Window w, Atom a1, Atom a2, int i1, int i2, _Xconst unsigned char *c, int i3); /* 14 */", "    void (*xChangeWindowAttributes) (Display *d, Window w, unsigned long ul, XSetWindowAttributes *x); /* 15 */", "    void (*xConfigureWindow) (Display *d, Window w, unsigned int i, XWindowChanges *x); /* 16 */", "    void (*xCopyArea) (Display *d, Drawable dr1, Drawable dr2, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4); /* 17 */", "    void (*xCopyPlane) (Display *d, Drawable dr1, Drawable dr2, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4, unsigned long ul); /* 18 */", "    Pixmap (*xCreateBitmapFromData) (Display *display, Drawable d, _Xconst char *data, unsigned int width, unsigned int height); /* 19 */", "    void (*xDefineCursor) (Display *d, Window w, Cursor c); /* 20 */", "    void (*xDestroyWindow) (Display *d, Window w); /* 21 */", "    void (*xDrawArc) (Display *d, Drawable dr, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4); /* 22 */", "    void (*xDrawLines) (Display *d, Drawable dr, GC g, XPoint *x, int i1, int i2); /* 23 */", "    void (*xDrawRectangle) (Display *d, Drawable dr, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2); /* 24 */", "    void (*xFillArc) (Display *d, Drawable dr, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4); /* 25 */", "    void (*xFillPolygon) (Display *d, Drawable dr, GC g, XPoint *x, int i1, int i2, int i3); /* 26 */", "    void (*xFillRectangles) (Display *d, Drawable dr, GC g, XRectangle *x, int i); /* 27 */", "    void (*xFreeColormap) (Display *d, Colormap c); /* 28 */", "    void (*xFreeColors) (Display *d, Colormap c, unsigned long *ulp, int i, unsigned long ul); /* 29 */", "    void (*xFreeModifiermap) (XModifierKeymap *x); /* 30 */", "    Status (*xGetGeometry) (Display *d, Drawable dr, Window *w, int *i1, int *i2, unsigned int *ui1, unsigned int *ui2, unsigned int *ui3, unsigned int *ui4); /* 31 */", "    int (*xGetWindowProperty) (Display *d, Window w, Atom a1, long l1, long l2, Bool b, Atom a2, Atom *ap, int *ip, unsigned long *ulp1, unsigned long *ulp2, unsigned char **cpp); /* 32 */", "    int (*xGrabKeyboard) (Display *d, Window w, Bool b, int i1, int i2, Time t); /* 33 */", "    int (*xGrabPointer) (Display *d, Window w1, Bool b, unsigned int ui, int i1, int i2, Window w2, Cursor c, Time t); /* 34 */", "    KeyCode (*xKeysymToKeycode) (Display *d, KeySym k); /* 35 */", "    void (*xMapWindow) (Display *d, Window w); /* 36 */", "    void (*xMoveResizeWindow) (Display *d, Window w, int i1, int i2, unsigned int ui1, unsigned int ui2); /* 37 */", "    void (*xMoveWindow) (Display *d, Window w, int i1, int i2); /* 38 */", "    Bool (*xQueryPointer) (Display *d, Window w1, Window *w2, Window *w3, int *i1, int *i2, int *i3, int *i4, unsigned int *ui); /* 39 */", "    void (*xRaiseWindow) (Display *d, Window w); /* 40 */", "    void (*xRefreshKeyboardMapping) (XMappingEvent *x); /* 41 */", "    void (*xResizeWindow) (Display *d, Window w, unsigned int ui1, unsigned int ui2); /* 42 */", "    void (*xSelectInput) (Display *d, Window w, long l); /* 43 */", "    Status (*xSendEvent) (Display *d, Window w, Bool b, long l, XEvent *x); /* 44 */", "    void (*xSetIconName) (Display *d, Window w, _Xconst char *c); /* 45 */", "    void (*xSetInputFocus) (Display *d, Window w, int i, Time t); /* 46 */", "    void (*xSetSelectionOwner) (Display *d, Atom a, Window w, Time t); /* 47 */", "    void (*xSetWindowBackground) (Display *d, Window w, unsigned long ul); /* 48 */", "    void (*xSetWindowBackgroundPixmap) (Display *d, Window w, Pixmap p); /* 49 */", "    void (*xSetWindowBorder) (Display *d, Window w, unsigned long ul); /* 50 */", "    void (*xSetWindowBorderPixmap) (Display *d, Window w, Pixmap p); /* 51 */", "    void (*xSetWindowBorderWidth) (Display *d, Window w, unsigned int ui); /* 52 */", "    void (*xSetWindowColormap) (Display *d, Window w, Colormap c); /* 53 */", "    void (*xUngrabKeyboard) (Display *d, Time t); /* 54 */", "    void (*xUngrabPointer) (Display *d, Time t); /* 55 */", "    void (*xUnmapWindow) (Display *d, Window w); /* 56 */", "    void (*tkPutImage) (unsigned long *colors, int ncolors, Display *display, Drawable d, GC gc, XImage *image, int src_x, int src_y, int dest_x, int dest_y, unsigned int width, unsigned int height); /* 57 */", "    Status (*xParseColor) (Display *display, Colormap map, _Xconst char *spec, XColor *colorPtr); /* 58 */", "    GC (*xCreateGC) (Display *display, Drawable d, unsigned long valuemask, XGCValues *values); /* 59 */", "    void (*xFreeGC) (Display *display, GC gc); /* 60 */", "    Atom (*xInternAtom) (Display *display, _Xconst char *atom_name, Bool only_if_exists); /* 61 */", "    void (*xSetBackground) (Display *display, GC gc, unsigned long foreground); /* 62 */", "    void (*xSetForeground) (Display *display, GC gc, unsigned long foreground); /* 63 */", "    void (*xSetClipMask) (Display *display, GC gc, Pixmap pixmap); /* 64 */", "    void (*xSetClipOrigin) (Display *display, GC gc, int clip_x_origin, int clip_y_origin); /* 65 */", "    void (*xSetTSOrigin) (Display *display, GC gc, int ts_x_origin, int ts_y_origin); /* 66 */", "    void (*xChangeGC) (Display *d, GC gc, unsigned long mask, XGCValues *values); /* 67 */", "    void (*xSetFont) (Display *display, GC gc, Font font); /* 68 */", "    void (*xSetArcMode) (Display *display, GC gc, int arc_mode); /* 69 */", "    void (*xSetStipple) (Display *display, GC gc, Pixmap stipple); /* 70 */", "    void (*xSetFillRule) (Display *display, GC gc, int fill_rule); /* 71 */", "    void (*xSetFillStyle) (Display *display, GC gc, int fill_style); /* 72 */", "    void (*xSetFunction) (Display *display, GC gc, int function); /* 73 */", "    void (*xSetLineAttributes) (Display *display, GC gc, unsigned int line_width, int line_style, int cap_style, int join_style); /* 74 */", "    int (*_XInitImageFuncPtrs) (XImage *image); /* 75 */", "    XIC (*xCreateIC) (void); /* 76 */", "    XVisualInfo * (*xGetVisualInfo) (Display *display, long vinfo_mask, XVisualInfo *vinfo_template, int *nitems_return); /* 77 */", "    void (*xSetWMClientMachine) (Display *display, Window w, XTextProperty *text_prop); /* 78 */", "    Status (*xStringListToTextProperty) (char **list, int count, XTextProperty *text_prop_return); /* 79 */", "    void (*xDrawSegments) (Display *display, Drawable d, GC gc, XSegment *segments, int nsegments); /* 80 */", "    void (*xForceScreenSaver) (Display *display, int mode); /* 81 */", "    void (*xDrawLine) (Display *d, Drawable dr, GC g, int x1, int y1, int x2, int y2); /* 82 */", "    void (*xFillRectangle) (Display *display, Drawable d, GC gc, int x, int y, unsigned int width, unsigned int height); /* 83 */", "    void (*xClearWindow) (Display *d, Window w); /* 84 */", "    void (*xDrawPoint) (Display *display, Drawable d, GC gc, int x, int y); /* 85 */", "    void (*xDrawPoints) (Display *display, Drawable d, GC gc, XPoint *points, int npoints, int mode); /* 86 */", "    void (*xWarpPointer) (Display *display, Window src_w, Window dest_w, int src_x, int src_y, unsigned int src_width, unsigned int src_height, int dest_x, int dest_y); /* 87 */", "    void (*xQueryColor) (Display *display, Colormap colormap, XColor *def_in_out); /* 88 */", "    void (*xQueryColors) (Display *display, Colormap colormap, XColor *defs_in_out, int ncolors); /* 89 */", "    Status (*xQueryTree) (Display *d, Window w1, Window *w2, Window *w3, Window **w4, unsigned int *ui); /* 90 */", "    int (*xSync) (Display *display, Bool flag); /* 91 */", "#endif /* AQUA */", "} TkIntXlibStubs;", "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "extern TkIntXlibStubs *tkIntXlibStubsPtr;", "#ifdef __cplusplus", "}", "#endif", "", "#if defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS)", "", "/*", " * Inline function declarations:", " */", "", "#ifdef __WIN32__ /* WIN */", "#ifndef XSetDashes", "#define XSetDashes \\", "\t(tkIntXlibStubsPtr->xSetDashes) /* 0 */", "#endif", "#ifndef XGetModifierMapping", "#define XGetModifierMapping \\", "\t(tkIntXlibStubsPtr->xGetModifierMapping) /* 1 */", "#endif", "#ifndef XCreateImage", "#define XCreateImage \\", "\t(tkIntXlibStubsPtr->xCreateImage) /* 2 */", "#endif", "#ifndef XGetImage", "#define XGetImage \\", "\t(tkIntXlibStubsPtr->xGetImage) /* 3 */", "#endif", "#ifndef XGetAtomName", "#define XGetAtomName \\", "\t(tkIntXlibStubsPtr->xGetAtomName) /* 4 */", "#endif", "#ifndef XKeysymToString", "#define XKeysymToString \\", "\t(tkIntXlibStubsPtr->xKeysymToString) /* 5 */", "#endif", "#ifndef XCreateColormap", "#define XCreateColormap \\", "\t(tkIntXlibStubsPtr->xCreateColormap) /* 6 */", "#endif", "#ifndef XCreatePixmapCursor", "#define XCreatePixmapCursor \\", "\t(tkIntXlibStubsPtr->xCreatePixmapCursor) /* 7 */", "#endif", "#ifndef XCreateGlyphCursor", "#define XCreateGlyphCursor \\", "\t(tkIntXlibStubsPtr->xCreateGlyphCursor) /* 8 */", "#endif", "#ifndef XGContextFromGC", "#define XGContextFromGC \\", "\t(tkIntXlibStubsPtr->xGContextFromGC) /* 9 */", "#endif", "#ifndef XListHosts", "#define XListHosts \\", "\t(tkIntXlibStubsPtr->xListHosts) /* 10 */", "#endif", "#ifndef XKeycodeToKeysym", "#define XKeycodeToKeysym \\", "\t(tkIntXlibStubsPtr->xKeycodeToKeysym) /* 11 */", "#endif", "#ifndef XStringToKeysym", "#define XStringToKeysym \\", "\t(tkIntXlibStubsPtr->xStringToKeysym) /* 12 */", "#endif", "#ifndef XRootWindow", "#define XRootWindow \\", "\t(tkIntXlibStubsPtr->xRootWindow) /* 13 */", "#endif", "#ifndef XSetErrorHandler", "#define XSetErrorHandler \\", "\t(tkIntXlibStubsPtr->xSetErrorHandler) /* 14 */", "#endif", "#ifndef XIconifyWindow", "#define XIconifyWindow \\", "\t(tkIntXlibStubsPtr->xIconifyWindow) /* 15 */", "#endif", "#ifndef XWithdrawWindow", "#define XWithdrawWindow \\", "\t(tkIntXlibStubsPtr->xWithdrawWindow) /* 16 */", "#endif", "#ifndef XGetWMColormapWindows", "#define XGetWMColormapWindows \\", "\t(tkIntXlibStubsPtr->xGetWMColormapWindows) /* 17 */", "#endif", "#ifndef XAllocColor", "#define XAllocColor \\", "\t(tkIntXlibStubsPtr->xAllocColor) /* 18 */", "#endif", "#ifndef XBell", "#define XBell \\", "\t(tkIntXlibStubsPtr->xBell) /* 19 */", "#endif", "#ifndef XChangeProperty", "#define XChangeProperty \\", "\t(tkIntXlibStubsPtr->xChangeProperty) /* 20 */", "#endif", "#ifndef XChangeWindowAttributes", "#define XChangeWindowAttributes \\", "\t(tkIntXlibStubsPtr->xChangeWindowAttributes) /* 21 */", "#endif", "#ifndef XClearWindow", "#define XClearWindow \\", "\t(tkIntXlibStubsPtr->xClearWindow) /* 22 */", "#endif", "#ifndef XConfigureWindow", "#define XConfigureWindow \\", "\t(tkIntXlibStubsPtr->xConfigureWindow) /* 23 */", "#endif", "#ifndef XCopyArea", "#define XCopyArea \\", "\t(tkIntXlibStubsPtr->xCopyArea) /* 24 */", "#endif", "#ifndef XCopyPlane", "#define XCopyPlane \\", "\t(tkIntXlibStubsPtr->xCopyPlane) /* 25 */", "#endif", "#ifndef XCreateBitmapFromData", "#define XCreateBitmapFromData \\", "\t(tkIntXlibStubsPtr->xCreateBitmapFromData) /* 26 */", "#endif", "#ifndef XDefineCursor", "#define XDefineCursor \\", "\t(tkIntXlibStubsPtr->xDefineCursor) /* 27 */", "#endif", "#ifndef XDeleteProperty", "#define XDeleteProperty \\", "\t(tkIntXlibStubsPtr->xDeleteProperty) /* 28 */", "#endif", "#ifndef XDestroyWindow", "#define XDestroyWindow \\", "\t(tkIntXlibStubsPtr->xDestroyWindow) /* 29 */", "#endif", "#ifndef XDrawArc", "#define XDrawArc \\", "\t(tkIntXlibStubsPtr->xDrawArc) /* 30 */", "#endif", "#ifndef XDrawLines", "#define XDrawLines \\", "\t(tkIntXlibStubsPtr->xDrawLines) /* 31 */", "#endif", "#ifndef XDrawRectangle", "#define XDrawRectangle \\", "\t(tkIntXlibStubsPtr->xDrawRectangle) /* 32 */", "#endif", "#ifndef XFillArc", "#define XFillArc \\", "\t(tkIntXlibStubsPtr->xFillArc) /* 33 */", "#endif", "#ifndef XFillPolygon", "#define XFillPolygon \\", "\t(tkIntXlibStubsPtr->xFillPolygon) /* 34 */", "#endif", "#ifndef XFillRectangles", "#define XFillRectangles \\", "\t(tkIntXlibStubsPtr->xFillRectangles) /* 35 */", "#endif", "#ifndef XForceScreenSaver", "#define XForceScreenSaver \\", "\t(tkIntXlibStubsPtr->xForceScreenSaver) /* 36 */", "#endif", "#ifndef XFreeColormap", "#define XFreeColormap \\", "\t(tkIntXlibStubsPtr->xFreeColormap) /* 37 */", "#endif", "#ifndef XFreeColors", "#define XFreeColors \\", "\t(tkIntXlibStubsPtr->xFreeColors) /* 38 */", "#endif", "#ifndef XFreeCursor", "#define XFreeCursor \\", "\t(tkIntXlibStubsPtr->xFreeCursor) /* 39 */", "#endif", "#ifndef XFreeModifiermap", "#define XFreeModifiermap \\", "\t(tkIntXlibStubsPtr->xFreeModifiermap) /* 40 */", "#endif", "#ifndef XGetGeometry", "#define XGetGeometry \\", "\t(tkIntXlibStubsPtr->xGetGeometry) /* 41 */", "#endif", "#ifndef XGetInputFocus", "#define XGetInputFocus \\", "\t(tkIntXlibStubsPtr->xGetInputFocus) /* 42 */", "#endif", "#ifndef XGetWindowProperty", "#define XGetWindowProperty \\", "\t(tkIntXlibStubsPtr->xGetWindowProperty) /* 43 */", "#endif", "#ifndef XGetWindowAttributes", "#define XGetWindowAttributes \\", "\t(tkIntXlibStubsPtr->xGetWindowAttributes) /* 44 */", "#endif", "#ifndef XGrabKeyboard", "#define XGrabKeyboard \\", "\t(tkIntXlibStubsPtr->xGrabKeyboard) /* 45 */", "#endif", "#ifndef XGrabPointer", "#define XGrabPointer \\", "\t(tkIntXlibStubsPtr->xGrabPointer) /* 46 */", "#endif", "#ifndef XKeysymToKeycode", "#define XKeysymToKeycode \\", "\t(tkIntXlibStubsPtr->xKeysymToKeycode) /* 47 */", "#endif", "#ifndef XLookupColor", "#define XLookupColor \\", "\t(tkIntXlibStubsPtr->xLookupColor) /* 48 */", "#endif", "#ifndef XMapWindow", "#define XMapWindow \\", "\t(tkIntXlibStubsPtr->xMapWindow) /* 49 */", "#endif", "#ifndef XMoveResizeWindow", "#define XMoveResizeWindow \\", "\t(tkIntXlibStubsPtr->xMoveResizeWindow) /* 50 */", "#endif", "#ifndef XMoveWindow", "#define XMoveWindow \\", "\t(tkIntXlibStubsPtr->xMoveWindow) /* 51 */", "#endif", "#ifndef XNextEvent", "#define XNextEvent \\", "\t(tkIntXlibStubsPtr->xNextEvent) /* 52 */", "#endif", "#ifndef XPutBackEvent", "#define XPutBackEvent \\", "\t(tkIntXlibStubsPtr->xPutBackEvent) /* 53 */", "#endif", "#ifndef XQueryColors", "#define XQueryColors \\", "\t(tkIntXlibStubsPtr->xQueryColors) /* 54 */", "#endif", "#ifndef XQueryPointer", "#define XQueryPointer \\", "\t(tkIntXlibStubsPtr->xQueryPointer) /* 55 */", "#endif", "#ifndef XQueryTree", "#define XQueryTree \\", "\t(tkIntXlibStubsPtr->xQueryTree) /* 56 */", "#endif", "#ifndef XRaiseWindow", "#define XRaiseWindow \\", "\t(tkIntXlibStubsPtr->xRaiseWindow) /* 57 */", "#endif", "#ifndef XRefreshKeyboardMapping", "#define XRefreshKeyboardMapping \\", "\t(tkIntXlibStubsPtr->xRefreshKeyboardMapping) /* 58 */", "#endif", "#ifndef XResizeWindow", "#define XResizeWindow \\", "\t(tkIntXlibStubsPtr->xResizeWindow) /* 59 */", "#endif", "#ifndef XSelectInput", "#define XSelectInput \\", "\t(tkIntXlibStubsPtr->xSelectInput) /* 60 */", "#endif", "#ifndef XSendEvent", "#define XSendEvent \\", "\t(tkIntXlibStubsPtr->xSendEvent) /* 61 */", "#endif", "#ifndef XSetCommand", "#define XSetCommand \\", "\t(tkIntXlibStubsPtr->xSetCommand) /* 62 */", "#endif", "#ifndef XSetIconName", "#define XSetIconName \\", "\t(tkIntXlibStubsPtr->xSetIconName) /* 63 */", "#endif", "#ifndef XSetInputFocus", "#define XSetInputFocus \\", "\t(tkIntXlibStubsPtr->xSetInputFocus) /* 64 */", "#endif", "#ifndef XSetSelectionOwner", "#define XSetSelectionOwner \\", "\t(tkIntXlibStubsPtr->xSetSelectionOwner) /* 65 */", "#endif", "#ifndef XSetWindowBackground", "#define XSetWindowBackground \\", "\t(tkIntXlibStubsPtr->xSetWindowBackground) /* 66 */", "#endif", "#ifndef XSetWindowBackgroundPixmap", "#define XSetWindowBackgroundPixmap \\", "\t(tkIntXlibStubsPtr->xSetWindowBackgroundPixmap) /* 67 */", "#endif", "#ifndef XSetWindowBorder", "#define XSetWindowBorder \\", "\t(tkIntXlibStubsPtr->xSetWindowBorder) /* 68 */", "#endif", "#ifndef XSetWindowBorderPixmap", "#define XSetWindowBorderPixmap \\", "\t(tkIntXlibStubsPtr->xSetWindowBorderPixmap) /* 69 */", "#endif", "#ifndef XSetWindowBorderWidth", "#define XSetWindowBorderWidth \\", "\t(tkIntXlibStubsPtr->xSetWindowBorderWidth) /* 70 */", "#endif", "#ifndef XSetWindowColormap", "#define XSetWindowColormap \\", "\t(tkIntXlibStubsPtr->xSetWindowColormap) /* 71 */", "#endif", "#ifndef XTranslateCoordinates", "#define XTranslateCoordinates \\", "\t(tkIntXlibStubsPtr->xTranslateCoordinates) /* 72 */", "#endif", "#ifndef XUngrabKeyboard", "#define XUngrabKeyboard \\", "\t(tkIntXlibStubsPtr->xUngrabKeyboard) /* 73 */", "#endif", "#ifndef XUngrabPointer", "#define XUngrabPointer \\", "\t(tkIntXlibStubsPtr->xUngrabPointer) /* 74 */", "#endif", "#ifndef XUnmapWindow", "#define XUnmapWindow \\", "\t(tkIntXlibStubsPtr->xUnmapWindow) /* 75 */", "#endif", "#ifndef XWindowEvent", "#define XWindowEvent \\", "\t(tkIntXlibStubsPtr->xWindowEvent) /* 76 */", "#endif", "#ifndef XDestroyIC", "#define XDestroyIC \\", "\t(tkIntXlibStubsPtr->xDestroyIC) /* 77 */", "#endif", "#ifndef XFilterEvent", "#define XFilterEvent \\", "\t(tkIntXlibStubsPtr->xFilterEvent) /* 78 */", "#endif", "#ifndef XmbLookupString", "#define XmbLookupString \\", "\t(tkIntXlibStubsPtr->xmbLookupString) /* 79 */", "#endif", "#ifndef TkPutImage", "#define TkPutImage \\", "\t(tkIntXlibStubsPtr->tkPutImage) /* 80 */", "#endif", "/* Slot 81 is reserved */", "#ifndef XParseColor", "#define XParseColor \\", "\t(tkIntXlibStubsPtr->xParseColor) /* 82 */", "#endif", "#ifndef XCreateGC", "#define XCreateGC \\", "\t(tkIntXlibStubsPtr->xCreateGC) /* 83 */", "#endif", "#ifndef XFreeGC", "#define XFreeGC \\", "\t(tkIntXlibStubsPtr->xFreeGC) /* 84 */", "#endif", "#ifndef XInternAtom", "#define XInternAtom \\", "\t(tkIntXlibStubsPtr->xInternAtom) /* 85 */", "#endif", "#ifndef XSetBackground", "#define XSetBackground \\", "\t(tkIntXlibStubsPtr->xSetBackground) /* 86 */", "#endif", "#ifndef XSetForeground", "#define XSetForeground \\", "\t(tkIntXlibStubsPtr->xSetForeground) /* 87 */", "#endif", "#ifndef XSetClipMask", "#define XSetClipMask \\", "\t(tkIntXlibStubsPtr->xSetClipMask) /* 88 */", "#endif", "#ifndef XSetClipOrigin", "#define XSetClipOrigin \\", "\t(tkIntXlibStubsPtr->xSetClipOrigin) /* 89 */", "#endif", "#ifndef XSetTSOrigin", "#define XSetTSOrigin \\", "\t(tkIntXlibStubsPtr->xSetTSOrigin) /* 90 */", "#endif", "#ifndef XChangeGC", "#define XChangeGC \\", "\t(tkIntXlibStubsPtr->xChangeGC) /* 91 */", "#endif", "#ifndef XSetFont", "#define XSetFont \\", "\t(tkIntXlibStubsPtr->xSetFont) /* 92 */", "#endif", "#ifndef XSetArcMode", "#define XSetArcMode \\", "\t(tkIntXlibStubsPtr->xSetArcMode) /* 93 */", "#endif", "#ifndef XSetStipple", "#define XSetStipple \\", "\t(tkIntXlibStubsPtr->xSetStipple) /* 94 */", "#endif", "#ifndef XSetFillRule", "#define XSetFillRule \\", "\t(tkIntXlibStubsPtr->xSetFillRule) /* 95 */", "#endif", "#ifndef XSetFillStyle", "#define XSetFillStyle \\", "\t(tkIntXlibStubsPtr->xSetFillStyle) /* 96 */", "#endif", "#ifndef XSetFunction", "#define XSetFunction \\", "\t(tkIntXlibStubsPtr->xSetFunction) /* 97 */", "#endif", "#ifndef XSetLineAttributes", "#define XSetLineAttributes \\", "\t(tkIntXlibStubsPtr->xSetLineAttributes) /* 98 */", "#endif", "#ifndef _XInitImageFuncPtrs", "#define _XInitImageFuncPtrs \\", "\t(tkIntXlibStubsPtr->_XInitImageFuncPtrs) /* 99 */", "#endif", "#ifndef XCreateIC", "#define XCreateIC \\", "\t(tkIntXlibStubsPtr->xCreateIC) /* 100 */", "#endif", "#ifndef XGetVisualInfo", "#define XGetVisualInfo \\", "\t(tkIntXlibStubsPtr->xGetVisualInfo) /* 101 */", "#endif", "#ifndef XSetWMClientMachine", "#define XSetWMClientMachine \\", "\t(tkIntXlibStubsPtr->xSetWMClientMachine) /* 102 */", "#endif", "#ifndef XStringListToTextProperty", "#define XStringListToTextProperty \\", "\t(tkIntXlibStubsPtr->xStringListToTextProperty) /* 103 */", "#endif", "#ifndef XDrawLine", "#define XDrawLine \\", "\t(tkIntXlibStubsPtr->xDrawLine) /* 104 */", "#endif", "#ifndef XWarpPointer", "#define XWarpPointer \\", "\t(tkIntXlibStubsPtr->xWarpPointer) /* 105 */", "#endif", "#ifndef XFillRectangle", "#define XFillRectangle \\", "\t(tkIntXlibStubsPtr->xFillRectangle) /* 106 */", "#endif", "#endif /* WIN */", "#ifdef MAC_OSX_TK /* AQUA */", "#ifndef XSetDashes", "#define XSetDashes \\", "\t(tkIntXlibStubsPtr->xSetDashes) /* 0 */", "#endif", "#ifndef XGetModifierMapping", "#define XGetModifierMapping \\", "\t(tkIntXlibStubsPtr->xGetModifierMapping) /* 1 */", "#endif", "#ifndef XCreateImage", "#define XCreateImage \\", "\t(tkIntXlibStubsPtr->xCreateImage) /* 2 */", "#endif", "#ifndef XGetImage", "#define XGetImage \\", "\t(tkIntXlibStubsPtr->xGetImage) /* 3 */", "#endif", "#ifndef XGetAtomName", "#define XGetAtomName \\", "\t(tkIntXlibStubsPtr->xGetAtomName) /* 4 */", "#endif", "#ifndef XKeysymToString", "#define XKeysymToString \\", "\t(tkIntXlibStubsPtr->xKeysymToString) /* 5 */", "#endif", "#ifndef XCreateColormap", "#define XCreateColormap \\", "\t(tkIntXlibStubsPtr->xCreateColormap) /* 6 */", "#endif", "#ifndef XGContextFromGC", "#define XGContextFromGC \\", "\t(tkIntXlibStubsPtr->xGContextFromGC) /* 7 */", "#endif", "#ifndef XKeycodeToKeysym", "#define XKeycodeToKeysym \\", "\t(tkIntXlibStubsPtr->xKeycodeToKeysym) /* 8 */", "#endif", "#ifndef XStringToKeysym", "#define XStringToKeysym \\", "\t(tkIntXlibStubsPtr->xStringToKeysym) /* 9 */", "#endif", "#ifndef XRootWindow", "#define XRootWindow \\", "\t(tkIntXlibStubsPtr->xRootWindow) /* 10 */", "#endif", "#ifndef XSetErrorHandler", "#define XSetErrorHandler \\", "\t(tkIntXlibStubsPtr->xSetErrorHandler) /* 11 */", "#endif", "#ifndef XAllocColor", "#define XAllocColor \\", "\t(tkIntXlibStubsPtr->xAllocColor) /* 12 */", "#endif", "#ifndef XBell", "#define XBell \\", "\t(tkIntXlibStubsPtr->xBell) /* 13 */", "#endif", "#ifndef XChangeProperty", "#define XChangeProperty \\", "\t(tkIntXlibStubsPtr->xChangeProperty) /* 14 */", "#endif", "#ifndef XChangeWindowAttributes", "#define XChangeWindowAttributes \\", "\t(tkIntXlibStubsPtr->xChangeWindowAttributes) /* 15 */", "#endif", "#ifndef XConfigureWindow", "#define XConfigureWindow \\", "\t(tkIntXlibStubsPtr->xConfigureWindow) /* 16 */", "#endif", "#ifndef XCopyArea", "#define XCopyArea \\", "\t(tkIntXlibStubsPtr->xCopyArea) /* 17 */", "#endif", "#ifndef XCopyPlane", "#define XCopyPlane \\", "\t(tkIntXlibStubsPtr->xCopyPlane) /* 18 */", "#endif", "#ifndef XCreateBitmapFromData", "#define XCreateBitmapFromData \\", "\t(tkIntXlibStubsPtr->xCreateBitmapFromData) /* 19 */", "#endif", "#ifndef XDefineCursor", "#define XDefineCursor \\", "\t(tkIntXlibStubsPtr->xDefineCursor) /* 20 */", "#endif", "#ifndef XDestroyWindow", "#define XDestroyWindow \\", "\t(tkIntXlibStubsPtr->xDestroyWindow) /* 21 */", "#endif", "#ifndef XDrawArc", "#define XDrawArc \\", "\t(tkIntXlibStubsPtr->xDrawArc) /* 22 */", "#endif", "#ifndef XDrawLines", "#define XDrawLines \\", "\t(tkIntXlibStubsPtr->xDrawLines) /* 23 */", "#endif", "#ifndef XDrawRectangle", "#define XDrawRectangle \\", "\t(tkIntXlibStubsPtr->xDrawRectangle) /* 24 */", "#endif", "#ifndef XFillArc", "#define XFillArc \\", "\t(tkIntXlibStubsPtr->xFillArc) /* 25 */", "#endif", "#ifndef XFillPolygon", "#define XFillPolygon \\", "\t(tkIntXlibStubsPtr->xFillPolygon) /* 26 */", "#endif", "#ifndef XFillRectangles", "#define XFillRectangles \\", "\t(tkIntXlibStubsPtr->xFillRectangles) /* 27 */", "#endif", "#ifndef XFreeColormap", "#define XFreeColormap \\", "\t(tkIntXlibStubsPtr->xFreeColormap) /* 28 */", "#endif", "#ifndef XFreeColors", "#define XFreeColors \\", "\t(tkIntXlibStubsPtr->xFreeColors) /* 29 */", "#endif", "#ifndef XFreeModifiermap", "#define XFreeModifiermap \\", "\t(tkIntXlibStubsPtr->xFreeModifiermap) /* 30 */", "#endif", "#ifndef XGetGeometry", "#define XGetGeometry \\", "\t(tkIntXlibStubsPtr->xGetGeometry) /* 31 */", "#endif", "#ifndef XGetWindowProperty", "#define XGetWindowProperty \\", "\t(tkIntXlibStubsPtr->xGetWindowProperty) /* 32 */", "#endif", "#ifndef XGrabKeyboard", "#define XGrabKeyboard \\", "\t(tkIntXlibStubsPtr->xGrabKeyboard) /* 33 */", "#endif", "#ifndef XGrabPointer", "#define XGrabPointer \\", "\t(tkIntXlibStubsPtr->xGrabPointer) /* 34 */", "#endif", "#ifndef XKeysymToKeycode", "#define XKeysymToKeycode \\", "\t(tkIntXlibStubsPtr->xKeysymToKeycode) /* 35 */", "#endif", "#ifndef XMapWindow", "#define XMapWindow \\", "\t(tkIntXlibStubsPtr->xMapWindow) /* 36 */", "#endif", "#ifndef XMoveResizeWindow", "#define XMoveResizeWindow \\", "\t(tkIntXlibStubsPtr->xMoveResizeWindow) /* 37 */", "#endif", "#ifndef XMoveWindow", "#define XMoveWindow \\", "\t(tkIntXlibStubsPtr->xMoveWindow) /* 38 */", "#endif", "#ifndef XQueryPointer", "#define XQueryPointer \\", "\t(tkIntXlibStubsPtr->xQueryPointer) /* 39 */", "#endif", "#ifndef XRaiseWindow", "#define XRaiseWindow \\", "\t(tkIntXlibStubsPtr->xRaiseWindow) /* 40 */", "#endif", "#ifndef XRefreshKeyboardMapping", "#define XRefreshKeyboardMapping \\", "\t(tkIntXlibStubsPtr->xRefreshKeyboardMapping) /* 41 */", "#endif", "#ifndef XResizeWindow", "#define XResizeWindow \\", "\t(tkIntXlibStubsPtr->xResizeWindow) /* 42 */", "#endif", "#ifndef XSelectInput", "#define XSelectInput \\", "\t(tkIntXlibStubsPtr->xSelectInput) /* 43 */", "#endif", "#ifndef XSendEvent", "#define XSendEvent \\", "\t(tkIntXlibStubsPtr->xSendEvent) /* 44 */", "#endif", "#ifndef XSetIconName", "#define XSetIconName \\", "\t(tkIntXlibStubsPtr->xSetIconName) /* 45 */", "#endif", "#ifndef XSetInputFocus", "#define XSetInputFocus \\", "\t(tkIntXlibStubsPtr->xSetInputFocus) /* 46 */", "#endif", "#ifndef XSetSelectionOwner", "#define XSetSelectionOwner \\", "\t(tkIntXlibStubsPtr->xSetSelectionOwner) /* 47 */", "#endif", "#ifndef XSetWindowBackground", "#define XSetWindowBackground \\", "\t(tkIntXlibStubsPtr->xSetWindowBackground) /* 48 */", "#endif", "#ifndef XSetWindowBackgroundPixmap", "#define XSetWindowBackgroundPixmap \\", "\t(tkIntXlibStubsPtr->xSetWindowBackgroundPixmap) /* 49 */", "#endif", "#ifndef XSetWindowBorder", "#define XSetWindowBorder \\", "\t(tkIntXlibStubsPtr->xSetWindowBorder) /* 50 */", "#endif", "#ifndef XSetWindowBorderPixmap", "#define XSetWindowBorderPixmap \\", "\t(tkIntXlibStubsPtr->xSetWindowBorderPixmap) /* 51 */", "#endif", "#ifndef XSetWindowBorderWidth", "#define XSetWindowBorderWidth \\", "\t(tkIntXlibStubsPtr->xSetWindowBorderWidth) /* 52 */", "#endif", "#ifndef XSetWindowColormap", "#define XSetWindowColormap \\", "\t(tkIntXlibStubsPtr->xSetWindowColormap) /* 53 */", "#endif", "#ifndef XUngrabKeyboard", "#define XUngrabKeyboard \\", "\t(tkIntXlibStubsPtr->xUngrabKeyboard) /* 54 */", "#endif", "#ifndef XUngrabPointer", "#define XUngrabPointer \\", "\t(tkIntXlibStubsPtr->xUngrabPointer) /* 55 */", "#endif", "#ifndef XUnmapWindow", "#define XUnmapWindow \\", "\t(tkIntXlibStubsPtr->xUnmapWindow) /* 56 */", "#endif", "#ifndef TkPutImage", "#define TkPutImage \\", "\t(tkIntXlibStubsPtr->tkPutImage) /* 57 */", "#endif", "#ifndef XParseColor", "#define XParseColor \\", "\t(tkIntXlibStubsPtr->xParseColor) /* 58 */", "#endif", "#ifndef XCreateGC", "#define XCreateGC \\", "\t(tkIntXlibStubsPtr->xCreateGC) /* 59 */", "#endif", "#ifndef XFreeGC", "#define XFreeGC \\", "\t(tkIntXlibStubsPtr->xFreeGC) /* 60 */", "#endif", "#ifndef XInternAtom", "#define XInternAtom \\", "\t(tkIntXlibStubsPtr->xInternAtom) /* 61 */", "#endif", "#ifndef XSetBackground", "#define XSetBackground \\", "\t(tkIntXlibStubsPtr->xSetBackground) /* 62 */", "#endif", "#ifndef XSetForeground", "#define XSetForeground \\", "\t(tkIntXlibStubsPtr->xSetForeground) /* 63 */", "#endif", "#ifndef XSetClipMask", "#define XSetClipMask \\", "\t(tkIntXlibStubsPtr->xSetClipMask) /* 64 */", "#endif", "#ifndef XSetClipOrigin", "#define XSetClipOrigin \\", "\t(tkIntXlibStubsPtr->xSetClipOrigin) /* 65 */", "#endif", "#ifndef XSetTSOrigin", "#define XSetTSOrigin \\", "\t(tkIntXlibStubsPtr->xSetTSOrigin) /* 66 */", "#endif", "#ifndef XChangeGC", "#define XChangeGC \\", "\t(tkIntXlibStubsPtr->xChangeGC) /* 67 */", "#endif", "#ifndef XSetFont", "#define XSetFont \\", "\t(tkIntXlibStubsPtr->xSetFont) /* 68 */", "#endif", "#ifndef XSetArcMode", "#define XSetArcMode \\", "\t(tkIntXlibStubsPtr->xSetArcMode) /* 69 */", "#endif", "#ifndef XSetStipple", "#define XSetStipple \\", "\t(tkIntXlibStubsPtr->xSetStipple) /* 70 */", "#endif", "#ifndef XSetFillRule", "#define XSetFillRule \\", "\t(tkIntXlibStubsPtr->xSetFillRule) /* 71 */", "#endif", "#ifndef XSetFillStyle", "#define XSetFillStyle \\", "\t(tkIntXlibStubsPtr->xSetFillStyle) /* 72 */", "#endif", "#ifndef XSetFunction", "#define XSetFunction \\", "\t(tkIntXlibStubsPtr->xSetFunction) /* 73 */", "#endif", "#ifndef XSetLineAttributes", "#define XSetLineAttributes \\", "\t(tkIntXlibStubsPtr->xSetLineAttributes) /* 74 */", "#endif", "#ifndef _XInitImageFuncPtrs", "#define _XInitImageFuncPtrs \\", "\t(tkIntXlibStubsPtr->_XInitImageFuncPtrs) /* 75 */", "#endif", "#ifndef XCreateIC", "#define XCreateIC \\", "\t(tkIntXlibStubsPtr->xCreateIC) /* 76 */", "#endif", "#ifndef XGetVisualInfo", "#define XGetVisualInfo \\", "\t(tkIntXlibStubsPtr->xGetVisualInfo) /* 77 */", "#endif", "#ifndef XSetWMClientMachine", "#define XSetWMClientMachine \\", "\t(tkIntXlibStubsPtr->xSetWMClientMachine) /* 78 */", "#endif", "#ifndef XStringListToTextProperty", "#define XStringListToTextProperty \\", "\t(tkIntXlibStubsPtr->xStringListToTextProperty) /* 79 */", "#endif", "#ifndef XDrawSegments", "#define XDrawSegments \\", "\t(tkIntXlibStubsPtr->xDrawSegments) /* 80 */", "#endif", "#ifndef XForceScreenSaver", "#define XForceScreenSaver \\", "\t(tkIntXlibStubsPtr->xForceScreenSaver) /* 81 */", "#endif", "#ifndef XDrawLine", "#define XDrawLine \\", "\t(tkIntXlibStubsPtr->xDrawLine) /* 82 */", "#endif", "#ifndef XFillRectangle", "#define XFillRectangle \\", "\t(tkIntXlibStubsPtr->xFillRectangle) /* 83 */", "#endif", "#ifndef XClearWindow", "#define XClearWindow \\", "\t(tkIntXlibStubsPtr->xClearWindow) /* 84 */", "#endif", "#ifndef XDrawPoint", "#define XDrawPoint \\", "\t(tkIntXlibStubsPtr->xDrawPoint) /* 85 */", "#endif", "#ifndef XDrawPoints", "#define XDrawPoints \\", "\t(tkIntXlibStubsPtr->xDrawPoints) /* 86 */", "#endif", "#ifndef XWarpPointer", "#define XWarpPointer \\", "\t(tkIntXlibStubsPtr->xWarpPointer) /* 87 */", "#endif", "#ifndef XQueryColor", "#define XQueryColor \\", "\t(tkIntXlibStubsPtr->xQueryColor) /* 88 */", "#endif", "#ifndef XQueryColors", "#define XQueryColors \\", "\t(tkIntXlibStubsPtr->xQueryColors) /* 89 */", "#endif", "#ifndef XQueryTree", "#define XQueryTree \\", "\t(tkIntXlibStubsPtr->xQueryTree) /* 90 */", "#endif", "#ifndef XSync", "#define XSync \\", "\t(tkIntXlibStubsPtr->xSync) /* 91 */", "#endif", "#endif /* AQUA */", "", "#endif /* defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS) */", "", "/* !END!: Do not edit above this line. */", "", "#undef TCL_STORAGE_CLASS", "#define TCL_STORAGE_CLASS DLLIMPORT", "", "#endif /* _TKINTXLIBDECLS */" },
    ["tkMacOSX.h"] = { "/*", " * tkMacOSX.h --", " *", " *\tDeclarations of Macintosh specific exported variables and procedures.", " *", " * Copyright (c) 1995-1997 Sun Microsystems, Inc.", " * Copyright 2001-2009, Apple Inc.", " * Copyright (c) 2005-2009 Daniel A. Steffen <das@users.sourceforge.net>", " *", ' * See the file "license.terms" for information on usage and redistribution', " * of this file, and for a DISCLAIMER OF ALL WARRANTIES.", " *", " * RCS: @(#) $Id$", " */", "", "#ifndef _TKMAC", "#define _TKMAC", "", "#ifndef _TK", '#include "tk.h"', "#endif", "", "/*", " * Structures and function types for handling Netscape-type in process", " * embedding where Tk does not control the top-level", " */", "", "typedef int (Tk_MacOSXEmbedRegisterWinProc) (long winID, Tk_Window window);", "typedef void* (Tk_MacOSXEmbedGetGrafPortProc) (Tk_Window window);", "typedef int (Tk_MacOSXEmbedMakeContainerExistProc) (Tk_Window window);", "typedef void (Tk_MacOSXEmbedGetClipProc) (Tk_Window window, TkRegion rgn);", "typedef void (Tk_MacOSXEmbedGetOffsetInParentProc) (Tk_Window window, void *ulCorner);", "", '#include "tkPlatDecls.h"', "", "#endif /* _TKMAC */" },
    ["tkPlatDecls.h"] = { "/*", " * tkPlatDecls.h --", " *", " *\tDeclarations of functions in the platform-specific public Tcl API.", " *", " * Copyright (c) 1998-1999 by Scriptics Corporation.", " *", ' * See the file "license.terms" for information on usage and redistribution', " * of this file, and for a DISCLAIMER OF ALL WARRANTIES.", " *", " * RCS: @(#) $Id$", " */", "", "#ifndef _TKPLATDECLS", "#define _TKPLATDECLS", "", "#ifdef BUILD_tk", "#undef TCL_STORAGE_CLASS", "#define TCL_STORAGE_CLASS DLLEXPORT", "#endif", "", "/*", " * WARNING: This file is automatically generated by the tools/genStubs.tcl", " * script.  Any modifications to the function declarations below should be made", " * in the generic/tk.decls script.", " */", "", "/* !BEGIN!: Do not edit below this line. */", "", "/*", " * Exported function declarations:", " */", "", "#ifdef __WIN32__ /* WIN */", "#ifndef Tk_AttachHWND_TCL_DECLARED", "#define Tk_AttachHWND_TCL_DECLARED", "/* 0 */", "EXTERN Window\t\tTk_AttachHWND(Tk_Window tkwin, HWND hwnd);", "#endif", "#ifndef Tk_GetHINSTANCE_TCL_DECLARED", "#define Tk_GetHINSTANCE_TCL_DECLARED", "/* 1 */", "EXTERN HINSTANCE\tTk_GetHINSTANCE(void);", "#endif", "#ifndef Tk_GetHWND_TCL_DECLARED", "#define Tk_GetHWND_TCL_DECLARED", "/* 2 */", "EXTERN HWND\t\tTk_GetHWND(Window window);", "#endif", "#ifndef Tk_HWNDToWindow_TCL_DECLARED", "#define Tk_HWNDToWindow_TCL_DECLARED", "/* 3 */", "EXTERN Tk_Window\tTk_HWNDToWindow(HWND hwnd);", "#endif", "#ifndef Tk_PointerEvent_TCL_DECLARED", "#define Tk_PointerEvent_TCL_DECLARED", "/* 4 */", "EXTERN void\t\tTk_PointerEvent(HWND hwnd, int x, int y);", "#endif", "#ifndef Tk_TranslateWinEvent_TCL_DECLARED", "#define Tk_TranslateWinEvent_TCL_DECLARED", "/* 5 */", "EXTERN int\t\tTk_TranslateWinEvent(HWND hwnd, UINT message,", "\t\t\t\tWPARAM wParam, LPARAM lParam,", "\t\t\t\tLRESULT *result);", "#endif", "#endif /* WIN */", "#ifdef MAC_OSX_TK /* AQUA */", "#ifndef Tk_MacOSXSetEmbedHandler_TCL_DECLARED", "#define Tk_MacOSXSetEmbedHandler_TCL_DECLARED", "/* 0 */", "EXTERN void\t\tTk_MacOSXSetEmbedHandler(", "\t\t\t\tTk_MacOSXEmbedRegisterWinProc *registerWinProcPtr,", "\t\t\t\tTk_MacOSXEmbedGetGrafPortProc *getPortProcPtr,", "\t\t\t\tTk_MacOSXEmbedMakeContainerExistProc *containerExistProcPtr,", "\t\t\t\tTk_MacOSXEmbedGetClipProc *getClipProc,", "\t\t\t\tTk_MacOSXEmbedGetOffsetInParentProc *getOffsetProc);", "#endif", "#ifndef Tk_MacOSXTurnOffMenus_TCL_DECLARED", "#define Tk_MacOSXTurnOffMenus_TCL_DECLARED", "/* 1 */", "EXTERN void\t\tTk_MacOSXTurnOffMenus(void);", "#endif", "#ifndef Tk_MacOSXTkOwnsCursor_TCL_DECLARED", "#define Tk_MacOSXTkOwnsCursor_TCL_DECLARED", "/* 2 */", "EXTERN void\t\tTk_MacOSXTkOwnsCursor(int tkOwnsIt);", "#endif", "#ifndef TkMacOSXInitMenus_TCL_DECLARED", "#define TkMacOSXInitMenus_TCL_DECLARED", "/* 3 */", "EXTERN void\t\tTkMacOSXInitMenus(Tcl_Interp *interp);", "#endif", "#ifndef TkMacOSXInitAppleEvents_TCL_DECLARED", "#define TkMacOSXInitAppleEvents_TCL_DECLARED", "/* 4 */", "EXTERN void\t\tTkMacOSXInitAppleEvents(Tcl_Interp *interp);", "#endif", "#ifndef TkGenWMConfigureEvent_TCL_DECLARED", "#define TkGenWMConfigureEvent_TCL_DECLARED", "/* 5 */", "EXTERN void\t\tTkGenWMConfigureEvent(Tk_Window tkwin, int x, int y,", "\t\t\t\tint width, int height, int flags);", "#endif", "#ifndef TkMacOSXInvalClipRgns_TCL_DECLARED", "#define TkMacOSXInvalClipRgns_TCL_DECLARED", "/* 6 */", "EXTERN void\t\tTkMacOSXInvalClipRgns(Tk_Window tkwin);", "#endif", "#ifndef TkMacOSXGetDrawablePort_TCL_DECLARED", "#define TkMacOSXGetDrawablePort_TCL_DECLARED", "/* 7 */", "EXTERN void *\t\tTkMacOSXGetDrawablePort(Drawable drawable);", "#endif", "#ifndef TkMacOSXGetRootControl_TCL_DECLARED", "#define TkMacOSXGetRootControl_TCL_DECLARED", "/* 8 */", "EXTERN void *\t\tTkMacOSXGetRootControl(Drawable drawable);", "#endif", "#ifndef Tk_MacOSXSetupTkNotifier_TCL_DECLARED", "#define Tk_MacOSXSetupTkNotifier_TCL_DECLARED", "/* 9 */", "EXTERN void\t\tTk_MacOSXSetupTkNotifier(void);", "#endif", "#ifndef Tk_MacOSXIsAppInFront_TCL_DECLARED", "#define Tk_MacOSXIsAppInFront_TCL_DECLARED", "/* 10 */", "EXTERN int\t\tTk_MacOSXIsAppInFront(void);", "#endif", "#endif /* AQUA */", "", "typedef struct TkPlatStubs {", "    int magic;", "    struct TkPlatStubHooks *hooks;", "", "#ifdef __WIN32__ /* WIN */", "    Window (*tk_AttachHWND) (Tk_Window tkwin, HWND hwnd); /* 0 */", "    HINSTANCE (*tk_GetHINSTANCE) (void); /* 1 */", "    HWND (*tk_GetHWND) (Window window); /* 2 */", "    Tk_Window (*tk_HWNDToWindow) (HWND hwnd); /* 3 */", "    void (*tk_PointerEvent) (HWND hwnd, int x, int y); /* 4 */", "    int (*tk_TranslateWinEvent) (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam, LRESULT *result); /* 5 */", "#endif /* WIN */", "#ifdef MAC_OSX_TK /* AQUA */", "    void (*tk_MacOSXSetEmbedHandler) (Tk_MacOSXEmbedRegisterWinProc *registerWinProcPtr, Tk_MacOSXEmbedGetGrafPortProc *getPortProcPtr, Tk_MacOSXEmbedMakeContainerExistProc *containerExistProcPtr, Tk_MacOSXEmbedGetClipProc *getClipProc, Tk_MacOSXEmbedGetOffsetInParentProc *getOffsetProc); /* 0 */", "    void (*tk_MacOSXTurnOffMenus) (void); /* 1 */", "    void (*tk_MacOSXTkOwnsCursor) (int tkOwnsIt); /* 2 */", "    void (*tkMacOSXInitMenus) (Tcl_Interp *interp); /* 3 */", "    void (*tkMacOSXInitAppleEvents) (Tcl_Interp *interp); /* 4 */", "    void (*tkGenWMConfigureEvent) (Tk_Window tkwin, int x, int y, int width, int height, int flags); /* 5 */", "    void (*tkMacOSXInvalClipRgns) (Tk_Window tkwin); /* 6 */", "    void * (*tkMacOSXGetDrawablePort) (Drawable drawable); /* 7 */", "    void * (*tkMacOSXGetRootControl) (Drawable drawable); /* 8 */", "    void (*tk_MacOSXSetupTkNotifier) (void); /* 9 */", "    int (*tk_MacOSXIsAppInFront) (void); /* 10 */", "#endif /* AQUA */", "} TkPlatStubs;", "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "extern TkPlatStubs *tkPlatStubsPtr;", "#ifdef __cplusplus", "}", "#endif", "", "#if defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS)", "", "/*", " * Inline function declarations:", " */", "", "#ifdef __WIN32__ /* WIN */", "#ifndef Tk_AttachHWND", "#define Tk_AttachHWND \\", "\t(tkPlatStubsPtr->tk_AttachHWND) /* 0 */", "#endif", "#ifndef Tk_GetHINSTANCE", "#define Tk_GetHINSTANCE \\", "\t(tkPlatStubsPtr->tk_GetHINSTANCE) /* 1 */", "#endif", "#ifndef Tk_GetHWND", "#define Tk_GetHWND \\", "\t(tkPlatStubsPtr->tk_GetHWND) /* 2 */", "#endif", "#ifndef Tk_HWNDToWindow", "#define Tk_HWNDToWindow \\", "\t(tkPlatStubsPtr->tk_HWNDToWindow) /* 3 */", "#endif", "#ifndef Tk_PointerEvent", "#define Tk_PointerEvent \\", "\t(tkPlatStubsPtr->tk_PointerEvent) /* 4 */", "#endif", "#ifndef Tk_TranslateWinEvent", "#define Tk_TranslateWinEvent \\", "\t(tkPlatStubsPtr->tk_TranslateWinEvent) /* 5 */", "#endif", "#endif /* WIN */", "#ifdef MAC_OSX_TK /* AQUA */", "#ifndef Tk_MacOSXSetEmbedHandler", "#define Tk_MacOSXSetEmbedHandler \\", "\t(tkPlatStubsPtr->tk_MacOSXSetEmbedHandler) /* 0 */", "#endif", "#ifndef Tk_MacOSXTurnOffMenus", "#define Tk_MacOSXTurnOffMenus \\", "\t(tkPlatStubsPtr->tk_MacOSXTurnOffMenus) /* 1 */", "#endif", "#ifndef Tk_MacOSXTkOwnsCursor", "#define Tk_MacOSXTkOwnsCursor \\", "\t(tkPlatStubsPtr->tk_MacOSXTkOwnsCursor) /* 2 */", "#endif", "#ifndef TkMacOSXInitMenus", "#define TkMacOSXInitMenus \\", "\t(tkPlatStubsPtr->tkMacOSXInitMenus) /* 3 */", "#endif", "#ifndef TkMacOSXInitAppleEvents", "#define TkMacOSXInitAppleEvents \\", "\t(tkPlatStubsPtr->tkMacOSXInitAppleEvents) /* 4 */", "#endif", "#ifndef TkGenWMConfigureEvent", "#define TkGenWMConfigureEvent \\", "\t(tkPlatStubsPtr->tkGenWMConfigureEvent) /* 5 */", "#endif", "#ifndef TkMacOSXInvalClipRgns", "#define TkMacOSXInvalClipRgns \\", "\t(tkPlatStubsPtr->tkMacOSXInvalClipRgns) /* 6 */", "#endif", "#ifndef TkMacOSXGetDrawablePort", "#define TkMacOSXGetDrawablePort \\", "\t(tkPlatStubsPtr->tkMacOSXGetDrawablePort) /* 7 */", "#endif", "#ifndef TkMacOSXGetRootControl", "#define TkMacOSXGetRootControl \\", "\t(tkPlatStubsPtr->tkMacOSXGetRootControl) /* 8 */", "#endif", "#ifndef Tk_MacOSXSetupTkNotifier", "#define Tk_MacOSXSetupTkNotifier \\", "\t(tkPlatStubsPtr->tk_MacOSXSetupTkNotifier) /* 9 */", "#endif", "#ifndef Tk_MacOSXIsAppInFront", "#define Tk_MacOSXIsAppInFront \\", "\t(tkPlatStubsPtr->tk_MacOSXIsAppInFront) /* 10 */", "#endif", "#endif /* AQUA */", "", "#endif /* defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS) */", "", "/* !END!: Do not edit above this line. */", "", "#undef TCL_STORAGE_CLASS", "#define TCL_STORAGE_CLASS DLLIMPORT", "", "#endif /* _TKPLATDECLS */" },
    ["ttyent.h"] = { "/*", " * Copyright (c) 1989, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)ttyent.h\t8.1 (Berkeley) 6/2/93", " */", "", "#ifndef\t_TTYENT_H_", "#define\t_TTYENT_H_", "", '#define\t_PATH_TTYS\t"/etc/ttys"', "", '#define\t_TTYS_OFF\t"off"', '#define\t_TTYS_ON\t"on"', '#define\t_TTYS_SECURE\t"secure"', '#define\t_TTYS_WINDOW\t"window"', '#define _TTYS_ONERROR   "onerror"', '#define _TTYS_ONOPTION  "onoption"', '#define _TTYS_SLOT      "slot"', "", "struct ttyent {", "\tchar\t*ty_name;\t/* terminal device name */", "\tchar\t*ty_getty;\t/* command to execute, usually getty */", "\tchar\t*ty_type;\t/* terminal type for termcap */", "#define\tTTY_ON\t\t0x01\t/* enable logins (start ty_getty program) */", "#define\tTTY_SECURE\t0x02\t/* allow uid of 0 to login */", "\tint\tty_status;\t/* status flags */", "\tchar \t*ty_window;\t/* command to start up window manager */", "\tchar    *ty_onerror;    /* command to execute after getty failure */", "\tchar    *ty_onoption;   /* command to execute after console login */", "\tchar\t*ty_comment;\t/* comment field */", "};", "", "#include <sys/cdefs.h>", "", "__BEGIN_DECLS", "struct ttyent *getttyent(void);", "struct ttyent *getttynam(const char *);", "int setttyent(void);", "int endttyent(void);", "__END_DECLS", "", "#endif /* !_TTYENT_H_ */" },
    ["tzfile.h"] = { "#ifndef TZFILE_H", "#define TZFILE_H", "", "", "/*", "** This file is in the public domain, so clarified as of", "** 1996-06-05 by Arthur David Olson (arthur_david_olson@nih.gov).", "**", "** $FreeBSD: src/lib/libc/stdtime/tzfile.h,v 1.8 2002/03/22 23:42:05 obrien Exp $", "*/", "", "/*", "** This header is for use ONLY with the time conversion code.", "** There is no guarantee that it will remain unchanged,", "** or that it will remain at all.", "** Do NOT copy it to any system include directory.", "** Thank you!", "*/", "", "/*", "** ID", "*/", "", "#ifndef lint", "#ifndef NOID", "/*", 'static char\ttzfilehid[] = "@(#)tzfile.h\t7.14";', "*/", "#endif /* !defined NOID */", "#endif /* !defined lint */", "", "/*", "** Information about time zone files.", "*/", "", "#ifndef TZDIR", '#define TZDIR\t"/usr/share/zoneinfo" /* Time zone object file directory */', "#endif /* !defined TZDIR */", "", "#ifndef TZDEFAULT", '#define TZDEFAULT\t"/etc/localtime"', "#endif /* !defined TZDEFAULT */", "", "#ifndef TZDEFRULES", '#define TZDEFRULES\t"posixrules"', "#endif /* !defined TZDEFRULES */", "", "/*", "** Each file begins with. . .", "*/", "", '#define\tTZ_MAGIC\t"TZif"', "", "struct tzhead {", " \tchar\ttzh_magic[4];\t\t/* TZ_MAGIC */", "\tchar\ttzh_reserved[16];\t/* reserved for future use */", "\tchar\ttzh_ttisgmtcnt[4];\t/* coded number of trans. time flags */", "\tchar\ttzh_ttisstdcnt[4];\t/* coded number of trans. time flags */", "\tchar\ttzh_leapcnt[4];\t\t/* coded number of leap seconds */", "\tchar\ttzh_timecnt[4];\t\t/* coded number of transition times */", "\tchar\ttzh_typecnt[4];\t\t/* coded number of local time types */", "\tchar\ttzh_charcnt[4];\t\t/* coded number of abbr. chars */", "};", "", "/*", "** . . .followed by. . .", "**", "**\ttzh_timecnt (char [4])s\t\tcoded transition times a la time(2)", "**\ttzh_timecnt (unsigned char)s\ttypes of local time starting at above", "**\ttzh_typecnt repetitions of", "**\t\tone (char [4])\t\tcoded UTC offset in seconds", "**\t\tone (unsigned char)\tused to set tm_isdst", "**\t\tone (unsigned char)\tthat's an abbreviation list index", "**\ttzh_charcnt (char)s\t\t'\\0'-terminated zone abbreviations", "**\ttzh_leapcnt repetitions of", "**\t\tone (char [4])\t\tcoded leap second transition times", "**\t\tone (char [4])\t\ttotal correction after above", "**\ttzh_ttisstdcnt (char)s\t\tindexed by type; if TRUE, transition", "**\t\t\t\t\ttime is standard time, if FALSE,", "**\t\t\t\t\ttransition time is wall clock time", "**\t\t\t\t\tif absent, transition times are", "**\t\t\t\t\tassumed to be wall clock time", "**\ttzh_ttisgmtcnt (char)s\t\tindexed by type; if TRUE, transition", "**\t\t\t\t\ttime is UTC, if FALSE,", "**\t\t\t\t\ttransition time is local time", "**\t\t\t\t\tif absent, transition times are", "**\t\t\t\t\tassumed to be local time", "*/", "", "/*", '** In the current implementation, "tzset()" refuses to deal with files that', "** exceed any of the limits below.", "*/", "", "#ifndef TZ_MAX_TIMES", "/*", "** The TZ_MAX_TIMES value below is enough to handle a bit more than a", "** year's worth of solar time (corrected daily to the nearest second) or", "** 138 years of Pacific Presidential Election time", "** (where there are three time zone transitions every fourth year).", "*/", "#define TZ_MAX_TIMES\t370", "#endif /* !defined TZ_MAX_TIMES */", "", "#ifndef TZ_MAX_TYPES", "#ifndef NOSOLAR", "#define TZ_MAX_TYPES\t256 /* Limited by what (unsigned char)'s can hold */", "#endif /* !defined NOSOLAR */", "#ifdef NOSOLAR", "/*", "** Must be at least 14 for Europe/Riga as of Jan 12 1995,", "** as noted by Earl Chew <earl@hpato.aus.hp.com>.", "*/", "#define TZ_MAX_TYPES\t20\t/* Maximum number of local time types */", "#endif /* !defined NOSOLAR */", "#endif /* !defined TZ_MAX_TYPES */", "", "#ifndef TZ_MAX_CHARS", "#define TZ_MAX_CHARS\t50\t/* Maximum number of abbreviation characters */", "\t\t\t\t/* (limited by what unsigned chars can hold) */", "#endif /* !defined TZ_MAX_CHARS */", "", "#ifndef TZ_MAX_LEAPS", "#define TZ_MAX_LEAPS\t50\t/* Maximum number of leap second corrections */", "#endif /* !defined TZ_MAX_LEAPS */", "", "#define SECSPERMIN\t60", "#define MINSPERHOUR\t60", "#define HOURSPERDAY\t24", "#define DAYSPERWEEK\t7", "#define DAYSPERNYEAR\t365", "#define DAYSPERLYEAR\t366", "#define SECSPERHOUR\t(SECSPERMIN * MINSPERHOUR)", "#define SECSPERDAY\t((long) SECSPERHOUR * HOURSPERDAY)", "#define MONSPERYEAR\t12", "", "#define TM_SUNDAY\t0", "#define TM_MONDAY\t1", "#define TM_TUESDAY\t2", "#define TM_WEDNESDAY\t3", "#define TM_THURSDAY\t4", "#define TM_FRIDAY\t5", "#define TM_SATURDAY\t6", "", "#define TM_JANUARY\t0", "#define TM_FEBRUARY\t1", "#define TM_MARCH\t2", "#define TM_APRIL\t3", "#define TM_MAY\t\t4", "#define TM_JUNE\t\t5", "#define TM_JULY\t\t6", "#define TM_AUGUST\t7", "#define TM_SEPTEMBER\t8", "#define TM_OCTOBER\t9", "#define TM_NOVEMBER\t10", "#define TM_DECEMBER\t11", "", "#define TM_YEAR_BASE\t1900", "", "#define EPOCH_YEAR\t1970", "#define EPOCH_WDAY\tTM_THURSDAY", "", "/*", "** Accurate only for the past couple of centuries;", "** that will probably do.", "*/", "", "#define isleap(y) (((y) % 4) == 0 && (((y) % 100) != 0 || ((y) % 400) == 0))", "", "/*", "** Since everything in isleap is modulo 400 (or a factor of 400), we know that", "**\tisleap(y) == isleap(y % 400)", "** and so", "**\tisleap(a + b) == isleap((a + b) % 400)", "** or", "**\tisleap(a + b) == isleap(a % 400 + b % 400)", "** This is true even if % means modulo rather than Fortran remainder", "** (which is allowed by C89 but not C99).", "** We use this to avoid addition overflow problems.", "*/", "", "#define isleap_sum(a, b)\tisleap((a) % 400 + (b) % 400)", "", "#ifndef USG", "", "/*", "** Use of the underscored variants may cause problems if you move your code to", "** certain System-V-based systems; for maximum portability, use the", "** underscore-free variants.  The underscored variants are provided for", "** backward compatibility only; they may disappear from future versions of", "** this file.", "*/", "", "#define SECS_PER_MIN\tSECSPERMIN", "#define MINS_PER_HOUR\tMINSPERHOUR", "#define HOURS_PER_DAY\tHOURSPERDAY", "#define DAYS_PER_WEEK\tDAYSPERWEEK", "#define DAYS_PER_NYEAR\tDAYSPERNYEAR", "#define DAYS_PER_LYEAR\tDAYSPERLYEAR", "#define SECS_PER_HOUR\tSECSPERHOUR", "#define SECS_PER_DAY\tSECSPERDAY", "#define MONS_PER_YEAR\tMONSPERYEAR", "", "#endif /* !defined USG */", "", "#endif /* !defined TZFILE_H */" },
    ["ucontext.h"] = { "/*", " * Copyright (c) 2002, 2008, 2009 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "", "/*", " * These routines are DEPRECATED and should not be used.", " */", "#ifndef _UCONTEXT_H_", "#define _UCONTEXT_H_", "", "#include <sys/cdefs.h>", "", "#ifdef _XOPEN_SOURCE", "#include <sys/ucontext.h>", "#include <Availability.h>", "", "__BEGIN_DECLS", "int  getcontext(ucontext_t *) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5, __MAC_10_6, __IPHONE_2_0, __IPHONE_2_0);", "void makecontext(ucontext_t *, void (*)(), int, ...) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5, __MAC_10_6, __IPHONE_2_0, __IPHONE_2_0);", "int  setcontext(const ucontext_t *) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5, __MAC_10_6, __IPHONE_2_0, __IPHONE_2_0);", "int  swapcontext(ucontext_t * __restrict, const ucontext_t * __restrict) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5, __MAC_10_6, __IPHONE_2_0, __IPHONE_2_0);", "__END_DECLS", "#else /* !_XOPEN_SOURCE */", "#error The deprecated ucontext routines require _XOPEN_SOURCE to be defined", "#endif /* _XOPEN_SOURCE */", "", "#endif /* _UCONTEXT_H_ */" },
    ["ulimit.h"] = { "/*-", " * Copyright (c) 2002 Kyle Martin <mkm@ieee.org>", " * All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " *", " * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " * $FreeBSD: src/include/ulimit.h,v 1.4 2003/01/08 01:18:13 tjr Exp $", " */", "", "#ifndef _ULIMIT_H_", "#define\t_ULIMIT_H_", "", "#include <sys/cdefs.h>", "", "#define\tUL_GETFSIZE\t1", "#define\tUL_SETFSIZE\t2", "", "__BEGIN_DECLS", "long\tulimit(int, ...);", "__END_DECLS", "", "#endif /* !_ULIMIT_H_ */" },
    ["unctrl.h"] = { "/****************************************************************************", " * Copyright (c) 1998,2000 Free Software Foundation, Inc.                   *", " *                                                                          *", " * Permission is hereby granted, free of charge, to any person obtaining a  *", " * copy of this software and associated documentation files (the            *", ' * "Software"), to deal in the Software without restriction, including      *', " * without limitation the rights to use, copy, modify, merge, publish,      *", " * distribute, distribute with modifications, sublicense, and/or sell       *", " * copies of the Software, and to permit persons to whom the Software is    *", " * furnished to do so, subject to the following conditions:                 *", " *                                                                          *", " * The above copyright notice and this permission notice shall be included  *", " * in all copies or substantial portions of the Software.                   *", " *                                                                          *", ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *', " * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *", " * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *", " * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *", " * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *", " * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *", " * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *", " *                                                                          *", " * Except as contained in this notice, the name(s) of the above copyright   *", " * holders shall not be used in advertising or otherwise to promote the     *", " * sale, use or other dealings in this Software without prior written       *", " * authorization.                                                           *", " ****************************************************************************/", "", "/****************************************************************************", " *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *", " *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *", " ****************************************************************************/", "", "/*", " * unctrl.h", " *", " * Display a printable version of a control character.", " * Control characters are displayed in caret notation (^x), DELETE is displayed", " * as ^?. Printable characters are displayed as is.", " */", "", "/* $Id: unctrl.h.in,v 1.10 2001/03/24 21:53:25 tom Exp $ */", "", "#ifndef NCURSES_UNCTRL_H_incl", "#define NCURSES_UNCTRL_H_incl\t1", "", "#undef  NCURSES_VERSION", '#define NCURSES_VERSION "5.7"', "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "", "#include <curses.h>", "", "#undef unctrl", "NCURSES_EXPORT(NCURSES_CONST char *) unctrl (chtype);", "", "#ifdef __cplusplus", "}", "#endif", "", "#endif /* NCURSES_UNCTRL_H_incl */" },
    ["unistd.h"] = { "/*", " * Copyright (c) 2000, 2002-2006, 2008-2010, 2012 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/*-", " * Copyright (c) 1998-1999 Apple Computer, Inc. All Rights Reserved", " * Copyright (c) 1991, 1993, 1994", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)unistd.h\t8.12 (Berkeley) 4/27/95", " *", " *  Copyright (c)  1998 Apple Compter, Inc.", " *  All Rights Reserved", " */", "", "/* History:", "        7/14/99 EKN at Apple fixed getdirentriesattr from getdirentryattr", "        3/26/98 CHW at Apple added real interface to searchfs call", "  \t3/5/98  CHW at Apple added hfs semantic system calls headers", "*/", "", "#ifndef _UNISTD_H_", "#define\t_UNISTD_H_", "", "#include <_types.h>", "#include <sys/unistd.h>", "#include <Availability.h>", "#include <sys/_types/_gid_t.h>", "#include <sys/_types/_intptr_t.h>", "#include <sys/_types/_off_t.h>", "#include <sys/_types/_pid_t.h>", "/* DO NOT REMOVE THIS COMMENT: fixincludes needs to see:", " * _GCC_SIZE_T */", "#include <sys/_types/_size_t.h>", "#include <sys/_types/_ssize_t.h>", "#include <sys/_types/_uid_t.h>", "#include <sys/_types/_useconds_t.h>", "#include <sys/_types/_null.h>", "", "#define\t STDIN_FILENO\t0\t/* standard input file descriptor */", "#define\tSTDOUT_FILENO\t1\t/* standard output file descriptor */", "#define\tSTDERR_FILENO\t2\t/* standard error file descriptor */", "", "", "/* Version test macros */", "/* _POSIX_VERSION and _POSIX2_VERSION from sys/unistd.h */", "#define\t_XOPEN_VERSION\t\t\t600\t\t/* [XSI] */", "#define\t_XOPEN_XCU_VERSION\t\t4\t\t/* Older standard */", "", "", "/* Please keep this list in the same order as the applicable standard */", "#define\t_POSIX_ADVISORY_INFO\t\t(-1)\t\t/* [ADV] */", "#define\t_POSIX_ASYNCHRONOUS_IO\t\t(-1)\t\t/* [AIO] */", "#define\t_POSIX_BARRIERS\t\t\t(-1)\t\t/* [BAR] */", "#define\t_POSIX_CHOWN_RESTRICTED\t\t200112L", "#define\t_POSIX_CLOCK_SELECTION\t\t(-1)\t\t/* [CS] */", "#define\t_POSIX_CPUTIME\t\t\t(-1)\t\t/* [CPT] */", "#define\t_POSIX_FSYNC\t\t\t200112L\t\t/* [FSC] */", "#define\t_POSIX_IPV6\t\t\t200112L", "#define\t_POSIX_JOB_CONTROL\t\t200112L", "#define\t_POSIX_MAPPED_FILES\t\t200112L\t\t/* [MF] */", "#define\t_POSIX_MEMLOCK\t\t\t(-1)\t\t/* [ML] */", "#define\t_POSIX_MEMLOCK_RANGE\t\t(-1)\t\t/* [MR] */", "#define\t_POSIX_MEMORY_PROTECTION\t200112L\t\t/* [MPR] */", "#define\t_POSIX_MESSAGE_PASSING\t\t(-1)\t\t/* [MSG] */", "#define\t_POSIX_MONOTONIC_CLOCK\t\t(-1)\t\t/* [MON] */", "#define\t_POSIX_NO_TRUNC\t\t\t200112L", "#define\t_POSIX_PRIORITIZED_IO\t\t(-1)\t\t/* [PIO] */", "#define\t_POSIX_PRIORITY_SCHEDULING\t(-1)\t\t/* [PS] */", "#define\t_POSIX_RAW_SOCKETS\t\t(-1)\t\t/* [RS] */", "#define\t_POSIX_READER_WRITER_LOCKS\t200112L\t\t/* [THR] */", "#define\t_POSIX_REALTIME_SIGNALS\t\t(-1)\t\t/* [RTS] */", "#define\t_POSIX_REGEXP\t\t\t200112L", "#define\t_POSIX_SAVED_IDS\t\t200112L\t\t/* XXX required */", "#define\t_POSIX_SEMAPHORES\t\t(-1)\t\t/* [SEM] */", "#define\t_POSIX_SHARED_MEMORY_OBJECTS\t(-1)\t\t/* [SHM] */", "#define\t_POSIX_SHELL\t\t\t200112L", "#define\t_POSIX_SPAWN\t\t\t(-1)\t\t/* [SPN] */", "#define\t_POSIX_SPIN_LOCKS\t\t(-1)\t\t/* [SPI] */", "#define\t_POSIX_SPORADIC_SERVER\t\t(-1)\t\t/* [SS] */", "#define\t_POSIX_SYNCHRONIZED_IO\t\t(-1)\t\t/* [SIO] */", "#define\t_POSIX_THREAD_ATTR_STACKADDR\t200112L\t\t/* [TSA] */", "#define\t_POSIX_THREAD_ATTR_STACKSIZE\t200112L\t\t/* [TSS] */", "#define\t_POSIX_THREAD_CPUTIME\t\t(-1)\t\t/* [TCT] */", "#define\t_POSIX_THREAD_PRIO_INHERIT\t(-1)\t\t/* [TPI] */", "#define\t_POSIX_THREAD_PRIO_PROTECT\t(-1)\t\t/* [TPP] */", "#define\t_POSIX_THREAD_PRIORITY_SCHEDULING\t(-1)\t/* [TPS] */", "#define\t_POSIX_THREAD_PROCESS_SHARED\t200112L\t\t/* [TSH] */", "#define\t_POSIX_THREAD_SAFE_FUNCTIONS\t200112L\t\t/* [TSF] */", "#define\t_POSIX_THREAD_SPORADIC_SERVER\t(-1)\t\t/* [TSP] */", "#define\t_POSIX_THREADS\t\t\t200112L\t\t/* [THR] */", "#define\t_POSIX_TIMEOUTS\t\t\t(-1)\t\t/* [TMO] */", "#define\t_POSIX_TIMERS\t\t\t(-1)\t\t/* [TMR] */", "#define\t_POSIX_TRACE\t\t\t(-1)\t\t/* [TRC] */", "#define\t_POSIX_TRACE_EVENT_FILTER\t(-1)\t\t/* [TEF] */", "#define\t_POSIX_TRACE_INHERIT\t\t(-1)\t\t/* [TRI] */", "#define\t_POSIX_TRACE_LOG\t\t(-1)\t\t/* [TRL] */", "#define\t_POSIX_TYPED_MEMORY_OBJECTS\t(-1)\t\t/* [TYM] */", "#ifndef _POSIX_VDISABLE", "#define\t_POSIX_VDISABLE\t\t\t0xff\t\t/* same as sys/termios.h */", "#endif /* _POSIX_VDISABLE */", "", "#if __DARWIN_C_LEVEL >= 199209L", "#define\t_POSIX2_C_BIND\t\t\t200112L", "#define\t_POSIX2_C_DEV\t\t\t200112L\t\t/* c99 command */", "#define\t_POSIX2_CHAR_TERM\t\t200112L", "#define\t_POSIX2_FORT_DEV\t\t(-1)\t\t/* fort77 command */", "#define\t_POSIX2_FORT_RUN\t\t200112L", "#define\t_POSIX2_LOCALEDEF\t\t200112L\t\t/* localedef command */", "#define\t_POSIX2_PBS\t\t\t(-1)", "#define\t_POSIX2_PBS_ACCOUNTING\t\t(-1)", "#define\t_POSIX2_PBS_CHECKPOINT\t\t(-1)", "#define\t_POSIX2_PBS_LOCATE\t\t(-1)", "#define\t_POSIX2_PBS_MESSAGE\t\t(-1)", "#define\t_POSIX2_PBS_TRACK\t\t(-1)", "#define\t_POSIX2_SW_DEV\t\t\t200112L", "#define\t_POSIX2_UPE\t\t\t200112L\t/* XXXX no fc, newgrp, tabs */", "#endif /* __DARWIN_C_LEVEL */", "", "#define\t__ILP32_OFF32          (-1)", "#define\t__ILP32_OFFBIG         (1)", "#define\t__LP64_OFF64           (1)", "#define\t__LPBIG_OFFBIG         (1)", "", "#if __DARWIN_C_LEVEL >= 200112L", "#define\t_POSIX_V6_ILP32_OFF32\t\t__ILP32_OFF32", "#define\t_POSIX_V6_ILP32_OFFBIG\t\t__ILP32_OFFBIG", "#define\t_POSIX_V6_LP64_OFF64\t\t__LP64_OFF64", "#define\t_POSIX_V6_LPBIG_OFFBIG\t\t__LPBIG_OFFBIG", "#endif /* __DARWIN_C_LEVEL >= 200112L */", "", "#if __DARWIN_C_LEVEL >= 200809L", "#define\t_POSIX_V7_ILP32_OFF32\t\t__ILP32_OFF32", "#define\t_POSIX_V7_ILP32_OFFBIG\t\t__ILP32_OFFBIG", "#define\t_POSIX_V7_LP64_OFF64\t\t__LP64_OFF64", "#define\t_POSIX_V7_LPBIG_OFFBIG\t\t__LPBIG_OFFBIG", "#endif /* __DARWIN_C_LEVEL >= 200809L */", "", "#if __DARWIN_C_LEVEL >= __DARWIN_C_FULL", "#define\t_V6_ILP32_OFF32             __ILP32_OFF32", "#define\t_V6_ILP32_OFFBIG            __ILP32_OFFBIG", "#define\t_V6_LP64_OFF64              __LP64_OFF64", "#define\t_V6_LPBIG_OFFBIG            __LPBIG_OFFBIG", "#endif /* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */", "", "#if (__DARWIN_C_LEVEL >= 199506L && __DARWIN_C_LEVEL < 200809L) || __DARWIN_C_LEVEL >= __DARWIN_C_FULL", "/* Removed in Issue 7 */", "#define\t_XBS5_ILP32_OFF32\t\t    __ILP32_OFF32", "#define\t_XBS5_ILP32_OFFBIG\t\t    __ILP32_OFFBIG", "#define\t_XBS5_LP64_OFF64\t\t    __LP64_OFF64", "#define\t_XBS5_LPBIG_OFFBIG\t\t    __LPBIG_OFFBIG", "#endif /* __DARWIN_C_LEVEL < 200809L */", "", "#if __DARWIN_C_LEVEL >= 199506L /* This really should be XSI */ ", "#define\t_XOPEN_CRYPT\t\t\t(1)", "#define\t_XOPEN_ENH_I18N\t\t\t(1)\t\t/* XXX required */", "#define\t_XOPEN_LEGACY\t\t\t(-1)\t/* no ftime gcvt, wcswcs */", "#define\t_XOPEN_REALTIME\t\t\t(-1)\t/* no q'ed signals, mq_* */", "#define\t_XOPEN_REALTIME_THREADS\t\t(-1)\t/* no posix_spawn, et. al. */", "#define\t_XOPEN_SHM\t\t\t(1)", "#define\t_XOPEN_STREAMS\t\t\t(-1)   /* Issue 6 */", "#define\t_XOPEN_UNIX\t\t\t(1)", "#endif /* XSI */", "", "/* configurable system variables */", "#define\t_SC_ARG_MAX\t\t\t 1", "#define\t_SC_CHILD_MAX\t\t\t 2", "#define\t_SC_CLK_TCK\t\t\t 3", "#define\t_SC_NGROUPS_MAX\t\t\t 4", "#define\t_SC_OPEN_MAX\t\t\t 5", "#define\t_SC_JOB_CONTROL\t\t\t 6", "#define\t_SC_SAVED_IDS\t\t\t 7", "#define\t_SC_VERSION\t\t\t 8", "#define\t_SC_BC_BASE_MAX\t\t\t 9", "#define\t_SC_BC_DIM_MAX\t\t\t10", "#define\t_SC_BC_SCALE_MAX\t\t11", "#define\t_SC_BC_STRING_MAX\t\t12", "#define\t_SC_COLL_WEIGHTS_MAX\t\t13", "#define\t_SC_EXPR_NEST_MAX\t\t14", "#define\t_SC_LINE_MAX\t\t\t15", "#define\t_SC_RE_DUP_MAX\t\t\t16", "#define\t_SC_2_VERSION\t\t\t17", "#define\t_SC_2_C_BIND\t\t\t18", "#define\t_SC_2_C_DEV\t\t\t19", "#define\t_SC_2_CHAR_TERM\t\t\t20", "#define\t_SC_2_FORT_DEV\t\t\t21", "#define\t_SC_2_FORT_RUN\t\t\t22", "#define\t_SC_2_LOCALEDEF\t\t\t23", "#define\t_SC_2_SW_DEV\t\t\t24", "#define\t_SC_2_UPE\t\t\t25", "#define\t_SC_STREAM_MAX\t\t\t26", "#define\t_SC_TZNAME_MAX\t\t\t27", "", "#if __DARWIN_C_LEVEL >= 199309L", "#define\t_SC_ASYNCHRONOUS_IO\t\t28", "#define\t_SC_PAGESIZE\t\t\t29", "#define\t_SC_MEMLOCK\t\t\t30", "#define\t_SC_MEMLOCK_RANGE\t\t31", "#define\t_SC_MEMORY_PROTECTION\t\t32", "#define\t_SC_MESSAGE_PASSING\t\t33", "#define\t_SC_PRIORITIZED_IO\t\t34", "#define\t_SC_PRIORITY_SCHEDULING\t\t35", "#define\t_SC_REALTIME_SIGNALS\t\t36", "#define\t_SC_SEMAPHORES\t\t\t37", "#define\t_SC_FSYNC\t\t\t38", "#define\t_SC_SHARED_MEMORY_OBJECTS \t39", "#define\t_SC_SYNCHRONIZED_IO\t\t40", "#define\t_SC_TIMERS\t\t\t41", "#define\t_SC_AIO_LISTIO_MAX\t\t42", "#define\t_SC_AIO_MAX\t\t\t43", "#define\t_SC_AIO_PRIO_DELTA_MAX\t\t44", "#define\t_SC_DELAYTIMER_MAX\t\t45", "#define\t_SC_MQ_OPEN_MAX\t\t\t46", "#define\t_SC_MAPPED_FILES\t\t47\t/* swap _SC_PAGESIZE vs. BSD */", "#define\t_SC_RTSIG_MAX\t\t\t48", "#define\t_SC_SEM_NSEMS_MAX\t\t49", "#define\t_SC_SEM_VALUE_MAX\t\t50", "#define\t_SC_SIGQUEUE_MAX\t\t51", "#define\t_SC_TIMER_MAX\t\t\t52", "#endif /* __DARWIN_C_LEVEL >= 199309L */", "", "#if __DARWIN_C_LEVEL >= __DARWIN_C_FULL", "#define\t_SC_NPROCESSORS_CONF\t\t57", "#define\t_SC_NPROCESSORS_ONLN\t\t58", "#endif /* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */", "", "#if __DARWIN_C_LEVEL >= 200112L", "#define\t_SC_2_PBS\t\t\t59", "#define\t_SC_2_PBS_ACCOUNTING\t\t60", "#define\t_SC_2_PBS_CHECKPOINT\t\t61", "#define\t_SC_2_PBS_LOCATE\t\t62", "#define\t_SC_2_PBS_MESSAGE\t\t63", "#define\t_SC_2_PBS_TRACK\t\t\t64", "#define\t_SC_ADVISORY_INFO\t\t65", "#define\t_SC_BARRIERS\t\t\t66", "#define\t_SC_CLOCK_SELECTION\t\t67", "#define\t_SC_CPUTIME\t\t\t68", "#define\t_SC_FILE_LOCKING\t\t69", "#define\t_SC_GETGR_R_SIZE_MAX\t\t70", "#define\t_SC_GETPW_R_SIZE_MAX\t\t71", "#define\t_SC_HOST_NAME_MAX\t\t72", "#define\t_SC_LOGIN_NAME_MAX\t\t73", "#define\t_SC_MONOTONIC_CLOCK\t\t74", "#define\t_SC_MQ_PRIO_MAX\t\t\t75", "#define\t_SC_READER_WRITER_LOCKS\t\t76", "#define\t_SC_REGEXP\t\t\t77", "#define\t_SC_SHELL\t\t\t78", "#define\t_SC_SPAWN\t\t\t79", "#define\t_SC_SPIN_LOCKS\t\t\t80", "#define\t_SC_SPORADIC_SERVER\t\t81", "#define\t_SC_THREAD_ATTR_STACKADDR\t82", "#define\t_SC_THREAD_ATTR_STACKSIZE\t83", "#define\t_SC_THREAD_CPUTIME\t\t84", "#define\t_SC_THREAD_DESTRUCTOR_ITERATIONS 85", "#define\t_SC_THREAD_KEYS_MAX\t\t86", "#define\t_SC_THREAD_PRIO_INHERIT\t\t87", "#define\t_SC_THREAD_PRIO_PROTECT\t\t88", "#define\t_SC_THREAD_PRIORITY_SCHEDULING\t89", "#define\t_SC_THREAD_PROCESS_SHARED\t90", "#define\t_SC_THREAD_SAFE_FUNCTIONS\t91", "#define\t_SC_THREAD_SPORADIC_SERVER\t92", "#define\t_SC_THREAD_STACK_MIN\t\t93", "#define\t_SC_THREAD_THREADS_MAX\t\t94", "#define\t_SC_TIMEOUTS\t\t\t95", "#define\t_SC_THREADS\t\t\t96", "#define\t_SC_TRACE\t\t\t97", "#define\t_SC_TRACE_EVENT_FILTER\t\t98", "#define\t_SC_TRACE_INHERIT\t\t99", "#define\t_SC_TRACE_LOG\t\t\t100", "#define\t_SC_TTY_NAME_MAX\t\t101", "#define\t_SC_TYPED_MEMORY_OBJECTS\t102", "#define\t_SC_V6_ILP32_OFF32\t\t103", "#define\t_SC_V6_ILP32_OFFBIG\t\t104", "#define\t_SC_V6_LP64_OFF64\t\t105", "#define\t_SC_V6_LPBIG_OFFBIG\t\t106", "#define\t_SC_IPV6\t\t\t118", "#define\t_SC_RAW_SOCKETS\t\t\t119", "#define\t_SC_SYMLOOP_MAX\t\t\t120", "#endif /* __DARWIN_C_LEVEL >= 200112L */", "", "#if __DARWIN_C_LEVEL >= 199506L /* Really XSI */", "#define\t_SC_ATEXIT_MAX\t\t\t107", "#define\t_SC_IOV_MAX\t\t\t56", "#define\t_SC_PAGE_SIZE\t\t\t_SC_PAGESIZE", "#define\t_SC_XOPEN_CRYPT\t\t\t108", "#define\t_SC_XOPEN_ENH_I18N\t\t109", "#define\t_SC_XOPEN_LEGACY\t\t110      /* Issue 6 */", "#define\t_SC_XOPEN_REALTIME\t\t111      /* Issue 6 */", "#define\t_SC_XOPEN_REALTIME_THREADS\t112  /* Issue 6 */", "#define\t_SC_XOPEN_SHM\t\t\t113", "#define\t_SC_XOPEN_STREAMS\t\t114      /* Issue 6 */", "#define\t_SC_XOPEN_UNIX\t\t\t115", "#define\t_SC_XOPEN_VERSION\t\t116", "#define\t_SC_XOPEN_XCU_VERSION\t\t121", "#endif /* XSI */", "", "#if (__DARWIN_C_LEVEL >= 199506L && __DARWIN_C_LEVEL < 200809L) || __DARWIN_C_LEVEL >= __DARWIN_C_FULL", "/* Removed in Issue 7 */", "#define\t_SC_XBS5_ILP32_OFF32\t\t122", "#define\t_SC_XBS5_ILP32_OFFBIG\t\t123", "#define\t_SC_XBS5_LP64_OFF64\t\t124", "#define\t_SC_XBS5_LPBIG_OFFBIG\t\t125", "#endif /* __DARWIN_C_LEVEL <= 200809L */", "", "#if __DARWIN_C_LEVEL >= 200112L", "#define\t_SC_SS_REPL_MAX\t\t\t126", "#define\t_SC_TRACE_EVENT_NAME_MAX\t127", "#define\t_SC_TRACE_NAME_MAX\t\t128", "#define\t_SC_TRACE_SYS_MAX\t\t129", "#define\t_SC_TRACE_USER_EVENT_MAX\t130", "#endif", "", "#if __DARWIN_C_LEVEL < 200112L || __DARWIN_C_LEVEL >= __DARWIN_C_FULL", "/* Removed in Issue 6 */", "#define\t_SC_PASS_MAX\t\t\t131", "#endif", "", "#if __DARWIN_C_LEVEL >= 199209L", "#ifndef _CS_PATH /* Defined in <sys/unistd.h> */", "#define\t_CS_PATH\t\t\t\t1", "#endif", "#endif", "", "#if __DARWIN_C_LEVEL >= 200112", "#define\t_CS_POSIX_V6_ILP32_OFF32_CFLAGS\t\t2", "#define\t_CS_POSIX_V6_ILP32_OFF32_LDFLAGS\t3", "#define\t_CS_POSIX_V6_ILP32_OFF32_LIBS\t\t4", "#define\t_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS\t5", "#define\t_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS\t6", "#define\t_CS_POSIX_V6_ILP32_OFFBIG_LIBS\t\t7", "#define\t_CS_POSIX_V6_LP64_OFF64_CFLAGS\t\t8", "#define\t_CS_POSIX_V6_LP64_OFF64_LDFLAGS\t\t9", "#define\t_CS_POSIX_V6_LP64_OFF64_LIBS\t\t10", "#define\t_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS\t11", "#define\t_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS\t12", "#define\t_CS_POSIX_V6_LPBIG_OFFBIG_LIBS\t\t13", "#define\t_CS_POSIX_V6_WIDTH_RESTRICTED_ENVS\t14", "#endif", "", "#if (__DARWIN_C_LEVEL >= 199506L && __DARWIN_C_LEVEL < 200809L) || __DARWIN_C_LEVEL >= __DARWIN_C_FULL", "/* Removed in Issue 7 */", "#define\t_CS_XBS5_ILP32_OFF32_CFLAGS\t\t20", "#define\t_CS_XBS5_ILP32_OFF32_LDFLAGS\t\t21", "#define\t_CS_XBS5_ILP32_OFF32_LIBS\t\t22", "#define\t_CS_XBS5_ILP32_OFF32_LINTFLAGS\t\t23", "#define\t_CS_XBS5_ILP32_OFFBIG_CFLAGS\t\t24", "#define\t_CS_XBS5_ILP32_OFFBIG_LDFLAGS\t\t25", "#define\t_CS_XBS5_ILP32_OFFBIG_LIBS\t\t26", "#define\t_CS_XBS5_ILP32_OFFBIG_LINTFLAGS\t\t27", "#define\t_CS_XBS5_LP64_OFF64_CFLAGS\t\t28", "#define\t_CS_XBS5_LP64_OFF64_LDFLAGS\t\t29", "#define\t_CS_XBS5_LP64_OFF64_LIBS\t\t30", "#define\t_CS_XBS5_LP64_OFF64_LINTFLAGS\t\t31", "#define\t_CS_XBS5_LPBIG_OFFBIG_CFLAGS\t\t32", "#define\t_CS_XBS5_LPBIG_OFFBIG_LDFLAGS\t\t33", "#define\t_CS_XBS5_LPBIG_OFFBIG_LIBS\t\t34", "#define\t_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS\t\t35", "#endif", "", "#if __DARWIN_C_LEVEL >= __DARWIN_C_FULL", "#define\t_CS_DARWIN_USER_DIR\t\t\t65536", "#define\t_CS_DARWIN_USER_TEMP_DIR\t\t65537", "#define\t_CS_DARWIN_USER_CACHE_DIR\t\t65538", "#endif /* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */", "", "", "#ifdef _DARWIN_UNLIMITED_GETGROUPS", "#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_2", '#error "_DARWIN_UNLIMITED_GETGROUPS specified, but -miphoneos-version-min version does not support it."', "#elif defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_6", '#error "_DARWIN_UNLIMITED_GETGROUPS specified, but -mmacosx-version-min version does not support it."', "#endif", "#endif", "", "/* POSIX.1-1990 */", "", "__BEGIN_DECLS", "void\t _exit(int) __dead2;", "int\t access(const char *, int);", "unsigned int", "\t alarm(unsigned int);", "int\t chdir(const char *);", "int\t chown(const char *, uid_t, gid_t);", "", "int\t close(int) __DARWIN_ALIAS_C(close);", "", "int\t dup(int);", "int\t dup2(int, int);", "int\t execl(const char *, const char *, ...);", "int\t execle(const char *, const char *, ...);", "int\t execlp(const char *, const char *, ...);", "int\t execv(const char *, char * const *);", "int\t execve(const char *, char * const *, char * const *);", "int\t execvp(const char *, char * const *);", "pid_t\t fork(void);", "long\t fpathconf(int, int);", "char\t*getcwd(char *, size_t);", "gid_t\t getegid(void);", "uid_t\t geteuid(void);", "gid_t\t getgid(void);", "#if defined(_DARWIN_UNLIMITED_GETGROUPS) || defined(_DARWIN_C_SOURCE)", "int\t getgroups(int, gid_t []) __DARWIN_ALIAS_STARTING(__MAC_10_6, __IPHONE_3_2, __DARWIN_EXTSN(getgroups));", "#else /* !_DARWIN_UNLIMITED_GETGROUPS && !_DARWIN_C_SOURCE */", "int\t getgroups(int, gid_t []);", "#endif /* _DARWIN_UNLIMITED_GETGROUPS || _DARWIN_C_SOURCE */", "char\t*getlogin(void);", "pid_t\t getpgrp(void);", "pid_t\t getpid(void);", "pid_t\t getppid(void);", "uid_t\t getuid(void);", "int\t isatty(int);", "int\t link(const char *, const char *);", "off_t\t lseek(int, off_t, int);", "long\t pathconf(const char *, int);", "", "int\t pause(void) __DARWIN_ALIAS_C(pause);", "", "int\t pipe(int [2]);", "", "ssize_t\t read(int, void *, size_t) __DARWIN_ALIAS_C(read);", "", "int\t rmdir(const char *);", "int\t setgid(gid_t);", "int\t setpgid(pid_t, pid_t);", "pid_t\t setsid(void);", "int\t setuid(uid_t);", "", "unsigned int", "\t sleep(unsigned int) __DARWIN_ALIAS_C(sleep);", "", "long\t sysconf(int);", "pid_t\t tcgetpgrp(int);", "int\t tcsetpgrp(int, pid_t);", "char\t*ttyname(int);", "", "#if __DARWIN_UNIX03", "int\t ttyname_r(int, char *, size_t) __DARWIN_ALIAS(ttyname_r);", "#else /* !__DARWIN_UNIX03 */", "char\t*ttyname_r(int, char *, size_t);", "#endif /* __DARWIN_UNIX03 */", "", "int\t unlink(const char *);", "", "ssize_t\t write(int, const void *, size_t) __DARWIN_ALIAS_C(write);", "__END_DECLS", "", "", "", "/* Additional functionality provided by:", " * POSIX.2-1992 C Language Binding Option", " */", "", "#if __DARWIN_C_LEVEL >= 199209L", "__BEGIN_DECLS", "size_t\t confstr(int, char *, size_t) __DARWIN_ALIAS(confstr);", "", "int\t getopt(int, char * const [], const char *) __DARWIN_ALIAS(getopt);", "", "extern char *optarg;\t\t\t/* getopt(3) external variables */", "extern int optind, opterr, optopt;", "__END_DECLS", "#endif /* __DARWIN_C_LEVEL >= 199209L */", "", "", "", "/* Additional functionality provided by:", " * POSIX.1c-1995,", " * POSIX.1i-1995,", " * and the omnibus ISO/IEC 9945-1: 1996", " */", "", "#if __DARWIN_C_LEVEL >= 199506L", "                               /* These F_* are really XSI or Issue 6 */", "#define F_ULOCK         0      /* unlock locked section */", "#define\tF_LOCK          1      /* lock a section for exclusive use */", "#define\tF_TLOCK         2      /* test and lock a section for exclusive use */", "#define\tF_TEST          3      /* test a section for locks by other procs */", "", " __BEGIN_DECLS", "", "/* Begin XSI */", "/* Removed in Issue 6 */", "#if !defined(_POSIX_C_SOURCE) || _POSIX_C_SOURCE < 200112L", "#if !defined(_POSIX_C_SOURCE)", "__deprecated", "#endif", "void\t*brk(const void *);", "int\t chroot(const char *) __POSIX_C_DEPRECATED(199506L);", "#endif", "", "char\t*crypt(const char *, const char *);", "#ifndef __CTERMID_DEFINED", "/* Multiply defined in stdio.h and unistd.h by SUS */", "#define __CTERMID_DEFINED 1", "char    *ctermid(char *);", "#endif", "#if __DARWIN_UNIX03", "void\t encrypt(char *, int) __DARWIN_ALIAS(encrypt);", "#else /* !__DARWIN_UNIX03 */", "int\t encrypt(char *, int);", "#endif /* __DARWIN_UNIX03 */", "int\t fchdir(int);", "long\t gethostid(void);", "pid_t\t getpgid(pid_t);", "pid_t\t getsid(pid_t);", "", "/* Removed in Issue 6 */", "#if !defined(_POSIX_C_SOURCE) || _POSIX_C_SOURCE < 200112L", "int\t getdtablesize(void) __POSIX_C_DEPRECATED(199506L);", "int\t getpagesize(void) __pure2 __POSIX_C_DEPRECATED(199506L);", "char\t*getpass(const char *) __POSIX_C_DEPRECATED(199506L);", "#endif", "", "/* Removed in Issue 7 */", "#if !defined(_POSIX_C_SOURCE) || _POSIX_C_SOURCE < 200809L", "char\t*getwd(char *) __POSIX_C_DEPRECATED(200112L); /* obsoleted by getcwd() */", "#endif", "", "int\t lchown(const char *, uid_t, gid_t) __DARWIN_ALIAS(lchown);", "", "int\t lockf(int, int, off_t) __DARWIN_ALIAS_C(lockf);", "", "int\t nice(int) __DARWIN_ALIAS(nice);", "", "ssize_t\t pread(int, void *, size_t, off_t) __DARWIN_ALIAS_C(pread);", "", "ssize_t\t pwrite(int, const void *, size_t, off_t) __DARWIN_ALIAS_C(pwrite);", "", "/* Removed in Issue 6 */", "#if !defined(_POSIX_C_SOURCE) || _POSIX_C_SOURCE < 200112L", "/* Note that Issue 5 changed the argument as intprt_t,", " * but we keep it as int for binary compatability. */", "#if !defined(_POSIX_C_SOURCE)", "__deprecated", "#endif", "void\t*sbrk(int);", "#endif", "", "#if __DARWIN_UNIX03", "pid_t\t setpgrp(void) __DARWIN_ALIAS(setpgrp);", "#else /* !__DARWIN_UNIX03 */", "int\t setpgrp(pid_t pid, pid_t pgrp);\t/* obsoleted by setpgid() */", "#endif /* __DARWIN_UNIX03 */", "", "int\t setregid(gid_t, gid_t) __DARWIN_ALIAS(setregid);", "", "int\t setreuid(uid_t, uid_t) __DARWIN_ALIAS(setreuid);", "", "void     swab(const void * __restrict, void * __restrict, ssize_t);", "void\t sync(void);", "int\t truncate(const char *, off_t);", "useconds_t\t ualarm(useconds_t, useconds_t);", "int\t usleep(useconds_t) __DARWIN_ALIAS_C(usleep);", "pid_t\t vfork(void);", "/* End XSI */", "", "int\t fsync(int) __DARWIN_ALIAS_C(fsync);", "", "int\t ftruncate(int, off_t);", "int\t getlogin_r(char *, size_t);", "__END_DECLS", "#endif /* __DARWIN_C_LEVEL >= 199506L */", "", "", "", "/* Additional functionality provided by:", " * POSIX.1-2001", " * ISO C99", " */", "", "#if __DARWIN_C_LEVEL >= 200112L", "__BEGIN_DECLS", "int\t fchown(int, uid_t, gid_t);", "int\t gethostname(char *, size_t);", "ssize_t  readlink(const char * __restrict, char * __restrict, size_t);", "int\t setegid(gid_t);", "int\t seteuid(uid_t);", "int\t symlink(const char *, const char *);", "__END_DECLS", "#endif /* __DARWIN_C_LEVEL >= 200112L */", "", "", "", "/* Darwin extensions */", "", "#if __DARWIN_C_LEVEL >= __DARWIN_C_FULL", "#include <sys/select.h>", "", "#include <sys/_types/_dev_t.h>", "#include <sys/_types/_mode_t.h>", "#include <sys/_types/_uuid_t.h>", "", "__BEGIN_DECLS", "void\t _Exit(int) __dead2;", "int\t accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t);", "int\t acct(const char *);", "int\t add_profil(char *, size_t, unsigned long, unsigned int);", "void\t endusershell(void);", "int\t execvP(const char *, const char *, char * const *);", "char\t*fflagstostr(unsigned long);", "int\t getdomainname(char *, int);", "int\t getgrouplist(const char *, int, int *, int *);", "#if defined(__has_include)", "#if __has_include(<gethostuuid_private.h>)", "#include <gethostuuid_private.h>", "#else", "#include <gethostuuid.h>", "#endif", "#else", "#include <gethostuuid.h>", "#endif", "mode_t\t getmode(const void *, mode_t);", "int\t getpeereid(int, uid_t *, gid_t *);", "int\t getsgroups_np(int *, uuid_t);", "char\t*getusershell(void);", "int\t getwgroups_np(int *, uuid_t);", "int\t initgroups(const char *, int);", "int\t iruserok(unsigned long, int, const char *, const char *);", "int\t iruserok_sa(const void *, int, int, const char *, const char *);", "int\t issetugid(void);", "char\t*mkdtemp(char *);", "int\t mknod(const char *, mode_t, dev_t);", "int\t mkpath_np(const char *path, mode_t omode) __OSX_AVAILABLE_STARTING(__MAC_10_8, __IPHONE_5_0); /* returns errno */", "int\t mkstemp(char *);", "int\t mkstemps(char *, int);", "char\t*mktemp(char *);", "int\t nfssvc(int, void *);", "int\t profil(char *, size_t, unsigned long, unsigned int);", "int\t pthread_setugid_np(uid_t, gid_t);", "int\t pthread_getugid_np( uid_t *, gid_t *);", "int\t rcmd(char **, int, const char *, const char *, const char *, int *);", "int\t rcmd_af(char **, int, const char *, const char *, const char *, int *,", "\t\tint);", "int\t reboot(int);", "int\t revoke(const char *);", "int\t rresvport(int *);", "int\t rresvport_af(int *, int);", "int\t ruserok(const char *, int, const char *, const char *);", "int\t setdomainname(const char *, int);", "int\t setgroups(int, const gid_t *);", "void\t sethostid(long);", "int\t sethostname(const char *, int);", "#if __DARWIN_UNIX03", "void\t setkey(const char *) __DARWIN_ALIAS(setkey);", "#else /* !__DARWIN_UNIX03 */", "int\t setkey(const char *);", "#endif /* __DARWIN_UNIX03 */", "int\t setlogin(const char *);", "void\t*setmode(const char *) __DARWIN_ALIAS_STARTING(__MAC_10_6, __IPHONE_2_0, __DARWIN_ALIAS(setmode));", "int\t setrgid(gid_t);", "int\t setruid(uid_t);", "int\t setsgroups_np(int, const uuid_t);", "void\t setusershell(void);", "int\t setwgroups_np(int, const uuid_t);", "int\t strtofflags(char **, unsigned long *, unsigned long *);", "int\t swapon(const char *);", "int\t syscall(int, ...);", "int\t ttyslot(void);", "int\t undelete(const char *);", "int\t unwhiteout(const char *);", "void\t*valloc(size_t);\t\t\t", "", "extern char *suboptarg;\t\t\t/* getsubopt(3) external variable */", "int\t getsubopt(char **, char * const *, char **);", "", "/*  HFS & HFS Plus semantics system calls go here */", "#ifdef __LP64__", "int    fgetattrlist(int,void*,void*,size_t,unsigned int) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_0);", "int    fsetattrlist(int,void*,void*,size_t,unsigned int) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_0);", "int    getattrlist(const char*,void*,void*,size_t,unsigned int) __DARWIN_ALIAS(getattrlist);", "int    setattrlist(const char*,void*,void*,size_t,unsigned int) __DARWIN_ALIAS(setattrlist);", "int exchangedata(const char*,const char*,unsigned int);", "int    getdirentriesattr(int,void*,void*,size_t,unsigned int*,unsigned int*,unsigned int*,unsigned int);", "", "#else /* __LP64__ */", "int\tfgetattrlist(int,void*,void*,size_t,unsigned long) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_0);", "int\tfsetattrlist(int,void*,void*,size_t,unsigned long) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_0);", "int\tgetattrlist(const char*,void*,void*,size_t,unsigned long) __DARWIN_ALIAS(getattrlist);", "int\tsetattrlist(const char*,void*,void*,size_t,unsigned long) __DARWIN_ALIAS(setattrlist);", "int exchangedata(const char*,const char*,unsigned long);", "int\tgetdirentriesattr(int,void*,void*,size_t,unsigned long*,unsigned long*,unsigned long*,unsigned long);", "", "#endif /* __LP64__ */", "", "struct fssearchblock;", "struct searchstate;", "", "int\t searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *);", "int\t fsctl(const char *,unsigned long,void*,unsigned int);", "int\t ffsctl(int,unsigned long,void*,unsigned int) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_0);", "", "#define\tSYNC_VOLUME_FULLSYNC\t0x01\t/* Flush data and metadata to platter, not just to disk cache */", "#define SYNC_VOLUME_WAIT\t0x02\t/* Wait for sync to complete */", "", "int\tfsync_volume_np(int, int) __OSX_AVAILABLE_STARTING(__MAC_10_8, __IPHONE_6_0);", "int\tsync_volume_np(const char *, int) __OSX_AVAILABLE_STARTING(__MAC_10_8, __IPHONE_6_0);", "", "extern int optreset;", "", "__END_DECLS", "#endif /* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */", "", "#endif /* _UNISTD_H_ */" },
    ["unwind.h"] = { "/* -*- mode: C++; c-basic-offset: 4; -*- ", " *", " * Copyright (c) 2010-2011 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " * ", " * ", " *            C interface to libuwind ", " *", " * Source compatible with Level 1 Base ABI documented at:", " *    http://www.codesourcery.com/public/cxx-abi/abi-eh.html", " * ", " */", "", "", "#ifndef __UNWIND_H__", "#define __UNWIND_H__", "", "#include <stdint.h>", "#include <stddef.h>", "#include <Availability.h>", "", "", "typedef enum {", "\t_URC_NO_REASON = 0,", "\t_URC_FOREIGN_EXCEPTION_CAUGHT = 1,", "\t_URC_FATAL_PHASE2_ERROR = 2,", "\t_URC_FATAL_PHASE1_ERROR = 3,", "\t_URC_NORMAL_STOP = 4,", "\t_URC_END_OF_STACK = 5,", "\t_URC_HANDLER_FOUND = 6,", "\t_URC_INSTALL_CONTEXT = 7,", "\t_URC_CONTINUE_UNWIND = 8", "} _Unwind_Reason_Code;", "", "typedef enum {", "        _UA_SEARCH_PHASE = 1,", "        _UA_CLEANUP_PHASE = 2,", "        _UA_HANDLER_FRAME = 4,", "        _UA_FORCE_UNWIND = 8,", "        _UA_END_OF_STACK = 16\t// gcc extension to C++ ABI", "} _Unwind_Action;", "", "", "struct _Unwind_Context;\t\t// opaque ", "struct _Unwind_Exception;\t// forward declaration", "", "struct _Unwind_Exception {", "\tuint64_t                   exception_class;", "\tvoid\t\t\t\t\t (*exception_cleanup)(_Unwind_Reason_Code reason, struct _Unwind_Exception* exc);", "\tuintptr_t                  private_1;        // non-zero means forced unwind", "\tuintptr_t                  private_2;        // holds sp that phase1 found for phase2 to use", "#if !__LP64__", "\t// The gcc implementation of _Unwind_Exception used attribute mode on the above fields", "\t// which had the side effect of causing this whole struct to round up to 32 bytes in size.", "\t// To be more explicit, we add pad fields added for binary compatibility.  ", "\tuint32_t\t\t\t\treserved[3];", "#endif", "};", "", "", "typedef _Unwind_Reason_Code (*_Unwind_Stop_Fn)", "\t\t(int version,", "\t\t _Unwind_Action actions,", "\t\t uint64_t exceptionClass,", "\t\t struct _Unwind_Exception* exceptionObject,", "\t\t struct _Unwind_Context* context,", "\t\t void* stop_parameter );", "", "", "typedef _Unwind_Reason_Code (*__personality_routine)", "\t    (int version,", "\t     _Unwind_Action actions,", "\t     uint64_t exceptionClass,", "\t     struct _Unwind_Exception* exceptionObject,", "\t     struct _Unwind_Context* context);", "\t\t ", "", "\t\t ", "#ifdef __cplusplus", 'extern "C" {', "#endif", "", "//", "// The following are the base functions documented by the C++ ABI", "//", "#if __arm__", "\textern _Unwind_Reason_Code _Unwind_SjLj_RaiseException(struct _Unwind_Exception* exception_object);", "\textern void\t\t          _Unwind_SjLj_Resume(struct _Unwind_Exception* exception_object);", "#else", "\textern _Unwind_Reason_Code _Unwind_RaiseException(struct _Unwind_Exception* exception_object);", "\textern void\t\t          _Unwind_Resume(struct _Unwind_Exception* exception_object);", "#endif", "extern void\t\t_Unwind_DeleteException(struct _Unwind_Exception* exception_object);", "extern uintptr_t _Unwind_GetGR(struct _Unwind_Context* context, int index);", "extern void\t\t_Unwind_SetGR(struct _Unwind_Context* context, int index, uintptr_t new_value);", "extern uintptr_t _Unwind_GetIP(struct _Unwind_Context* context);", "extern void\t\t_Unwind_SetIP(struct _Unwind_Context*, uintptr_t new_value);", "extern uintptr_t _Unwind_GetRegionStart(struct _Unwind_Context* context);", "extern uintptr_t _Unwind_GetLanguageSpecificData(struct _Unwind_Context* context);", "#if __arm__", "\textern _Unwind_Reason_Code _Unwind_SjLj_ForcedUnwind(struct _Unwind_Exception* exception_object, _Unwind_Stop_Fn stop, void* stop_parameter );", "#else\t", "\textern _Unwind_Reason_Code _Unwind_ForcedUnwind(struct _Unwind_Exception* exception_object, _Unwind_Stop_Fn stop, void* stop_parameter );", "#endif", "", "#if __arm__", "\ttypedef struct _Unwind_FunctionContext* _Unwind_FunctionContext_t;", "\textern void _Unwind_SjLj_Register(_Unwind_FunctionContext_t fc);", "\textern void _Unwind_SjLj_Unregister(_Unwind_FunctionContext_t fc);", "#endif\t", "\t", "//", "// The following are semi-suppoted extensions to the C++ ABI", "//", "", "", "//", "//\tcalled by __cxa_rethrow().  ", "//", "#if __arm__", "\textern _Unwind_Reason_Code _Unwind_SjLj_Resume_or_Rethrow(struct _Unwind_Exception* exception_object);", "#else", "\textern _Unwind_Reason_Code _Unwind_Resume_or_Rethrow(struct _Unwind_Exception* exception_object);", "#endif", "\t", "", "//", "// _Unwind_Backtrace() is a gcc extension that walks the stack and calls the ", "// _Unwind_Trace_Fn once per frame until it reaches the bottom of the stack", "// or the _Unwind_Trace_Fn function returns something other than _URC_NO_REASON.", "//", "typedef _Unwind_Reason_Code (*_Unwind_Trace_Fn)(struct _Unwind_Context*, void*);", "extern _Unwind_Reason_Code\t_Unwind_Backtrace(_Unwind_Trace_Fn, void*);", "", "", "//", "// _Unwind_GetCFA is a gcc extension that can be called from within a personality ", "// handler to get the CFA (stack pointer before call) of current frame.", "//", "extern uintptr_t _Unwind_GetCFA(struct _Unwind_Context*);", "", "", "//", "// _Unwind_GetIPInfo is a gcc extension that can be called from within a personality ", "// handler.  Similar to _Unwind_GetIP() but also returns in *ipBefore a non-zero ", "// value if the instruction pointer is at or before the instruction causing ", "// the unwind.  Normally, in a function call, the IP returned is the return address", "// which is after the call instruction and may be past the end of the function", "// containing the call instruction.", "//", "extern uintptr_t _Unwind_GetIPInfo(struct _Unwind_Context* context, int* ipBefore);", "", "", "//", "// __register_frame() is used with dynamically generated code to register the FDE", "// for a generated (JIT) code.  The FDE must use pc-rel addressing to point to its", "// function and optional LSDA.  __register_frame() has existed in all versions of", "// Mac OS X, but in 10.4 and 10.5 it was buggy and did not actually register the ", "// FDE with the unwinder.  In 10.6 and later it does register properly.", "//", "extern void\t__register_frame(const void* fde);", "extern void\t__deregister_frame(const void* fde);", "", "", "//", "// _Unwind_Find_FDE() will locate the FDE if the pc is in some function that has", '// an associated FDE. Note, Mac OS X 10.6 and later, introduces "compact unwind info"', "// which the runtime uses in preference to dwarf unwind info.  This function", "// will only work if the target function has an FDE but no compact unwind info.", "//", "struct dwarf_eh_bases", "{", "    uintptr_t tbase;", "    uintptr_t dbase;", "    uintptr_t func;", "};", "extern const void* _Unwind_Find_FDE(const void* pc, struct dwarf_eh_bases*);", "", "", "//", "// This function attempts to find the start (address of first instruction) of", "// a function given an address inside the function.  It only works if the function", "// has an FDE (dwarf unwind info).  ", "// This function is unimplemented on Mac OS X 10.6 and later.  Instead, use", "// _Unwind_Find_FDE() and look at the dwarf_eh_bases.func result.", "extern void* _Unwind_FindEnclosingFunction(void* pc);", "", "", "// Mac OS X does not support text-rel and data-rel addressing so these functions are unimplemented", "extern uintptr_t _Unwind_GetDataRelBase(struct _Unwind_Context* context) __attribute__((unavailable));", "extern uintptr_t _Unwind_GetTextRelBase(struct _Unwind_Context* context) __attribute__((unavailable));", "", "", "", "// Mac OS X 10.4 and 10.5 had implementations of these functions in libgcc_s.dylib,", "// but they never worked.  These functions are no longer available.", "extern void\t __register_frame_info_bases(const void* fde, void* ob, void* tb, void* db) __attribute__((unavailable));", "extern void\t __register_frame_info(const void* fde, void* ob) __attribute__((unavailable));", "extern void\t __register_frame_info_table_bases(const void* fde, void* ob,void* tb, void* db) __attribute__((unavailable));", "extern void\t __register_frame_info_table(const void* fde, void* ob) __attribute__((unavailable));", "extern void\t __register_frame_table(const void* fde) __attribute__((unavailable));", "extern void* __deregister_frame_info(const void* fde) __attribute__((unavailable));", "extern void* __deregister_frame_info_bases(const void* fde) __attribute__((unavailable));", "", "", "#ifdef __cplusplus", "}", "#endif", "", "", "", "#endif // __UNWIND_H__", "", "" },
    ["util.h"] = { "/*", " * Copyright (c) 2000, 2007, 2008 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/*\t$NetBSD: util.h,v 1.10 1997/12/01 02:25:46 lukem Exp $\t*/", "", "/*-", " * Copyright (c) 1995", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " */", "", "#ifndef _UTIL_H_", "#define _UTIL_H_", "", "#include <sys/cdefs.h>", "#include <sys/ttycom.h>", "#include <sys/types.h>", "#include <stdio.h>", "#include <pwd.h>", "#include <termios.h>", "#include <Availability.h>", "", "#define\tPIDLOCK_NONBLOCK\t1", "#define PIDLOCK_USEHOSTNAME\t2", "", "/*", " * fparseln() specific operation flags.", " */", "#define\tFPARSELN_UNESCESC\t0x01", "#define\tFPARSELN_UNESCCONT\t0x02", "#define\tFPARSELN_UNESCCOMM\t0x04", "#define\tFPARSELN_UNESCREST\t0x08", "#define\tFPARSELN_UNESCALL\t0x0f", "", "/*", " * opendev() specific operation flags.", " */", "#define OPENDEV_PART\t0x01\t\t/* Try to open the raw partition. */", "#define OPENDEV_BLCK\t0x04\t\t/* Open block, not character device. */", "", "__BEGIN_DECLS", "struct utmp; /* forward reference to /usr/include/utmp.h */", "void\tlogin(struct utmp *)\t\t__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0,__MAC_10_5,__IPHONE_NA,__IPHONE_NA);", "int\tlogin_tty(int);", "int\tlogout(const char *)\t\t__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0,__MAC_10_5,__IPHONE_NA,__IPHONE_NA);", "void\tlogwtmp(const char *, const char *, const char *) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0,__MAC_10_5,__IPHONE_2_0,__IPHONE_2_0);", "int\topendev(char *, int, int, char **);", "int\topenpty(int *, int *, char *, struct termios *,", "\t\t     struct winsize *);", "char   *fparseln(FILE *, size_t *, size_t *, const char[3], int);", "pid_t\tforkpty(int *, char *, struct termios *, struct winsize *);", "int\tpidlock(const char *, int, pid_t *, const char *);", "int\tttylock(const char *, int, pid_t *);", "int\tttyunlock(const char *);", "int\tttyaction(char *tty, char *act, char *user);", "struct iovec;", "char   *ttymsg(struct iovec *, int, const char *, int);", "__END_DECLS", "", "/* Include utmp.h last to avoid deprecation warning above */", "#include <utmp.h>", "", "#endif /* !_UTIL_H_ */" },
    ["utime.h"] = { "/*", " * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/*-", " * Copyright (c) 1990, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)utime.h\t8.1 (Berkeley) 6/2/93", " */", "", "#ifndef\t_UTIME_H_", "#define\t_UTIME_H_", "", "#include <_types.h>", "#include <sys/_types/_time_t.h>", "", "struct utimbuf {", "\ttime_t actime;\t\t/* Access time */", "\ttime_t modtime;\t\t/* Modification time */", "};", "", "#include <sys/cdefs.h>", "", "__BEGIN_DECLS", "int utime(const char *, const struct utimbuf *);", "__END_DECLS", "", "#endif /* !_UTIME_H_ */" },
    ["utmp.h"] = { "/*", " * Copyright (c) 2000, 2005, 2007, 2008 Apple Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/*", " * Copyright (c) 1988, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " * (c) UNIX System Laboratories, Inc.", " * All or some portions of this file are derived from material licensed", " * to the University of California by American Telephone and Telegraph", " * Co. or Unix System Laboratories, Inc. and are reproduced herein with", " * the permission of UNIX System Laboratories, Inc.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)utmp.h\t8.2 (Berkeley) 1/21/94", " */", "", "#ifndef\t_UTMP_H_", "#define\t_UTMP_H_", "", "/*", " * This header file is DEPRECATED and only provided for compatibility", " * with previous releases of Mac OS X.  Use of these structures, especially", " * in 64-bit computing, may corrupt the utmp, wtmp and lastlog files.", " *", " * Use the utmpx APIs instead.", " */", "", "#include <_types.h>", "#include <sys/_types/_time_t.h>", "", "/* These files no longer exist in 10.5 and later */", '#define\t_PATH_UTMP\t"/var/run/utmp"', '#define\t_PATH_WTMP\t"/var/log/wtmp"', '#define\t_PATH_LASTLOG\t"/var/log/lastlog"', "", "#define\tUT_NAMESIZE\t8", "#define\tUT_LINESIZE\t8", "#define\tUT_HOSTSIZE\t16", "", "struct lastlog {", "\ttime_t\tll_time;", "\tchar\tll_line[UT_LINESIZE];", "\tchar\tll_host[UT_HOSTSIZE];", "}\t\t\t\t\t__deprecated;", "", "struct utmp {", "\tchar\tut_line[UT_LINESIZE];", "\tchar\tut_name[UT_NAMESIZE];", "\tchar\tut_host[UT_HOSTSIZE];", "\tlong\tut_time;", "}\t\t\t\t\t__deprecated;", "", "#endif /* !_UTMP_H_ */" },
    ["utmpx.h"] = { "/*", " * Copyright (c) 2004-2006 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/*\t$NetBSD: utmpx.h,v 1.11 2003/08/26 16:48:32 wiz Exp $\t */", "", "/*-", " * Copyright (c) 2002 The NetBSD Foundation, Inc.", " * All rights reserved.", " *", " * This code is derived from software contributed to The NetBSD Foundation", " * by Christos Zoulas.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *        This product includes software developed by the NetBSD", " *        Foundation, Inc. and its contributors.", " * 4. Neither the name of The NetBSD Foundation nor the names of its", " *    contributors may be used to endorse or promote products derived", " *    from this software without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS", " * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED", " * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR", " * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS", " * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR", " * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF", " * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS", " * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN", " * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)", " * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE", " * POSSIBILITY OF SUCH DAMAGE.", " */", "#ifndef\t_UTMPX_H_", "#define\t_UTMPX_H_", "", "#include <_types.h>", "#include <sys/time.h>", "#include <sys/cdefs.h>", "#include <Availability.h>", "#include <sys/_types/_pid_t.h>", "", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "#include <sys/_types/_uid_t.h>", "#endif /* !_POSIX_C_SOURCE || _DARWIN_C_SOURCE */", "", '#define\t_PATH_UTMPX\t\t"/var/run/utmpx"', "", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "#define\tUTMPX_FILE\t_PATH_UTMPX", "#endif /* !_POSIX_C_SOURCE || _DARWIN_C_SOURCE */", "", "#define _UTX_USERSIZE\t256\t/* matches MAXLOGNAME */", "#define _UTX_LINESIZE\t32", "#define\t_UTX_IDSIZE\t4", "#define _UTX_HOSTSIZE\t256", "", "#define EMPTY\t\t0", "#define RUN_LVL\t\t1", "#define BOOT_TIME\t2", "#define OLD_TIME\t3", "#define NEW_TIME\t4", "#define INIT_PROCESS\t5", "#define LOGIN_PROCESS\t6", "#define USER_PROCESS\t7", "#define DEAD_PROCESS\t8", "", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "#define ACCOUNTING\t9", "#define SIGNATURE\t10", "#define SHUTDOWN_TIME\t11", "", "#define UTMPX_AUTOFILL_MASK\t\t\t0x8000", "#define UTMPX_DEAD_IF_CORRESPONDING_MASK\t0x4000", "", "/* notify(3) change notification name */", '#define UTMPX_CHANGE_NOTIFICATION\t\t"com.apple.system.utmpx"', "#endif /* !_POSIX_C_SOURCE || _DARWIN_C_SOURCE */", "", "/*", " * The following structure describes the fields of the utmpx entries", " * stored in _PATH_UTMPX. This is not the format the", " * entries are stored in the files, and application should only access", " * entries using routines described in getutxent(3).", " */", "", "#ifdef _UTMPX_COMPAT", "#define ut_user ut_name", "#define ut_xtime ut_tv.tv_sec", "#endif /* _UTMPX_COMPAT */", "", "struct utmpx {", "\tchar ut_user[_UTX_USERSIZE];\t/* login name */", "\tchar ut_id[_UTX_IDSIZE];\t/* id */", "\tchar ut_line[_UTX_LINESIZE];\t/* tty name */", "\tpid_t ut_pid;\t\t\t/* process id creating the entry */", "\tshort ut_type;\t\t\t/* type of this entry */", "\tstruct timeval ut_tv;\t\t/* time entry was created */", "\tchar ut_host[_UTX_HOSTSIZE];\t/* host name */", "\t__uint32_t ut_pad[16];\t\t/* reserved for future use */", "};", "", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "struct lastlogx {", "\tstruct timeval ll_tv;\t\t/* time entry was created */", "\tchar ll_line[_UTX_LINESIZE];\t/* tty name */", "\tchar ll_host[_UTX_HOSTSIZE];\t/* host name */", "};", "#endif /* !_POSIX_C_SOURCE || _DARWIN_C_SOURCE */", "", "__BEGIN_DECLS", "", "void\tendutxent(void);", "", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "void\tendutxent_wtmp(void) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "struct lastlogx *", "\tgetlastlogx(uid_t, struct lastlogx *) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "struct lastlogx *", "\tgetlastlogxbyname(const char*, struct lastlogx *)__OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "struct utmp;\t/* forward reference */", "void\tgetutmp(const struct utmpx *, struct utmp *) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5, __MAC_10_9, __IPHONE_2_0, __IPHONE_7_0);", "void\tgetutmpx(const struct utmp *, struct utmpx *) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5, __MAC_10_9, __IPHONE_2_0, __IPHONE_7_0);", "#endif /* !_POSIX_C_SOURCE || _DARWIN_C_SOURCE */", "", "struct utmpx *", "\tgetutxent(void);", "", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "struct utmpx *", "\tgetutxent_wtmp(void) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "#endif /* !_POSIX_C_SOURCE || _DARWIN_C_SOURCE */", "", "struct utmpx *", "\tgetutxid(const struct utmpx *);", "struct utmpx *", "\tgetutxline(const struct utmpx *);", "struct utmpx *", "\tpututxline(const struct utmpx *);", "void\tsetutxent(void);", "", "#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)", "void\tsetutxent_wtmp(int) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int\tutmpxname(const char *) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "int\twtmpxname(const char *) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);", "#endif /* !_POSIX_C_SOURCE || _DARWIN_C_SOURCE */", "", "__END_DECLS", "", "#endif /* !_UTMPX_H_ */" },
    ["vis.h"] = { "/*", " * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "/*-", " * Copyright (c) 1990, 1993", " *\tThe Regents of the University of California.  All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *\tThis product includes software developed by the University of", " *\tCalifornia, Berkeley and its contributors.", " * 4. Neither the name of the University nor the names of its contributors", " *    may be used to endorse or promote products derived from this software", " *    without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\t@(#)vis.h\t8.1 (Berkeley) 6/2/93", " */", "", "#ifndef _VIS_H_", "#define\t_VIS_H_", "", "#include <_types.h>", "#include <sys/_types/_size_t.h>", "", "/*", " * to select alternate encoding format", " */", "#define\tVIS_OCTAL\t0x01\t/* use octal \\ddd format */", "#define\tVIS_CSTYLE\t0x02\t/* use \\[nrft0..] where appropriate */", "", "/*", " * to alter set of characters encoded (default is to encode all", " * non-graphic except space, tab, and newline).", " */", "#define\tVIS_SP\t\t0x04\t/* also encode space */", "#define\tVIS_TAB\t\t0x08\t/* also encode tab */", "#define\tVIS_NL\t\t0x10\t/* also encode newline */", "#define\tVIS_WHITE\t(VIS_SP | VIS_TAB | VIS_NL)", '#define\tVIS_SAFE\t0x20\t/* only encode "unsafe" characters */', "", "/*", " * other", " */", "#define\tVIS_NOSLASH\t0x40\t/* inhibit printing '\\' */", "#define\tVIS_HTTPSTYLE\t0x80\t/* http-style escape % HEX HEX */", "#define\tVIS_GLOB\t0x100\t/* encode glob(3) magics */", "", "/*", " * unvis return codes", " */", "#define\tUNVIS_VALID\t 1\t/* character valid */", "#define\tUNVIS_VALIDPUSH\t 2\t/* character valid, push back passed char */", "#define\tUNVIS_NOCHAR\t 3\t/* valid sequence, no character produced */", "#define\tUNVIS_SYNBAD\t-1\t/* unrecognized escape sequence */", "#define\tUNVIS_ERROR\t-2\t/* decoder in unknown state (unrecoverable) */", "", "/*", " * unvis flags", " */", "#define\tUNVIS_END\t1\t/* no more characters */", "", "#include <sys/cdefs.h>", "", "__BEGIN_DECLS", "char\t*vis(char *, int, int, int);", "int\tstrvis(char *, const char *, int);", "int\tstrvisx(char *, const char *, size_t, int);", "int\tstrunvis(char *, const char *);", "int\tstrunvisx(char *, const char *, int);", "int\tunvis(char *, int, int *, int);", "__END_DECLS", "", "#endif /* !_VIS_H_ */" },
    ["vproc.h"] = { "/*", " * Copyright (c) 2006 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_APACHE_LICENSE_HEADER_START@", " * ", ' * Licensed under the Apache License, Version 2.0 (the "License");', " * you may not use this file except in compliance with the License.", " * You may obtain a copy of the License at", " * ", " *     http://www.apache.org/licenses/LICENSE-2.0", " * ", " * Unless required by applicable law or agreed to in writing, software", ' * distributed under the License is distributed on an "AS IS" BASIS,', " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.", " * See the License for the specific language governing permissions and", " * limitations under the License.", " * ", " * @APPLE_APACHE_LICENSE_HEADER_END@", " */", "", "#ifndef __VPROC_H__", "#define __VPROC_H__", "", "#include <sys/cdefs.h>", "#include <sys/types.h>", "#include <Availability.h>", "", "#ifndef VPROC_HAS_TRANSACTIONS", "\t#define VPROC_HAS_TRANSACTIONS", "#endif", "", "__BEGIN_DECLS", "", "#pragma GCC visibility push(default)", "", "typedef void * vproc_err_t;", "", "typedef struct vproc_s * vproc_t;", "typedef void * vprocmgr_t;", "", "const char *vproc_strerror(vproc_err_t r);", "", "/*!", " * @header      vproc", " *", " * Processes have two reference counts associated with them:", " *", " * Transactions Tracks unfinished work. For example: saving a modified", " *\t\tdocument.", " * Standby\tTracks outstanding callbacks from external subsystems.", " *", " * Descriptive aliases:", " *", ' * A process with no outstanding transactions is called "clean."', ' * A process with outstanding transactions is called "dirty."', ' * A process with no standby work is called "idle."', " *", " * Sometimes, the operating system needs processes to exit. Unix has two", " * primary signals to kill applications:", " *", " * SIGKILL\tNot catchable by the application.", " * SIGTERM\tCatchable by the application.", " *", " * If a process is clean, the operating system is free to SIGKILL it at", " * shutdown or logout. This behavior is opt in.", " *", " * If a process is clean and idle, the operating system may send SIGKILL after", " * a application specified timeout. This behavior is opt in.", " *", " * If a process is dirty and idle, the operating system may send SIGTERM after", " * a application specified timeout. This behavior is opt in.", " *", " *", " * launchd jobs should update their property lists accordingly.", " *", " * We plan to have LaunchServices use private methods to coordinate", " * whether GUI applications have opted into this design.", " */", "", "/*!", " * @typedef\tvproc_transaction_t", " *", " * @abstract", " * An opaque handle used to track outstanding transactions.", " */", "typedef struct vproc_transaction_s *vproc_transaction_t;", "", "/*!", " * @function vproc_transaction_begin", " *", " * @param\tvirtual_proc", " * This is meant for future API improvements. Pass NULL for now.", " *", " * @result", " * Returns an opaque handle to be passed to vproc_transaction_end().", " *", " * @abstract", " * Call this API before creating data that needs to be saved via I/O later.", " */", "vproc_transaction_t", "vproc_transaction_begin(vproc_t virtual_proc) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_5_0);", "", "/*!", " * @function vproc_transaction_end", " *", " * @param\tvirtual_proc", " * This is meant for future API improvements. Pass NULL for now.", " *", " * @param\thandle", " * The handle previously created with vproc_transaction_begin().", " *", " * @abstract", " * Call this API after the data has either been flushed or otherwise resolved.", " *", " * @discussion", " * Calling this API with the same handle more than once is undefined.", " */", "void", "vproc_transaction_end(vproc_t virtual_proc, vproc_transaction_t handle) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_5_0);", "", "/*!", " * @typedef\tvproc_standby_t", " *", " * @abstract", " * An opaque handle used to track outstanding standby requests.", " */", "typedef struct vproc_standby_s *vproc_standby_t;", "", "/*!", " * @function vproc_standby_begin", " *", " * @param\tvirtual_proc", " * This is meant for future API improvements. Pass NULL for now.", " *", " * @result", " * Returns an opaque handle to be passed to vproc_standby_end().", " *", " * @abstract", " * Call this API before registering notifications. For example: timers network", " * state change, or when monitoring keyboard/mouse events.", " * ", " * @discussion", " * This API is undefined and is currently a no-op.", " */", "vproc_standby_t", "vproc_standby_begin(vproc_t virtual_proc) __OSX_AVAILABLE_STARTING(__MAC_NA, __IPHONE_NA);", "", "/*!", " * @function vproc_standby_end", " *", " * @param\tvirtual_proc", " * This is meant for future API improvements. Pass NULL for now.", " *", " * @param\thandle", " * The handle previously created with vproc_standby_begin().", " *", " * @abstract", " * Call this API when deregistering notifications.", " *", " * @discussion", " * Calling this API with the same handle more than once is undefined.", " * This API is undefined and is currently a no-op.", " */", "void", "vproc_standby_end(vproc_t virtual_proc, vproc_standby_t handle) __OSX_AVAILABLE_STARTING(__MAC_NA, __IPHONE_NA);", "", "#pragma GCC visibility pop", "", "__END_DECLS", "", "#endif /* __VPROC_H__ */" },
    ["wchar.h"] = { "/*-", " * Copyright (c)1999 Citrus Project,", " * All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " *", " * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " * $FreeBSD: /repoman/r/ncvs/src/include/wchar.h,v 1.34 2003/03/13 06:29:53 tjr Exp $", " */", "", "/*-", " * Copyright (c) 1999, 2000 The NetBSD Foundation, Inc.", " * All rights reserved.", " *", " * This code is derived from software contributed to The NetBSD Foundation", " * by Julian Coleman.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " * 3. All advertising materials mentioning features or use of this software", " *    must display the following acknowledgement:", " *        This product includes software developed by the NetBSD", " *        Foundation, Inc. and its contributors.", " * 4. Neither the name of The NetBSD Foundation nor the names of its", " *    contributors may be used to endorse or promote products derived", " *    from this software without specific prior written permission.", " *", " * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS", " * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED", " * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR", " * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS", " * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR", " * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF", " * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS", " * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN", " * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)", " * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE", " * POSSIBILITY OF SUCH DAMAGE.", " *", " *\t$NetBSD: wchar.h,v 1.8 2000/12/22 05:31:42 itojun Exp $", " */", "", "#ifndef _WCHAR_H_", "#define _WCHAR_H_", "", "#include <_types.h>", "#include <sys/cdefs.h>", "#include <Availability.h>", "", "#include <sys/_types/_null.h>", "#include <sys/_types/_size_t.h>", "#include <sys/_types/_mbstate_t.h>", "#include <sys/_types/_ct_rune_t.h>", "#include <sys/_types/_rune_t.h>", "#include <sys/_types/_wchar_t.h>", "", "#ifndef WCHAR_MIN", "#define WCHAR_MIN\t__DARWIN_WCHAR_MIN", "#endif", "", "#ifndef WCHAR_MAX", "#define WCHAR_MAX\t__DARWIN_WCHAR_MAX", "#endif", "", "#include <stdarg.h>", "#include <stdio.h>", "#include <time.h>", "#include <_wctype.h>", "", "", "/* Initially added in Issue 4 */", "__BEGIN_DECLS", "wint_t\tbtowc(int);", "wint_t\tfgetwc(FILE *);", "wchar_t\t*fgetws(wchar_t * __restrict, int, FILE * __restrict);", "wint_t\tfputwc(wchar_t, FILE *);", "int\tfputws(const wchar_t * __restrict, FILE * __restrict);", "int\tfwide(FILE *, int);", "int\tfwprintf(FILE * __restrict, const wchar_t * __restrict, ...);", "int\tfwscanf(FILE * __restrict, const wchar_t * __restrict, ...);", "wint_t\tgetwc(FILE *);", "wint_t\tgetwchar(void);", "size_t\tmbrlen(const char * __restrict, size_t, mbstate_t * __restrict);", "size_t\tmbrtowc(wchar_t * __restrict, const char * __restrict, size_t,", "\t    mbstate_t * __restrict);", "int\tmbsinit(const mbstate_t *);", "size_t\tmbsrtowcs(wchar_t * __restrict, const char ** __restrict, size_t,", "\t    mbstate_t * __restrict);", "wint_t\tputwc(wchar_t, FILE *);", "wint_t\tputwchar(wchar_t);", "int\tswprintf(wchar_t * __restrict, size_t, const wchar_t * __restrict, ...);", "int\tswscanf(const wchar_t * __restrict, const wchar_t * __restrict, ...);", "wint_t\tungetwc(wint_t, FILE *);", "int\tvfwprintf(FILE * __restrict, const wchar_t * __restrict,", "\t    __darwin_va_list);", "int\tvswprintf(wchar_t * __restrict, size_t, const wchar_t * __restrict,", "\t    __darwin_va_list);", "int\tvwprintf(const wchar_t * __restrict, __darwin_va_list);", "size_t\twcrtomb(char * __restrict, wchar_t, mbstate_t * __restrict);", "wchar_t\t*wcscat(wchar_t * __restrict, const wchar_t * __restrict);", "wchar_t\t*wcschr(const wchar_t *, wchar_t);", "int\twcscmp(const wchar_t *, const wchar_t *);", "int\twcscoll(const wchar_t *, const wchar_t *);", "wchar_t\t*wcscpy(wchar_t * __restrict, const wchar_t * __restrict);", "size_t\twcscspn(const wchar_t *, const wchar_t *);", "size_t\twcsftime(wchar_t * __restrict, size_t, const wchar_t * __restrict,", "\t    const struct tm * __restrict) __DARWIN_ALIAS(wcsftime);", "size_t\twcslen(const wchar_t *);", "wchar_t\t*wcsncat(wchar_t * __restrict, const wchar_t * __restrict, size_t);", "int\twcsncmp(const wchar_t *, const wchar_t *, size_t);", "wchar_t\t*wcsncpy(wchar_t * __restrict , const wchar_t * __restrict, size_t);", "wchar_t\t*wcspbrk(const wchar_t *, const wchar_t *);", "wchar_t\t*wcsrchr(const wchar_t *, wchar_t);", "size_t\twcsrtombs(char * __restrict, const wchar_t ** __restrict, size_t,", "\t    mbstate_t * __restrict);", "size_t\twcsspn(const wchar_t *, const wchar_t *);", "wchar_t\t*wcsstr(const wchar_t * __restrict, const wchar_t * __restrict);", "size_t\twcsxfrm(wchar_t * __restrict, const wchar_t * __restrict, size_t);", "int\twctob(wint_t);", "double\twcstod(const wchar_t * __restrict, wchar_t ** __restrict);", "wchar_t\t*wcstok(wchar_t * __restrict, const wchar_t * __restrict,", "\t    wchar_t ** __restrict);", "long\t wcstol(const wchar_t * __restrict, wchar_t ** __restrict, int);", "unsigned long", "\t wcstoul(const wchar_t * __restrict, wchar_t ** __restrict, int);", "wchar_t\t*wmemchr(const wchar_t *, wchar_t, size_t);", "int\twmemcmp(const wchar_t *, const wchar_t *, size_t);", "wchar_t\t*wmemcpy(wchar_t * __restrict, const wchar_t * __restrict, size_t);", "wchar_t\t*wmemmove(wchar_t *, const wchar_t *, size_t);", "wchar_t\t*wmemset(wchar_t *, wchar_t, size_t);", "int\twprintf(const wchar_t * __restrict, ...);", "int\twscanf(const wchar_t * __restrict, ...);", "int\twcswidth(const wchar_t *, size_t);", "int\twcwidth(wchar_t);", "__END_DECLS", "", "", "", "/* Additional functionality provided by:", " * POSIX.1-2001", " * ISO C99", " */", "", "#if __DARWIN_C_LEVEL >= 200112L || defined(_C99_SOURCE) || defined(__cplusplus)", "__BEGIN_DECLS", "int\tvfwscanf(FILE * __restrict, const wchar_t * __restrict,", "\t    __darwin_va_list);", "int\tvswscanf(const wchar_t * __restrict, const wchar_t * __restrict,", "\t    __darwin_va_list);", "int\tvwscanf(const wchar_t * __restrict, __darwin_va_list);", "float\twcstof(const wchar_t * __restrict, wchar_t ** __restrict);", "long double", "\twcstold(const wchar_t * __restrict, wchar_t ** __restrict);", "#if !__DARWIN_NO_LONG_LONG", "long long", "\twcstoll(const wchar_t * __restrict, wchar_t ** __restrict, int);", "unsigned long long", "\twcstoull(const wchar_t * __restrict, wchar_t ** __restrict, int);", "#endif /* !__DARWIN_NO_LONG_LONG */", "__END_DECLS", "#endif", "", "", "", "/* Additional functionality provided by:", " * POSIX.1-2008", " */", "", "#if __DARWIN_C_LEVEL >= 200809L", "__BEGIN_DECLS", "size_t  mbsnrtowcs(wchar_t * __restrict, const char ** __restrict, size_t,", "            size_t, mbstate_t * __restrict);", "wchar_t *wcpcpy(wchar_t * __restrict, const wchar_t * __restrict) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);", "wchar_t *wcpncpy(wchar_t * __restrict, const wchar_t * __restrict, size_t) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);", "wchar_t *wcsdup(const wchar_t *) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);", "int     wcscasecmp(const wchar_t *, const wchar_t *) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);", "int     wcsncasecmp(const wchar_t *, const wchar_t *, size_t n) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);", "size_t  wcsnlen(const wchar_t *, size_t) __pure __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);", "size_t  wcsnrtombs(char * __restrict, const wchar_t ** __restrict, size_t,", "            size_t, mbstate_t * __restrict);", "__END_DECLS", "#endif /* __DARWIN_C_LEVEL >= 200809L */", "", "", "", "/* Darwin extensions */", "", "#if __DARWIN_C_LEVEL >= __DARWIN_C_FULL", "__BEGIN_DECLS", "wchar_t *fgetwln(FILE * __restrict, size_t *) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);", "size_t\twcslcat(wchar_t *, const wchar_t *, size_t);", "size_t\twcslcpy(wchar_t *, const wchar_t *, size_t);", "__END_DECLS", "#endif /* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */", "", "", "/* Poison the following routines if -fshort-wchar is set */", "#if !defined(__cplusplus) && defined(__WCHAR_MAX__) && __WCHAR_MAX__ <= 0xffffU", "#pragma GCC poison fgetwln fgetws fputwc fputws fwprintf fwscanf mbrtowc mbsnrtowcs mbsrtowcs putwc putwchar swprintf swscanf vfwprintf vfwscanf vswprintf vswscanf vwprintf vwscanf wcrtomb wcscat wcschr wcscmp wcscoll wcscpy wcscspn wcsftime wcsftime wcslcat wcslcpy wcslen wcsncat wcsncmp wcsncpy wcsnrtombs wcspbrk wcsrchr wcsrtombs wcsspn wcsstr wcstod wcstof wcstok wcstol wcstold wcstoll wcstoul wcstoull wcswidth wcsxfrm wcwidth wmemchr wmemcmp wmemcpy wmemmove wmemset wprintf wscanf", "#endif", "", "#ifdef _USE_EXTENDED_LOCALES_", "#include <xlocale/_wchar.h>", "#endif /* _USE_EXTENDED_LOCALES_ */", "", "#endif /* !_WCHAR_H_ */" },
    ["wctype.h"] = { "/*-", " * Copyright (c)1999 Citrus Project,", " * All rights reserved.", " *", " * Redistribution and use in source and binary forms, with or without", " * modification, are permitted provided that the following conditions", " * are met:", " * 1. Redistributions of source code must retain the above copyright", " *    notice, this list of conditions and the following disclaimer.", " * 2. Redistributions in binary form must reproduce the above copyright", " *    notice, this list of conditions and the following disclaimer in the", " *    documentation and/or other materials provided with the distribution.", " *", " * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", " * SUCH DAMAGE.", " *", " *\tcitrus Id: wctype.h,v 1.4 2000/12/21 01:50:21 itojun Exp", " *\t$NetBSD: wctype.h,v 1.3 2000/12/22 14:16:16 itojun Exp $", " * $FreeBSD: /repoman/r/ncvs/src/include/wctype.h,v 1.10 2002/08/21 16:19:55 mike Exp $", " */", "", "#ifndef _WCTYPE_H_", "#define\t_WCTYPE_H_", "", "#include <sys/cdefs.h>", "#include <_types.h>", "#include <_types/_wctrans_t.h>", "", "#define __DARWIN_WCTYPE_TOP_inline\t__header_inline", "", "#include <_wctype.h>", "#include <ctype.h>", "", "/*", " * Use inline functions if we are allowed to and the compiler supports them.", " */", "#if !defined(_DONT_USE_CTYPE_INLINE_) && \\", "    (defined(_USE_CTYPE_INLINE_) || defined(__GNUC__) || defined(__cplusplus))", "", "__DARWIN_WCTYPE_TOP_inline int", "iswblank(wint_t _wc)", "{", "\treturn (__istype(_wc, _CTYPE_B));", "}", "", "#if !defined(_ANSI_SOURCE)", "__DARWIN_WCTYPE_TOP_inline int", "iswascii(wint_t _wc)", "{", "\treturn ((_wc & ~0x7F) == 0);", "}", "", "__DARWIN_WCTYPE_TOP_inline int", "iswhexnumber(wint_t _wc)", "{", "\treturn (__istype(_wc, _CTYPE_X));", "}", "", "__DARWIN_WCTYPE_TOP_inline int", "iswideogram(wint_t _wc)", "{", "\treturn (__istype(_wc, _CTYPE_I));", "}", "", "__DARWIN_WCTYPE_TOP_inline int", "iswnumber(wint_t _wc)", "{", "\treturn (__istype(_wc, _CTYPE_D));", "}", "", "__DARWIN_WCTYPE_TOP_inline int", "iswphonogram(wint_t _wc)", "{", "\treturn (__istype(_wc, _CTYPE_Q));", "}", "", "__DARWIN_WCTYPE_TOP_inline int", "iswrune(wint_t _wc)", "{", "\treturn (__istype(_wc, 0xFFFFFFF0L));", "}", "", "__DARWIN_WCTYPE_TOP_inline int", "iswspecial(wint_t _wc)", "{", "\treturn (__istype(_wc, _CTYPE_T));", "}", "#endif /* !_ANSI_SOURCE */", "", "#else /* not using inlines */", "", "__BEGIN_DECLS", "int\tiswblank(wint_t);", "", "#if !defined(_ANSI_SOURCE)", "wint_t\tiswascii(wint_t);", "wint_t\tiswhexnumber(wint_t);", "wint_t\tiswideogram(wint_t);", "wint_t\tiswnumber(wint_t);", "wint_t\tiswphonogram(wint_t);", "wint_t\tiswrune(wint_t);", "wint_t\tiswspecial(wint_t);", "#endif", "__END_DECLS", "", "#endif /* using inlines */", "", "__BEGIN_DECLS", "#if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))", "wint_t\tnextwctype(wint_t, wctype_t);", "#endif", "wint_t\ttowctrans(wint_t, wctrans_t);", "wctrans_t", "\twctrans(const char *);", "__END_DECLS", "", "#ifdef _USE_EXTENDED_LOCALES_", "#include <xlocale/_wctype.h>", "#endif /* _USE_EXTENDED_LOCALES_ */", "", "#endif\t\t/* _WCTYPE_H_ */" },
    ["wordexp.h"] = { "/*", " *   Copyright 1994, University Corporation for Atmospheric Research", " *   See ../COPYRIGHT file for copying and redistribution conditions.", " */", "/*", " * Reproduction of ../COPYRIGHT file:", " *", " *********************************************************************", " ", "Copyright 1995-2002 University Corporation for Atmospheric Research/Unidata", "", "Portions of this software were developed by the Unidata Program at the ", "University Corporation for Atmospheric Research.", "", "Access and use of this software shall impose the following obligations", "and understandings on the user. The user is granted the right, without", "any fee or cost, to use, copy, modify, alter, enhance and distribute", "this software, and any derivative works thereof, and its supporting", "documentation for any purpose whatsoever, provided that this entire", "notice appears in all copies of the software, derivative works and", "supporting documentation.  Further, UCAR requests that the user credit", "UCAR/Unidata in any publications that result from the use of this", "software or in any product that includes this software. The names UCAR", "and/or Unidata, however, may not be used in any advertising or publicity", "to endorse or promote any products or commercial entity unless specific", "written permission is obtained from UCAR/Unidata. The user also", "understands that UCAR/Unidata is not obligated to provide the user with", "any support, consulting, training or assistance of any kind with regard", "to the use, operation and performance of this software nor to provide", 'the user with any updates, revisions, new versions or "bug fixes."', "", 'THIS SOFTWARE IS PROVIDED BY UCAR/UNIDATA "AS IS" AND ANY EXPRESS OR', "IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED", "WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE", "DISCLAIMED. IN NO EVENT SHALL UCAR/UNIDATA BE LIABLE FOR ANY SPECIAL,", "INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING", "FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,", "NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION", "WITH THE ACCESS, USE OR PERFORMANCE OF THIS SOFTWARE.", "", " *********************************************************************", " *", " */", "", "/* $Id: wordexp.h,v 1.5 1994/05/12 20:46:40 davis Exp $ */", "#ifndef _WORDEXP_H", "#define _WORDEXP_H", "", "#include <sys/cdefs.h>", "#include <_types.h>", "#include <sys/_types/_size_t.h>", "#include <Availability.h>", "", "typedef struct {", "\tsize_t we_wordc;", "\tchar **we_wordv;", "\tsize_t we_offs;", "} wordexp_t;", "", "/* wordexp() flags Argument */", "#define WRDE_APPEND\t0x01", "#define WRDE_DOOFFS\t0x02", "#define WRDE_NOCMD\t0x04", "#define WRDE_REUSE\t0x08", "#define WRDE_SHOWERR\t0x10", "#define WRDE_UNDEF\t0x20", "", "/*", " * wordexp() Return Values", " */", "/* required */", "#define WRDE_BADCHAR\t1", "#define WRDE_BADVAL\t2", "#define WRDE_CMDSUB\t3", "#define WRDE_NOSPACE\t4", "#define WRDE_NOSYS\t5", "#define WRDE_SYNTAX\t6", "", "", "__BEGIN_DECLS", "int wordexp(const char * __restrict, wordexp_t * __restrict, int) __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_NA);", "void wordfree(wordexp_t *) __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_NA);", "__END_DECLS", "", "#endif  /* _WORDEXP_H */" },
    ["xlocale.h"] = { "/*", " * Copyright (c) 2005 Apple Computer, Inc. All rights reserved.", " *", " * @APPLE_LICENSE_HEADER_START@", " * ", " * This file contains Original Code and/or Modifications of Original Code", " * as defined in and that are subject to the Apple Public Source License", " * Version 2.0 (the 'License'). You may not use this file except in", " * compliance with the License. Please obtain a copy of the License at", " * http://www.opensource.apple.com/apsl/ and read it before using this", " * file.", " * ", " * The Original Code and all software distributed under the License are", " * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER", " * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,", " * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,", " * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.", " * Please see the License for the specific language governing rights and", " * limitations under the License.", " * ", " * @APPLE_LICENSE_HEADER_END@", " */", "", "#ifndef _XLOCALE_H_", "#define _XLOCALE_H_", "", "#include <sys/cdefs.h>", "", "#ifndef _USE_EXTENDED_LOCALES_", "#define _USE_EXTENDED_LOCALES_", "#endif /* _USE_EXTENDED_LOCALES_ */", "", "struct _xlocale; /* forward reference */", "typedef struct _xlocale *\t\tlocale_t;", "", "#include <_locale.h>", "#include <_xlocale.h>", "", "#define LC_ALL_MASK\t\t\t(  LC_COLLATE_MASK \\", "\t\t\t\t\t | LC_CTYPE_MASK \\", "\t\t\t\t\t | LC_MESSAGES_MASK \\", "\t\t\t\t\t | LC_MONETARY_MASK \\", "\t\t\t\t\t | LC_NUMERIC_MASK \\", "\t\t\t\t\t | LC_TIME_MASK )", "#define LC_COLLATE_MASK\t\t\t(1 << 0)", "#define LC_CTYPE_MASK\t\t\t(1 << 1)", "#define LC_MESSAGES_MASK\t\t(1 << 2)", "#define LC_MONETARY_MASK\t\t(1 << 3)", "#define LC_NUMERIC_MASK\t\t\t(1 << 4)", "#define LC_TIME_MASK\t\t\t(1 << 5)", "", "#define _LC_NUM_MASK\t\t\t6", "#define _LC_LAST_MASK\t\t\t(1 << (_LC_NUM_MASK - 1))", "", "#define LC_GLOBAL_LOCALE\t\t((locale_t)-1)", "", "#ifdef MB_CUR_MAX", "#undef MB_CUR_MAX", "#define MB_CUR_MAX\t\t\t(___mb_cur_max())", "#ifndef MB_CUR_MAX_L", "#define MB_CUR_MAX_L(x)\t\t\t(___mb_cur_max_l(x))", "#endif /* !MB_CUR_MAX_L */", "#endif /* MB_CUR_MAX */", "", "__BEGIN_DECLS", "extern const locale_t _c_locale;", "", "locale_t\tduplocale(locale_t);", "int\t\tfreelocale(locale_t);", "struct lconv *\tlocaleconv_l(locale_t);", "locale_t\tnewlocale(int, __const char *, locale_t);", "__const char *\tquerylocale(int, locale_t);", "locale_t\tuselocale(locale_t);", "__END_DECLS", "", "#ifdef _CTYPE_H_", "#include <xlocale/_ctype.h>", "#endif /* _CTYPE_H_ */", "#ifdef __WCTYPE_H_", "#include <xlocale/__wctype.h>", "#endif /* __WCTYPE_H_ */", "#ifdef _INTTYPES_H_", "#include <xlocale/_inttypes.h>", "#endif /* _INTTYPES_H_ */", "#ifdef _LANGINFO_H_", "#include <xlocale/_langinfo.h>", "#endif /* _LANGINFO_H_ */", "#ifdef _MONETARY_H_", "#include <xlocale/_monetary.h>", "#endif /* _MONETARY_H_ */", "#ifdef _REGEX_H_", "#include <xlocale/_regex.h>", "#endif /* _REGEX_H_ */", "#ifdef _STDIO_H_", "#include <xlocale/_stdio.h>", "#endif /* _STDIO_H_ */", "#ifdef _STDLIB_H_", "#include <xlocale/_stdlib.h>", "#endif /* _STDLIB_H_ */", "#ifdef _STRING_H_", "#include <xlocale/_string.h>", "#endif /*STRING_CTYPE_H_ */", "#ifdef _TIME_H_", "#include <xlocale/_time.h>", "#endif /* _TIME_H_ */", "#ifdef _WCHAR_H_", "#include <xlocale/_wchar.h>", "#endif /*WCHAR_CTYPE_H_ */", "#ifdef _WCTYPE_H_", "#include <xlocale/_wctype.h>", "#endif /* _WCTYPE_H_ */", "", "#endif /* _XLOCALE_H_ */" },
    ["zconf.h"] = { "/* zconf.h -- configuration of the zlib compression library", " * Copyright (C) 1995-2010 Jean-loup Gailly.", " * For conditions of distribution and use, see copyright notice in zlib.h", " */", "", "/* @(#) $Id$ */", "", "#ifndef ZCONF_H", "#define ZCONF_H", "", "/*", " * If you *really* need a unique prefix for all types and library functions,", ' * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.', " * Even better than compiling with -DZ_PREFIX would be to use configure to set", ' * this permanently in zconf.h using "./configure --zprefix".', " */", "#ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */", "", "/* all linked symbols */", "#  define _dist_code            z__dist_code", "#  define _length_code          z__length_code", "#  define _tr_align             z__tr_align", "#  define _tr_flush_block       z__tr_flush_block", "#  define _tr_init              z__tr_init", "#  define _tr_stored_block      z__tr_stored_block", "#  define _tr_tally             z__tr_tally", "#  define adler32               z_adler32", "#  define adler32_combine       z_adler32_combine", "#  define adler32_combine64     z_adler32_combine64", "#  define compress              z_compress", "#  define compress2             z_compress2", "#  define compressBound         z_compressBound", "#  define crc32                 z_crc32", "#  define crc32_combine         z_crc32_combine", "#  define crc32_combine64       z_crc32_combine64", "#  define deflate               z_deflate", "#  define deflateBound          z_deflateBound", "#  define deflateCopy           z_deflateCopy", "#  define deflateEnd            z_deflateEnd", "#  define deflateInit2_         z_deflateInit2_", "#  define deflateInit_          z_deflateInit_", "#  define deflateParams         z_deflateParams", "#  define deflatePrime          z_deflatePrime", "#  define deflateReset          z_deflateReset", "#  define deflateSetDictionary  z_deflateSetDictionary", "#  define deflateSetHeader      z_deflateSetHeader", "#  define deflateTune           z_deflateTune", "#  define deflate_copyright     z_deflate_copyright", "#  define get_crc_table         z_get_crc_table", "#  define gz_error              z_gz_error", "#  define gz_intmax             z_gz_intmax", "#  define gz_strwinerror        z_gz_strwinerror", "#  define gzbuffer              z_gzbuffer", "#  define gzclearerr            z_gzclearerr", "#  define gzclose               z_gzclose", "#  define gzclose_r             z_gzclose_r", "#  define gzclose_w             z_gzclose_w", "#  define gzdirect              z_gzdirect", "#  define gzdopen               z_gzdopen", "#  define gzeof                 z_gzeof", "#  define gzerror               z_gzerror", "#  define gzflush               z_gzflush", "#  define gzgetc                z_gzgetc", "#  define gzgets                z_gzgets", "#  define gzoffset              z_gzoffset", "#  define gzoffset64            z_gzoffset64", "#  define gzopen                z_gzopen", "#  define gzopen64              z_gzopen64", "#  define gzprintf              z_gzprintf", "#  define gzputc                z_gzputc", "#  define gzputs                z_gzputs", "#  define gzread                z_gzread", "#  define gzrewind              z_gzrewind", "#  define gzseek                z_gzseek", "#  define gzseek64              z_gzseek64", "#  define gzsetparams           z_gzsetparams", "#  define gztell                z_gztell", "#  define gztell64              z_gztell64", "#  define gzungetc              z_gzungetc", "#  define gzwrite               z_gzwrite", "#  define inflate               z_inflate", "#  define inflateBack           z_inflateBack", "#  define inflateBackEnd        z_inflateBackEnd", "#  define inflateBackInit_      z_inflateBackInit_", "#  define inflateCopy           z_inflateCopy", "#  define inflateEnd            z_inflateEnd", "#  define inflateGetHeader      z_inflateGetHeader", "#  define inflateInit2_         z_inflateInit2_", "#  define inflateInit_          z_inflateInit_", "#  define inflateMark           z_inflateMark", "#  define inflatePrime          z_inflatePrime", "#  define inflateReset          z_inflateReset", "#  define inflateReset2         z_inflateReset2", "#  define inflateSetDictionary  z_inflateSetDictionary", "#  define inflateSync           z_inflateSync", "#  define inflateSyncPoint      z_inflateSyncPoint", "#  define inflateUndermine      z_inflateUndermine", "#  define inflate_copyright     z_inflate_copyright", "#  define inflate_fast          z_inflate_fast", "#  define inflate_table         z_inflate_table", "#  define uncompress            z_uncompress", "#  define zError                z_zError", "#  define zcalloc               z_zcalloc", "#  define zcfree                z_zcfree", "#  define zlibCompileFlags      z_zlibCompileFlags", "#  define zlibVersion           z_zlibVersion", "", "/* all zlib typedefs in zlib.h and zconf.h */", "#  define Byte                  z_Byte", "#  define Bytef                 z_Bytef", "#  define alloc_func            z_alloc_func", "#  define charf                 z_charf", "#  define free_func             z_free_func", "#  define gzFile                z_gzFile", "#  define gz_header             z_gz_header", "#  define gz_headerp            z_gz_headerp", "#  define in_func               z_in_func", "#  define intf                  z_intf", "#  define out_func              z_out_func", "#  define uInt                  z_uInt", "#  define uIntf                 z_uIntf", "#  define uLong                 z_uLong", "#  define uLongf                z_uLongf", "#  define voidp                 z_voidp", "#  define voidpc                z_voidpc", "#  define voidpf                z_voidpf", "", "/* all zlib structs in zlib.h and zconf.h */", "#  define gz_header_s           z_gz_header_s", "#  define internal_state        z_internal_state", "", "#endif", "", "#if defined(__MSDOS__) && !defined(MSDOS)", "#  define MSDOS", "#endif", "#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)", "#  define OS2", "#endif", "#if defined(_WINDOWS) && !defined(WINDOWS)", "#  define WINDOWS", "#endif", "#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)", "#  ifndef WIN32", "#    define WIN32", "#  endif", "#endif", "#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)", "#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)", "#    ifndef SYS16BIT", "#      define SYS16BIT", "#    endif", "#  endif", "#endif", "", "/*", " * Compile with -DMAXSEG_64K if the alloc function cannot allocate more", " * than 64k bytes at a time (needed on systems with 16-bit int).", " */", "#ifdef SYS16BIT", "#  define MAXSEG_64K", "#endif", "#ifdef MSDOS", "#  define UNALIGNED_OK", "#endif", "", "#ifdef __STDC_VERSION__", "#  ifndef STDC", "#    define STDC", "#  endif", "#  if __STDC_VERSION__ >= 199901L", "#    ifndef STDC99", "#      define STDC99", "#    endif", "#  endif", "#endif", "#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))", "#  define STDC", "#endif", "#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))", "#  define STDC", "#endif", "#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))", "#  define STDC", "#endif", "#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))", "#  define STDC", "#endif", "", "#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */", "#  define STDC", "#endif", "", "#ifndef STDC", "#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */", "#    define const       /* note: need a more gentle solution here */", "#  endif", "#endif", "", "/* Some Mac compilers merge all .h files incorrectly: */", "#if defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)", "#  define NO_DUMMY_DECL", "#endif", "", "/* Maximum value for memLevel in deflateInit2 */", "#ifndef MAX_MEM_LEVEL", "#  ifdef MAXSEG_64K", "#    define MAX_MEM_LEVEL 8", "#  else", "#    define MAX_MEM_LEVEL 9", "#  endif", "#endif", "", "/* Maximum value for windowBits in deflateInit2 and inflateInit2.", " * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files", " * created by gzip. (Files created by minigzip can still be extracted by", " * gzip.)", " */", "#ifndef MAX_WBITS", "#  define MAX_WBITS   15 /* 32K LZ77 window */", "#endif", "", "/* The memory requirements for deflate are (in bytes):", "            (1 << (windowBits+2)) +  (1 << (memLevel+9))", " that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)", " plus a few kilobytes for small objects. For example, if you want to reduce", " the default memory requirements from 256K to 128K, compile with", '     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"', " Of course this will generally degrade compression (there's no free lunch).", "", "   The memory requirements for inflate are (in bytes) 1 << windowBits", " that is, 32K for windowBits=15 (default value) plus a few kilobytes", " for small objects.", "*/", "", "                        /* Type declarations */", "", "#ifndef OF /* function prototypes */", "#  ifdef STDC", "#    define OF(args)  args", "#  else", "#    define OF(args)  ()", "#  endif", "#endif", "", "/* The following definitions for FAR are needed only for MSDOS mixed", " * model programming (small or medium model with some far allocations).", " * This was tested only with MSC; for other MSDOS compilers you may have", " * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,", " * just define FAR to be empty.", " */", "#ifdef SYS16BIT", "#  if defined(M_I86SM) || defined(M_I86MM)", "     /* MSC small or medium model */", "#    define SMALL_MEDIUM", "#    ifdef _MSC_VER", "#      define FAR _far", "#    else", "#      define FAR far", "#    endif", "#  endif", "#  if (defined(__SMALL__) || defined(__MEDIUM__))", "     /* Turbo C small or medium model */", "#    define SMALL_MEDIUM", "#    ifdef __BORLANDC__", "#      define FAR _far", "#    else", "#      define FAR far", "#    endif", "#  endif", "#endif", "", "#if defined(WINDOWS) || defined(WIN32)", "   /* If building or using zlib as a DLL, define ZLIB_DLL.", "    * This is not mandatory, but it offers a little performance increase.", "    */", "#  ifdef ZLIB_DLL", "#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))", "#      ifdef ZLIB_INTERNAL", "#        define ZEXTERN extern __declspec(dllexport)", "#      else", "#        define ZEXTERN extern __declspec(dllimport)", "#      endif", "#    endif", "#  endif  /* ZLIB_DLL */", "   /* If building or using zlib with the WINAPI/WINAPIV calling convention,", "    * define ZLIB_WINAPI.", "    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.", "    */", "#  ifdef ZLIB_WINAPI", "#    ifdef FAR", "#      undef FAR", "#    endif", "#    include <windows.h>", "     /* No need for _export, use ZLIB.DEF instead. */", "     /* For complete Windows compatibility, use WINAPI, not __stdcall. */", "#    define ZEXPORT WINAPI", "#    ifdef WIN32", "#      define ZEXPORTVA WINAPIV", "#    else", "#      define ZEXPORTVA FAR CDECL", "#    endif", "#  endif", "#endif", "", "#if defined (__BEOS__)", "#  ifdef ZLIB_DLL", "#    ifdef ZLIB_INTERNAL", "#      define ZEXPORT   __declspec(dllexport)", "#      define ZEXPORTVA __declspec(dllexport)", "#    else", "#      define ZEXPORT   __declspec(dllimport)", "#      define ZEXPORTVA __declspec(dllimport)", "#    endif", "#  endif", "#endif", "", "#ifndef ZEXTERN", "#  define ZEXTERN extern", "#endif", "#ifndef ZEXPORT", "#  define ZEXPORT", "#endif", "#ifndef ZEXPORTVA", "#  define ZEXPORTVA", "#endif", "", "#ifndef FAR", "#  define FAR", "#endif", "", "#if !defined(__MACTYPES__)", "typedef unsigned char  Byte;  /* 8 bits */", "#endif", "typedef unsigned int   uInt;  /* 16 bits or more */", "typedef unsigned long  uLong; /* 32 bits or more */", "", "#ifdef SMALL_MEDIUM", "   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */", "#  define Bytef Byte FAR", "#else", "   typedef Byte  FAR Bytef;", "#endif", "typedef char  FAR charf;", "typedef int   FAR intf;", "typedef uInt  FAR uIntf;", "typedef uLong FAR uLongf;", "", "#ifdef STDC", "   typedef void const *voidpc;", "   typedef void FAR   *voidpf;", "   typedef void       *voidp;", "#else", "   typedef Byte const *voidpc;", "   typedef Byte FAR   *voidpf;", "   typedef Byte       *voidp;", "#endif", "", "#if defined(__APPLE__) /* avoid unistd.h on Win32 */", "#if 1    /* was set to #if 1 by ./configure */", "#  define Z_HAVE_UNISTD_H", "#endif", "#endif /* defined(__APPLE__) */", "", "#ifdef STDC", "#  include <sys/types.h>    /* for off_t */", "#endif", "", '/* a little trick to accommodate both "#define _LARGEFILE64_SOURCE" and', ' * "#define _LARGEFILE64_SOURCE 1" as requesting 64-bit operations, (even', " * though the former does not conform to the LFS document), but considering", ' * both "#undef _LARGEFILE64_SOURCE" and "#define _LARGEFILE64_SOURCE 0" as', " * equivalently requesting no 64-bit operations", " */", "#if -_LARGEFILE64_SOURCE - -1 == 1", "#  undef _LARGEFILE64_SOURCE", "#endif", "", "#if defined(Z_HAVE_UNISTD_H) || defined(_LARGEFILE64_SOURCE)", "#  include <unistd.h>       /* for SEEK_* and off_t */", "#  ifdef VMS", "#    include <unixio.h>     /* for off_t */", "#  endif", "#  if !defined(z_off_t) && !defined(__APPLE__)", "#    define z_off_t off_t", "#  endif", "#endif", "", "#ifndef SEEK_SET", "#  define SEEK_SET        0       /* Seek from beginning of file.  */", "#  define SEEK_CUR        1       /* Seek from current position.  */", '#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */', "#endif", "", "#ifndef z_off_t", "#  define z_off_t long", "#endif", "", "#if defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0", "#  define z_off64_t off64_t", "#elif defined(__APPLE__)", "#  define z_off64_t off_t", "#else", "#  define z_off64_t z_off_t", "#endif", "", "#if defined(__OS400__)", "#  define NO_vsnprintf", "#endif", "", "#if defined(__MVS__)", "#  define NO_vsnprintf", "#endif", "", "/* MVS linker does not support external names larger than 8 bytes */", "#if defined(__MVS__)", '  #pragma map(deflateInit_,"DEIN")', '  #pragma map(deflateInit2_,"DEIN2")', '  #pragma map(deflateEnd,"DEEND")', '  #pragma map(deflateBound,"DEBND")', '  #pragma map(inflateInit_,"ININ")', '  #pragma map(inflateInit2_,"ININ2")', '  #pragma map(inflateEnd,"INEND")', '  #pragma map(inflateSync,"INSY")', '  #pragma map(inflateSetDictionary,"INSEDI")', '  #pragma map(compressBound,"CMBND")', '  #pragma map(inflate_table,"INTABL")', '  #pragma map(inflate_fast,"INFA")', '  #pragma map(inflate_copyright,"INCOPY")', "#endif", "", "#endif /* ZCONF_H */" },
    ["zlib.h"] = { "/* zlib.h -- interface of the 'zlib' general purpose compression library", "  version 1.2.5, April 19th, 2010", "", "  Copyright (C) 1995-2010 Jean-loup Gailly and Mark Adler", "", "  This software is provided 'as-is', without any express or implied", "  warranty.  In no event will the authors be held liable for any damages", "  arising from the use of this software.", "", "  Permission is granted to anyone to use this software for any purpose,", "  including commercial applications, and to alter it and redistribute it", "  freely, subject to the following restrictions:", "", "  1. The origin of this software must not be misrepresented; you must not", "     claim that you wrote the original software. If you use this software", "     in a product, an acknowledgment in the product documentation would be", "     appreciated but is not required.", "  2. Altered source versions must be plainly marked as such, and must not be", "     misrepresented as being the original software.", "  3. This notice may not be removed or altered from any source distribution.", "", "  Jean-loup Gailly        Mark Adler", "  jloup@gzip.org          madler@alumni.caltech.edu", "", "", "  The data format used by the zlib library is described by RFCs (Request for", "  Comments) 1950 to 1952 in the files http://www.ietf.org/rfc/rfc1950.txt", "  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).", "*/", "", "#ifndef ZLIB_H", "#define ZLIB_H", "", '#include "zconf.h"', "#ifdef __APPLE__", "#include <Availability.h>", "#else /* !__APPLE__ */", "#define __OSX_AVAILABLE_STARTING(x,y)\t/* nothing */", "#endif /* !__APPLE__ */", "", "#ifdef __cplusplus", 'extern "C" {', "#endif", "", '#define ZLIB_VERSION "1.2.5"', "#define ZLIB_VERNUM 0x1250", "#define ZLIB_VER_MAJOR 1", "#define ZLIB_VER_MINOR 2", "#define ZLIB_VER_REVISION 5", "#define ZLIB_VER_SUBREVISION 0", "", "/*", "    The 'zlib' compression library provides in-memory compression and", "  decompression functions, including integrity checks of the uncompressed data.", "  This version of the library supports only one compression method (deflation)", "  but other algorithms will be added later and will have the same stream", "  interface.", "", "    Compression can be done in a single step if the buffers are large enough,", "  or can be done by repeated calls of the compression function.  In the latter", "  case, the application must provide more input and/or consume the output", "  (providing more output space) before each call.", "", "    The compressed data format used by default by the in-memory functions is", "  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped", "  around a deflate stream, which is itself documented in RFC 1951.", "", "    The library also supports reading and writing files in gzip (.gz) format", "  with an interface similar to that of stdio using the functions that start", '  with "gz".  The gzip format is different from the zlib format.  gzip is a', "  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.", "", "    This library can optionally read and write gzip streams in memory as well.", "", "    The zlib format was designed to be compact and fast for use in memory", "  and on communications channels.  The gzip format was designed for single-", "  file compression on file systems, has a larger header than zlib to maintain", "  directory information, and uses a different, slower check method than zlib.", "", "    The library does not install any signal handler.  The decoder checks", "  the consistency of the compressed data, so the library should never crash", "  even in case of corrupted input.", "*/", "", "typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));", "typedef void   (*free_func)  OF((voidpf opaque, voidpf address));", "", "struct internal_state;", "", "typedef struct z_stream_s {", "    Bytef    *next_in;  /* next input byte */", "    uInt     avail_in;  /* number of bytes available at next_in */", "    uLong    total_in;  /* total nb of input bytes read so far */", "", "    Bytef    *next_out; /* next output byte should be put there */", "    uInt     avail_out; /* remaining free space at next_out */", "    uLong    total_out; /* total nb of bytes output so far */", "", "    char     *msg;      /* last error message, NULL if no error */", "    struct internal_state FAR *state; /* not visible by applications */", "", "    alloc_func zalloc;  /* used to allocate the internal state */", "    free_func  zfree;   /* used to free the internal state */", "    voidpf     opaque;  /* private data object passed to zalloc and zfree */", "", "    int     data_type;  /* best guess about the data type: binary or text */", "    uLong   adler;      /* adler32 value of the uncompressed data */", "    uLong   reserved;   /* reserved for future use */", "} z_stream;", "", "typedef z_stream FAR *z_streamp;", "", "/*", "     gzip header information passed to and from zlib routines.  See RFC 1952", "  for more details on the meanings of these fields.", "*/", "typedef struct gz_header_s {", "    int     text;       /* true if compressed data believed to be text */", "    uLong   time;       /* modification time */", "    int     xflags;     /* extra flags (not used when writing a gzip file) */", "    int     os;         /* operating system */", "    Bytef   *extra;     /* pointer to extra field or Z_NULL if none */", "    uInt    extra_len;  /* extra field length (valid if extra != Z_NULL) */", "    uInt    extra_max;  /* space at extra (only when reading header) */", "    Bytef   *name;      /* pointer to zero-terminated file name or Z_NULL */", "    uInt    name_max;   /* space at name (only when reading header) */", "    Bytef   *comment;   /* pointer to zero-terminated comment or Z_NULL */", "    uInt    comm_max;   /* space at comment (only when reading header) */", "    int     hcrc;       /* true if there was or will be a header crc */", "    int     done;       /* true when done reading gzip header (not used", "                           when writing a gzip file) */", "} gz_header;", "", "typedef gz_header FAR *gz_headerp;", "", "/*", "     The application must update next_in and avail_in when avail_in has dropped", "   to zero.  It must update next_out and avail_out when avail_out has dropped", "   to zero.  The application must initialize zalloc, zfree and opaque before", "   calling the init function.  All other fields are set by the compression", "   library and must not be updated by the application.", "", "     The opaque value provided by the application will be passed as the first", "   parameter for calls of zalloc and zfree.  This can be useful for custom", "   memory management.  The compression library attaches no meaning to the", "   opaque value.", "", "     zalloc must return Z_NULL if there is not enough memory for the object.", "   If zlib is used in a multi-threaded application, zalloc and zfree must be", "   thread safe.", "", "     On 16-bit systems, the functions zalloc and zfree must be able to allocate", "   exactly 65536 bytes, but will not be required to allocate more than this if", "   the symbol MAXSEG_64K is defined (see zconf.h).  WARNING: On MSDOS, pointers", "   returned by zalloc for objects of exactly 65536 bytes *must* have their", "   offset normalized to zero.  The default allocation function provided by this", "   library ensures this (see zutil.c).  To reduce memory requirements and avoid", "   any allocation of 64K objects, at the expense of compression ratio, compile", "   the library with -DMAX_WBITS=14 (see zconf.h).", "", "     The fields total_in and total_out can be used for statistics or progress", "   reports.  After compression, total_in holds the total size of the", "   uncompressed data and may be saved for use in the decompressor (particularly", "   if the decompressor wants to decompress everything in a single step).", "*/", "", "                        /* constants */", "", "#define Z_NO_FLUSH      0", "#define Z_PARTIAL_FLUSH 1", "#define Z_SYNC_FLUSH    2", "#define Z_FULL_FLUSH    3", "#define Z_FINISH        4", "#define Z_BLOCK         5", "#define Z_TREES         6", "/* Allowed flush values; see deflate() and inflate() below for details */", "", "#define Z_OK            0", "#define Z_STREAM_END    1", "#define Z_NEED_DICT     2", "#define Z_ERRNO        (-1)", "#define Z_STREAM_ERROR (-2)", "#define Z_DATA_ERROR   (-3)", "#define Z_MEM_ERROR    (-4)", "#define Z_BUF_ERROR    (-5)", "#define Z_VERSION_ERROR (-6)", "/* Return codes for the compression/decompression functions. Negative values", " * are errors, positive values are used for special but normal events.", " */", "", "#define Z_NO_COMPRESSION         0", "#define Z_BEST_SPEED             1", "#define Z_BEST_COMPRESSION       9", "#define Z_DEFAULT_COMPRESSION  (-1)", "/* compression levels */", "", "#define Z_FILTERED            1", "#define Z_HUFFMAN_ONLY        2", "#define Z_RLE                 3", "#define Z_FIXED               4", "#define Z_DEFAULT_STRATEGY    0", "/* compression strategy; see deflateInit2() below for details */", "", "#define Z_BINARY   0", "#define Z_TEXT     1", "#define Z_ASCII    Z_TEXT   /* for compatibility with 1.2.2 and earlier */", "#define Z_UNKNOWN  2", "/* Possible values of the data_type field (though see inflate()) */", "", "#define Z_DEFLATED   8", "/* The deflate compression method (the only one supported in this version) */", "", "#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */", "", "#define zlib_version zlibVersion()", "/* for compatibility with versions < 1.0.2 */", "", "", "                        /* basic functions */", "", "ZEXTERN const char * ZEXPORT zlibVersion OF((void));", "/* The application can compare zlibVersion and ZLIB_VERSION for consistency.", "   If the first character differs, the library code actually used is not", "   compatible with the zlib.h header file used by the application.  This check", "   is automatically made by deflateInit and inflateInit.", " */", "", "/*", "ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));", "", "     Initializes the internal stream state for compression.  The fields", "   zalloc, zfree and opaque must be initialized before by the caller.  If", "   zalloc and zfree are set to Z_NULL, deflateInit updates them to use default", "   allocation functions.", "", "     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:", "   1 gives best speed, 9 gives best compression, 0 gives no compression at all", "   (the input data is simply copied a block at a time).  Z_DEFAULT_COMPRESSION", "   requests a default compromise between speed and compression (currently", "   equivalent to level 6).", "", "     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough", "   memory, Z_STREAM_ERROR if level is not a valid compression level, or", "   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible", "   with the version assumed by the caller (ZLIB_VERSION).  msg is set to null", "   if there is no error message.  deflateInit does not perform any compression:", "   this will be done by deflate().", "*/", "", "", "ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));", "/*", "    deflate compresses as much data as possible, and stops when the input", "  buffer becomes empty or the output buffer becomes full.  It may introduce", "  some output latency (reading input without producing any output) except when", "  forced to flush.", "", "    The detailed semantics are as follows.  deflate performs one or both of the", "  following actions:", "", "  - Compress more input starting at next_in and update next_in and avail_in", "    accordingly.  If not all input can be processed (because there is not", "    enough room in the output buffer), next_in and avail_in are updated and", "    processing will resume at this point for the next call of deflate().", "", "  - Provide more output starting at next_out and update next_out and avail_out", "    accordingly.  This action is forced if the parameter flush is non zero.", "    Forcing flush frequently degrades the compression ratio, so this parameter", "    should be set only when necessary (in interactive applications).  Some", "    output may be provided even if flush is not set.", "", "    Before the call of deflate(), the application should ensure that at least", "  one of the actions is possible, by providing more input and/or consuming more", "  output, and updating avail_in or avail_out accordingly; avail_out should", "  never be zero before the call.  The application can consume the compressed", "  output when it wants, for example when the output buffer is full (avail_out", "  == 0), or after each call of deflate().  If deflate returns Z_OK and with", "  zero avail_out, it must be called again after making room in the output", "  buffer because there might be more output pending.", "", "    Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to", "  decide how much data to accumulate before producing output, in order to", "  maximize compression.", "", "    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is", "  flushed to the output buffer and the output is aligned on a byte boundary, so", "  that the decompressor can get all input data available so far.  (In", "  particular avail_in is zero after the call if enough output space has been", "  provided before the call.) Flushing may degrade compression for some", "  compression algorithms and so it should be used only when necessary.  This", "  completes the current deflate block and follows it with an empty stored block", "  that is three bits plus filler bits to the next byte, followed by four bytes", "  (00 00 ff ff).", "", "    If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the", "  output buffer, but the output is not aligned to a byte boundary.  All of the", "  input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.", "  This completes the current deflate block and follows it with an empty fixed", "  codes block that is 10 bits long.  This assures that enough bytes are output", "  in order for the decompressor to finish the block before the empty fixed code", "  block.", "", "    If flush is set to Z_BLOCK, a deflate block is completed and emitted, as", "  for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to", "  seven bits of the current block are held to be written as the next byte after", "  the next deflate block is completed.  In this case, the decompressor may not", "  be provided enough bits at this point in order to complete decompression of", "  the data provided so far to the compressor.  It may need to wait for the next", "  block to be emitted.  This is for advanced applications that need to control", "  the emission of deflate blocks.", "", "    If flush is set to Z_FULL_FLUSH, all output is flushed as with", "  Z_SYNC_FLUSH, and the compression state is reset so that decompression can", "  restart from this point if previous compressed data has been damaged or if", "  random access is desired.  Using Z_FULL_FLUSH too often can seriously degrade", "  compression.", "", "    If deflate returns with avail_out == 0, this function must be called again", "  with the same value of the flush parameter and more output space (updated", "  avail_out), until the flush is complete (deflate returns with non-zero", "  avail_out).  In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that", "  avail_out is greater than six to avoid repeated flush markers due to", "  avail_out == 0 on return.", "", "    If the parameter flush is set to Z_FINISH, pending input is processed,", "  pending output is flushed and deflate returns with Z_STREAM_END if there was", "  enough output space; if deflate returns with Z_OK, this function must be", "  called again with Z_FINISH and more output space (updated avail_out) but no", "  more input data, until it returns with Z_STREAM_END or an error.  After", "  deflate has returned Z_STREAM_END, the only possible operations on the stream", "  are deflateReset or deflateEnd.", "", "    Z_FINISH can be used immediately after deflateInit if all the compression", "  is to be done in a single step.  In this case, avail_out must be at least the", "  value returned by deflateBound (see below).  If deflate does not return", "  Z_STREAM_END, then it must be called again as described above.", "", "    deflate() sets strm->adler to the adler32 checksum of all input read", "  so far (that is, total_in bytes).", "", "    deflate() may update strm->data_type if it can make a good guess about", "  the input data type (Z_BINARY or Z_TEXT).  In doubt, the data is considered", "  binary.  This field is only for information purposes and does not affect the", "  compression algorithm in any manner.", "", "    deflate() returns Z_OK if some progress has been made (more input", "  processed or more output produced), Z_STREAM_END if all input has been", "  consumed and all output has been produced (only when flush is set to", "  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example", "  if next_in or next_out was Z_NULL), Z_BUF_ERROR if no progress is possible", "  (for example avail_in or avail_out was zero).  Note that Z_BUF_ERROR is not", "  fatal, and deflate() can be called again with more input and more output", "  space to continue compressing.", "*/", "", "", "ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));", "/*", "     All dynamically allocated data structures for this stream are freed.", "   This function discards any unprocessed input and does not flush any pending", "   output.", "", "     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the", "   stream state was inconsistent, Z_DATA_ERROR if the stream was freed", "   prematurely (some input or output was discarded).  In the error case, msg", "   may be set but then points to a static string (which must not be", "   deallocated).", "*/", "", "", "/*", "ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));", "", "     Initializes the internal stream state for decompression.  The fields", "   next_in, avail_in, zalloc, zfree and opaque must be initialized before by", "   the caller.  If next_in is not Z_NULL and avail_in is large enough (the", "   exact value depends on the compression method), inflateInit determines the", "   compression method from the zlib header and allocates all data structures", "   accordingly; otherwise the allocation will be deferred to the first call of", "   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to", "   use default allocation functions.", "", "     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough", "   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the", "   version assumed by the caller, or Z_STREAM_ERROR if the parameters are", "   invalid, such as a null pointer to the structure.  msg is set to null if", "   there is no error message.  inflateInit does not perform any decompression", "   apart from possibly reading the zlib header if present: actual decompression", "   will be done by inflate().  (So next_in and avail_in may be modified, but", "   next_out and avail_out are unused and unchanged.) The current implementation", "   of inflateInit() does not process any header information -- that is deferred", "   until inflate() is called.", "*/", "", "", "ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));", "/*", "    inflate decompresses as much data as possible, and stops when the input", "  buffer becomes empty or the output buffer becomes full.  It may introduce", "  some output latency (reading input without producing any output) except when", "  forced to flush.", "", "  The detailed semantics are as follows.  inflate performs one or both of the", "  following actions:", "", "  - Decompress more input starting at next_in and update next_in and avail_in", "    accordingly.  If not all input can be processed (because there is not", "    enough room in the output buffer), next_in is updated and processing will", "    resume at this point for the next call of inflate().", "", "  - Provide more output starting at next_out and update next_out and avail_out", "    accordingly.  inflate() provides as much output as possible, until there is", "    no more input data or no more space in the output buffer (see below about", "    the flush parameter).", "", "    Before the call of inflate(), the application should ensure that at least", "  one of the actions is possible, by providing more input and/or consuming more", "  output, and updating the next_* and avail_* values accordingly.  The", "  application can consume the uncompressed output when it wants, for example", "  when the output buffer is full (avail_out == 0), or after each call of", "  inflate().  If inflate returns Z_OK and with zero avail_out, it must be", "  called again after making room in the output buffer because there might be", "  more output pending.", "", "    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,", "  Z_BLOCK, or Z_TREES.  Z_SYNC_FLUSH requests that inflate() flush as much", "  output as possible to the output buffer.  Z_BLOCK requests that inflate()", "  stop if and when it gets to the next deflate block boundary.  When decoding", "  the zlib or gzip format, this will cause inflate() to return immediately", "  after the header and before the first block.  When doing a raw inflate,", "  inflate() will go ahead and process the first block, and will return when it", "  gets to the end of that block, or when it runs out of data.", "", "    The Z_BLOCK option assists in appending to or combining deflate streams.", "  Also to assist in this, on return inflate() will set strm->data_type to the", "  number of unused bits in the last byte taken from strm->next_in, plus 64 if", "  inflate() is currently decoding the last block in the deflate stream, plus", "  128 if inflate() returned immediately after decoding an end-of-block code or", "  decoding the complete header up to just before the first byte of the deflate", "  stream.  The end-of-block will not be indicated until all of the uncompressed", "  data from that block has been written to strm->next_out.  The number of", "  unused bits may in general be greater than seven, except when bit 7 of", "  data_type is set, in which case the number of unused bits will be less than", "  eight.  data_type is set as noted here every time inflate() returns for all", "  flush options, and so can be used to determine the amount of currently", "  consumed input in bits.", "", "    The Z_TREES option behaves as Z_BLOCK does, but it also returns when the", "  end of each deflate block header is reached, before any actual data in that", "  block is decoded.  This allows the caller to determine the length of the", "  deflate block header for later use in random access within a deflate block.", "  256 is added to the value of strm->data_type when inflate() returns", "  immediately after reaching the end of the deflate block header.", "", "    inflate() should normally be called until it returns Z_STREAM_END or an", "  error.  However if all decompression is to be performed in a single step (a", "  single call of inflate), the parameter flush should be set to Z_FINISH.  In", "  this case all pending input is processed and all pending output is flushed;", "  avail_out must be large enough to hold all the uncompressed data.  (The size", "  of the uncompressed data may have been saved by the compressor for this", "  purpose.) The next operation on this stream must be inflateEnd to deallocate", "  the decompression state.  The use of Z_FINISH is never required, but can be", "  used to inform inflate that a faster approach may be used for the single", "  inflate() call.", "", "     In this implementation, inflate() always flushes as much output as", "  possible to the output buffer, and always uses the faster approach on the", "  first call.  So the only effect of the flush parameter in this implementation", "  is on the return value of inflate(), as noted below, or when it returns early", "  because Z_BLOCK or Z_TREES is used.", "", "     If a preset dictionary is needed after this call (see inflateSetDictionary", "  below), inflate sets strm->adler to the adler32 checksum of the dictionary", "  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets", "  strm->adler to the adler32 checksum of all output produced so far (that is,", "  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described", "  below.  At the end of the stream, inflate() checks that its computed adler32", "  checksum is equal to that saved by the compressor and returns Z_STREAM_END", "  only if the checksum is correct.", "", "    inflate() can decompress and check either zlib-wrapped or gzip-wrapped", "  deflate data.  The header type is detected automatically, if requested when", "  initializing with inflateInit2().  Any information contained in the gzip", "  header is not retained, so applications that need that information should", "  instead use raw inflate, see inflateInit2() below, or inflateBack() and", "  perform their own processing of the gzip header and trailer.", "", "    inflate() returns Z_OK if some progress has been made (more input processed", "  or more output produced), Z_STREAM_END if the end of the compressed data has", "  been reached and all uncompressed output has been produced, Z_NEED_DICT if a", "  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was", "  corrupted (input stream not conforming to the zlib format or incorrect check", "  value), Z_STREAM_ERROR if the stream structure was inconsistent (for example", "  next_in or next_out was Z_NULL), Z_MEM_ERROR if there was not enough memory,", "  Z_BUF_ERROR if no progress is possible or if there was not enough room in the", "  output buffer when Z_FINISH is used.  Note that Z_BUF_ERROR is not fatal, and", "  inflate() can be called again with more input and more output space to", "  continue decompressing.  If Z_DATA_ERROR is returned, the application may", "  then call inflateSync() to look for a good compression block if a partial", "  recovery of the data is desired.", "*/", "", "", "ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));", "/*", "     All dynamically allocated data structures for this stream are freed.", "   This function discards any unprocessed input and does not flush any pending", "   output.", "", "     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state", "   was inconsistent.  In the error case, msg may be set but then points to a", "   static string (which must not be deallocated).", "*/", "", "", "                        /* Advanced functions */", "", "/*", "    The following functions are needed only in some special applications.", "*/", "", "/*", "ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,", "                                     int  level,", "                                     int  method,", "                                     int  windowBits,", "                                     int  memLevel,", "                                     int  strategy));", "", "     This is another version of deflateInit with more compression options.  The", "   fields next_in, zalloc, zfree and opaque must be initialized before by the", "   caller.", "", "     The method parameter is the compression method.  It must be Z_DEFLATED in", "   this version of the library.", "", "     The windowBits parameter is the base two logarithm of the window size", "   (the size of the history buffer).  It should be in the range 8..15 for this", "   version of the library.  Larger values of this parameter result in better", "   compression at the expense of memory usage.  The default value is 15 if", "   deflateInit is used instead.", "", "     windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits", "   determines the window size.  deflate() will then generate raw deflate data", "   with no zlib header or trailer, and will not compute an adler32 check value.", "", "     windowBits can also be greater than 15 for optional gzip encoding.  Add", "   16 to windowBits to write a simple gzip header and trailer around the", "   compressed data instead of a zlib wrapper.  The gzip header will have no", "   file name, no extra data, no comment, no modification time (set to zero), no", "   header crc, and the operating system will be set to 255 (unknown).  If a", "   gzip stream is being written, strm->adler is a crc32 instead of an adler32.", "", "     The memLevel parameter specifies how much memory should be allocated", "   for the internal compression state.  memLevel=1 uses minimum memory but is", "   slow and reduces compression ratio; memLevel=9 uses maximum memory for", "   optimal speed.  The default value is 8.  See zconf.h for total memory usage", "   as a function of windowBits and memLevel.", "", "     The strategy parameter is used to tune the compression algorithm.  Use the", "   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a", "   filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no", "   string match), or Z_RLE to limit match distances to one (run-length", "   encoding).  Filtered data consists mostly of small values with a somewhat", "   random distribution.  In this case, the compression algorithm is tuned to", "   compress them better.  The effect of Z_FILTERED is to force more Huffman", "   coding and less string matching; it is somewhat intermediate between", "   Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY.  Z_RLE is designed to be almost as", "   fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data.  The", "   strategy parameter only affects the compression ratio but not the", "   correctness of the compressed output even if it is not set appropriately.", "   Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler", "   decoder for special applications.", "", "     deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough", "   memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid", "   method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is", "   incompatible with the version assumed by the caller (ZLIB_VERSION).  msg is", "   set to null if there is no error message.  deflateInit2 does not perform any", "   compression: this will be done by deflate().", "*/", "", "ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,", "                                             const Bytef *dictionary,", "                                             uInt  dictLength));", "/*", "     Initializes the compression dictionary from the given byte sequence", "   without producing any compressed output.  This function must be called", "   immediately after deflateInit, deflateInit2 or deflateReset, before any call", "   of deflate.  The compressor and decompressor must use exactly the same", "   dictionary (see inflateSetDictionary).", "", "     The dictionary should consist of strings (byte sequences) that are likely", "   to be encountered later in the data to be compressed, with the most commonly", "   used strings preferably put towards the end of the dictionary.  Using a", "   dictionary is most useful when the data to be compressed is short and can be", "   predicted with good accuracy; the data can then be compressed better than", "   with the default empty dictionary.", "", "     Depending on the size of the compression data structures selected by", "   deflateInit or deflateInit2, a part of the dictionary may in effect be", "   discarded, for example if the dictionary is larger than the window size", "   provided in deflateInit or deflateInit2.  Thus the strings most likely to be", "   useful should be put at the end of the dictionary, not at the front.  In", "   addition, the current implementation of deflate will use at most the window", "   size minus 262 bytes of the provided dictionary.", "", "     Upon return of this function, strm->adler is set to the adler32 value", "   of the dictionary; the decompressor may later use this value to determine", "   which dictionary has been used by the compressor.  (The adler32 value", "   applies to the whole dictionary even if only a subset of the dictionary is", "   actually used by the compressor.) If a raw deflate was requested, then the", "   adler32 value is not computed and strm->adler is not set.", "", "     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a", "   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is", "   inconsistent (for example if deflate has already been called for this stream", "   or if the compression method is bsort).  deflateSetDictionary does not", "   perform any compression: this will be done by deflate().", "*/", "", "ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,", "                                    z_streamp source));", "/*", "     Sets the destination stream as a complete copy of the source stream.", "", "     This function can be useful when several compression strategies will be", "   tried, for example when there are several ways of pre-processing the input", "   data with a filter.  The streams that will be discarded should then be freed", "   by calling deflateEnd.  Note that deflateCopy duplicates the internal", "   compression state which can be quite large, so this strategy is slow and can", "   consume lots of memory.", "", "     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not", "   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent", "   (such as zalloc being Z_NULL).  msg is left unchanged in both source and", "   destination.", "*/", "", "ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));", "/*", "     This function is equivalent to deflateEnd followed by deflateInit,", "   but does not free and reallocate all the internal compression state.  The", "   stream will keep the same compression level and any other attributes that", "   may have been set by deflateInit2.", "", "     deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source", "   stream state was inconsistent (such as zalloc or state being Z_NULL).", "*/", "", "ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,", "                                      int level,", "                                      int strategy));", "/*", "     Dynamically update the compression level and compression strategy.  The", "   interpretation of level and strategy is as in deflateInit2.  This can be", "   used to switch between compression and straight copy of the input data, or", "   to switch to a different kind of input data requiring a different strategy.", "   If the compression level is changed, the input available so far is", "   compressed with the old level (and may be flushed); the new level will take", "   effect only at the next call of deflate().", "", "     Before the call of deflateParams, the stream state must be set as for", "   a call of deflate(), since the currently available input may have to be", "   compressed and flushed.  In particular, strm->avail_out must be non-zero.", "", "     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source", "   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR if", "   strm->avail_out was zero.", "*/", "", "ZEXTERN int ZEXPORT deflateTune OF((z_streamp strm,", "                                    int good_length,", "                                    int max_lazy,", "                                    int nice_length,", "                                    int max_chain));", "/*", "     Fine tune deflate's internal compression parameters.  This should only be", "   used by someone who understands the algorithm used by zlib's deflate for", "   searching for the best matching string, and even then only by the most", "   fanatic optimizer trying to squeeze out the last compressed bit for their", "   specific input data.  Read the deflate.c source code for the meaning of the", "   max_lazy, good_length, nice_length, and max_chain parameters.", "", "     deflateTune() can be called after deflateInit() or deflateInit2(), and", "   returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.", " */", "", "ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,", "                                       uLong sourceLen));", "/*", "     deflateBound() returns an upper bound on the compressed size after", "   deflation of sourceLen bytes.  It must be called after deflateInit() or", "   deflateInit2(), and after deflateSetHeader(), if used.  This would be used", "   to allocate an output buffer for deflation in a single pass, and so would be", "   called before deflate().", "*/", "", "ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,", "                                     int bits,", "                                     int value));", "/*", "     deflatePrime() inserts bits in the deflate output stream.  The intent", "   is that this function is used to start off the deflate output with the bits", "   leftover from a previous deflate stream when appending to it.  As such, this", "   function can only be used for raw deflate, and must be used before the first", "   deflate() call after a deflateInit2() or deflateReset().  bits must be less", "   than or equal to 16, and that many of the least significant bits of value", "   will be inserted in the output.", "", "     deflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source", "   stream state was inconsistent.", "*/", "", "ZEXTERN int ZEXPORT deflateSetHeader OF((z_streamp strm,", "                                         gz_headerp head));", "/*", "     deflateSetHeader() provides gzip header information for when a gzip", "   stream is requested by deflateInit2().  deflateSetHeader() may be called", "   after deflateInit2() or deflateReset() and before the first call of", "   deflate().  The text, time, os, extra field, name, and comment information", "   in the provided gz_header structure are written to the gzip header (xflag is", "   ignored -- the extra flags are set according to the compression level).  The", "   caller must assure that, if not Z_NULL, name and comment are terminated with", "   a zero byte, and that if extra is not Z_NULL, that extra_len bytes are", "   available there.  If hcrc is true, a gzip header crc is included.  Note that", "   the current versions of the command-line version of gzip (up through version", "   1.3.x) do not support header crc's, and will report that it is a \"multi-part", '   gzip file" and give up.', "", "     If deflateSetHeader is not used, the default gzip header has text false,", "   the time set to zero, and os set to 255, with no extra, name, or comment", "   fields.  The gzip header is returned to the default state by deflateReset().", "", "     deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source", "   stream state was inconsistent.", "*/", "", "/*", "ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,", "                                     int  windowBits));", "", "     This is another version of inflateInit with an extra parameter.  The", "   fields next_in, avail_in, zalloc, zfree and opaque must be initialized", "   before by the caller.", "", "     The windowBits parameter is the base two logarithm of the maximum window", "   size (the size of the history buffer).  It should be in the range 8..15 for", "   this version of the library.  The default value is 15 if inflateInit is used", "   instead.  windowBits must be greater than or equal to the windowBits value", "   provided to deflateInit2() while compressing, or it must be equal to 15 if", "   deflateInit2() was not used.  If a compressed stream with a larger window", "   size is given as input, inflate() will return with the error code", "   Z_DATA_ERROR instead of trying to allocate a larger window.", "", "     windowBits can also be zero to request that inflate use the window size in", "   the zlib header of the compressed stream.", "", "     windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits", "   determines the window size.  inflate() will then process raw deflate data,", "   not looking for a zlib or gzip header, not generating a check value, and not", "   looking for any check values for comparison at the end of the stream.  This", "   is for use with other formats that use the deflate compressed data format", "   such as zip.  Those formats provide their own check values.  If a custom", "   format is developed using the raw deflate format for compressed data, it is", "   recommended that a check value such as an adler32 or a crc32 be applied to", "   the uncompressed data as is done in the zlib, gzip, and zip formats.  For", "   most applications, the zlib format should be used as is.  Note that comments", "   above on the use in deflateInit2() applies to the magnitude of windowBits.", "", "     windowBits can also be greater than 15 for optional gzip decoding.  Add", "   32 to windowBits to enable zlib and gzip decoding with automatic header", "   detection, or add 16 to decode only the gzip format (the zlib format will", "   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is a", "   crc32 instead of an adler32.", "", "     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough", "   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the", "   version assumed by the caller, or Z_STREAM_ERROR if the parameters are", "   invalid, such as a null pointer to the structure.  msg is set to null if", "   there is no error message.  inflateInit2 does not perform any decompression", "   apart from possibly reading the zlib header if present: actual decompression", "   will be done by inflate().  (So next_in and avail_in may be modified, but", "   next_out and avail_out are unused and unchanged.) The current implementation", "   of inflateInit2() does not process any header information -- that is", "   deferred until inflate() is called.", "*/", "", "ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,", "                                             const Bytef *dictionary,", "                                             uInt  dictLength));", "/*", "     Initializes the decompression dictionary from the given uncompressed byte", "   sequence.  This function must be called immediately after a call of inflate,", "   if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor", "   can be determined from the adler32 value returned by that call of inflate.", "   The compressor and decompressor must use exactly the same dictionary (see", "   deflateSetDictionary).  For raw inflate, this function can be called", "   immediately after inflateInit2() or inflateReset() and before any call of", "   inflate() to set the dictionary.  The application must insure that the", "   dictionary that was used for compression is provided.", "", "     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a", "   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is", "   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the", "   expected one (incorrect adler32 value).  inflateSetDictionary does not", "   perform any decompression: this will be done by subsequent calls of", "   inflate().", "*/", "", "ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));", "/*", "     Skips invalid compressed data until a full flush point (see above the", "   description of deflate with Z_FULL_FLUSH) can be found, or until all", "   available input is skipped.  No output is provided.", "", "     inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR", "   if no more input was provided, Z_DATA_ERROR if no flush point has been", "   found, or Z_STREAM_ERROR if the stream structure was inconsistent.  In the", "   success case, the application may save the current current value of total_in", "   which indicates where valid compressed data was found.  In the error case,", "   the application may repeatedly call inflateSync, providing more input each", "   time, until success or end of the input data.", "*/", "", "ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,", "                                    z_streamp source));", "/*", "     Sets the destination stream as a complete copy of the source stream.", "", "     This function can be useful when randomly accessing a large stream.  The", "   first pass through the stream can periodically record the inflate state,", "   allowing restarting inflate at those points when randomly accessing the", "   stream.", "", "     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not", "   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent", "   (such as zalloc being Z_NULL).  msg is left unchanged in both source and", "   destination.", "*/", "", "ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));", "/*", "     This function is equivalent to inflateEnd followed by inflateInit,", "   but does not free and reallocate all the internal decompression state.  The", "   stream will keep attributes that may have been set by inflateInit2.", "", "     inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source", "   stream state was inconsistent (such as zalloc or state being Z_NULL).", "*/", "", "ZEXTERN int ZEXPORT inflateReset2 OF((z_streamp strm,", "                                      int windowBits))", "                                      __OSX_AVAILABLE_STARTING(__MAC_10_7,__IPHONE_5_0);", "/*", "     This function is the same as inflateReset, but it also permits changing", "   the wrap and window size requests.  The windowBits parameter is interpreted", "   the same as it is for inflateInit2.", "", "     inflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source", "   stream state was inconsistent (such as zalloc or state being Z_NULL), or if", "   the windowBits parameter is invalid.", "*/", "", "ZEXTERN int ZEXPORT inflatePrime OF((z_streamp strm,", "                                     int bits,", "                                     int value));", "/*", "     This function inserts bits in the inflate input stream.  The intent is", "   that this function is used to start inflating at a bit position in the", "   middle of a byte.  The provided bits will be used before any bytes are used", "   from next_in.  This function should only be used with raw inflate, and", "   should be used before the first inflate() call after inflateInit2() or", "   inflateReset().  bits must be less than or equal to 16, and that many of the", "   least significant bits of value will be inserted in the input.", "", "     If bits is negative, then the input stream bit buffer is emptied.  Then", "   inflatePrime() can be called again to put bits in the buffer.  This is used", "   to clear out bits leftover after feeding inflate a block description prior", "   to feeding inflate codes.", "", "     inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source", "   stream state was inconsistent.", "*/", "", "ZEXTERN long ZEXPORT inflateMark OF((z_streamp strm))", "                                     __OSX_AVAILABLE_STARTING(__MAC_10_7,__IPHONE_5_0);", "/*", "     This function returns two values, one in the lower 16 bits of the return", "   value, and the other in the remaining upper bits, obtained by shifting the", "   return value down 16 bits.  If the upper value is -1 and the lower value is", "   zero, then inflate() is currently decoding information outside of a block.", "   If the upper value is -1 and the lower value is non-zero, then inflate is in", "   the middle of a stored block, with the lower value equaling the number of", "   bytes from the input remaining to copy.  If the upper value is not -1, then", "   it is the number of bits back from the current bit position in the input of", "   the code (literal or length/distance pair) currently being processed.  In", "   that case the lower value is the number of bytes already emitted for that", "   code.", "", "     A code is being processed if inflate is waiting for more input to complete", "   decoding of the code, or if it has completed decoding but is waiting for", "   more output space to write the literal or match data.", "", "     inflateMark() is used to mark locations in the input data for random", "   access, which may be at bit positions, and to note those cases where the", "   output of a code may span boundaries of random access blocks.  The current", "   location in the input stream can be determined from avail_in and data_type", "   as noted in the description for the Z_BLOCK flush parameter for inflate.", "", "     inflateMark returns the value noted above or -1 << 16 if the provided", "   source stream state was inconsistent.", "*/", "", "ZEXTERN int ZEXPORT inflateGetHeader OF((z_streamp strm,", "                                         gz_headerp head));", "/*", "     inflateGetHeader() requests that gzip header information be stored in the", "   provided gz_header structure.  inflateGetHeader() may be called after", "   inflateInit2() or inflateReset(), and before the first call of inflate().", "   As inflate() processes the gzip stream, head->done is zero until the header", "   is completed, at which time head->done is set to one.  If a zlib stream is", "   being decoded, then head->done is set to -1 to indicate that there will be", "   no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be", "   used to force inflate() to return immediately after header processing is", "   complete and before any actual data is decompressed.", "", "     The text, time, xflags, and os fields are filled in with the gzip header", "   contents.  hcrc is set to true if there is a header CRC.  (The header CRC", "   was valid if done is set to one.) If extra is not Z_NULL, then extra_max", "   contains the maximum number of bytes to write to extra.  Once done is true,", "   extra_len contains the actual extra field length, and extra contains the", "   extra field, or that field truncated if extra_max is less than extra_len.", "   If name is not Z_NULL, then up to name_max characters are written there,", "   terminated with a zero unless the length is greater than name_max.  If", "   comment is not Z_NULL, then up to comm_max characters are written there,", "   terminated with a zero unless the length is greater than comm_max.  When any", "   of extra, name, or comment are not Z_NULL and the respective field is not", "   present in the header, then that field is set to Z_NULL to signal its", "   absence.  This allows the use of deflateSetHeader() with the returned", "   structure to duplicate the header.  However if those fields are set to", "   allocated memory, then the application will need to save those pointers", "   elsewhere so that they can be eventually freed.", "", "     If inflateGetHeader is not used, then the header information is simply", "   discarded.  The header is always checked for validity, including the header", "   CRC if present.  inflateReset() will reset the process to discard the header", "   information.  The application would need to call inflateGetHeader() again to", "   retrieve the header from the next gzip stream.", "", "     inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source", "   stream state was inconsistent.", "*/", "", "/*", "ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,", "                                        unsigned char FAR *window));", "", "     Initialize the internal stream state for decompression using inflateBack()", "   calls.  The fields zalloc, zfree and opaque in strm must be initialized", "   before the call.  If zalloc and zfree are Z_NULL, then the default library-", "   derived memory allocation routines are used.  windowBits is the base two", "   logarithm of the window size, in the range 8..15.  window is a caller", "   supplied buffer of that size.  Except for special applications where it is", "   assured that deflate was used with small window sizes, windowBits must be 15", "   and a 32K byte window must be supplied to be able to decompress general", "   deflate streams.", "", "     See inflateBack() for the usage of these routines.", "", "     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of", "   the paramaters are invalid, Z_MEM_ERROR if the internal state could not be", "   allocated, or Z_VERSION_ERROR if the version of the library does not match", "   the version of the header file.", "*/", "", "typedef unsigned (*in_func) OF((void FAR *, unsigned char FAR * FAR *));", "typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));", "", "ZEXTERN int ZEXPORT inflateBack OF((z_streamp strm,", "                                    in_func in, void FAR *in_desc,", "                                    out_func out, void FAR *out_desc));", "/*", "     inflateBack() does a raw inflate with a single call using a call-back", "   interface for input and output.  This is more efficient than inflate() for", "   file i/o applications in that it avoids copying between the output and the", "   sliding window by simply making the window itself the output buffer.  This", "   function trusts the application to not change the output buffer passed by", "   the output function, at least until inflateBack() returns.", "", "     inflateBackInit() must be called first to allocate the internal state", "   and to initialize the state with the user-provided window buffer.", "   inflateBack() may then be used multiple times to inflate a complete, raw", "   deflate stream with each call.  inflateBackEnd() is then called to free the", "   allocated state.", "", "     A raw deflate stream is one with no zlib or gzip header or trailer.", "   This routine would normally be used in a utility that reads zip or gzip", "   files and writes out uncompressed files.  The utility would decode the", "   header and process the trailer on its own, hence this routine expects only", "   the raw deflate stream to decompress.  This is different from the normal", "   behavior of inflate(), which expects either a zlib or gzip header and", "   trailer around the deflate stream.", "", "     inflateBack() uses two subroutines supplied by the caller that are then", "   called by inflateBack() for input and output.  inflateBack() calls those", "   routines until it reads a complete deflate stream and writes out all of the", "   uncompressed data, or until it encounters an error.  The function's", "   parameters and return types are defined above in the in_func and out_func", "   typedefs.  inflateBack() will call in(in_desc, &buf) which should return the", "   number of bytes of provided input, and a pointer to that input in buf.  If", "   there is no input available, in() must return zero--buf is ignored in that", "   case--and inflateBack() will return a buffer error.  inflateBack() will call", "   out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].  out()", "   should return zero on success, or non-zero on failure.  If out() returns", "   non-zero, inflateBack() will return with an error.  Neither in() nor out()", "   are permitted to change the contents of the window provided to", "   inflateBackInit(), which is also the buffer that out() uses to write from.", "   The length written by out() will be at most the window size.  Any non-zero", "   amount of input may be provided by in().", "", "     For convenience, inflateBack() can be provided input on the first call by", "   setting strm->next_in and strm->avail_in.  If that input is exhausted, then", "   in() will be called.  Therefore strm->next_in must be initialized before", "   calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called", "   immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in", "   must also be initialized, and then if strm->avail_in is not zero, input will", "   initially be taken from strm->next_in[0 ..  strm->avail_in - 1].", "", "     The in_desc and out_desc parameters of inflateBack() is passed as the", "   first parameter of in() and out() respectively when they are called.  These", "   descriptors can be optionally used to pass any information that the caller-", "   supplied in() and out() functions need to do their job.", "", "     On return, inflateBack() will set strm->next_in and strm->avail_in to", "   pass back any unused input that was provided by the last in() call.  The", "   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR", "   if in() or out() returned an error, Z_DATA_ERROR if there was a format error", "   in the deflate stream (in which case strm->msg is set to indicate the nature", "   of the error), or Z_STREAM_ERROR if the stream was not properly initialized.", "   In the case of Z_BUF_ERROR, an input or output error can be distinguished", "   using strm->next_in which will be Z_NULL only if in() returned an error.  If", "   strm->next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning", "   non-zero.  (in() will always be called before out(), so strm->next_in is", "   assured to be defined if out() returns non-zero.) Note that inflateBack()", "   cannot return Z_OK.", "*/", "", "ZEXTERN int ZEXPORT inflateBackEnd OF((z_streamp strm));", "/*", "     All memory allocated by inflateBackInit() is freed.", "", "     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream", "   state was inconsistent.", "*/", "", "ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));", "/* Return flags indicating compile-time options.", "", "    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:", "     1.0: size of uInt", "     3.2: size of uLong", "     5.4: size of voidpf (pointer)", "     7.6: size of z_off_t", "", "    Compiler, assembler, and debug options:", "     8: DEBUG", "     9: ASMV or ASMINF -- use ASM code", "     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention", "     11: 0 (reserved)", "", "    One-time table building (smaller code, but not thread-safe if true):", "     12: BUILDFIXED -- build static block decoding tables when needed", "     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed", "     14,15: 0 (reserved)", "", "    Library content (indicates missing functionality):", "     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking", "                          deflate code when not needed)", "     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect", "                    and decode gzip streams (to avoid linking crc code)", "     18-19: 0 (reserved)", "", "    Operation variations (changes in library functionality):", "     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate", "     21: FASTEST -- deflate algorithm with only one, lowest compression level", "     22,23: 0 (reserved)", "", "    The sprintf variant used by gzprintf (zero is best):", "     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format", "     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!", "     26: 0 = returns value, 1 = void -- 1 means inferred string length returned", "", "    Remainder:", "     27-31: 0 (reserved)", " */", "", "", "                        /* utility functions */", "", "/*", "     The following utility functions are implemented on top of the basic", "   stream-oriented functions.  To simplify the interface, some default options", "   are assumed (compression level and memory usage, standard memory allocation", "   functions).  The source code of these utility functions can be modified if", "   you need special options.", "*/", "", "ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,", "                                 const Bytef *source, uLong sourceLen));", "/*", "     Compresses the source buffer into the destination buffer.  sourceLen is", "   the byte length of the source buffer.  Upon entry, destLen is the total size", "   of the destination buffer, which must be at least the value returned by", "   compressBound(sourceLen).  Upon exit, destLen is the actual size of the", "   compressed buffer.", "", "     compress returns Z_OK if success, Z_MEM_ERROR if there was not", "   enough memory, Z_BUF_ERROR if there was not enough room in the output", "   buffer.", "*/", "", "ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,", "                                  const Bytef *source, uLong sourceLen,", "                                  int level));", "/*", "     Compresses the source buffer into the destination buffer.  The level", "   parameter has the same meaning as in deflateInit.  sourceLen is the byte", "   length of the source buffer.  Upon entry, destLen is the total size of the", "   destination buffer, which must be at least the value returned by", "   compressBound(sourceLen).  Upon exit, destLen is the actual size of the", "   compressed buffer.", "", "     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough", "   memory, Z_BUF_ERROR if there was not enough room in the output buffer,", "   Z_STREAM_ERROR if the level parameter is invalid.", "*/", "", "ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));", "/*", "     compressBound() returns an upper bound on the compressed size after", "   compress() or compress2() on sourceLen bytes.  It would be used before a", "   compress() or compress2() call to allocate the destination buffer.", "*/", "", "ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,", "                                   const Bytef *source, uLong sourceLen));", "/*", "     Decompresses the source buffer into the destination buffer.  sourceLen is", "   the byte length of the source buffer.  Upon entry, destLen is the total size", "   of the destination buffer, which must be large enough to hold the entire", "   uncompressed data.  (The size of the uncompressed data must have been saved", "   previously by the compressor and transmitted to the decompressor by some", "   mechanism outside the scope of this compression library.) Upon exit, destLen", "   is the actual size of the uncompressed buffer.", "", "     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not", "   enough memory, Z_BUF_ERROR if there was not enough room in the output", "   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.", "*/", "", "", "                        /* gzip file access functions */", "", "/*", "     This library supports reading and writing files in gzip (.gz) format with", "   an interface similar to that of stdio, using the functions that start with", '   "gz".  The gzip format is different from the zlib format.  gzip is a gzip', "   wrapper, documented in RFC 1952, wrapped around a deflate stream.", "*/", "", "typedef voidp gzFile;       /* opaque gzip file descriptor */", "", "/*", "ZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));", "", "     Opens a gzip (.gz) file for reading or writing.  The mode parameter is as", '   in fopen ("rb" or "wb") but can also include a compression level ("wb9") or', "   a strategy: 'f' for filtered data as in \"wb6f\", 'h' for Huffman-only", "   compression as in \"wb1h\", 'R' for run-length encoding as in \"wb1R\", or 'F'", '   for fixed code compression as in "wb9F".  (See the description of', '   deflateInit2 for more information about the strategy parameter.) Also "a"', '   can be used instead of "w" to request that the gzip stream that will be', '   written be appended to the file.  "+" will result in an error, since reading', "   and writing to the same gzip file is not supported.", "", "     gzopen can be used to read a file which is not in gzip format; in this", "   case gzread will directly read from the file without decompression.", "", "     gzopen returns NULL if the file could not be opened, if there was", "   insufficient memory to allocate the gzFile state, or if an invalid mode was", "   specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).", "   errno can be checked to determine if the reason gzopen failed was that the", "   file could not be opened.", "*/", "", "ZEXTERN gzFile ZEXPORT gzdopen OF((int fd, const char *mode));", "/*", "     gzdopen associates a gzFile with the file descriptor fd.  File descriptors", "   are obtained from calls like open, dup, creat, pipe or fileno (if the file", "   has been previously opened with fopen).  The mode parameter is as in gzopen.", "", "     The next call of gzclose on the returned gzFile will also close the file", "   descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor", "   fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,", "   mode);.  The duplicated descriptor should be saved to avoid a leak, since", "   gzdopen does not close fd if it fails.", "", "     gzdopen returns NULL if there was insufficient memory to allocate the", "   gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not", "   provided, or '+' was provided), or if fd is -1.  The file descriptor is not", "   used until the next gz* read, write, seek, or close operation, so gzdopen", "   will not detect if fd is invalid (unless fd is -1).", "*/", "", "ZEXTERN int ZEXPORT gzbuffer OF((gzFile file, unsigned size))", "                                 __OSX_AVAILABLE_STARTING(__MAC_10_7,__IPHONE_5_0);", "/*", "     Set the internal buffer size used by this library's functions.  The", "   default buffer size is 8192 bytes.  This function must be called after", "   gzopen() or gzdopen(), and before any other calls that read or write the", "   file.  The buffer memory allocation is always deferred to the first read or", "   write.  Two buffers are allocated, either both of the specified size when", "   writing, or one of the specified size and the other twice that size when", "   reading.  A larger buffer size of, for example, 64K or 128K bytes will", "   noticeably increase the speed of decompression (reading).", "", "     The new buffer size also affects the maximum length for gzprintf().", "", "     gzbuffer() returns 0 on success, or -1 on failure, such as being called", "   too late.", "*/", "", "ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));", "/*", "     Dynamically update the compression level or strategy.  See the description", "   of deflateInit2 for the meaning of these parameters.", "", "     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not", "   opened for writing.", "*/", "", "ZEXTERN int ZEXPORT gzread OF((gzFile file, voidp buf, unsigned len));", "/*", "     Reads the given number of uncompressed bytes from the compressed file.  If", "   the input file was not in gzip format, gzread copies the given number of", "   bytes into the buffer.", "", "     After reaching the end of a gzip stream in the input, gzread will continue", "   to read, looking for another gzip stream, or failing that, reading the rest", "   of the input file directly without decompression.  The entire input file", "   will be read if gzread is called until it returns less than the requested", "   len.", "", "     gzread returns the number of uncompressed bytes actually read, less than", "   len for end of file, or -1 for error.", "*/", "", "ZEXTERN int ZEXPORT gzwrite OF((gzFile file,", "                                voidpc buf, unsigned len));", "/*", "     Writes the given number of uncompressed bytes into the compressed file.", "   gzwrite returns the number of uncompressed bytes written or 0 in case of", "   error.", "*/", "", "ZEXTERN int ZEXPORTVA gzprintf OF((gzFile file, const char *format, ...));", "/*", "     Converts, formats, and writes the arguments to the compressed file under", "   control of the format string, as in fprintf.  gzprintf returns the number of", "   uncompressed bytes actually written, or 0 in case of error.  The number of", "   uncompressed bytes written is limited to 8191, or one less than the buffer", "   size given to gzbuffer().  The caller should assure that this limit is not", "   exceeded.  If it is exceeded, then gzprintf() will return an error (0) with", "   nothing written.  In this case, there may also be a buffer overflow with", "   unpredictable consequences, which is possible only if zlib was compiled with", "   the insecure functions sprintf() or vsprintf() because the secure snprintf()", "   or vsnprintf() functions were not available.  This can be determined using", "   zlibCompileFlags().", "*/", "", "ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));", "/*", "     Writes the given null-terminated string to the compressed file, excluding", "   the terminating null character.", "", "     gzputs returns the number of characters written, or -1 in case of error.", "*/", "", "ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));", "/*", "     Reads bytes from the compressed file until len-1 characters are read, or a", "   newline character is read and transferred to buf, or an end-of-file", "   condition is encountered.  If any characters are read or if len == 1, the", "   string is terminated with a null character.  If no characters are read due", "   to an end-of-file or len < 1, then the buffer is left untouched.", "", "     gzgets returns buf which is a null-terminated string, or it returns NULL", "   for end-of-file or in case of error.  If there was an error, the contents at", "   buf are indeterminate.", "*/", "", "ZEXTERN int ZEXPORT gzputc OF((gzFile file, int c));", "/*", "     Writes c, converted to an unsigned char, into the compressed file.  gzputc", "   returns the value that was written, or -1 in case of error.", "*/", "", "ZEXTERN int ZEXPORT gzgetc OF((gzFile file));", "/*", "     Reads one byte from the compressed file.  gzgetc returns this byte or -1", "   in case of end of file or error.", "*/", "", "ZEXTERN int ZEXPORT gzungetc OF((int c, gzFile file));", "/*", "     Push one character back onto the stream to be read as the first character", "   on the next read.  At least one character of push-back is allowed.", "   gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will", "   fail if c is -1, and may fail if a character has been pushed but not read", "   yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the", "   output buffer size of pushed characters is allowed.  (See gzbuffer above.)", "   The pushed character will be discarded if the stream is repositioned with", "   gzseek() or gzrewind().", "*/", "", "ZEXTERN int ZEXPORT gzflush OF((gzFile file, int flush));", "/*", "     Flushes all pending output into the compressed file.  The parameter flush", "   is as in the deflate() function.  The return value is the zlib error number", "   (see function gzerror below).  gzflush is only permitted when writing.", "", "     If the flush parameter is Z_FINISH, the remaining data is written and the", "   gzip stream is completed in the output.  If gzwrite() is called again, a new", "   gzip stream will be started in the output.  gzread() is able to read such", "   concatented gzip streams.", "", "     gzflush should be called only when strictly necessary because it will", "   degrade compression if called too often.", "*/", "", "/*", "ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile file,", "                                   z_off_t offset, int whence));", "", "     Sets the starting position for the next gzread or gzwrite on the given", "   compressed file.  The offset represents a number of bytes in the", "   uncompressed data stream.  The whence parameter is defined as in lseek(2);", "   the value SEEK_END is not supported.", "", "     If the file is opened for reading, this function is emulated but can be", "   extremely slow.  If the file is opened for writing, only forward seeks are", "   supported; gzseek then compresses a sequence of zeroes up to the new", "   starting position.", "", "     gzseek returns the resulting offset location as measured in bytes from", "   the beginning of the uncompressed stream, or -1 in case of error, in", "   particular if the file is opened for writing and the new starting position", "   would be before the current position.", "*/", "", "ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));", "/*", "     Rewinds the given file. This function is supported only for reading.", "", "     gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)", "*/", "", "/*", "ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));", "", "     Returns the starting position for the next gzread or gzwrite on the given", "   compressed file.  This position represents a number of bytes in the", "   uncompressed data stream, and is zero when starting, even if appending or", "   reading a gzip stream from the middle of a file using gzdopen().", "", "     gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)", "*/", "", "/*", "ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile file));", "", "     Returns the current offset in the file being read or written.  This offset", "   includes the count of bytes that precede the gzip stream, for example when", "   appending or when using gzdopen() for reading.  When reading, the offset", "   does not include as yet unused buffered input.  This information can be used", "   for a progress indicator.  On error, gzoffset() returns -1.", "*/", "", "ZEXTERN int ZEXPORT gzeof OF((gzFile file));", "/*", "     Returns true (1) if the end-of-file indicator has been set while reading,", "   false (0) otherwise.  Note that the end-of-file indicator is set only if the", "   read tried to go past the end of the input, but came up short.  Therefore,", "   just like feof(), gzeof() may return false even if there is no more data to", "   read, in the event that the last read request was for the exact number of", "   bytes remaining in the input file.  This will happen if the input file size", "   is an exact multiple of the buffer size.", "", "     If gzeof() returns true, then the read functions will return no more data,", "   unless the end-of-file indicator is reset by gzclearerr() and the input file", "   has grown since the previous end of file was detected.", "*/", "", "ZEXTERN int ZEXPORT gzdirect OF((gzFile file));", "/*", "     Returns true (1) if file is being copied directly while reading, or false", "   (0) if file is a gzip stream being decompressed.  This state can change from", "   false to true while reading the input file if the end of a gzip stream is", "   reached, but is followed by data that is not another gzip stream.", "", "     If the input file is empty, gzdirect() will return true, since the input", "   does not contain a gzip stream.", "", "     If gzdirect() is used immediately after gzopen() or gzdopen() it will", "   cause buffers to be allocated to allow reading the file to determine if it", "   is a gzip file.  Therefore if gzbuffer() is used, it should be called before", "   gzdirect().", "*/", "", "ZEXTERN int ZEXPORT    gzclose OF((gzFile file));", "/*", "     Flushes all pending output if necessary, closes the compressed file and", "   deallocates the (de)compression state.  Note that once file is closed, you", "   cannot call gzerror with file, since its structures have been deallocated.", "   gzclose must not be called more than once on the same file, just as free", "   must not be called more than once on the same allocation.", "", "     gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a", "   file operation error, or Z_OK on success.", "*/", "", "ZEXTERN int ZEXPORT gzclose_r OF((gzFile file))", "                                  __OSX_AVAILABLE_STARTING(__MAC_10_7,__IPHONE_5_0);", "ZEXTERN int ZEXPORT gzclose_w OF((gzFile file))", "                                  __OSX_AVAILABLE_STARTING(__MAC_10_7,__IPHONE_5_0);", "/*", "     Same as gzclose(), but gzclose_r() is only for use when reading, and", "   gzclose_w() is only for use when writing or appending.  The advantage to", "   using these instead of gzclose() is that they avoid linking in zlib", "   compression or decompression code that is not used when only reading or only", "   writing respectively.  If gzclose() is used, then both compression and", "   decompression code will be included the application when linking to a static", "   zlib library.", "", "   Because Mac OS X doesn't use a static zlib library, these routine are of", "   no value for Mac OS X-only applications, and gzclose() is recommended", "   instead.", "*/", "", "ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));", "/*", "     Returns the error message for the last error which occurred on the given", "   compressed file.  errnum is set to zlib error number.  If an error occurred", "   in the file system and not in the compression library, errnum is set to", "   Z_ERRNO and the application may consult errno to get the exact error code.", "", "     The application must not modify the returned string.  Future calls to", "   this function may invalidate the previously returned string.  If file is", "   closed, then the string previously returned by gzerror will no longer be", "   available.", "", "     gzerror() should be used to distinguish errors from end-of-file for those", "   functions above that do not distinguish those cases in their return values.", "*/", "", "ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));", "/*", "     Clears the error and end-of-file flags for file.  This is analogous to the", "   clearerr() function in stdio.  This is useful for continuing to read a gzip", "   file that is being written concurrently.", "*/", "", "", "                        /* checksum functions */", "", "/*", "     These functions are not related to compression but are exported", "   anyway because they might be useful in applications using the compression", "   library.", "*/", "", "ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));", "/*", "     Update a running Adler-32 checksum with the bytes buf[0..len-1] and", "   return the updated checksum.  If buf is Z_NULL, this function returns the", "   required initial value for the checksum.", "", "     An Adler-32 checksum is almost as reliable as a CRC32 but can be computed", "   much faster.", "", "   Usage example:", "", "     uLong adler = adler32(0L, Z_NULL, 0);", "", "     while (read_buffer(buffer, length) != EOF) {", "       adler = adler32(adler, buffer, length);", "     }", "     if (adler != original_adler) error();", "*/", "", "/*", "ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,", "                                          z_off_t len2));", "", "     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1", "   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for", "   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of", "   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.", "*/", "", "ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));", "/*", "     Update a running CRC-32 with the bytes buf[0..len-1] and return the", "   updated CRC-32.  If buf is Z_NULL, this function returns the required", "   initial value for the for the crc.  Pre- and post-conditioning (one's", "   complement) is performed within this function so it shouldn't be done by the", "   application.", "", "   Usage example:", "", "     uLong crc = crc32(0L, Z_NULL, 0);", "", "     while (read_buffer(buffer, length) != EOF) {", "       crc = crc32(crc, buffer, length);", "     }", "     if (crc != original_crc) error();", "*/", "", "/*", "ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));", "", "     Combine two CRC-32 check values into one.  For two sequences of bytes,", "   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were", "   calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32", "   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and", "   len2.", "*/", "", "", "                        /* various hacks, don't look :) */", "", "/* deflateInit and inflateInit are macros to allow checking the zlib version", " * and the compiler's view of z_stream:", " */", "ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,", "                                     const char *version, int stream_size));", "ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,", "                                     const char *version, int stream_size));", "ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,", "                                      int windowBits, int memLevel,", "                                      int strategy, const char *version,", "                                      int stream_size));", "ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,", "                                      const char *version, int stream_size));", "ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,", "                                         unsigned char FAR *window,", "                                         const char *version,", "                                         int stream_size));", "#define deflateInit(strm, level) \\", "        deflateInit_((strm), (level),       ZLIB_VERSION, (int)sizeof(z_stream))", "#define inflateInit(strm) \\", "        inflateInit_((strm),                ZLIB_VERSION, (int)sizeof(z_stream))", "#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \\", "        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\\", "                      (strategy),           ZLIB_VERSION, (int)sizeof(z_stream))", "#define inflateInit2(strm, windowBits) \\", "        inflateInit2_((strm), (windowBits), ZLIB_VERSION, (int)sizeof(z_stream))", "#define inflateBackInit(strm, windowBits, window) \\", "        inflateBackInit_((strm), (windowBits), (window), \\", "                                            ZLIB_VERSION, (int)sizeof(z_stream))", "", "/* provide 64-bit offset functions if _LARGEFILE64_SOURCE defined, and/or", " * change the regular functions to 64 bits if _FILE_OFFSET_BITS is 64 (if", " * both are true, the application gets the *64 functions, and the regular", " * functions are changed to 64 bits) -- in case these are set on systems", " * without large file support, _LFS64_LARGEFILE must also be true", " */", "#if defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0", "   ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));", "   ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));", "   ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));", "   ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));", "   ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off64_t));", "   ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off64_t));", "#endif", "", "#if !defined(ZLIB_INTERNAL) && _FILE_OFFSET_BITS-0 == 64 && _LFS64_LARGEFILE-0", "#  define gzopen gzopen64", "#  define gzseek gzseek64", "#  define gztell gztell64", "#  define gzoffset gzoffset64", "#  define adler32_combine adler32_combine64", "#  define crc32_combine crc32_combine64", "#  ifdef _LARGEFILE64_SOURCE", "     ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));", "     ZEXTERN z_off_t ZEXPORT gzseek64 OF((gzFile, z_off_t, int));", "     ZEXTERN z_off_t ZEXPORT gztell64 OF((gzFile));", "     ZEXTERN z_off_t ZEXPORT gzoffset64 OF((gzFile));", "     ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));", "     ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));", "#  endif", "#else", "   ZEXTERN gzFile ZEXPORT gzopen OF((const char *, const char *));", "   ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile, z_off_t, int));", "   ZEXTERN z_off_t ZEXPORT gztell OF((gzFile));", "   ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile))", "                                        __OSX_AVAILABLE_STARTING(__MAC_10_7,__IPHONE_5_0);", "   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));", "   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));", "#endif", "", "/* hack for buggy compilers */", "#if !defined(ZUTIL_H) && !defined(NO_DUMMY_DECL)", "    struct internal_state {int dummy;};", "#endif", "", "/* undocumented functions */", "ZEXTERN const char   * ZEXPORT zError           OF((int));", "ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp));", "ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));", "ZEXTERN int            ZEXPORT inflateUndermine OF((z_streamp, int))", "                                                    __OSX_AVAILABLE_STARTING(__MAC_10_7,__IPHONE_5_0);", "", "#ifdef __cplusplus", "}", "#endif", "", "#endif /* ZLIB_H */" }
  },
  convert = <function 1>,
  fill_structs = <function 2>,
  incfolder = "./inc",
  init = <function 3>,
  list = { ".", "..", ".DS_Store", "AssertMacros.h", "Availability.h", "AvailabilityInternal.h", "AvailabilityMacros.h", "Block.h", "ConditionalMacros.h", "MacTypes.h", "NSSystemDirectories.h", "TargetConditionals.h", "Xplugin.h", "_locale.h", "_structs.h", "_types.h", "_wctype.h", "_xlocale.h", "aio.h", "aliasdb.h", "alloca.h", "ar.h", "asl.h", "assert.h", "bitstring.h", "bootparams.h", "bzlib.h", "cache.h", "cache_callbacks.h", "checkint.h", "com_err.h", "complex.h", "copyfile.h", "cpio.h", "crt_externs.h", "ctype.h", "curses.h", "cxxabi.h", "db.h", "dirent.h", "disktab.h", "dlfcn.h", "dns.h", "dns_sd.h", "dns_util.h", "dtrace.h", "err.h", "errno.h", "eti.h", "execinfo.h", "expat.h", "expat_external.h", "fcntl.h", "fenv.h", "fmtmsg.h", "fnmatch.h", "form.h", "fsproperties.h", "fstab.h", "fts.h", "ftw.h", "get_compat.h", "gethostuuid.h", "getopt.h", "glob.h", "grp.h", "gssapi.h", "histedit.h", "iconv.h", "ifaddrs.h", "inttypes.h", "iso646.h", "krb5.h", "langinfo.h", "launch.h", "lber.h", "lber_types.h", "ldap.h", "ldap_cdefs.h", "ldap_features.h", "ldap_schema.h", "ldap_utf8.h", "ldif.h", "libc.h", "libcharset.h", "libgen.h", "libproc.h", "libunwind.h", "limits.h", "localcharset.h", "locale.h", "math.h", "membership.h", "memory.h", "menu.h", "module.map", "monetary.h", "monitor.h", "mpool.h", "nameser.h", "nc_tparm.h", "ncurses.h", "ncurses_dll.h", "ndbm.h", "netdb.h", "nl_types.h", "nlist.h", "notify.h", "notify_keys.h", "ntsid.h", "panel.h", "paths.h", "pcap-bpf.h", "pcap-namedb.h", "pcap.h", "poll.h", "printerdb.h", "printf.h", "profile.h", "pthread.h", "pthread_impl.h", "pthread_spis.h", "pwd.h", "ranlib.h", "readpassphrase.h", "regex.h", "removefile.h", "resolv.h", "rune.h", "runetype.h", "sandbox.h", "sched.h", "search.h", "semaphore.h", "setjmp.h", "sgtty.h", "signal.h", "slapi-plugin.h", "spawn.h", "sqlite3.h", "sqlite3ext.h", "stab.h", "standards.h", "stdbool.h", "stddef.h", "stdint.h", "stdio.h", "stdlib.h", "strhash.h", "string.h", "stringlist.h", "strings.h", "struct.h", "sysexits.h", "syslog.h", "tar.h", "tcl.h", "tclDecls.h", "tclPlatDecls.h", "tclTomMath.h", "tclTomMathDecls.h", "term.h", "term_entry.h", "termcap.h", "termios.h", "tic.h", "time.h", "timeconv.h", "tk.h", "tkDecls.h", "tkIntXlibDecls.h", "tkMacOSX.h", "tkPlatDecls.h", "ttyent.h", "tzfile.h", "ucontext.h", "ulimit.h", "unctrl.h", "unistd.h", "unwind.h", "util.h", "utime.h", "utmp.h", "utmpx.h", "vis.h", "vproc.h", "wchar.h", "wctype.h", "wordexp.h", "xlocale.h", "zconf.h", "zlib.h" },
  print = <function 4>,
  read = <function 5>,
  srcFolder = "./_src",
  structs = <1>{
    add = <function 6>,
    init = <function 7>,
    is_typedef = <function 8>,
    list = { {
        header = "libc.h",
        linedef = 62,
        name = "qelem",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 9>,
          init = <function 10>,
          list = { {
              fpointer = 0,
              name = "*q_forw",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct qelem"
            }, {
              fpointer = 0,
              name = "*q_back",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct qelem"
            }, {
              fpointer = 0,
              name = "*q_data",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            } },
          print = <function 11>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "pwd.h",
        linedef = 84,
        name = "passwd",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 13>,
          init = <function 14>,
          list = { {
              fpointer = 0,
              name = "*pw_name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*pw_passwd",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "pw_uid",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uid_t"
            }, {
              fpointer = 0,
              name = "pw_gid",
              pointer = 0,
              s = 0,
              t = 0,
              type = "gid_t"
            }, {
              fpointer = 0,
              name = "pw_change",
              pointer = 0,
              s = 0,
              t = 0,
              type = "__darwin_time_t"
            }, {
              fpointer = 0,
              name = "*pw_class",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*pw_gecos",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*pw_dir",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*pw_shell",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "pw_expire",
              pointer = 0,
              s = 0,
              t = 0,
              type = "__darwin_time_t"
            } },
          print = <function 15>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "iconv.h",
        linedef = 90,
        name = "iconv_hooks",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 16>,
          init = <function 17>,
          list = { {
              fpointer = 0,
              name = "uc_hook",
              pointer = 0,
              s = 0,
              t = 0,
              type = "iconv_unicode_char_hook"
            }, {
              fpointer = 0,
              name = "wc_hook",
              pointer = 0,
              s = 0,
              t = 0,
              type = "iconv_wide_char_hook"
            }, {
              fpointer = 0,
              name = "void* data",
              pointer = 1,
              s = 0,
              t = 0,
              type = ""
            } },
          print = <function 18>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "iconv.h",
        linedef = 144,
        name = "iconv_fallbacks",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 19>,
          init = <function 20>,
          list = { {
              fpointer = 0,
              name = "mb_to_uc_fallback",
              pointer = 0,
              s = 0,
              t = 0,
              type = "iconv_unicode_mb_to_uc_fallback"
            }, {
              fpointer = 0,
              name = "uc_to_mb_fallback",
              pointer = 0,
              s = 0,
              t = 0,
              type = "iconv_unicode_uc_to_mb_fallback"
            }, {
              fpointer = 0,
              name = "mb_to_wc_fallback",
              pointer = 0,
              s = 0,
              t = 0,
              type = "iconv_wchar_mb_to_wc_fallback"
            }, {
              fpointer = 0,
              name = "wc_to_mb_fallback",
              pointer = 0,
              s = 0,
              t = 0,
              type = "iconv_wchar_wc_to_mb_fallback"
            }, {
              fpointer = 0,
              name = "void* data",
              pointer = 1,
              s = 0,
              t = 0,
              type = ""
            } },
          print = <function 21>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "grp.h",
        linedef = 53,
        name = "group",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 22>,
          init = <function 23>,
          list = { {
              fpointer = 0,
              name = "*gr_name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*gr_passwd",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "gr_gid",
              pointer = 0,
              s = 0,
              t = 0,
              type = "gid_t"
            }, {
              fpointer = 0,
              name = "**gr_mem",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            } },
          print = <function 24>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "form.h",
        linedef = 71,
        name = "fieldnode",
        structs = <table 1>,
        typedef = 1,
        typedname = "FIELD",
        vars = {
          add = <function 25>,
          init = <function 26>,
          list = { {
              fpointer = 0,
              name = "status",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            }, {
              fpointer = 0,
              name = "rows",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "cols",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "frow",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "fcol",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "drows",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "dcols",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "maxgrow",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "nrow",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "nbuf",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "just",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "page",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "index",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "pad",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "fore",
              pointer = 0,
              s = 0,
              t = 0,
              type = "chtype"
            }, {
              fpointer = 0,
              name = "back",
              pointer = 0,
              s = 0,
              t = 0,
              type = "chtype"
            }, {
              fpointer = 0,
              name = "opts",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Field_Options"
            }, {
              fpointer = 0,
              name = "*\tsnext",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct fieldnode"
            }, {
              fpointer = 0,
              name = "*\tsprev",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct fieldnode"
            }, {
              fpointer = 0,
              name = "*\tlink",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct fieldnode"
            }, {
              fpointer = 0,
              name = "*\tform",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct formnode"
            }, {
              fpointer = 0,
              name = "*\ttype",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct typenode"
            }, {
              fpointer = 0,
              name = "*\t\targ",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "*\t\tbuf",
              pointer = 1,
              s = 0,
              t = 0,
              type = "FIELD_CELL"
            }, {
              fpointer = 0,
              name = "*\t\tusrptr",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            } },
          print = <function 27>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "form.h",
        linedef = 112,
        name = "typenode",
        structs = <table 1>,
        typedef = 1,
        typedname = "FIELDTYPE",
        vars = {
          add = <function 28>,
          init = <function 29>,
          list = { {
              fpointer = 0,
              name = "status",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            }, {
              fpointer = 0,
              name = "ref",
              pointer = 0,
              s = 0,
              t = 0,
              type = "long"
            }, {
              fpointer = 0,
              name = "*\tleft",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct typenode"
            }, {
              fpointer = 0,
              name = "*\tright",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct typenode"
            }, {
              fpointer = 1,
              name = "void* (*makearg)(va_list *)",
              pointer = 1,
              s = 0,
              t = 0,
              type = ""
            }, {
              fpointer = 1,
              name = "void* (*copyarg)(const void *)",
              pointer = 1,
              s = 0,
              t = 0,
              type = ""
            }, {
              fpointer = 1,
              name = "(*freearg)(void *)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*fcheck)(FIELD *,const void *)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "bool"
            }, {
              fpointer = 1,
              name = "(*ccheck)(int,const void *)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "bool"
            }, {
              fpointer = 1,
              name = "(*next)(FIELD *,const void *)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "bool"
            }, {
              fpointer = 1,
              name = "(*prev)(FIELD *,const void *)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "bool"
            } },
          print = <function 30>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "form.h",
        linedef = 134,
        name = "formnode",
        structs = <table 1>,
        typedef = 1,
        typedname = "FORM",
        vars = {
          add = <function 31>,
          init = <function 32>,
          list = { {
              fpointer = 0,
              name = "status",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            }, {
              fpointer = 0,
              name = "rows",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "cols",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "currow",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "curcol",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "toprow",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "begincol",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "maxfield",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "maxpage",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "curpage",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "opts",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Form_Options"
            }, {
              fpointer = 0,
              name = "*\t\twin",
              pointer = 1,
              s = 0,
              t = 0,
              type = "WINDOW"
            }, {
              fpointer = 0,
              name = "*\t\tsub",
              pointer = 1,
              s = 0,
              t = 0,
              type = "WINDOW"
            }, {
              fpointer = 0,
              name = "*\t\tw",
              pointer = 1,
              s = 0,
              t = 0,
              type = "WINDOW"
            }, {
              fpointer = 0,
              name = "**\t\tfield",
              pointer = 1,
              s = 1,
              t = 0,
              type = "FIELD"
            }, {
              fpointer = 0,
              name = "*\t\tcurrent",
              pointer = 1,
              s = 1,
              t = 0,
              type = "FIELD"
            }, {
              fpointer = 0,
              name = "*\t\tpage",
              pointer = 1,
              s = 0,
              t = 0,
              type = "_PAGE"
            }, {
              fpointer = 0,
              name = "*\t\tusrptr",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*forminit)(struct formnode *)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*formterm)(struct formnode *)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*fieldinit)(struct formnode *)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*fieldterm)(struct formnode *)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            } },
          print = <function 33>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "getopt.h",
        linedef = 54,
        name = "option",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 34>,
          init = <function 35>,
          list = { {
              fpointer = 0,
              name = "*name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 0,
              name = "has_arg",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*flag",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "val",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 36>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "aliasdb.h",
        linedef = 31,
        name = "aliasent",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 37>,
          init = <function 38>,
          list = { {
              fpointer = 0,
              name = "*alias_name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "alias_members_len",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned"
            }, {
              fpointer = 0,
              name = "**alias_members",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "alias_local",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 39>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tclTomMath.h",
        linedef = 202,
        name = "mp_int",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 40>,
          init = <function 41>,
          list = { {
              fpointer = 0,
              name = "used, alloc, sign",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*dp",
              pointer = 1,
              s = 0,
              t = 0,
              type = "mp_digit"
            } },
          print = <function 42>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "fts.h",
        linedef = 108,
        name = "_ftsent",
        structs = <table 1>,
        typedef = 1,
        typedname = "FTSENT",
        vars = {
          add = <function 43>,
          init = <function 44>,
          list = { {
              fpointer = 0,
              name = "*fts_cycle",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct _ftsent"
            }, {
              fpointer = 0,
              name = "*fts_parent",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct _ftsent"
            }, {
              fpointer = 0,
              name = "*fts_link",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct _ftsent"
            }, {
              fpointer = 0,
              name = "fts_number",
              pointer = 0,
              s = 0,
              t = 0,
              type = "long"
            }, {
              fpointer = 0,
              name = "*fts_pointer",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "*fts_accpath",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*fts_path",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "fts_errno",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "fts_symfd",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "fts_pathlen",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            }, {
              fpointer = 0,
              name = "fts_namelen",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            }, {
              fpointer = 0,
              name = "fts_ino",
              pointer = 0,
              s = 0,
              t = 0,
              type = "ino_t"
            }, {
              fpointer = 0,
              name = "fts_dev",
              pointer = 0,
              s = 0,
              t = 0,
              type = "dev_t"
            }, {
              fpointer = 0,
              name = "fts_nlink",
              pointer = 0,
              s = 0,
              t = 0,
              type = "nlink_t"
            }, {
              fpointer = 0,
              name = "fts_level",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "fts_info",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            }, {
              fpointer = 0,
              name = "fts_flags",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            }, {
              fpointer = 0,
              name = "fts_instr",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            }, {
              fpointer = 0,
              name = "*fts_statp",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct stat"
            }, {
              fpointer = 0,
              name = "fts_name[1]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            } },
          print = <function 45>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ftw.h",
        linedef = 48,
        name = "FTW",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 46>,
          init = <function 47>,
          list = { {
              fpointer = 0,
              name = "base",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "level",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 48>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tcl.h",
        linedef = 450,
        name = "Tcl_Interp",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tcl_Interp",
        vars = {
          add = <function 49>,
          init = <function 50>,
          list = { {
              fpointer = 0,
              name = "*result",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "(*freeProc) _ANSI_ARGS_((char *blockPtr))",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "errorLine",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 51>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tcl.h",
        linedef = 560,
        name = "Tcl_RegExpIndices",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tcl_RegExpIndices",
        vars = {
          add = <function 52>,
          init = <function 53>,
          list = { {
              fpointer = 0,
              name = "start",
              pointer = 0,
              s = 0,
              t = 0,
              type = "long"
            }, {
              fpointer = 0,
              name = "end",
              pointer = 0,
              s = 0,
              t = 0,
              type = "long"
            } },
          print = <function 54>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tcl.h",
        linedef = 567,
        name = "Tcl_RegExpInfo",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tcl_RegExpInfo",
        vars = {
          add = <function 55>,
          init = <function 56>,
          list = { {
              fpointer = 0,
              name = "nsubs",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*matches",
              pointer = 1,
              s = 1,
              t = 0,
              type = "Tcl_RegExpIndices"
            }, {
              fpointer = 0,
              name = "extendStart",
              pointer = 0,
              s = 0,
              t = 0,
              type = "long"
            }, {
              fpointer = 0,
              name = "reserved",
              pointer = 0,
              s = 0,
              t = 0,
              type = "long"
            } },
          print = <function 57>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tcl.h",
        linedef = 629,
        name = "Tcl_Value",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tcl_Value",
        vars = {
          add = <function 58>,
          init = <function 59>,
          list = { {
              fpointer = 0,
              name = "type",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Tcl_ValueType"
            }, {
              fpointer = 0,
              name = "intValue",
              pointer = 0,
              s = 0,
              t = 0,
              type = "long"
            }, {
              fpointer = 0,
              name = "doubleValue",
              pointer = 0,
              s = 0,
              t = 0,
              type = "double"
            }, {
              fpointer = 0,
              name = "wideValue",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Tcl_WideInt"
            } },
          print = <function 60>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tcl.h",
        linedef = 721,
        name = "Tcl_ObjType",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tcl_ObjType",
        vars = {
          add = <function 61>,
          init = <function 62>,
          list = { {
              fpointer = 0,
              name = "*name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*freeIntRepProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FreeInternalRepProc"
            }, {
              fpointer = 0,
              name = "*dupIntRepProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DupInternalRepProc"
            }, {
              fpointer = 0,
              name = "*updateStringProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_UpdateStringProc"
            }, {
              fpointer = 0,
              name = "*setFromAnyProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_SetFromAnyProc"
            } },
          print = <function 63>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tcl.h",
        linedef = 745,
        name = "Tcl_Obj",
        structs = <table 1>,
        typedef = 1,
        typedname = "twoPtrValue",
        vars = {
          add = <function 64>,
          init = <function 65>,
          list = { {
              fpointer = 0,
              name = "refCount",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*bytes",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "length",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*typePtr",
              pointer = 1,
              s = 1,
              t = 0,
              type = "Tcl_ObjType"
            }, {
              fpointer = 0,
              name = "longValue",
              pointer = 0,
              s = 0,
              t = 0,
              type = "long"
            }, {
              fpointer = 0,
              name = "doubleValue",
              pointer = 0,
              s = 0,
              t = 0,
              type = "double"
            }, {
              fpointer = 0,
              name = "*otherValuePtr",
              pointer = 1,
              s = 0,
              t = 0,
              type = "VOID"
            }, {
              fpointer = 0,
              name = "wideValue",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Tcl_WideInt"
            }, {
              fpointer = 0,
              name = "*ptr1",
              pointer = 1,
              s = 0,
              t = 0,
              type = "VOID"
            }, {
              fpointer = 0,
              name = "*ptr2",
              pointer = 1,
              s = 0,
              t = 0,
              type = "VOID"
            } },
          print = <function 66>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tcl.h",
        linedef = 803,
        name = "Tcl_SavedResult",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tcl_SavedResult",
        vars = {
          add = <function 67>,
          init = <function 68>,
          list = { {
              fpointer = 0,
              name = "*result",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*freeProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FreeProc"
            }, {
              fpointer = 0,
              name = "*objResultPtr",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 0,
              name = "*appendResult",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "appendAvl",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "appendUsed",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "resultSpace[TCL_RESULT_SIZE+1]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            } },
          print = <function 69>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tcl.h",
        linedef = 819,
        name = "Tcl_Namespace",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tcl_Namespace",
        vars = {
          add = <function 70>,
          init = <function 71>,
          list = { {
              fpointer = 0,
              name = "*name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*fullName",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "clientData",
              pointer = 0,
              s = 0,
              t = 0,
              type = "ClientData"
            }, {
              fpointer = 0,
              name = "*deleteProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_NamespaceDeleteProc"
            }, {
              fpointer = 0,
              name = "*parentPtr",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct Tcl_Namespace"
            } },
          print = <function 72>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tcl.h",
        linedef = 859,
        name = "Tcl_CallFrame",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tcl_CallFrame",
        vars = {
          add = <function 73>,
          init = <function 74>,
          list = { {
              fpointer = 0,
              name = "*nsPtr",
              pointer = 1,
              s = 1,
              t = 0,
              type = "Tcl_Namespace"
            }, {
              fpointer = 0,
              name = "dummy1",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "dummy2",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*dummy3",
              pointer = 1,
              s = 0,
              t = 0,
              type = "VOID"
            }, {
              fpointer = 0,
              name = "*dummy4",
              pointer = 1,
              s = 0,
              t = 0,
              type = "VOID"
            }, {
              fpointer = 0,
              name = "*dummy5",
              pointer = 1,
              s = 0,
              t = 0,
              type = "VOID"
            }, {
              fpointer = 0,
              name = "dummy6",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*dummy7",
              pointer = 1,
              s = 0,
              t = 0,
              type = "VOID"
            }, {
              fpointer = 0,
              name = "*dummy8",
              pointer = 1,
              s = 0,
              t = 0,
              type = "VOID"
            }, {
              fpointer = 0,
              name = "dummy9",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*dummy10",
              pointer = 1,
              s = 0,
              t = 0,
              type = "VOID"
            }, {
              fpointer = 0,
              name = "*dummy11",
              pointer = 1,
              s = 0,
              t = 0,
              type = "VOID"
            }, {
              fpointer = 0,
              name = "*dummy12",
              pointer = 1,
              s = 0,
              t = 0,
              type = "VOID"
            }, {
              fpointer = 0,
              name = "*dummy13",
              pointer = 1,
              s = 0,
              t = 0,
              type = "VOID"
            } },
          print = <function 75>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tcl.h",
        linedef = 890,
        name = "Tcl_CmdInfo",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tcl_CmdInfo",
        vars = {
          add = <function 76>,
          init = <function 77>,
          list = { {
              fpointer = 0,
              name = "isNativeObjectProc",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "* Tcl_CreateObjCommand",
              pointer = 1,
              s = 0,
              t = 0,
              type = ""
            }, {
              fpointer = 0,
              name = "*objProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_ObjCmdProc"
            }, {
              fpointer = 0,
              name = "objClientData",
              pointer = 0,
              s = 0,
              t = 0,
              type = "ClientData"
            }, {
              fpointer = 0,
              name = "*proc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_CmdProc"
            }, {
              fpointer = 0,
              name = "clientData",
              pointer = 0,
              s = 0,
              t = 0,
              type = "ClientData"
            }, {
              fpointer = 0,
              name = "*deleteProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_CmdDeleteProc"
            }, {
              fpointer = 0,
              name = "deleteData",
              pointer = 0,
              s = 0,
              t = 0,
              type = "ClientData"
            }, {
              fpointer = 0,
              name = "*namespacePtr",
              pointer = 1,
              s = 1,
              t = 0,
              type = "Tcl_Namespace"
            }, {
              fpointer = 0,
              name = "* change a command's namespace",
              pointer = 1,
              s = 0,
              t = 0,
              type = ""
            } },
          print = <function 78>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tcl.h",
        linedef = 918,
        name = "Tcl_DString",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tcl_DString",
        vars = {
          add = <function 79>,
          init = <function 80>,
          list = { {
              fpointer = 0,
              name = "*string",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "length",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "spaceAvl",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "staticSpace[TCL_DSTRING_STATIC_SIZE]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            } },
          print = <function 81>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tcl.h",
        linedef = 1106,
        name = "Tcl_HashEntry",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 82>,
          init = <function 83>,
          list = { {
              fpointer = 0,
              name = "*nextPtr",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_HashEntry"
            }, {
              fpointer = 0,
              name = "*tablePtr",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_HashTable"
            }, {
              fpointer = 0,
              name = "*hash",
              pointer = 1,
              s = 0,
              t = 0,
              type = "VOID"
            }, {
              fpointer = 0,
              name = "**bucketPtr",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_HashEntry"
            }, {
              fpointer = 0,
              name = "clientData",
              pointer = 0,
              s = 0,
              t = 0,
              type = "ClientData"
            }, {
              fpointer = 0,
              name = "*oneWordValue",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*objPtr",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 0,
              name = "words[1]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "int"
            }, {
              fpointer = 0,
              name = "string[4]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            } },
          print = <function 84>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tcl.h",
        linedef = 1155,
        name = "Tcl_HashKeyType",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 85>,
          init = <function 86>,
          list = { {
              fpointer = 0,
              name = "version",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "flags",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*hashKeyProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_HashKeyProc"
            }, {
              fpointer = 0,
              name = "*compareKeysProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_CompareHashKeysProc"
            }, {
              fpointer = 0,
              name = "*allocEntryProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_AllocHashEntryProc"
            }, {
              fpointer = 0,
              name = "*freeEntryProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FreeHashEntryProc"
            } },
          print = <function 87>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tcl.h",
        linedef = 1200,
        name = "Tcl_HashTable",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 88>,
          init = <function 89>,
          list = { {
              fpointer = 0,
              name = "**buckets",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_HashEntry"
            }, {
              fpointer = 0,
              name = "*staticBuckets[TCL_SMALL_HASH_TABLE]",
              pointer = 1,
              s = 0,
              t = 1,
              type = "Tcl_HashEntry"
            }, {
              fpointer = 0,
              name = "numBuckets",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "numEntries",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "rebuildSize",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "downShift",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "mask",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "keyType",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*key))",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST char"
            }, {
              fpointer = 0,
              name = "*key, int *newPtr))",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST char"
            }, {
              fpointer = 0,
              name = "*typePtr",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_HashKeyType"
            } },
          print = <function 90>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tcl.h",
        linedef = 1235,
        name = "Tcl_HashSearch",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tcl_HashSearch",
        vars = {
          add = <function 91>,
          init = <function 92>,
          list = { {
              fpointer = 0,
              name = "*tablePtr",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_HashTable"
            }, {
              fpointer = 0,
              name = "nextIndex",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*nextEntryPtr",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_HashEntry"
            } },
          print = <function 93>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tcl.h",
        linedef = 1304,
        name = "Tcl_Event",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 94>,
          init = <function 95>,
          list = { {
              fpointer = 0,
              name = "*proc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_EventProc"
            }, {
              fpointer = 0,
              name = "*nextPtr",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct Tcl_Event"
            } },
          print = <function 96>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tcl.h",
        linedef = 1331,
        name = "Tcl_Time",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tcl_Time",
        vars = {
          add = <function 97>,
          init = <function 98>,
          list = { {
              fpointer = 0,
              name = "sec",
              pointer = 0,
              s = 0,
              t = 0,
              type = "long"
            }, {
              fpointer = 0,
              name = "usec",
              pointer = 0,
              s = 0,
              t = 0,
              type = "long"
            } },
          print = <function 99>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tcl.h",
        linedef = 1455,
        name = "Tcl_ChannelType",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tcl_ChannelType",
        vars = {
          add = <function 100>,
          init = <function 101>,
          list = { {
              fpointer = 0,
              name = "*typeName",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "version",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Tcl_ChannelTypeVersion"
            }, {
              fpointer = 0,
              name = "*closeProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverCloseProc"
            }, {
              fpointer = 0,
              name = "*inputProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverInputProc"
            }, {
              fpointer = 0,
              name = "*outputProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverOutputProc"
            }, {
              fpointer = 0,
              name = "*seekProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverSeekProc"
            }, {
              fpointer = 0,
              name = "*setOptionProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverSetOptionProc"
            }, {
              fpointer = 0,
              name = "*getOptionProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverGetOptionProc"
            }, {
              fpointer = 0,
              name = "*watchProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverWatchProc"
            }, {
              fpointer = 0,
              name = "*getHandleProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverGetHandleProc"
            }, {
              fpointer = 0,
              name = "*close2Proc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverClose2Proc"
            }, {
              fpointer = 0,
              name = "*blockModeProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverBlockModeProc"
            }, {
              fpointer = 0,
              name = "*flushProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverFlushProc"
            }, {
              fpointer = 0,
              name = "*handlerProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverHandlerProc"
            }, {
              fpointer = 0,
              name = "*wideSeekProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverWideSeekProc"
            }, {
              fpointer = 0,
              name = "*threadActionProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverThreadActionProc"
            }, {
              fpointer = 0,
              name = "*truncateProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverTruncateProc"
            } },
          print = <function 102>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tcl.h",
        linedef = 1551,
        name = "Tcl_GlobTypeData",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tcl_GlobTypeData",
        vars = {
          add = <function 103>,
          init = <function 104>,
          list = { {
              fpointer = 0,
              name = "type",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "perm",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*macType",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 0,
              name = "*macCreator",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            } },
          print = <function 105>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tcl.h",
        linedef = 1668,
        name = "Tcl_Filesystem",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tcl_Filesystem",
        vars = {
          add = <function 106>,
          init = <function 107>,
          list = { {
              fpointer = 0,
              name = "*typeName",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST char"
            }, {
              fpointer = 0,
              name = "structureLength",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "version",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Tcl_FSVersion"
            }, {
              fpointer = 0,
              name = "*pathInFilesystemProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FSPathInFilesystemProc"
            }, {
              fpointer = 0,
              name = "*dupInternalRepProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FSDupInternalRepProc"
            }, {
              fpointer = 0,
              name = "*freeInternalRepProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FSFreeInternalRepProc"
            }, {
              fpointer = 0,
              name = "*internalToNormalizedProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FSInternalToNormalizedProc"
            }, {
              fpointer = 0,
              name = "*createInternalRepProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FSCreateInternalRepProc"
            }, {
              fpointer = 0,
              name = "*normalizePathProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FSNormalizePathProc"
            }, {
              fpointer = 0,
              name = "*filesystemPathTypeProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FSFilesystemPathTypeProc"
            }, {
              fpointer = 0,
              name = "*filesystemSeparatorProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FSFilesystemSeparatorProc"
            }, {
              fpointer = 0,
              name = "*statProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FSStatProc"
            }, {
              fpointer = 0,
              name = "*accessProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FSAccessProc"
            }, {
              fpointer = 0,
              name = "*openFileChannelProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FSOpenFileChannelProc"
            }, {
              fpointer = 0,
              name = "*matchInDirectoryProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FSMatchInDirectoryProc"
            }, {
              fpointer = 0,
              name = "*utimeProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FSUtimeProc"
            }, {
              fpointer = 0,
              name = "*linkProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FSLinkProc"
            }, {
              fpointer = 0,
              name = "*listVolumesProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FSListVolumesProc"
            }, {
              fpointer = 0,
              name = "*fileAttrStringsProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FSFileAttrStringsProc"
            }, {
              fpointer = 0,
              name = "*fileAttrsGetProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FSFileAttrsGetProc"
            }, {
              fpointer = 0,
              name = "*fileAttrsSetProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FSFileAttrsSetProc"
            }, {
              fpointer = 0,
              name = "*createDirectoryProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FSCreateDirectoryProc"
            }, {
              fpointer = 0,
              name = "*removeDirectoryProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FSRemoveDirectoryProc"
            }, {
              fpointer = 0,
              name = "*deleteFileProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FSDeleteFileProc"
            }, {
              fpointer = 0,
              name = "*copyFileProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FSCopyFileProc"
            }, {
              fpointer = 0,
              name = "*renameFileProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FSRenameFileProc"
            }, {
              fpointer = 0,
              name = "*copyDirectoryProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FSCopyDirectoryProc"
            }, {
              fpointer = 0,
              name = "*lstatProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FSLstatProc"
            }, {
              fpointer = 0,
              name = "*loadFileProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FSLoadFileProc"
            }, {
              fpointer = 0,
              name = "*getCwdProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FSGetCwdProc"
            }, {
              fpointer = 0,
              name = "*chdirProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FSChdirProc"
            } },
          print = <function 108>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tcl.h",
        linedef = 1835,
        name = "Tcl_NotifierProcs",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tcl_NotifierProcs",
        vars = {
          add = <function 109>,
          init = <function 110>,
          list = { {
              fpointer = 0,
              name = "*setTimerProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_SetTimerProc"
            }, {
              fpointer = 0,
              name = "*waitForEventProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_WaitForEventProc"
            }, {
              fpointer = 0,
              name = "*createFileHandlerProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_CreateFileHandlerProc"
            }, {
              fpointer = 0,
              name = "*deleteFileHandlerProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DeleteFileHandlerProc"
            }, {
              fpointer = 0,
              name = "*initNotifierProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_InitNotifierProc"
            }, {
              fpointer = 0,
              name = "*finalizeNotifierProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_FinalizeNotifierProc"
            }, {
              fpointer = 0,
              name = "*alertNotifierProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_AlertNotifierProc"
            }, {
              fpointer = 0,
              name = "*serviceModeHookProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_ServiceModeHookProc"
            } },
          print = <function 111>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tcl.h",
        linedef = 1851,
        name = "Tcl_EncodingType",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tcl_EncodingType",
        vars = {
          add = <function 112>,
          init = <function 113>,
          list = { {
              fpointer = 0,
              name = "*encodingName",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST char"
            }, {
              fpointer = 0,
              name = "*toUtfProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_EncodingConvertProc"
            }, {
              fpointer = 0,
              name = "*fromUtfProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_EncodingConvertProc"
            }, {
              fpointer = 0,
              name = "*freeProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_EncodingFreeProc"
            }, {
              fpointer = 0,
              name = "clientData",
              pointer = 0,
              s = 0,
              t = 0,
              type = "ClientData"
            }, {
              fpointer = 0,
              name = "nullSize",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 114>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tcl.h",
        linedef = 1917,
        name = "Tcl_Token",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tcl_Token",
        vars = {
          add = <function 115>,
          init = <function 116>,
          list = { {
              fpointer = 0,
              name = "type",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*start",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST char"
            }, {
              fpointer = 0,
              name = "size",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "numComponents",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 117>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tcl.h",
        linedef = 2033,
        name = "Tcl_Parse",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tcl_Parse",
        vars = {
          add = <function 118>,
          init = <function 119>,
          list = { {
              fpointer = 0,
              name = "*commentStart",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST char"
            }, {
              fpointer = 0,
              name = "commentSize",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*commandStart",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST char"
            }, {
              fpointer = 0,
              name = "commandSize",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "numWords",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*tokenPtr",
              pointer = 1,
              s = 1,
              t = 0,
              type = "Tcl_Token"
            }, {
              fpointer = 0,
              name = "numTokens",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "tokensAvailable",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "errorType",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*string",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST char"
            }, {
              fpointer = 0,
              name = "*end",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST char"
            }, {
              fpointer = 0,
              name = "*interp",
              pointer = 1,
              s = 1,
              t = 0,
              type = "Tcl_Interp"
            }, {
              fpointer = 0,
              name = "*term",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST char"
            }, {
              fpointer = 0,
              name = "incomplete",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "staticTokens[NUM_STATIC_TOKENS]",
              pointer = 0,
              s = 1,
              t = 1,
              type = "Tcl_Token"
            }, {
              fpointer = 0,
              name = "* most commands",
              pointer = 1,
              s = 0,
              t = 0,
              type = ""
            } },
          print = <function 120>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tcl.h",
        linedef = 2160,
        name = "Tcl_Config",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tcl_Config",
        vars = {
          add = <function 121>,
          init = <function 122>,
          list = { {
              fpointer = 0,
              name = "*key",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST char"
            }, {
              fpointer = 0,
              name = "*value",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST char"
            } },
          print = <function 123>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "MacTypes.h",
        linedef = 122,
        name = "wide",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 124>,
          init = <function 125>,
          list = { {
              fpointer = 0,
              name = "hi",
              pointer = 0,
              s = 0,
              t = 0,
              type = "SInt32"
            }, {
              fpointer = 0,
              name = "lo",
              pointer = 0,
              s = 0,
              t = 0,
              type = "UInt32"
            } },
          print = <function 126>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "MacTypes.h",
        linedef = 127,
        name = "UnsignedWide",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 127>,
          init = <function 128>,
          list = { {
              fpointer = 0,
              name = "hi",
              pointer = 0,
              s = 0,
              t = 0,
              type = "UInt32"
            }, {
              fpointer = 0,
              name = "lo",
              pointer = 0,
              s = 0,
              t = 0,
              type = "UInt32"
            } },
          print = <function 129>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "MacTypes.h",
        linedef = 133,
        name = "wide",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 130>,
          init = <function 131>,
          list = { {
              fpointer = 0,
              name = "lo",
              pointer = 0,
              s = 0,
              t = 0,
              type = "UInt32"
            }, {
              fpointer = 0,
              name = "hi",
              pointer = 0,
              s = 0,
              t = 0,
              type = "SInt32"
            } },
          print = <function 132>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "MacTypes.h",
        linedef = 138,
        name = "UnsignedWide",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 133>,
          init = <function 134>,
          list = { {
              fpointer = 0,
              name = "lo",
              pointer = 0,
              s = 0,
              t = 0,
              type = "UInt32"
            }, {
              fpointer = 0,
              name = "hi",
              pointer = 0,
              s = 0,
              t = 0,
              type = "UInt32"
            } },
          print = <function 135>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "MacTypes.h",
        linedef = 213,
        name = "Float80",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 136>,
          init = <function 137>,
          list = { {
              fpointer = 0,
              name = "exp",
              pointer = 0,
              s = 0,
              t = 0,
              type = "SInt16"
            }, {
              fpointer = 0,
              name = "man[4]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "UInt16"
            } },
          print = <function 138>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "MacTypes.h",
        linedef = 219,
        name = "Float96",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 139>,
          init = <function 140>,
          list = { {
              fpointer = 0,
              name = "exp[2]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "SInt16"
            }, {
              fpointer = 0,
              name = "man[4]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "UInt16"
            } },
          print = <function 141>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "MacTypes.h",
        linedef = 224,
        name = "Float32Point",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 142>,
          init = <function 143>,
          list = { {
              fpointer = 0,
              name = "x",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Float32"
            }, {
              fpointer = 0,
              name = "y",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Float32"
            } },
          print = <function 144>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "MacTypes.h",
        linedef = 360,
        name = "BarList",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 145>,
          init = <function 146>,
          list = { {
              fpointer = 0,
              name = "listLength",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "elements[]",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Bar"
            } },
          print = <function 147>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "MacTypes.h",
        linedef = 507,
        name = "ProcessSerialNumber",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 148>,
          init = <function 149>,
          list = { {
              fpointer = 0,
              name = "highLongOfPSN",
              pointer = 0,
              s = 0,
              t = 0,
              type = "UInt32"
            }, {
              fpointer = 0,
              name = "lowLongOfPSN",
              pointer = 0,
              s = 0,
              t = 0,
              type = "UInt32"
            } },
          print = <function 150>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "MacTypes.h",
        linedef = 529,
        name = "Point",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 151>,
          init = <function 152>,
          list = { {
              fpointer = 0,
              name = "v",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "h",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            } },
          print = <function 153>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "MacTypes.h",
        linedef = 535,
        name = "Rect",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 154>,
          init = <function 155>,
          list = { {
              fpointer = 0,
              name = "top",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "left",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "bottom",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "right",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            } },
          print = <function 156>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "MacTypes.h",
        linedef = 543,
        name = "FixedPoint",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 157>,
          init = <function 158>,
          list = { {
              fpointer = 0,
              name = "x",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Fixed"
            }, {
              fpointer = 0,
              name = "y",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Fixed"
            } },
          print = <function 159>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "MacTypes.h",
        linedef = 548,
        name = "FixedRect",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 160>,
          init = <function 161>,
          list = { {
              fpointer = 0,
              name = "left",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Fixed"
            }, {
              fpointer = 0,
              name = "top",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Fixed"
            }, {
              fpointer = 0,
              name = "right",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Fixed"
            }, {
              fpointer = 0,
              name = "bottom",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Fixed"
            } },
          print = <function 162>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "MacTypes.h",
        linedef = 590,
        name = "TimeRecord",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 163>,
          init = <function 164>,
          list = { {
              fpointer = 0,
              name = "value",
              pointer = 0,
              s = 0,
              t = 0,
              type = "CompTimeValue"
            }, {
              fpointer = 0,
              name = "scale",
              pointer = 0,
              s = 0,
              t = 0,
              type = "TimeScale"
            }, {
              fpointer = 0,
              name = "base",
              pointer = 0,
              s = 0,
              t = 0,
              type = "TimeBase"
            } },
          print = <function 165>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "MacTypes.h",
        linedef = 628,
        name = "NumVersion",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 166>,
          init = <function 167>,
          list = { {
              fpointer = 0,
              name = "majorRev",
              pointer = 0,
              s = 0,
              t = 0,
              type = "UInt8"
            }, {
              fpointer = 0,
              name = "minorAndBugRev",
              pointer = 0,
              s = 0,
              t = 0,
              type = "UInt8"
            }, {
              fpointer = 0,
              name = "stage",
              pointer = 0,
              s = 0,
              t = 0,
              type = "UInt8"
            }, {
              fpointer = 0,
              name = "nonRelRev",
              pointer = 0,
              s = 0,
              t = 0,
              type = "UInt8"
            } },
          print = <function 168>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "MacTypes.h",
        linedef = 637,
        name = "NumVersion",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 169>,
          init = <function 170>,
          list = { {
              fpointer = 0,
              name = "nonRelRev",
              pointer = 0,
              s = 0,
              t = 0,
              type = "UInt8"
            }, {
              fpointer = 0,
              name = "stage",
              pointer = 0,
              s = 0,
              t = 0,
              type = "UInt8"
            }, {
              fpointer = 0,
              name = "minorAndBugRev",
              pointer = 0,
              s = 0,
              t = 0,
              type = "UInt8"
            }, {
              fpointer = 0,
              name = "majorRev",
              pointer = 0,
              s = 0,
              t = 0,
              type = "UInt8"
            } },
          print = <function 171>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "MacTypes.h",
        linedef = 663,
        name = "VersRec",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 172>,
          init = <function 173>,
          list = { {
              fpointer = 0,
              name = "numericVersion",
              pointer = 0,
              s = 0,
              t = 0,
              type = "NumVersion"
            }, {
              fpointer = 0,
              name = "countryCode",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "shortVersion",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Str255"
            }, {
              fpointer = 0,
              name = "reserved",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Str255"
            } },
          print = <function 174>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "stdio.h",
        linedef = 86,
        name = "__sbuf",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 175>,
          init = <function 176>,
          list = { {
              fpointer = 0,
              name = "*_base",
              pointer = 1,
              s = 0,
              t = 0,
              type = "unsigned char"
            }, {
              fpointer = 0,
              name = "_size",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 177>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "stdio.h",
        linedef = 120,
        name = "__sFILE",
        structs = <table 1>,
        typedef = 1,
        typedname = "FILE",
        vars = {
          add = <function 178>,
          init = <function 179>,
          list = { {
              fpointer = 0,
              name = "*_p",
              pointer = 1,
              s = 0,
              t = 0,
              type = "unsigned char"
            }, {
              fpointer = 0,
              name = "_r",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "_w",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "_flags",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "_file",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "_bf",
              pointer = 0,
              s = 1,
              t = 0,
              type = "struct\t__sbuf"
            }, {
              fpointer = 0,
              name = "_lbfsize",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*_cookie",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*_close)(void *)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*_read) (void *, char *, int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*_seek) (void *, fpos_t, int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "fpos_t"
            }, {
              fpointer = 1,
              name = "(*_write)(void *, const char *, int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "_ub",
              pointer = 0,
              s = 1,
              t = 0,
              type = "struct\t__sbuf"
            }, {
              fpointer = 0,
              name = "*_extra",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct __sFILEX"
            }, {
              fpointer = 0,
              name = "_ur",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "_ubuf[3]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "unsigned char"
            }, {
              fpointer = 0,
              name = "_nbuf[1]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "unsigned char"
            }, {
              fpointer = 0,
              name = "_lb",
              pointer = 0,
              s = 1,
              t = 0,
              type = "struct\t__sbuf"
            }, {
              fpointer = 0,
              name = "_blksize",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "_offset",
              pointer = 0,
              s = 0,
              t = 0,
              type = "fpos_t"
            } },
          print = <function 180>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "term_entry.h",
        linedef = 53,
        name = "entry",
        structs = <table 1>,
        typedef = 1,
        vars = {
          add = <function 181>,
          init = <function 182>,
          list = { {
              fpointer = 0,
              name = "tterm",
              pointer = 0,
              s = 0,
              t = 0,
              type = "TERMTYPE"
            }, {
              fpointer = 0,
              name = "nuses",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned"
            }, {
              fpointer = 0,
              name = "*name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*link",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct entry"
            }, {
              fpointer = 0,
              name = "line",
              pointer = 0,
              s = 0,
              t = 0,
              type = "long"
            } },
          print = <function 183>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "_locale.h",
        linedef = 43,
        name = "lconv",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 184>,
          init = <function 185>,
          list = { {
              fpointer = 0,
              name = "*decimal_point",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*thousands_sep",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*grouping",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*int_curr_symbol",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*currency_symbol",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*mon_decimal_point",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*mon_thousands_sep",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*mon_grouping",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*positive_sign",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*negative_sign",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "int_frac_digits",
              pointer = 0,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "frac_digits",
              pointer = 0,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "p_cs_precedes",
              pointer = 0,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "p_sep_by_space",
              pointer = 0,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "n_cs_precedes",
              pointer = 0,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "n_sep_by_space",
              pointer = 0,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "p_sign_posn",
              pointer = 0,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "n_sign_posn",
              pointer = 0,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "int_p_cs_precedes",
              pointer = 0,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "int_n_cs_precedes",
              pointer = 0,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "int_p_sep_by_space",
              pointer = 0,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "int_n_sep_by_space",
              pointer = 0,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "int_p_sign_posn",
              pointer = 0,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "int_n_sign_posn",
              pointer = 0,
              s = 0,
              t = 0,
              type = "char"
            } },
          print = <function 186>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "math.h",
        linedef = 725,
        name = "exception",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 187>,
          init = <function 188>,
          list = { {
              fpointer = 0,
              name = "type",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "arg1",
              pointer = 0,
              s = 0,
              t = 0,
              type = "double"
            }, {
              fpointer = 0,
              name = "arg2",
              pointer = 0,
              s = 0,
              t = 0,
              type = "double"
            }, {
              fpointer = 0,
              name = "retval",
              pointer = 0,
              s = 0,
              t = 0,
              type = "double"
            } },
          print = <function 189>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "printf.h",
        linedef = 67,
        name = "printf_info",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 190>,
          init = <function 191>,
          list = { {
              fpointer = 0,
              name = "*context",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "loc",
              pointer = 0,
              s = 0,
              t = 0,
              type = "locale_t"
            }, {
              fpointer = 0,
              name = "vsep",
              pointer = 0,
              s = 0,
              t = 0,
              type = "wchar_t"
            }, {
              fpointer = 0,
              name = "/* one of ,:",
              pointer = 1,
              s = 0,
              t = 0,
              type = ""
            }, {
              fpointer = 0,
              name = "prec",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "width",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "spec",
              pointer = 0,
              s = 0,
              t = 0,
              type = "wchar_t"
            }, {
              fpointer = 0,
              name = "pad",
              pointer = 0,
              s = 0,
              t = 0,
              type = "wchar_t"
            }, {
              fpointer = 0,
              name = "signchar",
              pointer = 0,
              s = 0,
              t = 0,
              type = "wchar_t"
            }, {
              fpointer = 0,
              name = ":1",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned\tis_long_double"
            }, {
              fpointer = 0,
              name = ":1",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned\tis_char"
            }, {
              fpointer = 0,
              name = ":1",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned\tis_short"
            }, {
              fpointer = 0,
              name = ":1",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned\tis_long"
            }, {
              fpointer = 0,
              name = ":1",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned\talt"
            }, {
              fpointer = 0,
              name = ":1",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned\tspace"
            }, {
              fpointer = 0,
              name = ":1",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned\tleft"
            }, {
              fpointer = 0,
              name = ":1",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned\tshowsign"
            }, {
              fpointer = 0,
              name = ":1",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned\tgroup"
            }, {
              fpointer = 0,
              name = ":1",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned\textra"
            }, {
              fpointer = 0,
              name = ":1",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned\twide"
            }, {
              fpointer = 0,
              name = ":1",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned\tis_quad"
            }, {
              fpointer = 0,
              name = ":1",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned\tis_intmax"
            }, {
              fpointer = 0,
              name = ":1",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned\tis_ptrdiff"
            }, {
              fpointer = 0,
              name = ":1",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned\tis_size"
            }, {
              fpointer = 0,
              name = ":1",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned\tis_vec"
            }, {
              fpointer = 0,
              name = "sofar",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "get_width",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned"
            }, {
              fpointer = 0,
              name = "get_prec",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned"
            }, {
              fpointer = 0,
              name = "*begin",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 0,
              name = "*end",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 0,
              name = "*arg[__PRINTFMAXARG]",
              pointer = 1,
              s = 0,
              t = 1,
              type = "void"
            } },
          print = <function 192>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "utime.h",
        linedef = 64,
        name = "utimbuf",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 193>,
          init = <function 194>,
          list = { {
              fpointer = 0,
              name = "actime",
              pointer = 0,
              s = 0,
              t = 0,
              type = "time_t"
            }, {
              fpointer = 0,
              name = "modtime",
              pointer = 0,
              s = 0,
              t = 0,
              type = "time_t"
            } },
          print = <function 195>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "libunwind.h",
        linedef = 69,
        name = "unw_proc_info_t",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 196>,
          init = <function 197>,
          list = { {
              fpointer = 0,
              name = "start_ip",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unw_word_t"
            }, {
              fpointer = 0,
              name = "end_ip",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unw_word_t"
            }, {
              fpointer = 0,
              name = "lsda",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unw_word_t"
            }, {
              fpointer = 0,
              name = "handler",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unw_word_t"
            }, {
              fpointer = 0,
              name = "gp",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unw_word_t"
            }, {
              fpointer = 0,
              name = "flags",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unw_word_t"
            }, {
              fpointer = 0,
              name = "format",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uint32_t"
            }, {
              fpointer = 0,
              name = "unwind_info_size",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uint32_t"
            }, {
              fpointer = 0,
              name = "unwind_info",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unw_word_t"
            }, {
              fpointer = 0,
              name = "extra",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unw_word_t"
            } },
          print = <function 198>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "term.h",
        linedef = 38,
        name = "term",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 199>,
          init = <function 200>,
          list = { {
              fpointer = 0,
              name = "*term_names",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*str_table",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*Booleans",
              pointer = 1,
              s = 0,
              t = 0,
              type = "NCURSES_SBOOL"
            }, {
              fpointer = 0,
              name = "*Numbers",
              pointer = 1,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "**Strings",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*ext_str_table",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**ext_Names",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "num_Booleans",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            }, {
              fpointer = 0,
              name = "num_Numbers",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            }, {
              fpointer = 0,
              name = "num_Strings",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            }, {
              fpointer = 0,
              name = "ext_Booleans",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            }, {
              fpointer = 0,
              name = "ext_Numbers",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            }, {
              fpointer = 0,
              name = "ext_Strings",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            } },
          print = <function 201>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "term.h",
        linedef = 81,
        name = "termios",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 202>,
          init = <function 203>,
          list = { {
              fpointer = 0,
              name = "*term_names",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*str_table",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*Booleans",
              pointer = 1,
              s = 0,
              t = 0,
              type = "NCURSES_SBOOL"
            }, {
              fpointer = 0,
              name = "*Numbers",
              pointer = 1,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "**Strings",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*ext_str_table",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**ext_Names",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "num_Booleans",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            }, {
              fpointer = 0,
              name = "num_Numbers",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            }, {
              fpointer = 0,
              name = "num_Strings",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            }, {
              fpointer = 0,
              name = "ext_Booleans",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            }, {
              fpointer = 0,
              name = "ext_Numbers",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            }, {
              fpointer = 0,
              name = "ext_Strings",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            } },
          print = <function 204>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "term.h",
        linedef = 92,
        name = "termio",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 205>,
          init = <function 206>,
          list = { {
              fpointer = 0,
              name = "*term_names",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*str_table",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*Booleans",
              pointer = 1,
              s = 0,
              t = 0,
              type = "NCURSES_SBOOL"
            }, {
              fpointer = 0,
              name = "*Numbers",
              pointer = 1,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "**Strings",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*ext_str_table",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**ext_Names",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "num_Booleans",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            }, {
              fpointer = 0,
              name = "num_Numbers",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            }, {
              fpointer = 0,
              name = "num_Strings",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            }, {
              fpointer = 0,
              name = "ext_Booleans",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            }, {
              fpointer = 0,
              name = "ext_Numbers",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            }, {
              fpointer = 0,
              name = "ext_Strings",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            } },
          print = <function 207>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "term.h",
        linedef = 134,
        name = "sgttyb",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 208>,
          init = <function 209>,
          list = { {
              fpointer = 0,
              name = "*term_names",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*str_table",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*Booleans",
              pointer = 1,
              s = 0,
              t = 0,
              type = "NCURSES_SBOOL"
            }, {
              fpointer = 0,
              name = "*Numbers",
              pointer = 1,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "**Strings",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*ext_str_table",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**ext_Names",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "num_Booleans",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            }, {
              fpointer = 0,
              name = "num_Numbers",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            }, {
              fpointer = 0,
              name = "num_Strings",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            }, {
              fpointer = 0,
              name = "ext_Booleans",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            }, {
              fpointer = 0,
              name = "ext_Numbers",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            }, {
              fpointer = 0,
              name = "ext_Strings",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            } },
          print = <function 210>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tclDecls.h",
        linedef = 3414,
        name = "TclStubHooks",
        structs = <table 1>,
        typedef = 1,
        typedname = "TclStubHooks",
        vars = {
          add = <function 211>,
          init = <function 212>,
          list = { {
              fpointer = 0,
              name = "*tclPlatStubs",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct TclPlatStubs"
            }, {
              fpointer = 0,
              name = "*tclIntStubs",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct TclIntStubs"
            }, {
              fpointer = 0,
              name = "*tclIntPlatStubs",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct TclIntPlatStubs"
            } },
          print = <function 213>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tclDecls.h",
        linedef = 3420,
        name = "TclStubs",
        structs = <table 1>,
        typedef = 1,
        typedname = "TclStubs",
        vars = {
          add = <function 214>,
          init = <function 215>,
          list = { {
              fpointer = 0,
              name = "magic",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*hooks",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct TclStubHooks"
            }, {
              fpointer = 1,
              name = "(*tcl_PkgProvideEx) (Tcl_Interp *interp, CONST char *name, CONST char *version, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_PkgRequireEx) (Tcl_Interp *interp, CONST char *name, CONST char *version, int exact, ClientData *clientDataPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "(*tcl_Panic) (CONST char *format, ...)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*tcl_Alloc) (unsigned int size)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "(*tcl_Free) (char *ptr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*tcl_Realloc) (char *ptr, unsigned int size)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "* (*tcl_DbCkalloc) (unsigned int size, CONST char *file, int line)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "(*tcl_DbCkfree) (char *ptr, CONST char *file, int line)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_DbCkrealloc) (char *ptr, unsigned int size, CONST char *file, int line)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "(*tcl_CreateFileHandler) (int fd, int mask, Tcl_FileProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "*reserved9",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_CreateFileHandler) (int fd, int mask, Tcl_FileProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_DeleteFileHandler) (int fd)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "*reserved10",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_DeleteFileHandler) (int fd)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_SetTimer) (Tcl_Time *timePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_Sleep) (int ms)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_WaitForEvent) (Tcl_Time *timePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_AppendAllObjTypes) (Tcl_Interp *interp, Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_AppendStringsToObj) (Tcl_Obj *objPtr, ...)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_AppendToObj) (Tcl_Obj *objPtr, CONST char *bytes, int length)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*tcl_ConcatObj) (int objc, Tcl_Obj *CONST objv[])",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "(*tcl_ConvertToType) (Tcl_Interp *interp, Tcl_Obj *objPtr, Tcl_ObjType *typePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_DbDecrRefCount) (Tcl_Obj *objPtr, CONST char *file, int line)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_DbIncrRefCount) (Tcl_Obj *objPtr, CONST char *file, int line)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_DbIsShared) (Tcl_Obj *objPtr, CONST char *file, int line)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_DbNewBooleanObj) (int boolValue, CONST char *file, int line)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "* (*tcl_DbNewByteArrayObj) (CONST unsigned char *bytes, int length, CONST char *file, int line)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "* (*tcl_DbNewDoubleObj) (double doubleValue, CONST char *file, int line)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "* (*tcl_DbNewListObj) (int objc, Tcl_Obj *CONST *objv, CONST char *file, int line)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "* (*tcl_DbNewLongObj) (long longValue, CONST char *file, int line)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "* (*tcl_DbNewObj) (CONST char *file, int line)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "* (*tcl_DbNewStringObj) (CONST char *bytes, int length, CONST char *file, int line)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "* (*tcl_DuplicateObj) (Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "(*tclFreeObj) (Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_GetBoolean) (Tcl_Interp *interp, CONST char *src, int *boolPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_GetBooleanFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, int *boolPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetByteArrayFromObj) (Tcl_Obj *objPtr, int *lengthPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "unsigned char"
            }, {
              fpointer = 1,
              name = "(*tcl_GetDouble) (Tcl_Interp *interp, CONST char *src, double *doublePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_GetDoubleFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, double *doublePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_GetIndexFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, CONST84 char **tablePtr, CONST char *msg, int flags, int *indexPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_GetInt) (Tcl_Interp *interp, CONST char *src, int *intPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_GetIntFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, int *intPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_GetLongFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, long *longPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetObjType) (CONST char *typeName)",
              pointer = 1,
              s = 1,
              t = 0,
              type = "Tcl_ObjType"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetStringFromObj) (Tcl_Obj *objPtr, int *lengthPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "(*tcl_InvalidateStringRep) (Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_ListObjAppendList) (Tcl_Interp *interp, Tcl_Obj *listPtr, Tcl_Obj *elemListPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ListObjAppendElement) (Tcl_Interp *interp, Tcl_Obj *listPtr, Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ListObjGetElements) (Tcl_Interp *interp, Tcl_Obj *listPtr, int *objcPtr, Tcl_Obj ***objvPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ListObjIndex) (Tcl_Interp *interp, Tcl_Obj *listPtr, int index, Tcl_Obj **objPtrPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ListObjLength) (Tcl_Interp *interp, Tcl_Obj *listPtr, int *lengthPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ListObjReplace) (Tcl_Interp *interp, Tcl_Obj *listPtr, int first, int count, int objc, Tcl_Obj *CONST objv[])",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_NewBooleanObj) (int boolValue)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "* (*tcl_NewByteArrayObj) (CONST unsigned char *bytes, int length)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "* (*tcl_NewDoubleObj) (double doubleValue)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "* (*tcl_NewIntObj) (int intValue)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "* (*tcl_NewListObj) (int objc, Tcl_Obj *CONST objv[])",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "* (*tcl_NewLongObj) (long longValue)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "* (*tcl_NewObj) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "* (*tcl_NewStringObj) (CONST char *bytes, int length)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "(*tcl_SetBooleanObj) (Tcl_Obj *objPtr, int boolValue)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*tcl_SetByteArrayLength) (Tcl_Obj *objPtr, int length)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "unsigned char"
            }, {
              fpointer = 1,
              name = "(*tcl_SetByteArrayObj) (Tcl_Obj *objPtr, CONST unsigned char *bytes, int length)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_SetDoubleObj) (Tcl_Obj *objPtr, double doubleValue)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_SetIntObj) (Tcl_Obj *objPtr, int intValue)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_SetListObj) (Tcl_Obj *objPtr, int objc, Tcl_Obj *CONST objv[])",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_SetLongObj) (Tcl_Obj *objPtr, long longValue)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_SetObjLength) (Tcl_Obj *objPtr, int length)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_SetStringObj) (Tcl_Obj *objPtr, CONST char *bytes, int length)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_AddErrorInfo) (Tcl_Interp *interp, CONST char *message)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_AddObjErrorInfo) (Tcl_Interp *interp, CONST char *message, int length)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_AllowExceptions) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_AppendElement) (Tcl_Interp *interp, CONST char *element)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_AppendResult) (Tcl_Interp *interp, ...)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_AsyncCreate) (Tcl_AsyncProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_AsyncHandler"
            }, {
              fpointer = 1,
              name = "(*tcl_AsyncDelete) (Tcl_AsyncHandler async)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_AsyncInvoke) (Tcl_Interp *interp, int code)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_AsyncMark) (Tcl_AsyncHandler async)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_AsyncReady) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_BackgroundError) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_Backslash) (CONST char *src, int *readPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "(*tcl_BadChannelOption) (Tcl_Interp *interp, CONST char *optionName, CONST char *optionList)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_CallWhenDeleted) (Tcl_Interp *interp, Tcl_InterpDeleteProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_CancelIdleCall) (Tcl_IdleProc *idleProc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_Close) (Tcl_Interp *interp, Tcl_Channel chan)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_CommandComplete) (CONST char *cmd)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_Concat) (int argc, CONST84 char *CONST *argv)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "(*tcl_ConvertElement) (CONST char *src, char *dst, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ConvertCountedElement) (CONST char *src, int length, char *dst, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_CreateAlias) (Tcl_Interp *slave, CONST char *slaveCmd, Tcl_Interp *target, CONST char *targetCmd, int argc, CONST84 char *CONST *argv)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_CreateAliasObj) (Tcl_Interp *slave, CONST char *slaveCmd, Tcl_Interp *target, CONST char *targetCmd, int objc, Tcl_Obj *CONST objv[])",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_CreateChannel) (Tcl_ChannelType *typePtr, CONST char *chanName, ClientData instanceData, int mask)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Channel"
            }, {
              fpointer = 1,
              name = "(*tcl_CreateChannelHandler) (Tcl_Channel chan, int mask, Tcl_ChannelProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_CreateCloseHandler) (Tcl_Channel chan, Tcl_CloseProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_CreateCommand) (Tcl_Interp *interp, CONST char *cmdName, Tcl_CmdProc *proc, ClientData clientData, Tcl_CmdDeleteProc *deleteProc)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Command"
            }, {
              fpointer = 1,
              name = "(*tcl_CreateEventSource) (Tcl_EventSetupProc *setupProc, Tcl_EventCheckProc *checkProc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_CreateExitHandler) (Tcl_ExitProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*tcl_CreateInterp) (void)",
              pointer = 1,
              s = 1,
              t = 0,
              type = "Tcl_Interp"
            }, {
              fpointer = 1,
              name = "(*tcl_CreateMathFunc) (Tcl_Interp *interp, CONST char *name, int numArgs, Tcl_ValueType *argTypes, Tcl_MathProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_CreateObjCommand) (Tcl_Interp *interp, CONST char *cmdName, Tcl_ObjCmdProc *proc, ClientData clientData, Tcl_CmdDeleteProc *deleteProc)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Command"
            }, {
              fpointer = 1,
              name = "* (*tcl_CreateSlave) (Tcl_Interp *interp, CONST char *slaveName, int isSafe)",
              pointer = 1,
              s = 1,
              t = 0,
              type = "Tcl_Interp"
            }, {
              fpointer = 1,
              name = "(*tcl_CreateTimerHandler) (int milliseconds, Tcl_TimerProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_TimerToken"
            }, {
              fpointer = 1,
              name = "(*tcl_CreateTrace) (Tcl_Interp *interp, int level, Tcl_CmdTraceProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Trace"
            }, {
              fpointer = 1,
              name = "(*tcl_DeleteAssocData) (Tcl_Interp *interp, CONST char *name)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_DeleteChannelHandler) (Tcl_Channel chan, Tcl_ChannelProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_DeleteCloseHandler) (Tcl_Channel chan, Tcl_CloseProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_DeleteCommand) (Tcl_Interp *interp, CONST char *cmdName)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_DeleteCommandFromToken) (Tcl_Interp *interp, Tcl_Command command)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_DeleteEvents) (Tcl_EventDeleteProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_DeleteEventSource) (Tcl_EventSetupProc *setupProc, Tcl_EventCheckProc *checkProc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_DeleteExitHandler) (Tcl_ExitProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_DeleteHashEntry) (Tcl_HashEntry *entryPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_DeleteHashTable) (Tcl_HashTable *tablePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_DeleteInterp) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_DetachPids) (int numPids, Tcl_Pid *pidPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_DeleteTimerHandler) (Tcl_TimerToken token)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_DeleteTrace) (Tcl_Interp *interp, Tcl_Trace trace)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_DontCallWhenDeleted) (Tcl_Interp *interp, Tcl_InterpDeleteProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_DoOneEvent) (int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_DoWhenIdle) (Tcl_IdleProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*tcl_DStringAppend) (Tcl_DString *dsPtr, CONST char *bytes, int length)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "* (*tcl_DStringAppendElement) (Tcl_DString *dsPtr, CONST char *element)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "(*tcl_DStringEndSublist) (Tcl_DString *dsPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_DStringFree) (Tcl_DString *dsPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_DStringGetResult) (Tcl_Interp *interp, Tcl_DString *dsPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_DStringInit) (Tcl_DString *dsPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_DStringResult) (Tcl_Interp *interp, Tcl_DString *dsPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_DStringSetLength) (Tcl_DString *dsPtr, int length)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_DStringStartSublist) (Tcl_DString *dsPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_Eof) (Tcl_Channel chan)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_ErrnoId) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "* (*tcl_ErrnoMsg) (int err)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "(*tcl_Eval) (Tcl_Interp *interp, CONST char *script)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_EvalFile) (Tcl_Interp *interp, CONST char *fileName)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_EvalObj) (Tcl_Interp *interp, Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_EventuallyFree) (ClientData clientData, Tcl_FreeProc *freeProc)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_Exit) (int status)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_ExposeCommand) (Tcl_Interp *interp, CONST char *hiddenCmdToken, CONST char *cmdName)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ExprBoolean) (Tcl_Interp *interp, CONST char *expr, int *ptr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ExprBooleanObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, int *ptr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ExprDouble) (Tcl_Interp *interp, CONST char *expr, double *ptr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ExprDoubleObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, double *ptr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ExprLong) (Tcl_Interp *interp, CONST char *expr, long *ptr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ExprLongObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, long *ptr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ExprObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, Tcl_Obj **resultPtrPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ExprString) (Tcl_Interp *interp, CONST char *expr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_Finalize) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_FindExecutable) (CONST char *argv0)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*tcl_FirstHashEntry) (Tcl_HashTable *tablePtr, Tcl_HashSearch *searchPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_HashEntry"
            }, {
              fpointer = 1,
              name = "(*tcl_Flush) (Tcl_Channel chan)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_FreeResult) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_GetAlias) (Tcl_Interp *interp, CONST char *slaveCmd, Tcl_Interp **targetInterpPtr, CONST84 char **targetCmdPtr, int *argcPtr, CONST84 char ***argvPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_GetAliasObj) (Tcl_Interp *interp, CONST char *slaveCmd, Tcl_Interp **targetInterpPtr, CONST84 char **targetCmdPtr, int *objcPtr, Tcl_Obj ***objv)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_GetAssocData) (Tcl_Interp *interp, CONST char *name, Tcl_InterpDeleteProc **procPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "ClientData"
            }, {
              fpointer = 1,
              name = "(*tcl_GetChannel) (Tcl_Interp *interp, CONST char *chanName, int *modePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Channel"
            }, {
              fpointer = 1,
              name = "(*tcl_GetChannelBufferSize) (Tcl_Channel chan)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_GetChannelHandle) (Tcl_Channel chan, int direction, ClientData *handlePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_GetChannelInstanceData) (Tcl_Channel chan)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "ClientData"
            }, {
              fpointer = 1,
              name = "(*tcl_GetChannelMode) (Tcl_Channel chan)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetChannelName) (Tcl_Channel chan)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "(*tcl_GetChannelOption) (Tcl_Interp *interp, Tcl_Channel chan, CONST char *optionName, Tcl_DString *dsPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetChannelType) (Tcl_Channel chan)",
              pointer = 1,
              s = 1,
              t = 0,
              type = "Tcl_ChannelType"
            }, {
              fpointer = 1,
              name = "(*tcl_GetCommandInfo) (Tcl_Interp *interp, CONST char *cmdName, Tcl_CmdInfo *infoPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetCommandName) (Tcl_Interp *interp, Tcl_Command command)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "(*tcl_GetErrno) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetHostName) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "(*tcl_GetInterpPath) (Tcl_Interp *askInterp, Tcl_Interp *slaveInterp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetMaster) (Tcl_Interp *interp)",
              pointer = 1,
              s = 1,
              t = 0,
              type = "Tcl_Interp"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetNameOfExecutable) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST char"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetObjResult) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "(*tcl_GetOpenFile) (Tcl_Interp *interp, CONST char *chanID, int forWriting, int checkUsage, ClientData *filePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*reserved167",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_GetOpenFile) (Tcl_Interp *interp, CONST char *chanID, int forWriting, int checkUsage, ClientData *filePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_GetPathType) (CONST char *path)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_PathType"
            }, {
              fpointer = 1,
              name = "(*tcl_Gets) (Tcl_Channel chan, Tcl_DString *dsPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_GetsObj) (Tcl_Channel chan, Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_GetServiceMode) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetSlave) (Tcl_Interp *interp, CONST char *slaveName)",
              pointer = 1,
              s = 1,
              t = 0,
              type = "Tcl_Interp"
            }, {
              fpointer = 1,
              name = "(*tcl_GetStdChannel) (int type)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Channel"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetStringResult) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetVar) (Tcl_Interp *interp, CONST char *varName, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetVar2) (Tcl_Interp *interp, CONST char *part1, CONST char *part2, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "(*tcl_GlobalEval) (Tcl_Interp *interp, CONST char *command)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_GlobalEvalObj) (Tcl_Interp *interp, Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_HideCommand) (Tcl_Interp *interp, CONST char *cmdName, CONST char *hiddenCmdToken)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_Init) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_InitHashTable) (Tcl_HashTable *tablePtr, int keyType)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_InputBlocked) (Tcl_Channel chan)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_InputBuffered) (Tcl_Channel chan)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_InterpDeleted) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_IsSafe) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_JoinPath) (int argc, CONST84 char *CONST *argv, Tcl_DString *resultPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "(*tcl_LinkVar) (Tcl_Interp *interp, CONST char *varName, char *addr, int type)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*reserved188",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_MakeFileChannel) (ClientData handle, int mode)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Channel"
            }, {
              fpointer = 1,
              name = "(*tcl_MakeSafe) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_MakeTcpClientChannel) (ClientData tcpSocket)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Channel"
            }, {
              fpointer = 1,
              name = "* (*tcl_Merge) (int argc, CONST84 char *CONST *argv)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "* (*tcl_NextHashEntry) (Tcl_HashSearch *searchPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_HashEntry"
            }, {
              fpointer = 1,
              name = "(*tcl_NotifyChannel) (Tcl_Channel channel, int mask)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*tcl_ObjGetVar2) (Tcl_Interp *interp, Tcl_Obj *part1Ptr, Tcl_Obj *part2Ptr, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "* (*tcl_ObjSetVar2) (Tcl_Interp *interp, Tcl_Obj *part1Ptr, Tcl_Obj *part2Ptr, Tcl_Obj *newValuePtr, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "(*tcl_OpenCommandChannel) (Tcl_Interp *interp, int argc, CONST84 char **argv, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Channel"
            }, {
              fpointer = 1,
              name = "(*tcl_OpenFileChannel) (Tcl_Interp *interp, CONST char *fileName, CONST char *modeString, int permissions)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Channel"
            }, {
              fpointer = 1,
              name = "(*tcl_OpenTcpClient) (Tcl_Interp *interp, int port, CONST char *address, CONST char *myaddr, int myport, int async)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Channel"
            }, {
              fpointer = 1,
              name = "(*tcl_OpenTcpServer) (Tcl_Interp *interp, int port, CONST char *host, Tcl_TcpAcceptProc *acceptProc, ClientData callbackData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Channel"
            }, {
              fpointer = 1,
              name = "(*tcl_Preserve) (ClientData data)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_PrintDouble) (Tcl_Interp *interp, double value, char *dst)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_PutEnv) (CONST char *assignment)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_PosixError) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "(*tcl_QueueEvent) (Tcl_Event *evPtr, Tcl_QueuePosition position)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_Read) (Tcl_Channel chan, char *bufPtr, int toRead)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ReapDetachedProcs) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_RecordAndEval) (Tcl_Interp *interp, CONST char *cmd, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_RecordAndEvalObj) (Tcl_Interp *interp, Tcl_Obj *cmdPtr, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_RegisterChannel) (Tcl_Interp *interp, Tcl_Channel chan)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_RegisterObjType) (Tcl_ObjType *typePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_RegExpCompile) (Tcl_Interp *interp, CONST char *pattern)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_RegExp"
            }, {
              fpointer = 1,
              name = "(*tcl_RegExpExec) (Tcl_Interp *interp, Tcl_RegExp regexp, CONST char *text, CONST char *start)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_RegExpMatch) (Tcl_Interp *interp, CONST char *text, CONST char *pattern)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_RegExpRange) (Tcl_RegExp regexp, int index, CONST84 char **startPtr, CONST84 char **endPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_Release) (ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_ResetResult) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_ScanElement) (CONST char *str, int *flagPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ScanCountedElement) (CONST char *str, int length, int *flagPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_SeekOld) (Tcl_Channel chan, int offset, int mode)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ServiceAll) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ServiceEvent) (int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_SetAssocData) (Tcl_Interp *interp, CONST char *name, Tcl_InterpDeleteProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_SetChannelBufferSize) (Tcl_Channel chan, int sz)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_SetChannelOption) (Tcl_Interp *interp, Tcl_Channel chan, CONST char *optionName, CONST char *newValue)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_SetCommandInfo) (Tcl_Interp *interp, CONST char *cmdName, CONST Tcl_CmdInfo *infoPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_SetErrno) (int err)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_SetErrorCode) (Tcl_Interp *interp, ...)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_SetMaxBlockTime) (Tcl_Time *timePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_SetPanicProc) (Tcl_PanicProc *panicProc)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_SetRecursionLimit) (Tcl_Interp *interp, int depth)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_SetResult) (Tcl_Interp *interp, char *result, Tcl_FreeProc *freeProc)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_SetServiceMode) (int mode)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_SetObjErrorCode) (Tcl_Interp *interp, Tcl_Obj *errorObjPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_SetObjResult) (Tcl_Interp *interp, Tcl_Obj *resultObjPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_SetStdChannel) (Tcl_Channel channel, int type)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*tcl_SetVar) (Tcl_Interp *interp, CONST char *varName, CONST char *newValue, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "* (*tcl_SetVar2) (Tcl_Interp *interp, CONST char *part1, CONST char *part2, CONST char *newValue, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "* (*tcl_SignalId) (int sig)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "* (*tcl_SignalMsg) (int sig)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "(*tcl_SourceRCFile) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_SplitList) (Tcl_Interp *interp, CONST char *listStr, int *argcPtr, CONST84 char ***argvPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_SplitPath) (CONST char *path, int *argcPtr, CONST84 char ***argvPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_StaticPackage) (Tcl_Interp *interp, CONST char *pkgName, Tcl_PackageInitProc *initProc, Tcl_PackageInitProc *safeInitProc)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_StringMatch) (CONST char *str, CONST char *pattern)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_TellOld) (Tcl_Channel chan)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_TraceVar) (Tcl_Interp *interp, CONST char *varName, int flags, Tcl_VarTraceProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_TraceVar2) (Tcl_Interp *interp, CONST char *part1, CONST char *part2, int flags, Tcl_VarTraceProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_TranslateFileName) (Tcl_Interp *interp, CONST char *name, Tcl_DString *bufferPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "(*tcl_Ungets) (Tcl_Channel chan, CONST char *str, int len, int atHead)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_UnlinkVar) (Tcl_Interp *interp, CONST char *varName)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_UnregisterChannel) (Tcl_Interp *interp, Tcl_Channel chan)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_UnsetVar) (Tcl_Interp *interp, CONST char *varName, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_UnsetVar2) (Tcl_Interp *interp, CONST char *part1, CONST char *part2, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_UntraceVar) (Tcl_Interp *interp, CONST char *varName, int flags, Tcl_VarTraceProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_UntraceVar2) (Tcl_Interp *interp, CONST char *part1, CONST char *part2, int flags, Tcl_VarTraceProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_UpdateLinkedVar) (Tcl_Interp *interp, CONST char *varName)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_UpVar) (Tcl_Interp *interp, CONST char *frameName, CONST char *varName, CONST char *localName, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_UpVar2) (Tcl_Interp *interp, CONST char *frameName, CONST char *part1, CONST char *part2, CONST char *localName, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_VarEval) (Tcl_Interp *interp, ...)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_VarTraceInfo) (Tcl_Interp *interp, CONST char *varName, int flags, Tcl_VarTraceProc *procPtr, ClientData prevClientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "ClientData"
            }, {
              fpointer = 1,
              name = "(*tcl_VarTraceInfo2) (Tcl_Interp *interp, CONST char *part1, CONST char *part2, int flags, Tcl_VarTraceProc *procPtr, ClientData prevClientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "ClientData"
            }, {
              fpointer = 1,
              name = "(*tcl_Write) (Tcl_Channel chan, CONST char *s, int slen)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_WrongNumArgs) (Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[], CONST char *message)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_DumpActiveMemory) (CONST char *fileName)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ValidateAllMemory) (CONST char *file, int line)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_AppendResultVA) (Tcl_Interp *interp, va_list argList)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_AppendStringsToObjVA) (Tcl_Obj *objPtr, va_list argList)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*tcl_HashStats) (Tcl_HashTable *tablePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "* (*tcl_ParseVar) (Tcl_Interp *interp, CONST char *start, CONST84 char **termPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "* (*tcl_PkgPresent) (Tcl_Interp *interp, CONST char *name, CONST char *version, int exact)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "* (*tcl_PkgPresentEx) (Tcl_Interp *interp, CONST char *name, CONST char *version, int exact, ClientData *clientDataPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "(*tcl_PkgProvide) (Tcl_Interp *interp, CONST char *name, CONST char *version)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_PkgRequire) (Tcl_Interp *interp, CONST char *name, CONST char *version, int exact)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "(*tcl_SetErrorCodeVA) (Tcl_Interp *interp, va_list argList)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_VarEvalVA) (Tcl_Interp *interp, va_list argList)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_WaitPid) (Tcl_Pid pid, int *statPtr, int options)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Pid"
            }, {
              fpointer = 1,
              name = "(*tcl_PanicVA) (CONST char *format, va_list argList)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_GetVersion) (int *major, int *minor, int *patchLevel, int *type)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_InitMemory) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_StackChannel) (Tcl_Interp *interp, Tcl_ChannelType *typePtr, ClientData instanceData, int mask, Tcl_Channel prevChan)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Channel"
            }, {
              fpointer = 1,
              name = "(*tcl_UnstackChannel) (Tcl_Interp *interp, Tcl_Channel chan)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_GetStackedChannel) (Tcl_Channel chan)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Channel"
            }, {
              fpointer = 1,
              name = "(*tcl_SetMainLoop) (Tcl_MainLoopProc *proc)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "*reserved285",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_AppendObjToObj) (Tcl_Obj *objPtr, Tcl_Obj *appendObjPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_CreateEncoding) (CONST Tcl_EncodingType *typePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Encoding"
            }, {
              fpointer = 1,
              name = "(*tcl_CreateThreadExitHandler) (Tcl_ExitProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_DeleteThreadExitHandler) (Tcl_ExitProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_DiscardResult) (Tcl_SavedResult *statePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_EvalEx) (Tcl_Interp *interp, CONST char *script, int numBytes, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_EvalObjv) (Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[], int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_EvalObjEx) (Tcl_Interp *interp, Tcl_Obj *objPtr, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ExitThread) (int status)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_ExternalToUtf) (Tcl_Interp *interp, Tcl_Encoding encoding, CONST char *src, int srcLen, int flags, Tcl_EncodingState *statePtr, char *dst, int dstLen, int *srcReadPtr, int *dstWrotePtr, int *dstCharsPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_ExternalToUtfDString) (Tcl_Encoding encoding, CONST char *src, int srcLen, Tcl_DString *dsPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "(*tcl_FinalizeThread) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_FinalizeNotifier) (ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_FreeEncoding) (Tcl_Encoding encoding)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_GetCurrentThread) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_ThreadId"
            }, {
              fpointer = 1,
              name = "(*tcl_GetEncoding) (Tcl_Interp *interp, CONST char *name)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Encoding"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetEncodingName) (Tcl_Encoding encoding)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "(*tcl_GetEncodingNames) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_GetIndexFromObjStruct) (Tcl_Interp *interp, Tcl_Obj *objPtr, CONST VOID *tablePtr, int offset, CONST char *msg, int flags, int *indexPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetThreadData) (Tcl_ThreadDataKey *keyPtr, int size)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "VOID"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetVar2Ex) (Tcl_Interp *interp, CONST char *part1, CONST char *part2, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "(*tcl_InitNotifier) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "ClientData"
            }, {
              fpointer = 1,
              name = "(*tcl_MutexLock) (Tcl_Mutex *mutexPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_MutexUnlock) (Tcl_Mutex *mutexPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_ConditionNotify) (Tcl_Condition *condPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_ConditionWait) (Tcl_Condition *condPtr, Tcl_Mutex *mutexPtr, Tcl_Time *timePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_NumUtfChars) (CONST char *src, int length)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ReadChars) (Tcl_Channel channel, Tcl_Obj *objPtr, int charsToRead, int appendFlag)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_RestoreResult) (Tcl_Interp *interp, Tcl_SavedResult *statePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_SaveResult) (Tcl_Interp *interp, Tcl_SavedResult *statePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_SetSystemEncoding) (Tcl_Interp *interp, CONST char *name)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_SetVar2Ex) (Tcl_Interp *interp, CONST char *part1, CONST char *part2, Tcl_Obj *newValuePtr, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "(*tcl_ThreadAlert) (Tcl_ThreadId threadId)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_ThreadQueueEvent) (Tcl_ThreadId threadId, Tcl_Event *evPtr, Tcl_QueuePosition position)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_UniCharAtIndex) (CONST char *src, int index)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_UniChar"
            }, {
              fpointer = 1,
              name = "(*tcl_UniCharToLower) (int ch)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_UniChar"
            }, {
              fpointer = 1,
              name = "(*tcl_UniCharToTitle) (int ch)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_UniChar"
            }, {
              fpointer = 1,
              name = "(*tcl_UniCharToUpper) (int ch)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_UniChar"
            }, {
              fpointer = 1,
              name = "(*tcl_UniCharToUtf) (int ch, char *buf)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_UtfAtIndex) (CONST char *src, int index)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "(*tcl_UtfCharComplete) (CONST char *src, int length)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_UtfBackslash) (CONST char *src, int *readPtr, char *dst)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_UtfFindFirst) (CONST char *src, int ch)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "* (*tcl_UtfFindLast) (CONST char *src, int ch)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "* (*tcl_UtfNext) (CONST char *src)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "* (*tcl_UtfPrev) (CONST char *src, CONST char *start)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "(*tcl_UtfToExternal) (Tcl_Interp *interp, Tcl_Encoding encoding, CONST char *src, int srcLen, int flags, Tcl_EncodingState *statePtr, char *dst, int dstLen, int *srcReadPtr, int *dstWrotePtr, int *dstCharsPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_UtfToExternalDString) (Tcl_Encoding encoding, CONST char *src, int srcLen, Tcl_DString *dsPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "(*tcl_UtfToLower) (char *src)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_UtfToTitle) (char *src)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_UtfToUniChar) (CONST char *src, Tcl_UniChar *chPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_UtfToUpper) (char *src)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_WriteChars) (Tcl_Channel chan, CONST char *src, int srcLen)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_WriteObj) (Tcl_Channel chan, Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetString) (Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetDefaultEncodingDir) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "(*tcl_SetDefaultEncodingDir) (CONST char *path)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_AlertNotifier) (ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_ServiceModeHook) (int mode)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_UniCharIsAlnum) (int ch)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_UniCharIsAlpha) (int ch)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_UniCharIsDigit) (int ch)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_UniCharIsLower) (int ch)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_UniCharIsSpace) (int ch)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_UniCharIsUpper) (int ch)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_UniCharIsWordChar) (int ch)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_UniCharLen) (CONST Tcl_UniChar *uniStr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_UniCharNcmp) (CONST Tcl_UniChar *ucs, CONST Tcl_UniChar *uct, unsigned long numChars)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_UniCharToUtfDString) (CONST Tcl_UniChar *uniStr, int uniLength, Tcl_DString *dsPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "* (*tcl_UtfToUniCharDString) (CONST char *src, int length, Tcl_DString *dsPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_UniChar"
            }, {
              fpointer = 1,
              name = "(*tcl_GetRegExpFromObj) (Tcl_Interp *interp, Tcl_Obj *patObj, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_RegExp"
            }, {
              fpointer = 1,
              name = "* (*tcl_EvalTokens) (Tcl_Interp *interp, Tcl_Token *tokenPtr, int count)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "(*tcl_FreeParse) (Tcl_Parse *parsePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_LogCommandInfo) (Tcl_Interp *interp, CONST char *script, CONST char *command, int length)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_ParseBraces) (Tcl_Interp *interp, CONST char *start, int numBytes, Tcl_Parse *parsePtr, int append, CONST84 char **termPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ParseCommand) (Tcl_Interp *interp, CONST char *start, int numBytes, int nested, Tcl_Parse *parsePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ParseExpr) (Tcl_Interp *interp, CONST char *start, int numBytes, Tcl_Parse *parsePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ParseQuotedString) (Tcl_Interp *interp, CONST char *start, int numBytes, Tcl_Parse *parsePtr, int append, CONST84 char **termPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ParseVarName) (Tcl_Interp *interp, CONST char *start, int numBytes, Tcl_Parse *parsePtr, int append)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetCwd) (Tcl_Interp *interp, Tcl_DString *cwdPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "(*tcl_Chdir) (CONST char *dirName)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_Access) (CONST char *path, int mode)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_Stat) (CONST char *path, struct stat *bufPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_UtfNcmp) (CONST char *s1, CONST char *s2, unsigned long n)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_UtfNcasecmp) (CONST char *s1, CONST char *s2, unsigned long n)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_StringCaseMatch) (CONST char *str, CONST char *pattern, int nocase)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_UniCharIsControl) (int ch)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_UniCharIsGraph) (int ch)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_UniCharIsPrint) (int ch)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_UniCharIsPunct) (int ch)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_RegExpExecObj) (Tcl_Interp *interp, Tcl_RegExp regexp, Tcl_Obj *textObj, int offset, int nmatches, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_RegExpGetInfo) (Tcl_RegExp regexp, Tcl_RegExpInfo *infoPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*tcl_NewUnicodeObj) (CONST Tcl_UniChar *unicode, int numChars)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "(*tcl_SetUnicodeObj) (Tcl_Obj *objPtr, CONST Tcl_UniChar *unicode, int numChars)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_GetCharLength) (Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_GetUniChar) (Tcl_Obj *objPtr, int index)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_UniChar"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetUnicode) (Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_UniChar"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetRange) (Tcl_Obj *objPtr, int first, int last)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "(*tcl_AppendUnicodeToObj) (Tcl_Obj *objPtr, CONST Tcl_UniChar *unicode, int length)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_RegExpMatchObj) (Tcl_Interp *interp, Tcl_Obj *textObj, Tcl_Obj *patternObj)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_SetNotifier) (Tcl_NotifierProcs *notifierProcPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetAllocMutex) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Mutex"
            }, {
              fpointer = 1,
              name = "(*tcl_GetChannelNames) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_GetChannelNamesEx) (Tcl_Interp *interp, CONST char *pattern)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ProcObjCmd) (ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ConditionFinalize) (Tcl_Condition *condPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_MutexFinalize) (Tcl_Mutex *mutex)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_CreateThread) (Tcl_ThreadId *idPtr, Tcl_ThreadCreateProc proc, ClientData clientData, int stackSize, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ReadRaw) (Tcl_Channel chan, char *dst, int bytesToRead)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_WriteRaw) (Tcl_Channel chan, CONST char *src, int srcLen)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_GetTopChannel) (Tcl_Channel chan)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Channel"
            }, {
              fpointer = 1,
              name = "(*tcl_ChannelBuffered) (Tcl_Channel chan)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_ChannelName) (CONST Tcl_ChannelType *chanTypePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "(*tcl_ChannelVersion) (CONST Tcl_ChannelType *chanTypePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_ChannelTypeVersion"
            }, {
              fpointer = 1,
              name = "* (*tcl_ChannelBlockModeProc) (CONST Tcl_ChannelType *chanTypePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverBlockModeProc"
            }, {
              fpointer = 1,
              name = "* (*tcl_ChannelCloseProc) (CONST Tcl_ChannelType *chanTypePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverCloseProc"
            }, {
              fpointer = 1,
              name = "* (*tcl_ChannelClose2Proc) (CONST Tcl_ChannelType *chanTypePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverClose2Proc"
            }, {
              fpointer = 1,
              name = "* (*tcl_ChannelInputProc) (CONST Tcl_ChannelType *chanTypePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverInputProc"
            }, {
              fpointer = 1,
              name = "* (*tcl_ChannelOutputProc) (CONST Tcl_ChannelType *chanTypePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverOutputProc"
            }, {
              fpointer = 1,
              name = "* (*tcl_ChannelSeekProc) (CONST Tcl_ChannelType *chanTypePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverSeekProc"
            }, {
              fpointer = 1,
              name = "* (*tcl_ChannelSetOptionProc) (CONST Tcl_ChannelType *chanTypePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverSetOptionProc"
            }, {
              fpointer = 1,
              name = "* (*tcl_ChannelGetOptionProc) (CONST Tcl_ChannelType *chanTypePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverGetOptionProc"
            }, {
              fpointer = 1,
              name = "* (*tcl_ChannelWatchProc) (CONST Tcl_ChannelType *chanTypePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverWatchProc"
            }, {
              fpointer = 1,
              name = "* (*tcl_ChannelGetHandleProc) (CONST Tcl_ChannelType *chanTypePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverGetHandleProc"
            }, {
              fpointer = 1,
              name = "* (*tcl_ChannelFlushProc) (CONST Tcl_ChannelType *chanTypePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverFlushProc"
            }, {
              fpointer = 1,
              name = "* (*tcl_ChannelHandlerProc) (CONST Tcl_ChannelType *chanTypePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverHandlerProc"
            }, {
              fpointer = 1,
              name = "(*tcl_JoinThread) (Tcl_ThreadId threadId, int *result)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_IsChannelShared) (Tcl_Channel channel)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_IsChannelRegistered) (Tcl_Interp *interp, Tcl_Channel channel)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_CutChannel) (Tcl_Channel channel)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_SpliceChannel) (Tcl_Channel channel)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_ClearChannelHandlers) (Tcl_Channel channel)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_IsChannelExisting) (CONST char *channelName)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_UniCharNcasecmp) (CONST Tcl_UniChar *ucs, CONST Tcl_UniChar *uct, unsigned long numChars)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_UniCharCaseMatch) (CONST Tcl_UniChar *uniStr, CONST Tcl_UniChar *uniPattern, int nocase)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_FindHashEntry) (Tcl_HashTable *tablePtr, CONST char *key)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_HashEntry"
            }, {
              fpointer = 1,
              name = "* (*tcl_CreateHashEntry) (Tcl_HashTable *tablePtr, CONST char *key, int *newPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_HashEntry"
            }, {
              fpointer = 1,
              name = "(*tcl_InitCustomHashTable) (Tcl_HashTable *tablePtr, int keyType, Tcl_HashKeyType *typePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_InitObjHashTable) (Tcl_HashTable *tablePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_CommandTraceInfo) (Tcl_Interp *interp, CONST char *varName, int flags, Tcl_CommandTraceProc *procPtr, ClientData prevClientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "ClientData"
            }, {
              fpointer = 1,
              name = "(*tcl_TraceCommand) (Tcl_Interp *interp, CONST char *varName, int flags, Tcl_CommandTraceProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_UntraceCommand) (Tcl_Interp *interp, CONST char *varName, int flags, Tcl_CommandTraceProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*tcl_AttemptAlloc) (unsigned int size)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "* (*tcl_AttemptDbCkalloc) (unsigned int size, CONST char *file, int line)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "* (*tcl_AttemptRealloc) (char *ptr, unsigned int size)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "* (*tcl_AttemptDbCkrealloc) (char *ptr, unsigned int size, CONST char *file, int line)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "(*tcl_AttemptSetObjLength) (Tcl_Obj *objPtr, int length)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_GetChannelThread) (Tcl_Channel channel)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_ThreadId"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetUnicodeFromObj) (Tcl_Obj *objPtr, int *lengthPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_UniChar"
            }, {
              fpointer = 1,
              name = "(*tcl_GetMathFuncInfo) (Tcl_Interp *interp, CONST char *name, int *numArgsPtr, Tcl_ValueType **argTypesPtr, Tcl_MathProc **procPtr, ClientData *clientDataPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_ListMathFuncs) (Tcl_Interp *interp, CONST char *pattern)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "* (*tcl_SubstObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "(*tcl_DetachChannel) (Tcl_Interp *interp, Tcl_Channel channel)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_IsStandardChannel) (Tcl_Channel channel)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_FSCopyFile) (Tcl_Obj *srcPathPtr, Tcl_Obj *destPathPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_FSCopyDirectory) (Tcl_Obj *srcPathPtr, Tcl_Obj *destPathPtr, Tcl_Obj **errorPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_FSCreateDirectory) (Tcl_Obj *pathPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_FSDeleteFile) (Tcl_Obj *pathPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_FSLoadFile) (Tcl_Interp *interp, Tcl_Obj *pathPtr, CONST char *sym1, CONST char *sym2, Tcl_PackageInitProc **proc1Ptr, Tcl_PackageInitProc **proc2Ptr, Tcl_LoadHandle *handlePtr, Tcl_FSUnloadFileProc **unloadProcPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_FSMatchInDirectory) (Tcl_Interp *interp, Tcl_Obj *result, Tcl_Obj *pathPtr, CONST char *pattern, Tcl_GlobTypeData *types)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_FSLink) (Tcl_Obj *pathPtr, Tcl_Obj *toPtr, int linkAction)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "(*tcl_FSRemoveDirectory) (Tcl_Obj *pathPtr, int recursive, Tcl_Obj **errorPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_FSRenameFile) (Tcl_Obj *srcPathPtr, Tcl_Obj *destPathPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_FSLstat) (Tcl_Obj *pathPtr, Tcl_StatBuf *buf)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_FSUtime) (Tcl_Obj *pathPtr, struct utimbuf *tval)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_FSFileAttrsGet) (Tcl_Interp *interp, int index, Tcl_Obj *pathPtr, Tcl_Obj **objPtrRef)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_FSFileAttrsSet) (Tcl_Interp *interp, int index, Tcl_Obj *pathPtr, Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "** (*tcl_FSFileAttrStrings) (Tcl_Obj *pathPtr, Tcl_Obj **objPtrRef)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST char"
            }, {
              fpointer = 1,
              name = "(*tcl_FSStat) (Tcl_Obj *pathPtr, Tcl_StatBuf *buf)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_FSAccess) (Tcl_Obj *pathPtr, int mode)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_FSOpenFileChannel) (Tcl_Interp *interp, Tcl_Obj *pathPtr, CONST char *modeString, int permissions)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Channel"
            }, {
              fpointer = 1,
              name = "* (*tcl_FSGetCwd) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "(*tcl_FSChdir) (Tcl_Obj *pathPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_FSConvertToPathType) (Tcl_Interp *interp, Tcl_Obj *pathPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_FSJoinPath) (Tcl_Obj *listObj, int elements)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "* (*tcl_FSSplitPath) (Tcl_Obj *pathPtr, int *lenPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "(*tcl_FSEqualPaths) (Tcl_Obj *firstPtr, Tcl_Obj *secondPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_FSGetNormalizedPath) (Tcl_Interp *interp, Tcl_Obj *pathPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "* (*tcl_FSJoinToPath) (Tcl_Obj *pathPtr, int objc, Tcl_Obj *CONST objv[])",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "(*tcl_FSGetInternalRep) (Tcl_Obj *pathPtr, Tcl_Filesystem *fsPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "ClientData"
            }, {
              fpointer = 1,
              name = "* (*tcl_FSGetTranslatedPath) (Tcl_Interp *interp, Tcl_Obj *pathPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "(*tcl_FSEvalFile) (Tcl_Interp *interp, Tcl_Obj *fileName)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_FSNewNativePath) (Tcl_Filesystem *fromFilesystem, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "* (*tcl_FSGetNativePath) (Tcl_Obj *pathPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST char"
            }, {
              fpointer = 1,
              name = "* (*tcl_FSFileSystemInfo) (Tcl_Obj *pathPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "* (*tcl_FSPathSeparator) (Tcl_Obj *pathPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "* (*tcl_FSListVolumes) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "(*tcl_FSRegister) (ClientData clientData, Tcl_Filesystem *fsPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_FSUnregister) (Tcl_Filesystem *fsPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_FSData) (Tcl_Filesystem *fsPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "ClientData"
            }, {
              fpointer = 1,
              name = "* (*tcl_FSGetTranslatedStringPath) (Tcl_Interp *interp, Tcl_Obj *pathPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST char"
            }, {
              fpointer = 1,
              name = "* (*tcl_FSGetFileSystemForPath) (Tcl_Obj *pathPtr)",
              pointer = 1,
              s = 1,
              t = 0,
              type = "Tcl_Filesystem"
            }, {
              fpointer = 1,
              name = "(*tcl_FSGetPathType) (Tcl_Obj *pathPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_PathType"
            }, {
              fpointer = 1,
              name = "(*tcl_OutputBuffered) (Tcl_Channel chan)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_FSMountsChanged) (Tcl_Filesystem *fsPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_EvalTokensStandard) (Tcl_Interp *interp, Tcl_Token *tokenPtr, int count)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_GetTime) (Tcl_Time *timeBuf)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_CreateObjTrace) (Tcl_Interp *interp, int level, int flags, Tcl_CmdObjTraceProc *objProc, ClientData clientData, Tcl_CmdObjTraceDeleteProc *delProc)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Trace"
            }, {
              fpointer = 1,
              name = "(*tcl_GetCommandInfoFromToken) (Tcl_Command token, Tcl_CmdInfo *infoPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_SetCommandInfoFromToken) (Tcl_Command token, CONST Tcl_CmdInfo *infoPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_DbNewWideIntObj) (Tcl_WideInt wideValue, CONST char *file, int line)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "(*tcl_GetWideIntFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, Tcl_WideInt *widePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_NewWideIntObj) (Tcl_WideInt wideValue)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "(*tcl_SetWideIntObj) (Tcl_Obj *objPtr, Tcl_WideInt wideValue)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*tcl_AllocStatBuf) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_StatBuf"
            }, {
              fpointer = 1,
              name = "(*tcl_Seek) (Tcl_Channel chan, Tcl_WideInt offset, int mode)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_WideInt"
            }, {
              fpointer = 1,
              name = "(*tcl_Tell) (Tcl_Channel chan)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_WideInt"
            }, {
              fpointer = 1,
              name = "* (*tcl_ChannelWideSeekProc) (CONST Tcl_ChannelType *chanTypePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverWideSeekProc"
            }, {
              fpointer = 1,
              name = "(*tcl_DictObjPut) (Tcl_Interp *interp, Tcl_Obj *dictPtr, Tcl_Obj *keyPtr, Tcl_Obj *valuePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_DictObjGet) (Tcl_Interp *interp, Tcl_Obj *dictPtr, Tcl_Obj *keyPtr, Tcl_Obj **valuePtrPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_DictObjRemove) (Tcl_Interp *interp, Tcl_Obj *dictPtr, Tcl_Obj *keyPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_DictObjSize) (Tcl_Interp *interp, Tcl_Obj *dictPtr, int *sizePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_DictObjFirst) (Tcl_Interp *interp, Tcl_Obj *dictPtr, Tcl_DictSearch *searchPtr, Tcl_Obj **keyPtrPtr, Tcl_Obj **valuePtrPtr, int *donePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_DictObjNext) (Tcl_DictSearch *searchPtr, Tcl_Obj **keyPtrPtr, Tcl_Obj **valuePtrPtr, int *donePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_DictObjDone) (Tcl_DictSearch *searchPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_DictObjPutKeyList) (Tcl_Interp *interp, Tcl_Obj *dictPtr, int keyc, Tcl_Obj *CONST *keyv, Tcl_Obj *valuePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_DictObjRemoveKeyList) (Tcl_Interp *interp, Tcl_Obj *dictPtr, int keyc, Tcl_Obj *CONST *keyv)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_NewDictObj) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "* (*tcl_DbNewDictObj) (CONST char *file, int line)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "(*tcl_RegisterConfig) (Tcl_Interp *interp, CONST char *pkgName, Tcl_Config *configuration, CONST char *valEncoding)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*tcl_CreateNamespace) (Tcl_Interp *interp, CONST char *name, ClientData clientData, Tcl_NamespaceDeleteProc *deleteProc)",
              pointer = 1,
              s = 1,
              t = 0,
              type = "Tcl_Namespace"
            }, {
              fpointer = 1,
              name = "(*tcl_DeleteNamespace) (Tcl_Namespace *nsPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_AppendExportList) (Tcl_Interp *interp, Tcl_Namespace *nsPtr, Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_Export) (Tcl_Interp *interp, Tcl_Namespace *nsPtr, CONST char *pattern, int resetListFirst)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_Import) (Tcl_Interp *interp, Tcl_Namespace *nsPtr, CONST char *pattern, int allowOverwrite)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_ForgetImport) (Tcl_Interp *interp, Tcl_Namespace *nsPtr, CONST char *pattern)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetCurrentNamespace) (Tcl_Interp *interp)",
              pointer = 1,
              s = 1,
              t = 0,
              type = "Tcl_Namespace"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetGlobalNamespace) (Tcl_Interp *interp)",
              pointer = 1,
              s = 1,
              t = 0,
              type = "Tcl_Namespace"
            }, {
              fpointer = 1,
              name = "* (*tcl_FindNamespace) (Tcl_Interp *interp, CONST char *name, Tcl_Namespace *contextNsPtr, int flags)",
              pointer = 1,
              s = 1,
              t = 0,
              type = "Tcl_Namespace"
            }, {
              fpointer = 1,
              name = "(*tcl_FindCommand) (Tcl_Interp *interp, CONST char *name, Tcl_Namespace *contextNsPtr, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Command"
            }, {
              fpointer = 1,
              name = "(*tcl_GetCommandFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Command"
            }, {
              fpointer = 1,
              name = "(*tcl_GetCommandFullName) (Tcl_Interp *interp, Tcl_Command command, Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_FSEvalFileEx) (Tcl_Interp *interp, Tcl_Obj *fileName, CONST char *encodingName)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_SetExitProc) (Tcl_ExitProc *proc)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_ExitProc"
            }, {
              fpointer = 1,
              name = "(*tcl_LimitAddHandler) (Tcl_Interp *interp, int type, Tcl_LimitHandlerProc *handlerProc, ClientData clientData, Tcl_LimitHandlerDeleteProc *deleteProc)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_LimitRemoveHandler) (Tcl_Interp *interp, int type, Tcl_LimitHandlerProc *handlerProc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_LimitReady) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_LimitCheck) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_LimitExceeded) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_LimitSetCommands) (Tcl_Interp *interp, int commandLimit)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_LimitSetTime) (Tcl_Interp *interp, Tcl_Time *timeLimitPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_LimitSetGranularity) (Tcl_Interp *interp, int type, int granularity)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_LimitTypeEnabled) (Tcl_Interp *interp, int type)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_LimitTypeExceeded) (Tcl_Interp *interp, int type)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_LimitTypeSet) (Tcl_Interp *interp, int type)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_LimitTypeReset) (Tcl_Interp *interp, int type)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_LimitGetCommands) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_LimitGetTime) (Tcl_Interp *interp, Tcl_Time *timeLimitPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_LimitGetGranularity) (Tcl_Interp *interp, int type)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_SaveInterpState) (Tcl_Interp *interp, int status)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_InterpState"
            }, {
              fpointer = 1,
              name = "(*tcl_RestoreInterpState) (Tcl_Interp *interp, Tcl_InterpState state)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_DiscardInterpState) (Tcl_InterpState state)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_SetReturnOptions) (Tcl_Interp *interp, Tcl_Obj *options)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetReturnOptions) (Tcl_Interp *interp, int result)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "(*tcl_IsEnsemble) (Tcl_Command token)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_CreateEnsemble) (Tcl_Interp *interp, CONST char *name, Tcl_Namespace *namespacePtr, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Command"
            }, {
              fpointer = 1,
              name = "(*tcl_FindEnsemble) (Tcl_Interp *interp, Tcl_Obj *cmdNameObj, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Command"
            }, {
              fpointer = 1,
              name = "(*tcl_SetEnsembleSubcommandList) (Tcl_Interp *interp, Tcl_Command token, Tcl_Obj *subcmdList)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_SetEnsembleMappingDict) (Tcl_Interp *interp, Tcl_Command token, Tcl_Obj *mapDict)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_SetEnsembleUnknownHandler) (Tcl_Interp *interp, Tcl_Command token, Tcl_Obj *unknownList)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_SetEnsembleFlags) (Tcl_Interp *interp, Tcl_Command token, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_GetEnsembleSubcommandList) (Tcl_Interp *interp, Tcl_Command token, Tcl_Obj **subcmdListPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_GetEnsembleMappingDict) (Tcl_Interp *interp, Tcl_Command token, Tcl_Obj **mapDictPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_GetEnsembleUnknownHandler) (Tcl_Interp *interp, Tcl_Command token, Tcl_Obj **unknownListPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_GetEnsembleFlags) (Tcl_Interp *interp, Tcl_Command token, int *flagsPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_GetEnsembleNamespace) (Tcl_Interp *interp, Tcl_Command token, Tcl_Namespace **namespacePtrPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_SetTimeProc) (Tcl_GetTimeProc *getProc, Tcl_ScaleTimeProc *scaleProc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_QueryTimeProc) (Tcl_GetTimeProc **getProc, Tcl_ScaleTimeProc **scaleProc, ClientData *clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*tcl_ChannelThreadActionProc) (CONST Tcl_ChannelType *chanTypePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverThreadActionProc"
            }, {
              fpointer = 1,
              name = "* (*tcl_NewBignumObj) (mp_int *value)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "* (*tcl_DbNewBignumObj) (mp_int *value, CONST char *file, int line)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "(*tcl_SetBignumObj) (Tcl_Obj *obj, mp_int *value)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_GetBignumFromObj) (Tcl_Interp *interp, Tcl_Obj *obj, mp_int *value)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_TakeBignumFromObj) (Tcl_Interp *interp, Tcl_Obj *obj, mp_int *value)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_TruncateChannel) (Tcl_Channel chan, Tcl_WideInt length)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_ChannelTruncateProc) (CONST Tcl_ChannelType *chanTypePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_DriverTruncateProc"
            }, {
              fpointer = 1,
              name = "(*tcl_SetChannelErrorInterp) (Tcl_Interp *interp, Tcl_Obj *msg)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_GetChannelErrorInterp) (Tcl_Interp *interp, Tcl_Obj **msg)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_SetChannelError) (Tcl_Channel chan, Tcl_Obj *msg)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_GetChannelError) (Tcl_Channel chan, Tcl_Obj **msg)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_InitBignumFromDouble) (Tcl_Interp *interp, double initval, mp_int *toInit)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetNamespaceUnknownHandler) (Tcl_Interp *interp, Tcl_Namespace *nsPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "(*tcl_SetNamespaceUnknownHandler) (Tcl_Interp *interp, Tcl_Namespace *nsPtr, Tcl_Obj *handlerPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_GetEncodingFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, Tcl_Encoding *encodingPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetEncodingSearchPath) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "(*tcl_SetEncodingSearchPath) (Tcl_Obj *searchPath)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_GetEncodingNameFromEnvironment) (Tcl_DString *bufPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST char"
            }, {
              fpointer = 1,
              name = "(*tcl_PkgRequireProc) (Tcl_Interp *interp, CONST char *name, int objc, Tcl_Obj *CONST objv[], ClientData *clientDataPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_AppendObjToErrorInfo) (Tcl_Interp *interp, Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tcl_AppendLimitedToObj) (Tcl_Obj *objPtr, CONST char *bytes, int length, int limit, CONST char *ellipsis)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*tcl_Format) (Tcl_Interp *interp, CONST char *format, int objc, Tcl_Obj *CONST objv[])",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "(*tcl_AppendFormatToObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, CONST char *format, int objc, Tcl_Obj *CONST objv[])",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tcl_ObjPrintf) (CONST char *format, ...)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "(*tcl_AppendPrintfToObj) (Tcl_Obj *objPtr, CONST char *format, ...)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            } },
          print = <function 216>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "fstab.h",
        linedef = 59,
        name = "fstab",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 217>,
          init = <function 218>,
          list = { {
              fpointer = 0,
              name = "*fs_spec",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*fs_file",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*fs_vfstype",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*fs_mntops",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*fs_type",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "fs_freq",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "fs_passno",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 219>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "sqlite3.h",
        linedef = 598,
        name = "sqlite3_file",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 220>,
          init = <function 221>,
          list = { {
              fpointer = 0,
              name = "*pMethods",
              pointer = 1,
              s = 1,
              t = 0,
              type = "const struct sqlite3_io_methods"
            } },
          print = <function 222>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "sqlite3.h",
        linedef = 693,
        name = "sqlite3_io_methods",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 223>,
          init = <function 224>,
          list = { {
              fpointer = 0,
              name = "iVersion",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xClose)(sqlite3_file*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xRead)(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xWrite)(sqlite3_file*, const void*, int iAmt, sqlite3_int64 iOfst)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xTruncate)(sqlite3_file*, sqlite3_int64 size)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xSync)(sqlite3_file*, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xFileSize)(sqlite3_file*, sqlite3_int64 *pSize)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xLock)(sqlite3_file*, int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xUnlock)(sqlite3_file*, int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xCheckReservedLock)(sqlite3_file*, int *pResOut)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xFileControl)(sqlite3_file*, int op, void *pArg)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xSectorSize)(sqlite3_file*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xDeviceCharacteristics)(sqlite3_file*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xShmMap)(sqlite3_file*, int iPg, int pgsz, int, void volatile**)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xShmLock)(sqlite3_file*, int offset, int n, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xShmBarrier)(sqlite3_file*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xShmUnmap)(sqlite3_file*, int deleteFlag)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 225>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "sqlite3.h",
        linedef = 1039,
        name = "sqlite3_vfs",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 226>,
          init = <function 227>,
          list = { {
              fpointer = 0,
              name = "iVersion",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "szOsFile",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "mxPathname",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*pNext",
              pointer = 1,
              s = 0,
              t = 0,
              type = "sqlite3_vfs"
            }, {
              fpointer = 0,
              name = "*zName",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 0,
              name = "*pAppData",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "flags, int *pOutFlags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xDelete)(sqlite3_vfs*, const char *zName, int syncDir)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xAccess)(sqlite3_vfs*, const char *zName, int flags, int *pResOut)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xFullPathname)(sqlite3_vfs*, const char *zName, int nOut, char *zOut)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "*(*xDlOpen)(sqlite3_vfs*, const char *zFilename)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xDlError)(sqlite3_vfs*, int nByte, char *zErrMsg)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*(*xDlSym)(sqlite3_vfs*,void*, const char *zSymbol))(void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xDlClose)(sqlite3_vfs*, void*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xRandomness)(sqlite3_vfs*, int nByte, char *zOut)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xSleep)(sqlite3_vfs*, int microseconds)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xCurrentTime)(sqlite3_vfs*, double*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xGetLastError)(sqlite3_vfs*, int, char *)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xCurrentTimeInt64)(sqlite3_vfs*, sqlite3_int64*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xSetSystemCall)(sqlite3_vfs*, const char *zName, sqlite3_syscall_ptr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xGetSystemCall)(sqlite3_vfs*, const char *zName)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "sqlite3_syscall_ptr"
            }, {
              fpointer = 1,
              name = "*(*xNextSystemCall)(sqlite3_vfs*, const char *zName)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            } },
          print = <function 228>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "sqlite3.h",
        linedef = 1333,
        name = "sqlite3_mem_methods",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 229>,
          init = <function 230>,
          list = { {
              fpointer = 1,
              name = "*(*xMalloc)(int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xFree)(void*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "*(*xRealloc)(void*,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSize)(void*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xRoundup)(int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xInit)(void*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xShutdown)(void*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "*pAppData",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            } },
          print = <function 231>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "sqlite3.h",
        linedef = 5005,
        name = "sqlite3_module",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 232>,
          init = <function 233>,
          list = { {
              fpointer = 0,
              name = "iVersion",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "**ppVTab, char**)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "sqlite3_vtab"
            }, {
              fpointer = 0,
              name = "**ppVTab, char**)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "sqlite3_vtab"
            }, {
              fpointer = 1,
              name = "(*xBestIndex)(sqlite3_vtab *pVTab, sqlite3_index_info*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xDisconnect)(sqlite3_vtab *pVTab)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xDestroy)(sqlite3_vtab *pVTab)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xOpen)(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xClose)(sqlite3_vtab_cursor*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "argc, sqlite3_value **argv)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xNext)(sqlite3_vtab_cursor*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xEof)(sqlite3_vtab_cursor*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xColumn)(sqlite3_vtab_cursor*, sqlite3_context*, int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xRowid)(sqlite3_vtab_cursor*, sqlite3_int64 *pRowid)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xUpdate)(sqlite3_vtab *, int, sqlite3_value **, sqlite3_int64 *)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xBegin)(sqlite3_vtab *pVTab)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xSync)(sqlite3_vtab *pVTab)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xCommit)(sqlite3_vtab *pVTab)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xRollback)(sqlite3_vtab *pVTab)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "**ppArg)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xRename)(sqlite3_vtab *pVtab, const char *zNew)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xSavepoint)(sqlite3_vtab *pVTab, int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xRelease)(sqlite3_vtab *pVTab, int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xRollbackTo)(sqlite3_vtab *pVTab, int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 234>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "sqlite3.h",
        linedef = 5093,
        name = "sqlite3_index_info",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 235>,
          init = <function 236>,
          list = { {
              fpointer = 0,
              name = "nConstraint",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "iColumn",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "op",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned char"
            }, {
              fpointer = 0,
              name = "usable",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned char"
            }, {
              fpointer = 0,
              name = "iTermOffset",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 237>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "sqlite3.h",
        linedef = 5096,
        name = "sqlite3_index_constraint",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 238>,
          init = <function 239>,
          list = { {
              fpointer = 0,
              name = "iColumn",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "op",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned char"
            }, {
              fpointer = 0,
              name = "usable",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned char"
            }, {
              fpointer = 0,
              name = "iTermOffset",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 240>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "sqlite3.h",
        linedef = 5103,
        name = "sqlite3_index_orderby",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 241>,
          init = <function 242>,
          list = { {
              fpointer = 0,
              name = "iColumn",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "desc",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned char"
            } },
          print = <function 243>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "sqlite3.h",
        linedef = 5108,
        name = "sqlite3_index_constraint_usage",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 244>,
          init = <function 245>,
          list = { {
              fpointer = 0,
              name = "argvIndex",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "omit",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned char"
            } },
          print = <function 246>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "sqlite3.h",
        linedef = 5191,
        name = "sqlite3_vtab",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 247>,
          init = <function 248>,
          list = { {
              fpointer = 0,
              name = "*pModule",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const sqlite3_module"
            }, {
              fpointer = 0,
              name = "nRef",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*zErrMsg",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            } },
          print = <function 249>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "sqlite3.h",
        linedef = 5215,
        name = "sqlite3_vtab_cursor",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 250>,
          init = <function 251>,
          list = { {
              fpointer = 0,
              name = "*pVtab",
              pointer = 1,
              s = 0,
              t = 0,
              type = "sqlite3_vtab"
            } },
          print = <function 252>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "sqlite3.h",
        linedef = 5686,
        name = "sqlite3_mutex_methods",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 253>,
          init = <function 254>,
          list = { {
              fpointer = 1,
              name = "(*xMutexInit)(void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xMutexEnd)(void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "*(*xMutexAlloc)(int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "sqlite3_mutex"
            }, {
              fpointer = 1,
              name = "(*xMutexFree)(sqlite3_mutex *)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xMutexEnter)(sqlite3_mutex *)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xMutexTry)(sqlite3_mutex *)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xMutexLeave)(sqlite3_mutex *)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xMutexHeld)(sqlite3_mutex *)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xMutexNotheld)(sqlite3_mutex *)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 255>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "sqlite3.h",
        linedef = 6173,
        name = "sqlite3_pcache_page",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 256>,
          init = <function 257>,
          list = { {
              fpointer = 0,
              name = "*pBuf",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "*pExtra",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            } },
          print = <function 258>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "sqlite3.h",
        linedef = 6338,
        name = "sqlite3_pcache_methods2",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 259>,
          init = <function 260>,
          list = { {
              fpointer = 0,
              name = "iVersion",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*pArg",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xInit)(void*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xShutdown)(void*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "*(*xCreate)(int szPage, int szExtra, int bPurgeable)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "sqlite3_pcache"
            }, {
              fpointer = 1,
              name = "(*xCachesize)(sqlite3_pcache*, int nCachesize)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xPagecount)(sqlite3_pcache*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "*(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "sqlite3_pcache_page"
            }, {
              fpointer = 1,
              name = "(*xUnpin)(sqlite3_pcache*, sqlite3_pcache_page*, int discard)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "oldKey, unsigned newKey)",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned"
            }, {
              fpointer = 1,
              name = "(*xTruncate)(sqlite3_pcache*, unsigned iLimit)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xDestroy)(sqlite3_pcache*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xShrink)(sqlite3_pcache*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            } },
          print = <function 261>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "sqlite3.h",
        linedef = 6361,
        name = "sqlite3_pcache_methods",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 262>,
          init = <function 263>,
          list = { {
              fpointer = 0,
              name = "*pArg",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xInit)(void*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xShutdown)(void*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "*(*xCreate)(int szPage, int bPurgeable)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "sqlite3_pcache"
            }, {
              fpointer = 1,
              name = "(*xCachesize)(sqlite3_pcache*, int nCachesize)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xPagecount)(sqlite3_pcache*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "*(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xUnpin)(sqlite3_pcache*, void*, int discard)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xRekey)(sqlite3_pcache*, void*, unsigned oldKey, unsigned newKey)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xTruncate)(sqlite3_pcache*, unsigned iLimit)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xDestroy)(sqlite3_pcache*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            } },
          print = <function 264>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "sqlite3.h",
        linedef = 7058,
        name = "sqlite3_rtree_geometry",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 265>,
          init = <function 266>,
          list = { {
              fpointer = 0,
              name = "*pContext",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "nParam",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*aParam",
              pointer = 1,
              s = 0,
              t = 0,
              type = "double"
            }, {
              fpointer = 0,
              name = "*pUser",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xDelUser)(void *)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            } },
          print = <function 267>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ar.h",
        linedef = 56,
        name = "ar_hdr",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 268>,
          init = <function 269>,
          list = { {
              fpointer = 0,
              name = "ar_name[16]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "ar_date[12]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "ar_uid[6]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "ar_gid[6]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "ar_mode[8]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "ar_size[10]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "ar_fmag[2]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            } },
          print = <function 270>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "dns_sd.h",
        linedef = 2699,
        name = "CompileTimeAssertionChecks_DNS_SD",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 271>,
          init = <function 272>,
          list = { {
              fpointer = 0,
              name = "assert0[(sizeof(union _TXTRecordRef_t) == 16) ? 1 : -1]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            } },
          print = <function 273>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "dlfcn.h",
        linedef = 45,
        name = "dl_info",
        structs = <table 1>,
        typedef = 1,
        typedname = "Dl_info",
        vars = {
          add = <function 274>,
          init = <function 275>,
          list = { {
              fpointer = 0,
              name = "*dli_fname",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 0,
              name = "*dli_fbase",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "*dli_sname",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 0,
              name = "*dli_saddr",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            } },
          print = <function 276>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "dtrace.h",
        linedef = 161,
        name = "dtrace_proginfo",
        structs = <table 1>,
        typedef = 1,
        typedname = "dtrace_proginfo_t",
        vars = {
          add = <function 277>,
          init = <function 278>,
          list = { {
              fpointer = 0,
              name = "dpi_descattr",
              pointer = 0,
              s = 0,
              t = 0,
              type = "dtrace_attribute_t"
            }, {
              fpointer = 0,
              name = "dpi_stmtattr",
              pointer = 0,
              s = 0,
              t = 0,
              type = "dtrace_attribute_t"
            }, {
              fpointer = 0,
              name = "dpi_aggregates",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uint_t"
            }, {
              fpointer = 0,
              name = "dpi_recgens",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uint_t"
            }, {
              fpointer = 0,
              name = "dpi_matches",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uint_t"
            }, {
              fpointer = 0,
              name = "dpi_speculations",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uint_t"
            } },
          print = <function 279>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "dtrace.h",
        linedef = 211,
        name = "dtrace_stmtdesc",
        structs = <table 1>,
        typedef = 1,
        typedname = "dtrace_stmtdesc_t",
        vars = {
          add = <function 280>,
          init = <function 281>,
          list = { {
              fpointer = 0,
              name = "*dtsd_ecbdesc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "dtrace_ecbdesc_t"
            }, {
              fpointer = 0,
              name = "*dtsd_action",
              pointer = 1,
              s = 0,
              t = 0,
              type = "dtrace_actdesc_t"
            }, {
              fpointer = 0,
              name = "*dtsd_action_last",
              pointer = 1,
              s = 0,
              t = 0,
              type = "dtrace_actdesc_t"
            }, {
              fpointer = 0,
              name = "*dtsd_aggdata",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "*dtsd_fmtdata",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "(*dtsd_callback)()",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "*dtsd_data",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "dtsd_descattr",
              pointer = 0,
              s = 0,
              t = 0,
              type = "dtrace_attribute_t"
            }, {
              fpointer = 0,
              name = "dtsd_stmtattr",
              pointer = 0,
              s = 0,
              t = 0,
              type = "dtrace_attribute_t"
            } },
          print = <function 282>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "dtrace.h",
        linedef = 250,
        name = "dtrace_probedata",
        structs = <table 1>,
        typedef = 1,
        typedname = "dtrace_probedata_t",
        vars = {
          add = <function 283>,
          init = <function 284>,
          list = { {
              fpointer = 0,
              name = "*dtpda_handle",
              pointer = 1,
              s = 0,
              t = 0,
              type = "dtrace_hdl_t"
            }, {
              fpointer = 0,
              name = "*dtpda_edesc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "dtrace_eprobedesc_t"
            }, {
              fpointer = 0,
              name = "*dtpda_pdesc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "dtrace_probedesc_t"
            }, {
              fpointer = 0,
              name = "dtpda_cpu",
              pointer = 0,
              s = 0,
              t = 0,
              type = "processorid_t"
            }, {
              fpointer = 0,
              name = "dtpda_data",
              pointer = 0,
              s = 0,
              t = 0,
              type = "caddr_t"
            }, {
              fpointer = 0,
              name = "dtpda_flow",
              pointer = 0,
              s = 0,
              t = 0,
              type = "dtrace_flowkind_t"
            }, {
              fpointer = 0,
              name = "*dtpda_prefix",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 0,
              name = "dtpda_indent",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 285>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "dtrace.h",
        linedef = 326,
        name = "dtrace_errdata",
        structs = <table 1>,
        typedef = 1,
        typedname = "dtrace_errdata_t",
        vars = {
          add = <function 286>,
          init = <function 287>,
          list = { {
              fpointer = 0,
              name = "*dteda_handle",
              pointer = 1,
              s = 0,
              t = 0,
              type = "dtrace_hdl_t"
            }, {
              fpointer = 0,
              name = "*dteda_edesc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "dtrace_eprobedesc_t"
            }, {
              fpointer = 0,
              name = "*dteda_pdesc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "dtrace_probedesc_t"
            }, {
              fpointer = 0,
              name = "dteda_cpu",
              pointer = 0,
              s = 0,
              t = 0,
              type = "processorid_t"
            }, {
              fpointer = 0,
              name = "dteda_action",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "dteda_offset",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "dteda_fault",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "dteda_addr",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uint64_t"
            }, {
              fpointer = 0,
              name = "*dteda_msg",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            } },
          print = <function 288>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "dtrace.h",
        linedef = 354,
        name = "dtrace_dropdata",
        structs = <table 1>,
        typedef = 1,
        typedname = "dtrace_dropdata_t",
        vars = {
          add = <function 289>,
          init = <function 290>,
          list = { {
              fpointer = 0,
              name = "*dtdda_handle",
              pointer = 1,
              s = 0,
              t = 0,
              type = "dtrace_hdl_t"
            }, {
              fpointer = 0,
              name = "dtdda_cpu",
              pointer = 0,
              s = 0,
              t = 0,
              type = "processorid_t"
            }, {
              fpointer = 0,
              name = "dtdda_kind",
              pointer = 0,
              s = 0,
              t = 0,
              type = "dtrace_dropkind_t"
            }, {
              fpointer = 0,
              name = "dtdda_drops",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uint64_t"
            }, {
              fpointer = 0,
              name = "dtdda_total",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uint64_t"
            }, {
              fpointer = 0,
              name = "*dtdda_msg",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            } },
          print = <function 291>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "dtrace.h",
        linedef = 374,
        name = "dtrace_bufdata",
        structs = <table 1>,
        typedef = 1,
        typedname = "dtrace_bufdata_t",
        vars = {
          add = <function 292>,
          init = <function 293>,
          list = { {
              fpointer = 0,
              name = "*dtbda_handle",
              pointer = 1,
              s = 0,
              t = 0,
              type = "dtrace_hdl_t"
            }, {
              fpointer = 0,
              name = "*dtbda_buffered",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 0,
              name = "*dtbda_probe",
              pointer = 1,
              s = 1,
              t = 0,
              type = "dtrace_probedata_t"
            }, {
              fpointer = 0,
              name = "*dtbda_recdesc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const dtrace_recdesc_t"
            }, {
              fpointer = 0,
              name = "*dtbda_aggdata",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const dtrace_aggdata_t"
            }, {
              fpointer = 0,
              name = "dtbda_flags",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uint32_t"
            } },
          print = <function 294>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "dtrace.h",
        linedef = 387,
        name = "dtrace_setoptdata",
        structs = <table 1>,
        typedef = 1,
        typedname = "dtrace_setoptdata_t",
        vars = {
          add = <function 295>,
          init = <function 296>,
          list = { {
              fpointer = 0,
              name = "*dtsda_handle",
              pointer = 1,
              s = 0,
              t = 0,
              type = "dtrace_hdl_t"
            }, {
              fpointer = 0,
              name = "*dtsda_probe",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const dtrace_probedata_t"
            }, {
              fpointer = 0,
              name = "*dtsda_option",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 0,
              name = "dtsda_oldval",
              pointer = 0,
              s = 0,
              t = 0,
              type = "dtrace_optval_t"
            }, {
              fpointer = 0,
              name = "dtsda_newval",
              pointer = 0,
              s = 0,
              t = 0,
              type = "dtrace_optval_t"
            } },
          print = <function 297>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "dtrace.h",
        linedef = 415,
        name = "dtrace_aggdata",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 298>,
          init = <function 299>,
          list = { {
              fpointer = 0,
              name = "*dtada_handle",
              pointer = 1,
              s = 0,
              t = 0,
              type = "dtrace_hdl_t"
            }, {
              fpointer = 0,
              name = "*dtada_desc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "dtrace_aggdesc_t"
            }, {
              fpointer = 0,
              name = "*dtada_edesc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "dtrace_eprobedesc_t"
            }, {
              fpointer = 0,
              name = "*dtada_pdesc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "dtrace_probedesc_t"
            }, {
              fpointer = 0,
              name = "dtada_data",
              pointer = 0,
              s = 0,
              t = 0,
              type = "caddr_t"
            }, {
              fpointer = 0,
              name = "dtada_normal",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uint64_t"
            }, {
              fpointer = 0,
              name = "dtada_size",
              pointer = 0,
              s = 0,
              t = 0,
              type = "size_t"
            }, {
              fpointer = 0,
              name = "dtada_delta",
              pointer = 0,
              s = 0,
              t = 0,
              type = "caddr_t"
            }, {
              fpointer = 0,
              name = "*dtada_percpu",
              pointer = 1,
              s = 0,
              t = 0,
              type = "caddr_t"
            }, {
              fpointer = 0,
              name = "*dtada_percpu_delta",
              pointer = 1,
              s = 0,
              t = 0,
              type = "caddr_t"
            } },
          print = <function 300>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "dtrace.h",
        linedef = 508,
        name = "dtrace_objinfo",
        structs = <table 1>,
        typedef = 1,
        typedname = "dtrace_objinfo_t",
        vars = {
          add = <function 301>,
          init = <function 302>,
          list = { {
              fpointer = 0,
              name = "*dto_name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 0,
              name = "*dto_file",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 0,
              name = "dto_id",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "dto_flags",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uint_t"
            }, {
              fpointer = 0,
              name = "dto_text_va",
              pointer = 0,
              s = 0,
              t = 0,
              type = "GElf_Addr"
            }, {
              fpointer = 0,
              name = "dto_text_size",
              pointer = 0,
              s = 0,
              t = 0,
              type = "GElf_Xword"
            }, {
              fpointer = 0,
              name = "dto_data_va",
              pointer = 0,
              s = 0,
              t = 0,
              type = "GElf_Addr"
            }, {
              fpointer = 0,
              name = "dto_data_size",
              pointer = 0,
              s = 0,
              t = 0,
              type = "GElf_Xword"
            }, {
              fpointer = 0,
              name = "dto_bss_va",
              pointer = 0,
              s = 0,
              t = 0,
              type = "GElf_Addr"
            }, {
              fpointer = 0,
              name = "dto_bss_size",
              pointer = 0,
              s = 0,
              t = 0,
              type = "GElf_Xword"
            } },
          print = <function 303>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "dtrace.h",
        linedef = 529,
        name = "dtrace_syminfo",
        structs = <table 1>,
        typedef = 1,
        typedname = "dtrace_syminfo_t",
        vars = {
          add = <function 304>,
          init = <function 305>,
          list = { {
              fpointer = 0,
              name = "*dts_object",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 0,
              name = "*dts_name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 0,
              name = "dts_id",
              pointer = 0,
              s = 0,
              t = 0,
              type = "ulong_t"
            } },
          print = <function 306>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "dtrace.h",
        linedef = 550,
        name = "dtrace_typeinfo",
        structs = <table 1>,
        typedef = 1,
        typedname = "dtrace_typeinfo_t",
        vars = {
          add = <function 307>,
          init = <function 308>,
          list = { {
              fpointer = 0,
              name = "*dtt_object",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 0,
              name = "*dtt_ctfp",
              pointer = 1,
              s = 0,
              t = 0,
              type = "ctf_file_t"
            }, {
              fpointer = 0,
              name = "dtt_type",
              pointer = 0,
              s = 0,
              t = 0,
              type = "ctf_id_t"
            } },
          print = <function 309>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "dtrace.h",
        linedef = 575,
        name = "dtrace_probeinfo",
        structs = <table 1>,
        typedef = 1,
        typedname = "dtrace_probeinfo_t",
        vars = {
          add = <function 310>,
          init = <function 311>,
          list = { {
              fpointer = 0,
              name = "dtp_attr",
              pointer = 0,
              s = 0,
              t = 0,
              type = "dtrace_attribute_t"
            }, {
              fpointer = 0,
              name = "dtp_arga",
              pointer = 0,
              s = 0,
              t = 0,
              type = "dtrace_attribute_t"
            }, {
              fpointer = 0,
              name = "*dtp_argv",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const dtrace_typeinfo_t"
            }, {
              fpointer = 0,
              name = "dtp_argc",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 312>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "dtrace.h",
        linedef = 598,
        name = "dtrace_vector",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 313>,
          init = <function 314>,
          list = { {
              fpointer = 1,
              name = "(*dtv_ioctl)(void *, int, void *)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*)",
              pointer = 1,
              s = 1,
              t = 0,
              type = "dtrace_syminfo_t"
            }, {
              fpointer = 1,
              name = "(*dtv_status)(void *, processorid_t)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*dtv_sysconf)(void *, int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "long"
            } },
          print = <function 315>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "disktab.h",
        linedef = 44,
        name = "disktab",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 316>,
          init = <function 317>,
          list = { {
              fpointer = 0,
              name = "*d_name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*d_type",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "d_secsize",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "d_ntracks",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "d_nsectors",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "d_ncylinders",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "d_rpm",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "d_badsectforw",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "d_sectoffset",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "p_size",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "p_bsize",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "p_fsize",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            } },
          print = <function 318>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "disktab.h",
        linedef = 54,
        name = "partition",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 319>,
          init = <function 320>,
          list = { {
              fpointer = 0,
              name = "p_size",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "p_bsize",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "p_fsize",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            } },
          print = <function 321>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ldap.h",
        linedef = 236,
        name = "ldapapiinfo",
        structs = <table 1>,
        typedef = 1,
        typedname = "LDAPAPIInfo",
        vars = {
          add = <function 322>,
          init = <function 323>,
          list = { {
              fpointer = 0,
              name = "ldapai_info_version",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "ldapai_api_version",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "ldapai_protocol_version",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "**ldapai_extensions",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*ldapai_vendor_name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "ldapai_vendor_version",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 324>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ldap.h",
        linedef = 246,
        name = "ldap_apifeature_info",
        structs = <table 1>,
        typedef = 1,
        typedname = "LDAPAPIFeatureInfo",
        vars = {
          add = <function 325>,
          init = <function 326>,
          list = { {
              fpointer = 0,
              name = "ldapaif_info_version",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "ldapaif_version",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 327>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ldap.h",
        linedef = 256,
        name = "ldapcontrol",
        structs = <table 1>,
        typedef = 1,
        typedname = "LDAPControl",
        vars = {
          add = <function 328>,
          init = <function 329>,
          list = { {
              fpointer = 0,
              name = "*\t\t\tldctl_oid",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "ldctl_value",
              pointer = 0,
              s = 1,
              t = 0,
              type = "struct berval"
            }, {
              fpointer = 0,
              name = "ldctl_iscritical",
              pointer = 0,
              s = 0,
              t = 0,
              type = "char"
            } },
          print = <function 330>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ldap.h",
        linedef = 736,
        name = "ldapmod",
        structs = <table 1>,
        typedef = 1,
        typedname = "mod_vals",
        vars = {
          add = <function 331>,
          init = <function 332>,
          list = { {
              fpointer = 0,
              name = "mod_op",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*mod_type",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**modv_strvals",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**modv_bvals",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct berval"
            } },
          print = <function 333>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ldap.h",
        linedef = 781,
        name = "ldap_url_desc",
        structs = <table 1>,
        typedef = 1,
        typedname = "LDAPURLDesc",
        vars = {
          add = <function 334>,
          init = <function 335>,
          list = { {
              fpointer = 0,
              name = "*lud_next",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct ldap_url_desc"
            }, {
              fpointer = 0,
              name = "*lud_scheme",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*lud_host",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "lud_port",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*lud_dn",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**lud_attrs",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "lud_scope",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*lud_filter",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**lud_exts",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "lud_crit_exts",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 336>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ldap.h",
        linedef = 892,
        name = "ldap_sync_t",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 337>,
          init = <function 338>,
          list = { {
              fpointer = 0,
              name = "*ls_base",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "ls_scope",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*ls_filter",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**ls_attrs",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "ls_timelimit",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "ls_sizelimit",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "ls_timeout",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "ls_search_entry",
              pointer = 0,
              s = 0,
              t = 0,
              type = "ldap_sync_search_entry_f"
            }, {
              fpointer = 0,
              name = "ls_search_reference",
              pointer = 0,
              s = 0,
              t = 0,
              type = "ldap_sync_search_reference_f"
            }, {
              fpointer = 0,
              name = "ls_intermediate",
              pointer = 0,
              s = 0,
              t = 0,
              type = "ldap_sync_intermediate_f"
            }, {
              fpointer = 0,
              name = "ls_search_result",
              pointer = 0,
              s = 0,
              t = 0,
              type = "ldap_sync_search_result_f"
            }, {
              fpointer = 0,
              name = "*ls_private",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "*ls_ld",
              pointer = 1,
              s = 0,
              t = 0,
              type = "LDAP"
            }, {
              fpointer = 0,
              name = "ls_msgid",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "ls_reloadHint",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "ls_cookie",
              pointer = 0,
              s = 1,
              t = 0,
              type = "struct berval"
            }, {
              fpointer = 0,
              name = "ls_refreshPhase",
              pointer = 0,
              s = 0,
              t = 0,
              type = "ldap_sync_refresh_t"
            } },
          print = <function 339>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ldap.h",
        linedef = 954,
        name = "ldap_conncb",
        structs = <table 1>,
        typedef = 1,
        typedname = "ldap_conncb",
        vars = {
          add = <function 340>,
          init = <function 341>,
          list = { {
              fpointer = 0,
              name = "*lc_add",
              pointer = 1,
              s = 0,
              t = 0,
              type = "ldap_conn_add_f"
            }, {
              fpointer = 0,
              name = "*lc_del",
              pointer = 1,
              s = 0,
              t = 0,
              type = "ldap_conn_del_f"
            }, {
              fpointer = 0,
              name = "*lc_arg",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            } },
          print = <function 342>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ldap.h",
        linedef = 1658,
        name = "ldap_ava",
        structs = <table 1>,
        typedef = 1,
        typedname = "LDAPAVA",
        vars = {
          add = <function 343>,
          init = <function 344>,
          list = { {
              fpointer = 0,
              name = "la_attr",
              pointer = 0,
              s = 1,
              t = 0,
              type = "struct berval"
            }, {
              fpointer = 0,
              name = "la_value",
              pointer = 0,
              s = 1,
              t = 0,
              type = "struct berval"
            }, {
              fpointer = 0,
              name = "la_flags",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned"
            }, {
              fpointer = 0,
              name = "*la_private",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            } },
          print = <function 345>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ldap.h",
        linedef = 2155,
        name = "ldapsortkey",
        structs = <table 1>,
        typedef = 1,
        typedname = "LDAPSortKey",
        vars = {
          add = <function 346>,
          init = <function 347>,
          list = { {
              fpointer = 0,
              name = "*attributeType",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*orderingRule",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "reverseOrder",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 348>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ldap.h",
        linedef = 2204,
        name = "ldapvlvinfo",
        structs = <table 1>,
        typedef = 1,
        typedname = "LDAPVLVInfo",
        vars = {
          add = <function 349>,
          init = <function 350>,
          list = { {
              fpointer = 0,
              name = "ldvlv_version",
              pointer = 0,
              s = 0,
              t = 0,
              type = "ber_int_t"
            }, {
              fpointer = 0,
              name = "ldvlv_before_count",
              pointer = 0,
              s = 0,
              t = 0,
              type = "ber_int_t"
            }, {
              fpointer = 0,
              name = "ldvlv_after_count",
              pointer = 0,
              s = 0,
              t = 0,
              type = "ber_int_t"
            }, {
              fpointer = 0,
              name = "ldvlv_offset",
              pointer = 0,
              s = 0,
              t = 0,
              type = "ber_int_t"
            }, {
              fpointer = 0,
              name = "ldvlv_count",
              pointer = 0,
              s = 0,
              t = 0,
              type = "ber_int_t"
            }, {
              fpointer = 0,
              name = "*\tldvlv_attrvalue",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct berval"
            }, {
              fpointer = 0,
              name = "*\tldvlv_context",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct berval"
            }, {
              fpointer = 0,
              name = "*\t\t\tldvlv_extradata",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            } },
          print = <function 351>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ldap.h",
        linedef = 2502,
        name = "LDAPDerefSpec",
        structs = <table 1>,
        typedef = 1,
        typedname = "LDAPDerefSpec",
        vars = {
          add = <function 352>,
          init = <function 353>,
          list = { {
              fpointer = 0,
              name = "*derefAttr",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**attributes",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            } },
          print = <function 354>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ldap.h",
        linedef = 2507,
        name = "LDAPDerefVal",
        structs = <table 1>,
        typedef = 1,
        typedname = "LDAPDerefVal",
        vars = {
          add = <function 355>,
          init = <function 356>,
          list = { {
              fpointer = 0,
              name = "*type",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "vals",
              pointer = 0,
              s = 0,
              t = 0,
              type = "BerVarray"
            }, {
              fpointer = 0,
              name = "*next",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct LDAPDerefVal"
            } },
          print = <function 357>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ldap.h",
        linedef = 2513,
        name = "LDAPDerefRes",
        structs = <table 1>,
        typedef = 1,
        typedname = "LDAPDerefRes",
        vars = {
          add = <function 358>,
          init = <function 359>,
          list = { {
              fpointer = 0,
              name = "*derefAttr",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "derefVal",
              pointer = 0,
              s = 1,
              t = 0,
              type = "struct berval"
            }, {
              fpointer = 0,
              name = "*attrVals",
              pointer = 1,
              s = 1,
              t = 0,
              type = "LDAPDerefVal"
            }, {
              fpointer = 0,
              name = "*next",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct LDAPDerefRes"
            } },
          print = <function 360>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ttyent.h",
        linedef = 49,
        name = "ttyent",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 361>,
          init = <function 362>,
          list = { {
              fpointer = 0,
              name = "*ty_name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*ty_getty",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*ty_type",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "ty_status",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*ty_window",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*ty_onerror",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*ty_onoption",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*ty_comment",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            } },
          print = <function 363>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "search.h",
        linedef = 16,
        name = "entry",
        structs = <table 1>,
        typedef = 1,
        typedname = "ENTRY",
        vars = {
          add = <function 364>,
          init = <function 365>,
          list = { {
              fpointer = 0,
              name = "*key",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*data",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            } },
          print = <function 366>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "search.h",
        linedef = 33,
        name = "node",
        structs = <table 1>,
        typedef = 1,
        typedname = "node_t",
        vars = {
          add = <function 367>,
          init = <function 368>,
          list = { {
              fpointer = 0,
              name = "*key",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*llink, *rlink",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct node"
            } },
          print = <function 369>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "search.h",
        linedef = 38,
        name = "que_elem",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 370>,
          init = <function 371>,
          list = { {
              fpointer = 0,
              name = "*next",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct que_elem"
            }, {
              fpointer = 0,
              name = "*prev",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct que_elem"
            } },
          print = <function 372>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "zlib.h",
        linedef = 90,
        name = "z_stream_s",
        structs = <table 1>,
        typedef = 1,
        typedname = "z_stream",
        vars = {
          add = <function 373>,
          init = <function 374>,
          list = { {
              fpointer = 0,
              name = "*next_in",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Bytef"
            }, {
              fpointer = 0,
              name = "avail_in",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uInt"
            }, {
              fpointer = 0,
              name = "total_in",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uLong"
            }, {
              fpointer = 0,
              name = "*next_out",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Bytef"
            }, {
              fpointer = 0,
              name = "avail_out",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uInt"
            }, {
              fpointer = 0,
              name = "total_out",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uLong"
            }, {
              fpointer = 0,
              name = "*msg",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*state",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct internal_state FAR"
            }, {
              fpointer = 0,
              name = "zalloc",
              pointer = 0,
              s = 0,
              t = 0,
              type = "alloc_func"
            }, {
              fpointer = 0,
              name = "zfree",
              pointer = 0,
              s = 0,
              t = 0,
              type = "free_func"
            }, {
              fpointer = 0,
              name = "opaque",
              pointer = 0,
              s = 0,
              t = 0,
              type = "voidpf"
            }, {
              fpointer = 0,
              name = "data_type",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "adler",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uLong"
            }, {
              fpointer = 0,
              name = "reserved",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uLong"
            } },
          print = <function 375>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "zlib.h",
        linedef = 117,
        name = "gz_header_s",
        structs = <table 1>,
        typedef = 1,
        typedname = "gz_header",
        vars = {
          add = <function 376>,
          init = <function 377>,
          list = { {
              fpointer = 0,
              name = "text",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "time",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uLong"
            }, {
              fpointer = 0,
              name = "xflags",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "os",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*extra",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Bytef"
            }, {
              fpointer = 0,
              name = "extra_len",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uInt"
            }, {
              fpointer = 0,
              name = "extra_max",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uInt"
            }, {
              fpointer = 0,
              name = "*name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Bytef"
            }, {
              fpointer = 0,
              name = "name_max",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uInt"
            }, {
              fpointer = 0,
              name = "*comment",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Bytef"
            }, {
              fpointer = 0,
              name = "comm_max",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uInt"
            }, {
              fpointer = 0,
              name = "hcrc",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "done",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 378>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "printerdb.h",
        linedef = 32,
        name = "prdb_property",
        structs = <table 1>,
        typedef = 1,
        typedname = "prdb_property",
        vars = {
          add = <function 379>,
          init = <function 380>,
          list = { {
              fpointer = 0,
              name = "*pp_key",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*pp_value",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            } },
          print = <function 381>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "printerdb.h",
        linedef = 37,
        name = "prdb_ent",
        structs = <table 1>,
        typedef = 1,
        typedname = "prdb_ent",
        vars = {
          add = <function 382>,
          init = <function 383>,
          list = { {
              fpointer = 0,
              name = "**pe_name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "pe_nprops",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned"
            }, {
              fpointer = 0,
              name = "*pe_prop",
              pointer = 1,
              s = 1,
              t = 0,
              type = "prdb_property"
            } },
          print = <function 384>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "utmp.h",
        linedef = 86,
        name = "lastlog",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 385>,
          init = <function 386>,
          list = { {
              fpointer = 0,
              name = "ll_time",
              pointer = 0,
              s = 0,
              t = 0,
              type = "time_t"
            }, {
              fpointer = 0,
              name = "ll_line[UT_LINESIZE]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "ll_host[UT_HOSTSIZE]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            } },
          print = <function 387>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "utmp.h",
        linedef = 92,
        name = "utmp",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 388>,
          init = <function 389>,
          list = { {
              fpointer = 0,
              name = "ut_line[UT_LINESIZE]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "ut_name[UT_NAMESIZE]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "ut_host[UT_HOSTSIZE]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "ut_time",
              pointer = 0,
              s = 0,
              t = 0,
              type = "long"
            } },
          print = <function 390>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "utmpx.h",
        linedef = 118,
        name = "utmpx",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 391>,
          init = <function 392>,
          list = { {
              fpointer = 0,
              name = "ut_user[_UTX_USERSIZE]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "ut_id[_UTX_IDSIZE]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "ut_line[_UTX_LINESIZE]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "ut_pid",
              pointer = 0,
              s = 0,
              t = 0,
              type = "pid_t"
            }, {
              fpointer = 0,
              name = "ut_type",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "ut_tv",
              pointer = 0,
              s = 1,
              t = 0,
              type = "struct timeval"
            }, {
              fpointer = 0,
              name = "ut_host[_UTX_HOSTSIZE]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "ut_pad[16]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "__uint32_t"
            } },
          print = <function 393>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "utmpx.h",
        linedef = 130,
        name = "lastlogx",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 394>,
          init = <function 395>,
          list = { {
              fpointer = 0,
              name = "ll_tv",
              pointer = 0,
              s = 1,
              t = 0,
              type = "struct timeval"
            }, {
              fpointer = 0,
              name = "ll_line[_UTX_LINESIZE]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "ll_host[_UTX_HOSTSIZE]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            } },
          print = <function 396>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "Xplugin.h",
        linedef = 102,
        name = "xp_box_struct",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 397>,
          init = <function 398>,
          list = { {
              fpointer = 0,
              name = "x1, y1, x2, y2",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            } },
          print = <function 399>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "Xplugin.h",
        linedef = 186,
        name = "xp_async_error_event_struct",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 400>,
          init = <function 401>,
          list = { {
              fpointer = 0,
              name = "request_type",
              pointer = 0,
              s = 0,
              t = 0,
              type = "xp_request_type"
            }, {
              fpointer = 0,
              name = "id",
              pointer = 0,
              s = 0,
              t = 0,
              type = "xp_resource_id"
            }, {
              fpointer = 0,
              name = "error",
              pointer = 0,
              s = 0,
              t = 0,
              type = "xp_error"
            } },
          print = <function 402>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "Xplugin.h",
        linedef = 207,
        name = "xp_window_state_event_struct",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 403>,
          init = <function 404>,
          list = { {
              fpointer = 0,
              name = "id",
              pointer = 0,
              s = 0,
              t = 0,
              type = "xp_window_id"
            }, {
              fpointer = 0,
              name = "state",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned int"
            } },
          print = <function 405>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "Xplugin.h",
        linedef = 241,
        name = "xp_window_changes_struct",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 406>,
          init = <function 407>,
          list = { {
              fpointer = 0,
              name = "x, y",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "width, height",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned int"
            }, {
              fpointer = 0,
              name = "bit_gravity",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "shape_nrects",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*shape_rects",
              pointer = 1,
              s = 0,
              t = 0,
              type = "xp_box"
            }, {
              fpointer = 0,
              name = "shape_tx, shape_ty",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "stack_mode",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "sibling",
              pointer = 0,
              s = 0,
              t = 0,
              type = "xp_window_id"
            }, {
              fpointer = 0,
              name = "depth",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned int"
            }, {
              fpointer = 0,
              name = "*colormap",
              pointer = 1,
              s = 0,
              t = 0,
              type = "xp_colormap_fun"
            }, {
              fpointer = 0,
              name = "*colormap_data",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "window_level",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "transient_for",
              pointer = 0,
              s = 0,
              t = 0,
              type = "xp_window_id"
            } },
          print = <function 408>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "unwind.h",
        linedef = 65,
        name = "_Unwind_Exception",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 409>,
          init = <function 410>,
          list = { {
              fpointer = 0,
              name = "exception_class",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uint64_t"
            }, {
              fpointer = 1,
              name = "(*exception_cleanup)(_Unwind_Reason_Code reason, struct _Unwind_Exception* exc)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "private_1",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uintptr_t"
            }, {
              fpointer = 0,
              name = "private_2",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uintptr_t"
            }, {
              fpointer = 0,
              name = "reserved[3]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "uint32_t"
            } },
          print = <function 411>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "unwind.h",
        linedef = 189,
        name = "dwarf_eh_bases",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 412>,
          init = <function 413>,
          list = { {
              fpointer = 0,
              name = "tbase",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uintptr_t"
            }, {
              fpointer = 0,
              name = "dbase",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uintptr_t"
            }, {
              fpointer = 0,
              name = "func",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uintptr_t"
            } },
          print = <function 414>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "slapi-plugin.h",
        linedef = 890,
        name = "slapi_plugindesc",
        structs = <table 1>,
        typedef = 1,
        typedname = "Slapi_PluginDesc",
        vars = {
          add = <function 415>,
          init = <function 416>,
          list = { {
              fpointer = 0,
              name = "*spd_id",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*spd_vendor",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*spd_version",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*spd_description",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            } },
          print = <function 417>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ldif.h",
        linedef = 94,
        name = "LDIFFP",
        structs = <table 1>,
        typedef = 1,
        typedname = "LDIFFP",
        vars = {
          add = <function 418>,
          init = <function 419>,
          list = { {
              fpointer = 0,
              name = "*fp",
              pointer = 1,
              s = 1,
              t = 0,
              type = "FILE"
            }, {
              fpointer = 0,
              name = "*prev",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct LDIFFP"
            } },
          print = <function 420>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tzfile.h",
        linedef = 54,
        name = "tzhead",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 421>,
          init = <function 422>,
          list = { {
              fpointer = 0,
              name = "tzh_magic[4]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "tzh_reserved[16]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "tzh_ttisgmtcnt[4]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "tzh_ttisstdcnt[4]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "tzh_leapcnt[4]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "tzh_timecnt[4]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "tzh_typecnt[4]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "tzh_charcnt[4]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            } },
          print = <function 423>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tkPlatDecls.h",
        linedef = 132,
        name = "TkPlatStubs",
        structs = <table 1>,
        typedef = 1,
        typedname = "TkPlatStubs",
        vars = {
          add = <function 424>,
          init = <function 425>,
          list = { {
              fpointer = 0,
              name = "magic",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*hooks",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct TkPlatStubHooks"
            }, {
              fpointer = 1,
              name = "(*tk_AttachHWND) (Tk_Window tkwin, HWND hwnd)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Window"
            }, {
              fpointer = 1,
              name = "(*tk_GetHINSTANCE) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "HINSTANCE"
            }, {
              fpointer = 1,
              name = "(*tk_GetHWND) (Window window)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "HWND"
            }, {
              fpointer = 1,
              name = "(*tk_HWNDToWindow) (HWND hwnd)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_Window"
            }, {
              fpointer = 1,
              name = "(*tk_PointerEvent) (HWND hwnd, int x, int y)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_TranslateWinEvent) (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam, LRESULT *result)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_MacOSXSetEmbedHandler) (Tk_MacOSXEmbedRegisterWinProc *registerWinProcPtr, Tk_MacOSXEmbedGetGrafPortProc *getPortProcPtr, Tk_MacOSXEmbedMakeContainerExistProc *containerExistProcPtr, Tk_MacOSXEmbedGetClipProc *getClipProc, Tk_MacOSXEmbedGetOffsetInParentProc *getOffsetProc)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_MacOSXTurnOffMenus) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_MacOSXTkOwnsCursor) (int tkOwnsIt)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tkMacOSXInitMenus) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tkMacOSXInitAppleEvents) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tkGenWMConfigureEvent) (Tk_Window tkwin, int x, int y, int width, int height, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tkMacOSXInvalClipRgns) (Tk_Window tkwin)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*tkMacOSXGetDrawablePort) (Drawable drawable)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*tkMacOSXGetRootControl) (Drawable drawable)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_MacOSXSetupTkNotifier) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_MacOSXIsAppInFront) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 426>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "nlist.h",
        linedef = 48,
        name = "nlist",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 427>,
          init = <function 428>,
          list = { {
              fpointer = 0,
              name = "*n_name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "n_strx",
              pointer = 0,
              s = 0,
              t = 0,
              type = "long"
            } },
          print = <function 429>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "nl_types.h",
        linedef = 64,
        name = "_nls_cat_hdr",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 430>,
          init = <function 431>,
          list = { {
              fpointer = 0,
              name = "__magic",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int32_t"
            }, {
              fpointer = 0,
              name = "__nsets",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int32_t"
            }, {
              fpointer = 0,
              name = "__mem",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int32_t"
            }, {
              fpointer = 0,
              name = "__msg_hdr_offset",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int32_t"
            }, {
              fpointer = 0,
              name = "__msg_txt_offset",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int32_t"
            } },
          print = <function 432>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "nl_types.h",
        linedef = 72,
        name = "_nls_set_hdr",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 433>,
          init = <function 434>,
          list = { {
              fpointer = 0,
              name = "__setno",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int32_t"
            }, {
              fpointer = 0,
              name = "__nmsgs",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int32_t"
            }, {
              fpointer = 0,
              name = "__index",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int32_t"
            } },
          print = <function 435>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "nl_types.h",
        linedef = 78,
        name = "_nls_msg_hdr",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 436>,
          init = <function 437>,
          list = { {
              fpointer = 0,
              name = "__msgno",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int32_t"
            }, {
              fpointer = 0,
              name = "__msglen",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int32_t"
            }, {
              fpointer = 0,
              name = "__offset",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int32_t"
            } },
          print = <function 438>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "nl_types.h",
        linedef = 89,
        name = "__nl_cat_d",
        structs = <table 1>,
        typedef = 1,
        vars = {
          add = <function 439>,
          init = <function 440>,
          list = { {
              fpointer = 0,
              name = "*__data",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "__size",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 441>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "panel.h",
        linedef = 43,
        name = "panel",
        structs = <table 1>,
        typedef = 1,
        typedname = "PANEL",
        vars = {
          add = <function 442>,
          init = <function 443>,
          list = { {
              fpointer = 0,
              name = "*win",
              pointer = 1,
              s = 0,
              t = 0,
              type = "WINDOW"
            }, {
              fpointer = 0,
              name = "*below",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct panel"
            }, {
              fpointer = 0,
              name = "*above",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct panel"
            }, {
              fpointer = 0,
              name = "*user",
              pointer = 1,
              s = 0,
              t = 0,
              type = "NCURSES_CONST void"
            } },
          print = <function 444>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tk.h",
        linedef = 158,
        name = "Tk_OptionSpec",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tk_OptionSpec",
        vars = {
          add = <function 445>,
          init = <function 446>,
          list = { {
              fpointer = 0,
              name = "type",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Tk_OptionType"
            }, {
              fpointer = 0,
              name = "*optionName",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 0,
              name = "*dbName",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 0,
              name = "*dbClass",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 0,
              name = "*defValue",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 0,
              name = "objOffset",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "internalOffset",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "flags",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "clientData",
              pointer = 0,
              s = 0,
              t = 0,
              type = "ClientData"
            }, {
              fpointer = 0,
              name = "typeMask",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "* manager",
              pointer = 1,
              s = 0,
              t = 0,
              type = ""
            } },
          print = <function 447>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tk.h",
        linedef = 221,
        name = "Tk_ObjCustomOption",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tk_ObjCustomOption",
        vars = {
          add = <function 448>,
          init = <function 449>,
          list = { {
              fpointer = 0,
              name = "*name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 0,
              name = "*setProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_CustomOptionSetProc"
            }, {
              fpointer = 0,
              name = "*getProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_CustomOptionGetProc"
            }, {
              fpointer = 0,
              name = "*restoreProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_CustomOptionRestoreProc"
            }, {
              fpointer = 0,
              name = "*freeProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_CustomOptionFreeProc"
            }, {
              fpointer = 0,
              name = "clientData",
              pointer = 0,
              s = 0,
              t = 0,
              type = "ClientData"
            } },
          print = <function 450>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tk.h",
        linedef = 260,
        name = "Tk_SavedOption",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tk_SavedOption",
        vars = {
          add = <function 451>,
          init = <function 452>,
          list = { {
              fpointer = 0,
              name = "*optionPtr",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct TkOption"
            }, {
              fpointer = 0,
              name = "*valuePtr",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 0,
              name = "* a Tcl object",
              pointer = 1,
              s = 0,
              t = 0,
              type = ""
            }, {
              fpointer = 0,
              name = "internalForm",
              pointer = 0,
              s = 0,
              t = 0,
              type = "double"
            }, {
              fpointer = 0,
              name = "* double, a long, or a pointer",
              pointer = 1,
              s = 0,
              t = 0,
              type = ""
            } },
          print = <function 453>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tk.h",
        linedef = 284,
        name = "Tk_SavedOptions",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tk_SavedOptions",
        vars = {
          add = <function 454>,
          init = <function 455>,
          list = { {
              fpointer = 0,
              name = "*recordPtr",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "tkwin",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Tk_Window"
            }, {
              fpointer = 0,
              name = "numItems",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "items[TK_NUM_SAVED_OPTIONS]",
              pointer = 0,
              s = 1,
              t = 1,
              type = "Tk_SavedOption"
            }, {
              fpointer = 0,
              name = "*nextPtr",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct Tk_SavedOptions"
            }, {
              fpointer = 0,
              name = "/* Points to next structure in list",
              pointer = 1,
              s = 0,
              t = 0,
              type = ""
            } },
          print = <function 456>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tk.h",
        linedef = 320,
        name = "Tk_CustomOption",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tk_CustomOption",
        vars = {
          add = <function 457>,
          init = <function 458>,
          list = { {
              fpointer = 0,
              name = "*parseProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_OptionParseProc"
            }, {
              fpointer = 0,
              name = "*printProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_OptionPrintProc"
            }, {
              fpointer = 0,
              name = "clientData",
              pointer = 0,
              s = 0,
              t = 0,
              type = "ClientData"
            } },
          print = <function 459>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tk.h",
        linedef = 339,
        name = "Tk_ConfigSpec",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tk_ConfigSpec",
        vars = {
          add = <function 460>,
          init = <function 461>,
          list = { {
              fpointer = 0,
              name = "type",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*argvName",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "dbName",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Tk_Uid"
            }, {
              fpointer = 0,
              name = "dbClass",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Tk_Uid"
            }, {
              fpointer = 0,
              name = "defValue",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Tk_Uid"
            }, {
              fpointer = 0,
              name = "offset",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "specFlags",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "* below",
              pointer = 1,
              s = 0,
              t = 0,
              type = ""
            }, {
              fpointer = 0,
              name = "*customPtr",
              pointer = 1,
              s = 1,
              t = 0,
              type = "Tk_CustomOption"
            } },
          print = <function 462>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tk.h",
        linedef = 513,
        name = "Tk_FontMetrics",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tk_FontMetrics",
        vars = {
          add = <function 463>,
          init = <function 464>,
          list = { {
              fpointer = 0,
              name = "ascent",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "descent",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "linespace",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 465>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tk.h",
        linedef = 555,
        name = "Tk_ClassProcs",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tk_ClassProcs",
        vars = {
          add = <function 466>,
          init = <function 467>,
          list = { {
              fpointer = 0,
              name = "size",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned int"
            }, {
              fpointer = 0,
              name = "*worldChangedProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ClassWorldChangedProc"
            }, {
              fpointer = 0,
              name = "*createProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ClassCreateProc"
            }, {
              fpointer = 0,
              name = "*modalProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ClassModalProc"
            } },
          print = <function 468>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tk.h",
        linedef = 599,
        name = "Tk_GeomMgr",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tk_GeomMgr",
        vars = {
          add = <function 469>,
          init = <function 470>,
          list = { {
              fpointer = 0,
              name = "*name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 0,
              name = "*requestProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_GeomRequestProc"
            }, {
              fpointer = 0,
              name = "*lostSlaveProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_GeomLostSlaveProc"
            } },
          print = <function 471>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tk.h",
        linedef = 755,
        name = "Tk_FakeWin",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tk_FakeWin",
        vars = {
          add = <function 472>,
          init = <function 473>,
          list = { {
              fpointer = 0,
              name = "*display",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Display"
            }, {
              fpointer = 0,
              name = "*dummy1",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "screenNum",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*visual",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Visual"
            }, {
              fpointer = 0,
              name = "depth",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "window",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Window"
            }, {
              fpointer = 0,
              name = "*dummy2",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*dummy3",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "parentPtr",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Tk_Window"
            }, {
              fpointer = 0,
              name = "*dummy4",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*dummy5",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*pathName",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "nameUid",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Tk_Uid"
            }, {
              fpointer = 0,
              name = "classUid",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Tk_Uid"
            }, {
              fpointer = 0,
              name = "changes",
              pointer = 0,
              s = 0,
              t = 0,
              type = "XWindowChanges"
            }, {
              fpointer = 0,
              name = "dummy6",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned int"
            }, {
              fpointer = 0,
              name = "atts",
              pointer = 0,
              s = 0,
              t = 0,
              type = "XSetWindowAttributes"
            }, {
              fpointer = 0,
              name = "dummy7",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned long"
            }, {
              fpointer = 0,
              name = "flags",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned int"
            }, {
              fpointer = 0,
              name = "*dummy8",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "dummy9",
              pointer = 0,
              s = 0,
              t = 0,
              type = "XIC"
            }, {
              fpointer = 0,
              name = "*dummy10",
              pointer = 1,
              s = 0,
              t = 0,
              type = "ClientData"
            }, {
              fpointer = 0,
              name = "dummy11",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "dummy12",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*dummy13",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*dummy14",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "dummy15",
              pointer = 0,
              s = 0,
              t = 0,
              type = "ClientData"
            }, {
              fpointer = 0,
              name = "reqWidth, reqHeight",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "internalBorderLeft",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*dummy16",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*dummy17",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "dummy18",
              pointer = 0,
              s = 0,
              t = 0,
              type = "ClientData"
            }, {
              fpointer = 0,
              name = "*dummy19",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "internalBorderRight",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "internalBorderTop",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "internalBorderBottom",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "minReqWidth",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "minReqHeight",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 474>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tk.h",
        linedef = 900,
        name = "Tk_SmoothMethod",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tk_SmoothMethod",
        vars = {
          add = <function 475>,
          init = <function 476>,
          list = { {
              fpointer = 0,
              name = "*name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "xPoints[], double dblPoints[]))",
              pointer = 0,
              s = 0,
              t = 1,
              type = "XPoint"
            }, {
              fpointer = 0,
              name = "numPoints, int numSteps))",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 477>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tk.h",
        linedef = 918,
        name = "Tk_Item",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tk_Item",
        vars = {
          add = <function 478>,
          init = <function 479>,
          list = { {
              fpointer = 0,
              name = "id",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*nextPtr",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct Tk_Item"
            }, {
              fpointer = 0,
              name = "staticTagSpace[TK_TAG_SPACE]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "Tk_Uid"
            }, {
              fpointer = 0,
              name = "*tagPtr",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_Uid"
            }, {
              fpointer = 0,
              name = "tagSpace",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "numTags",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*typePtr",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct Tk_ItemType"
            }, {
              fpointer = 0,
              name = "x1, y1, x2, y2",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*prevPtr",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct Tk_Item"
            }, {
              fpointer = 0,
              name = "state",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Tk_State"
            }, {
              fpointer = 0,
              name = "*reserved1",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "redraw_flags",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "* Starting here is additional type-specific stuff",
              pointer = 1,
              s = 0,
              t = 0,
              type = ""
            } },
          print = <function 480>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tk.h",
        linedef = 1027,
        name = "Tk_ItemType",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tk_ItemType",
        vars = {
          add = <function 481>,
          init = <function 482>,
          list = { {
              fpointer = 0,
              name = "*name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "itemSize",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*createProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ItemCreateProc"
            }, {
              fpointer = 0,
              name = "*configSpecs",
              pointer = 1,
              s = 1,
              t = 0,
              type = "Tk_ConfigSpec"
            }, {
              fpointer = 0,
              name = "*configProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ItemConfigureProc"
            }, {
              fpointer = 0,
              name = "*coordProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ItemCoordProc"
            }, {
              fpointer = 0,
              name = "*deleteProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ItemDeleteProc"
            }, {
              fpointer = 0,
              name = "*displayProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ItemDisplayProc"
            }, {
              fpointer = 0,
              name = "alwaysRedraw",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*pointProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ItemPointProc"
            }, {
              fpointer = 0,
              name = "*areaProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ItemAreaProc"
            }, {
              fpointer = 0,
              name = "*postscriptProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ItemPostscriptProc"
            }, {
              fpointer = 0,
              name = "*scaleProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ItemScaleProc"
            }, {
              fpointer = 0,
              name = "*translateProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ItemTranslateProc"
            }, {
              fpointer = 0,
              name = "*indexProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ItemIndexProc"
            }, {
              fpointer = 0,
              name = "*icursorProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ItemCursorProc"
            }, {
              fpointer = 0,
              name = "*selectionProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ItemSelectionProc"
            }, {
              fpointer = 0,
              name = "*insertProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ItemInsertProc"
            }, {
              fpointer = 0,
              name = "*dCharsProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ItemDCharsProc"
            }, {
              fpointer = 0,
              name = "*nextPtr",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct Tk_ItemType"
            }, {
              fpointer = 0,
              name = "*reserved1",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "reserved2",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*reserved3",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*reserved4",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            } },
          print = <function 483>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tk.h",
        linedef = 1094,
        name = "Tk_CanvasTextInfo",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tk_CanvasTextInfo",
        vars = {
          add = <function 484>,
          init = <function 485>,
          list = { {
              fpointer = 0,
              name = "selBorder",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Tk_3DBorder"
            }, {
              fpointer = 0,
              name = "selBorderWidth",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*selFgColorPtr",
              pointer = 1,
              s = 0,
              t = 0,
              type = "XColor"
            }, {
              fpointer = 0,
              name = "*selItemPtr",
              pointer = 1,
              s = 1,
              t = 0,
              type = "Tk_Item"
            }, {
              fpointer = 0,
              name = "selectFirst",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "selectLast",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*anchorItemPtr",
              pointer = 1,
              s = 1,
              t = 0,
              type = "Tk_Item"
            }, {
              fpointer = 0,
              name = "selectAnchor",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "insertBorder",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Tk_3DBorder"
            }, {
              fpointer = 0,
              name = "insertWidth",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "insertBorderWidth",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*focusItemPtr",
              pointer = 1,
              s = 1,
              t = 0,
              type = "Tk_Item"
            }, {
              fpointer = 0,
              name = "gotFocus",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "cursorOn",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 486>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tk.h",
        linedef = 1134,
        name = "Tk_Dash",
        structs = <table 1>,
        typedef = 1,
        typedname = "pattern",
        vars = {
          add = <function 487>,
          init = <function 488>,
          list = { {
              fpointer = 0,
              name = "number",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*pt",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "array[sizeof(char *)]",
              pointer = 1,
              s = 0,
              t = 1,
              type = "char"
            } },
          print = <function 489>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tk.h",
        linedef = 1142,
        name = "Tk_TSOffset",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tk_TSOffset",
        vars = {
          add = <function 490>,
          init = <function 491>,
          list = { {
              fpointer = 0,
              name = "flags",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "xoffset",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "yoffset",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 492>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tk.h",
        linedef = 1161,
        name = "Tk_Outline",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tk_Outline",
        vars = {
          add = <function 493>,
          init = <function 494>,
          list = { {
              fpointer = 0,
              name = "gc",
              pointer = 0,
              s = 0,
              t = 0,
              type = "GC"
            }, {
              fpointer = 0,
              name = "width",
              pointer = 0,
              s = 0,
              t = 0,
              type = "double"
            }, {
              fpointer = 0,
              name = "activeWidth",
              pointer = 0,
              s = 0,
              t = 0,
              type = "double"
            }, {
              fpointer = 0,
              name = "disabledWidth",
              pointer = 0,
              s = 0,
              t = 0,
              type = "double"
            }, {
              fpointer = 0,
              name = "offset",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "dash",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Tk_Dash"
            }, {
              fpointer = 0,
              name = "activeDash",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Tk_Dash"
            }, {
              fpointer = 0,
              name = "disabledDash",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Tk_Dash"
            }, {
              fpointer = 0,
              name = "*reserved1",
              pointer = 1,
              s = 0,
              t = 0,
              type = "VOID"
            }, {
              fpointer = 0,
              name = "*reserved2",
              pointer = 1,
              s = 0,
              t = 0,
              type = "VOID"
            }, {
              fpointer = 0,
              name = "*reserved3",
              pointer = 1,
              s = 0,
              t = 0,
              type = "VOID"
            }, {
              fpointer = 0,
              name = "tsoffset",
              pointer = 0,
              s = 1,
              t = 0,
              type = "Tk_TSOffset"
            }, {
              fpointer = 0,
              name = "*color",
              pointer = 1,
              s = 0,
              t = 0,
              type = "XColor"
            }, {
              fpointer = 0,
              name = "*activeColor",
              pointer = 1,
              s = 0,
              t = 0,
              type = "XColor"
            }, {
              fpointer = 0,
              name = "*disabledColor",
              pointer = 1,
              s = 0,
              t = 0,
              type = "XColor"
            }, {
              fpointer = 0,
              name = "stipple",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Pixmap"
            }, {
              fpointer = 0,
              name = "activeStipple",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Pixmap"
            }, {
              fpointer = 0,
              name = "disabledStipple",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Pixmap"
            } },
          print = <function 495>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tk.h",
        linedef = 1225,
        name = "Tk_ImageType",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 496>,
          init = <function 497>,
          list = { {
              fpointer = 0,
              name = "*name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*createProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ImageCreateProc"
            }, {
              fpointer = 0,
              name = "*getProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ImageGetProc"
            }, {
              fpointer = 0,
              name = "*displayProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ImageDisplayProc"
            }, {
              fpointer = 0,
              name = "*freeProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ImageFreeProc"
            }, {
              fpointer = 0,
              name = "*deleteProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ImageDeleteProc"
            }, {
              fpointer = 0,
              name = "*postscriptProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ImagePostscriptProc"
            }, {
              fpointer = 0,
              name = "*nextPtr",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct Tk_ImageType"
            }, {
              fpointer = 0,
              name = "*reserved",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            } },
          print = <function 498>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tk.h",
        linedef = 1272,
        name = "Tk_PhotoImageBlock",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tk_PhotoImageBlock",
        vars = {
          add = <function 499>,
          init = <function 500>,
          list = { {
              fpointer = 0,
              name = "*pixelPtr",
              pointer = 1,
              s = 0,
              t = 0,
              type = "unsigned char"
            }, {
              fpointer = 0,
              name = "width",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "height",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "pitch",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "pixelSize",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "offset[4]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "int"
            } },
          print = <function 501>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tk.h",
        linedef = 1342,
        name = "Tk_PhotoImageFormat",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 502>,
          init = <function 503>,
          list = { {
              fpointer = 0,
              name = "*name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*fileMatchProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ImageFileMatchProc"
            }, {
              fpointer = 0,
              name = "*stringMatchProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ImageStringMatchProc"
            }, {
              fpointer = 0,
              name = "*fileReadProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ImageFileReadProc"
            }, {
              fpointer = 0,
              name = "*stringReadProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ImageStringReadProc"
            }, {
              fpointer = 0,
              name = "*fileWriteProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ImageFileWriteProc"
            }, {
              fpointer = 0,
              name = "*stringWriteProc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ImageStringWriteProc"
            }, {
              fpointer = 0,
              name = "*nextPtr",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct Tk_PhotoImageFormat"
            } },
          print = <function 504>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tk.h",
        linedef = 1407,
        name = "Tk_ElementOptionSpec",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tk_ElementOptionSpec",
        vars = {
          add = <function 505>,
          init = <function 506>,
          list = { {
              fpointer = 0,
              name = "*name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "type",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Tk_OptionType"
            } },
          print = <function 507>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tk.h",
        linedef = 1413,
        name = "Tk_ElementSpec",
        structs = <table 1>,
        typedef = 1,
        typedname = "Tk_ElementSpec",
        vars = {
          add = <function 508>,
          init = <function 509>,
          list = { {
              fpointer = 0,
              name = "version",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*options",
              pointer = 1,
              s = 1,
              t = 0,
              type = "Tk_ElementOptionSpec"
            }, {
              fpointer = 0,
              name = "*getSize",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_GetElementSizeProc"
            }, {
              fpointer = 0,
              name = "*getBox",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_GetElementBoxProc"
            }, {
              fpointer = 0,
              name = "*getBorderWidth",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_GetElementBorderWidthProc"
            }, {
              fpointer = 0,
              name = "*draw",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_DrawElementProc"
            } },
          print = <function 510>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tic.h",
        linedef = 157,
        name = "token",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 511>,
          init = <function 512>,
          list = { {
              fpointer = 0,
              name = "*tk_name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "tk_valnumber",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*tk_valstring",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            } },
          print = <function 513>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tic.h",
        linedef = 170,
        name = "tinfo_fkeys",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 514>,
          init = <function 515>,
          list = { {
              fpointer = 0,
              name = "offset",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned"
            }, {
              fpointer = 0,
              name = "code",
              pointer = 0,
              s = 0,
              t = 0,
              type = "chtype"
            } },
          print = <function 516>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tic.h",
        linedef = 192,
        name = "name_table_entry",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 517>,
          init = <function 518>,
          list = { {
              fpointer = 0,
              name = "*nte_name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 0,
              name = "nte_type",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "nte_index",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "nte_link",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            } },
          print = <function 519>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tic.h",
        linedef = 200,
        name = "alias",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 520>,
          init = <function 521>,
          list = { {
              fpointer = 0,
              name = "*from",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 0,
              name = "*to",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 0,
              name = "*source",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            } },
          print = <function 522>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tclTomMathDecls.h",
        linedef = 455,
        name = "TclTomMathStubs",
        structs = <table 1>,
        typedef = 1,
        typedname = "TclTomMathStubs",
        vars = {
          add = <function 523>,
          init = <function 524>,
          list = { {
              fpointer = 0,
              name = "magic",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*hooks",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct TclTomMathStubHooks"
            }, {
              fpointer = 1,
              name = "(*tclBN_epoch) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_revision) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_add) (mp_int *a, mp_int *b, mp_int *c)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_add_d) (mp_int *a, mp_digit b, mp_int *c)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_and) (mp_int *a, mp_int *b, mp_int *c)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_clamp) (mp_int *a)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_clear) (mp_int *a)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_clear_multi) (mp_int *a, ...)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_cmp) (mp_int *a, mp_int *b)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_cmp_d) (mp_int *a, mp_digit b)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_cmp_mag) (mp_int *a, mp_int *b)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_copy) (mp_int *a, mp_int *b)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_count_bits) (mp_int *a)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_div) (mp_int *a, mp_int *b, mp_int *q, mp_int *r)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_div_d) (mp_int *a, mp_digit b, mp_int *q, mp_digit *r)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_div_2) (mp_int *a, mp_int *q)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_div_2d) (mp_int *a, int b, mp_int *q, mp_int *r)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_div_3) (mp_int *a, mp_int *q, mp_digit *r)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_exch) (mp_int *a, mp_int *b)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_expt_d) (mp_int *a, mp_digit b, mp_int *c)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_grow) (mp_int *a, int size)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_init) (mp_int *a)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_init_copy) (mp_int *a, mp_int *b)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_init_multi) (mp_int *a, ...)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_init_set) (mp_int *a, mp_digit b)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_init_size) (mp_int *a, int size)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_lshd) (mp_int *a, int shift)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_mod) (mp_int *a, mp_int *b, mp_int *r)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_mod_2d) (mp_int *a, int b, mp_int *r)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_mul) (mp_int *a, mp_int *b, mp_int *p)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_mul_d) (mp_int *a, mp_digit b, mp_int *p)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_mul_2) (mp_int *a, mp_int *p)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_mul_2d) (mp_int *a, int d, mp_int *p)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_neg) (mp_int *a, mp_int *b)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_or) (mp_int *a, mp_int *b, mp_int *c)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_radix_size) (mp_int *a, int radix, int *size)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_read_radix) (mp_int *a, const char *str, int radix)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_rshd) (mp_int *a, int shift)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_shrink) (mp_int *a)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_set) (mp_int *a, mp_digit b)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_sqr) (mp_int *a, mp_int *b)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_sqrt) (mp_int *a, mp_int *b)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_sub) (mp_int *a, mp_int *b, mp_int *c)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_sub_d) (mp_int *a, mp_digit b, mp_int *c)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_to_unsigned_bin) (mp_int *a, unsigned char *b)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_to_unsigned_bin_n) (mp_int *a, unsigned char *b, unsigned long *outlen)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_toradix_n) (mp_int *a, char *str, int radix, int maxlen)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_unsigned_bin_size) (mp_int *a)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_xor) (mp_int *a, mp_int *b, mp_int *c)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_zero) (mp_int *a)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tclBN_reverse) (unsigned char *s, int len)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tclBN_fast_s_mp_mul_digs) (mp_int *a, mp_int *b, mp_int *c, int digs)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_fast_s_mp_sqr) (mp_int *a, mp_int *b)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_karatsuba_mul) (mp_int *a, mp_int *b, mp_int *c)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_karatsuba_sqr) (mp_int *a, mp_int *b)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_toom_mul) (mp_int *a, mp_int *b, mp_int *c)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_mp_toom_sqr) (mp_int *a, mp_int *b)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_s_mp_add) (mp_int *a, mp_int *b, mp_int *c)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_s_mp_mul_digs) (mp_int *a, mp_int *b, mp_int *c, int digs)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_s_mp_sqr) (mp_int *a, mp_int *b)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tclBN_s_mp_sub) (mp_int *a, mp_int *b, mp_int *c)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 525>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tclPlatDecls.h",
        linedef = 77,
        name = "TclPlatStubs",
        structs = <table 1>,
        typedef = 1,
        typedname = "TclPlatStubs",
        vars = {
          add = <function 526>,
          init = <function 527>,
          list = { {
              fpointer = 0,
              name = "magic",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*hooks",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct TclPlatStubHooks"
            }, {
              fpointer = 1,
              name = "* (*tcl_WinUtfToTChar) (CONST char *str, int len, Tcl_DString *dsPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "TCHAR"
            }, {
              fpointer = 1,
              name = "* (*tcl_WinTCharToUtf) (CONST TCHAR *str, int len, Tcl_DString *dsPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "(*tcl_MacOSXOpenBundleResources) (Tcl_Interp *interp, CONST char *bundleName, int hasResourceFile, int maxPathLen, char *libraryPath)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tcl_MacOSXOpenVersionedBundleResources) (Tcl_Interp *interp, CONST char *bundleName, CONST char *bundleVersion, int hasResourceFile, int maxPathLen, char *libraryPath)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 528>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tkDecls.h",
        linedef = 1680,
        name = "TkStubHooks",
        structs = <table 1>,
        typedef = 1,
        typedname = "TkStubHooks",
        vars = {
          add = <function 529>,
          init = <function 530>,
          list = { {
              fpointer = 0,
              name = "*tkPlatStubs",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct TkPlatStubs"
            }, {
              fpointer = 0,
              name = "*tkIntStubs",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct TkIntStubs"
            }, {
              fpointer = 0,
              name = "*tkIntPlatStubs",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct TkIntPlatStubs"
            }, {
              fpointer = 0,
              name = "*tkIntXlibStubs",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct TkIntXlibStubs"
            } },
          print = <function 531>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tkDecls.h",
        linedef = 1687,
        name = "TkStubs",
        structs = <table 1>,
        typedef = 1,
        typedname = "TkStubs",
        vars = {
          add = <function 532>,
          init = <function 533>,
          list = { {
              fpointer = 0,
              name = "magic",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*hooks",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct TkStubHooks"
            }, {
              fpointer = 1,
              name = "(*tk_MainLoop) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*tk_3DBorderColor) (Tk_3DBorder border)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "XColor"
            }, {
              fpointer = 1,
              name = "(*tk_3DBorderGC) (Tk_Window tkwin, Tk_3DBorder border, int which)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "GC"
            }, {
              fpointer = 1,
              name = "(*tk_3DHorizontalBevel) (Tk_Window tkwin, Drawable drawable, Tk_3DBorder border, int x, int y, int width, int height, int leftIn, int rightIn, int topBevel, int relief)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_3DVerticalBevel) (Tk_Window tkwin, Drawable drawable, Tk_3DBorder border, int x, int y, int width, int height, int leftBevel, int relief)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_AddOption) (Tk_Window tkwin, CONST char *name, CONST char *value, int priority)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_BindEvent) (Tk_BindingTable bindingTable, XEvent *eventPtr, Tk_Window tkwin, int numObjects, ClientData *objectPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_CanvasDrawableCoords) (Tk_Canvas canvas, double x, double y, short *drawableXPtr, short *drawableYPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_CanvasEventuallyRedraw) (Tk_Canvas canvas, int x1, int y1, int x2, int y2)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_CanvasGetCoord) (Tcl_Interp *interp, Tk_Canvas canvas, CONST char *str, double *doublePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tk_CanvasGetTextInfo) (Tk_Canvas canvas)",
              pointer = 1,
              s = 1,
              t = 0,
              type = "Tk_CanvasTextInfo"
            }, {
              fpointer = 1,
              name = "(*tk_CanvasPsBitmap) (Tcl_Interp *interp, Tk_Canvas canvas, Pixmap bitmap, int x, int y, int width, int height)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_CanvasPsColor) (Tcl_Interp *interp, Tk_Canvas canvas, XColor *colorPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_CanvasPsFont) (Tcl_Interp *interp, Tk_Canvas canvas, Tk_Font font)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_CanvasPsPath) (Tcl_Interp *interp, Tk_Canvas canvas, double *coordPtr, int numPoints)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_CanvasPsStipple) (Tcl_Interp *interp, Tk_Canvas canvas, Pixmap bitmap)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_CanvasPsY) (Tk_Canvas canvas, double y)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "double"
            }, {
              fpointer = 1,
              name = "(*tk_CanvasSetStippleOrigin) (Tk_Canvas canvas, GC gc)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_CanvasTagsParseProc) (ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin, CONST char *value, char *widgRec, int offset)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tk_CanvasTagsPrintProc) (ClientData clientData, Tk_Window tkwin, char *widgRec, int offset, Tcl_FreeProc **freeProcPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "(*tk_CanvasTkwin) (Tk_Canvas canvas)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_Window"
            }, {
              fpointer = 1,
              name = "(*tk_CanvasWindowCoords) (Tk_Canvas canvas, double x, double y, short *screenXPtr, short *screenYPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_ChangeWindowAttributes) (Tk_Window tkwin, unsigned long valueMask, XSetWindowAttributes *attsPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_CharBbox) (Tk_TextLayout layout, int index, int *xPtr, int *yPtr, int *widthPtr, int *heightPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_ClearSelection) (Tk_Window tkwin, Atom selection)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_ClipboardAppend) (Tcl_Interp *interp, Tk_Window tkwin, Atom target, Atom format, char *buffer)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_ClipboardClear) (Tcl_Interp *interp, Tk_Window tkwin)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_ConfigureInfo) (Tcl_Interp *interp, Tk_Window tkwin, Tk_ConfigSpec *specs, char *widgRec, CONST char *argvName, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_ConfigureValue) (Tcl_Interp *interp, Tk_Window tkwin, Tk_ConfigSpec *specs, char *widgRec, CONST char *argvName, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_ConfigureWidget) (Tcl_Interp *interp, Tk_Window tkwin, Tk_ConfigSpec *specs, int argc, CONST84 char **argv, char *widgRec, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_ConfigureWindow) (Tk_Window tkwin, unsigned int valueMask, XWindowChanges *valuePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_ComputeTextLayout) (Tk_Font font, CONST char *str, int numChars, int wrapLength, Tk_Justify justify, int flags, int *widthPtr, int *heightPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_TextLayout"
            }, {
              fpointer = 1,
              name = "(*tk_CoordsToWindow) (int rootX, int rootY, Tk_Window tkwin)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_Window"
            }, {
              fpointer = 1,
              name = "(*tk_CreateBinding) (Tcl_Interp *interp, Tk_BindingTable bindingTable, ClientData object, CONST char *eventStr, CONST char *command, int append)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "unsigned long"
            }, {
              fpointer = 1,
              name = "(*tk_CreateBindingTable) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_BindingTable"
            }, {
              fpointer = 1,
              name = "(*tk_CreateErrorHandler) (Display *display, int errNum, int request, int minorCode, Tk_ErrorProc *errorProc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_ErrorHandler"
            }, {
              fpointer = 1,
              name = "(*tk_CreateEventHandler) (Tk_Window token, unsigned long mask, Tk_EventProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_CreateGenericHandler) (Tk_GenericProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_CreateImageType) (Tk_ImageType *typePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_CreateItemType) (Tk_ItemType *typePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_CreatePhotoImageFormat) (Tk_PhotoImageFormat *formatPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_CreateSelHandler) (Tk_Window tkwin, Atom selection, Atom target, Tk_SelectionProc *proc, ClientData clientData, Atom format)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_CreateWindow) (Tcl_Interp *interp, Tk_Window parent, CONST char *name, CONST char *screenName)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_Window"
            }, {
              fpointer = 1,
              name = "(*tk_CreateWindowFromPath) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *pathName, CONST char *screenName)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_Window"
            }, {
              fpointer = 1,
              name = "(*tk_DefineBitmap) (Tcl_Interp *interp, CONST char *name, CONST char *source, int width, int height)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_DefineCursor) (Tk_Window window, Tk_Cursor cursor)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_DeleteAllBindings) (Tk_BindingTable bindingTable, ClientData object)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_DeleteBinding) (Tcl_Interp *interp, Tk_BindingTable bindingTable, ClientData object, CONST char *eventStr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_DeleteBindingTable) (Tk_BindingTable bindingTable)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_DeleteErrorHandler) (Tk_ErrorHandler handler)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_DeleteEventHandler) (Tk_Window token, unsigned long mask, Tk_EventProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_DeleteGenericHandler) (Tk_GenericProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_DeleteImage) (Tcl_Interp *interp, CONST char *name)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_DeleteSelHandler) (Tk_Window tkwin, Atom selection, Atom target)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_DestroyWindow) (Tk_Window tkwin)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*tk_DisplayName) (Tk_Window tkwin)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "(*tk_DistanceToTextLayout) (Tk_TextLayout layout, int x, int y)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_Draw3DPolygon) (Tk_Window tkwin, Drawable drawable, Tk_3DBorder border, XPoint *pointPtr, int numPoints, int borderWidth, int leftRelief)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_Draw3DRectangle) (Tk_Window tkwin, Drawable drawable, Tk_3DBorder border, int x, int y, int width, int height, int borderWidth, int relief)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_DrawChars) (Display *display, Drawable drawable, GC gc, Tk_Font tkfont, CONST char *source, int numBytes, int x, int y)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_DrawFocusHighlight) (Tk_Window tkwin, GC gc, int width, Drawable drawable)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_DrawTextLayout) (Display *display, Drawable drawable, GC gc, Tk_TextLayout layout, int x, int y, int firstChar, int lastChar)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_Fill3DPolygon) (Tk_Window tkwin, Drawable drawable, Tk_3DBorder border, XPoint *pointPtr, int numPoints, int borderWidth, int leftRelief)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_Fill3DRectangle) (Tk_Window tkwin, Drawable drawable, Tk_3DBorder border, int x, int y, int width, int height, int borderWidth, int relief)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_FindPhoto) (Tcl_Interp *interp, CONST char *imageName)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_PhotoHandle"
            }, {
              fpointer = 1,
              name = "(*tk_FontId) (Tk_Font font)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Font"
            }, {
              fpointer = 1,
              name = "(*tk_Free3DBorder) (Tk_3DBorder border)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_FreeBitmap) (Display *display, Pixmap bitmap)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_FreeColor) (XColor *colorPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_FreeColormap) (Display *display, Colormap colormap)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_FreeCursor) (Display *display, Tk_Cursor cursor)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_FreeFont) (Tk_Font f)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_FreeGC) (Display *display, GC gc)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_FreeImage) (Tk_Image image)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_FreeOptions) (Tk_ConfigSpec *specs, char *widgRec, Display *display, int needFlags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_FreePixmap) (Display *display, Pixmap pixmap)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_FreeTextLayout) (Tk_TextLayout textLayout)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_FreeXId) (Display *display, XID xid)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_GCForColor) (XColor *colorPtr, Drawable drawable)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "GC"
            }, {
              fpointer = 1,
              name = "(*tk_GeometryRequest) (Tk_Window tkwin, int reqWidth, int reqHeight)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_Get3DBorder) (Tcl_Interp *interp, Tk_Window tkwin, Tk_Uid colorName)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_3DBorder"
            }, {
              fpointer = 1,
              name = "(*tk_GetAllBindings) (Tcl_Interp *interp, Tk_BindingTable bindingTable, ClientData object)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_GetAnchor) (Tcl_Interp *interp, CONST char *str, Tk_Anchor *anchorPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tk_GetAtomName) (Tk_Window tkwin, Atom atom)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "* (*tk_GetBinding) (Tcl_Interp *interp, Tk_BindingTable bindingTable, ClientData object, CONST char *eventStr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "(*tk_GetBitmap) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *str)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Pixmap"
            }, {
              fpointer = 1,
              name = "(*tk_GetBitmapFromData) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *source, int width, int height)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Pixmap"
            }, {
              fpointer = 1,
              name = "(*tk_GetCapStyle) (Tcl_Interp *interp, CONST char *str, int *capPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tk_GetColor) (Tcl_Interp *interp, Tk_Window tkwin, Tk_Uid name)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "XColor"
            }, {
              fpointer = 1,
              name = "* (*tk_GetColorByValue) (Tk_Window tkwin, XColor *colorPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "XColor"
            }, {
              fpointer = 1,
              name = "(*tk_GetColormap) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *str)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Colormap"
            }, {
              fpointer = 1,
              name = "(*tk_GetCursor) (Tcl_Interp *interp, Tk_Window tkwin, Tk_Uid str)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_Cursor"
            }, {
              fpointer = 1,
              name = "(*tk_GetCursorFromData) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *source, CONST char *mask, int width, int height, int xHot, int yHot, Tk_Uid fg, Tk_Uid bg)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_Cursor"
            }, {
              fpointer = 1,
              name = "(*tk_GetFont) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *str)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_Font"
            }, {
              fpointer = 1,
              name = "(*tk_GetFontFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_Font"
            }, {
              fpointer = 1,
              name = "(*tk_GetFontMetrics) (Tk_Font font, Tk_FontMetrics *fmPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_GetGC) (Tk_Window tkwin, unsigned long valueMask, XGCValues *valuePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "GC"
            }, {
              fpointer = 1,
              name = "(*tk_GetImage) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *name, Tk_ImageChangedProc *changeProc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_Image"
            }, {
              fpointer = 1,
              name = "(*tk_GetImageMasterData) (Tcl_Interp *interp, CONST char *name, Tk_ImageType **typePtrPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "ClientData"
            }, {
              fpointer = 1,
              name = "* (*tk_GetItemTypes) (void)",
              pointer = 1,
              s = 1,
              t = 0,
              type = "Tk_ItemType"
            }, {
              fpointer = 1,
              name = "(*tk_GetJoinStyle) (Tcl_Interp *interp, CONST char *str, int *joinPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_GetJustify) (Tcl_Interp *interp, CONST char *str, Tk_Justify *justifyPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_GetNumMainWindows) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_GetOption) (Tk_Window tkwin, CONST char *name, CONST char *className)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_Uid"
            }, {
              fpointer = 1,
              name = "(*tk_GetPixels) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *str, int *intPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_GetPixmap) (Display *display, Drawable d, int width, int height, int depth)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Pixmap"
            }, {
              fpointer = 1,
              name = "(*tk_GetRelief) (Tcl_Interp *interp, CONST char *name, int *reliefPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_GetRootCoords) (Tk_Window tkwin, int *xPtr, int *yPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_GetScrollInfo) (Tcl_Interp *interp, int argc, CONST84 char **argv, double *dblPtr, int *intPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_GetScreenMM) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *str, double *doublePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_GetSelection) (Tcl_Interp *interp, Tk_Window tkwin, Atom selection, Atom target, Tk_GetSelProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_GetUid) (CONST char *str)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_Uid"
            }, {
              fpointer = 1,
              name = "* (*tk_GetVisual) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *str, int *depthPtr, Colormap *colormapPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Visual"
            }, {
              fpointer = 1,
              name = "(*tk_GetVRootGeometry) (Tk_Window tkwin, int *xPtr, int *yPtr, int *widthPtr, int *heightPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_Grab) (Tcl_Interp *interp, Tk_Window tkwin, int grabGlobal)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_HandleEvent) (XEvent *eventPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_IdToWindow) (Display *display, Window window)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_Window"
            }, {
              fpointer = 1,
              name = "(*tk_ImageChanged) (Tk_ImageMaster master, int x, int y, int width, int height, int imageWidth, int imageHeight)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_Init) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_InternAtom) (Tk_Window tkwin, CONST char *name)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Atom"
            }, {
              fpointer = 1,
              name = "(*tk_IntersectTextLayout) (Tk_TextLayout layout, int x, int y, int width, int height)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_MaintainGeometry) (Tk_Window slave, Tk_Window master, int x, int y, int width, int height)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_MainWindow) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_Window"
            }, {
              fpointer = 1,
              name = "(*tk_MakeWindowExist) (Tk_Window tkwin)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_ManageGeometry) (Tk_Window tkwin, CONST Tk_GeomMgr *mgrPtr, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_MapWindow) (Tk_Window tkwin)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_MeasureChars) (Tk_Font tkfont, CONST char *source, int numBytes, int maxPixels, int flags, int *lengthPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_MoveResizeWindow) (Tk_Window tkwin, int x, int y, int width, int height)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_MoveWindow) (Tk_Window tkwin, int x, int y)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_MoveToplevelWindow) (Tk_Window tkwin, int x, int y)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*tk_NameOf3DBorder) (Tk_3DBorder border)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "* (*tk_NameOfAnchor) (Tk_Anchor anchor)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "* (*tk_NameOfBitmap) (Display *display, Pixmap bitmap)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "* (*tk_NameOfCapStyle) (int cap)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "* (*tk_NameOfColor) (XColor *colorPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "* (*tk_NameOfCursor) (Display *display, Tk_Cursor cursor)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "* (*tk_NameOfFont) (Tk_Font font)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "* (*tk_NameOfImage) (Tk_ImageMaster imageMaster)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "* (*tk_NameOfJoinStyle) (int join)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "* (*tk_NameOfJustify) (Tk_Justify justify)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "* (*tk_NameOfRelief) (int relief)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST84_RETURN char"
            }, {
              fpointer = 1,
              name = "(*tk_NameToWindow) (Tcl_Interp *interp, CONST char *pathName, Tk_Window tkwin)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_Window"
            }, {
              fpointer = 1,
              name = "(*tk_OwnSelection) (Tk_Window tkwin, Atom selection, Tk_LostSelProc *proc, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_ParseArgv) (Tcl_Interp *interp, Tk_Window tkwin, int *argcPtr, CONST84 char **argv, Tk_ArgvInfo *argTable, int flags)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_PhotoPutBlock_NoComposite) (Tk_PhotoHandle handle, Tk_PhotoImageBlock *blockPtr, int x, int y, int width, int height)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_PhotoPutZoomedBlock_NoComposite) (Tk_PhotoHandle handle, Tk_PhotoImageBlock *blockPtr, int x, int y, int width, int height, int zoomX, int zoomY, int subsampleX, int subsampleY)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_PhotoGetImage) (Tk_PhotoHandle handle, Tk_PhotoImageBlock *blockPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_PhotoBlank) (Tk_PhotoHandle handle)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_PhotoExpand_Panic) (Tk_PhotoHandle handle, int width, int height)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_PhotoGetSize) (Tk_PhotoHandle handle, int *widthPtr, int *heightPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_PhotoSetSize_Panic) (Tk_PhotoHandle handle, int width, int height)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_PointToChar) (Tk_TextLayout layout, int x, int y)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_PostscriptFontName) (Tk_Font tkfont, Tcl_DString *dsPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_PreserveColormap) (Display *display, Colormap colormap)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_QueueWindowEvent) (XEvent *eventPtr, Tcl_QueuePosition position)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_RedrawImage) (Tk_Image image, int imageX, int imageY, int width, int height, Drawable drawable, int drawableX, int drawableY)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_ResizeWindow) (Tk_Window tkwin, int width, int height)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_RestackWindow) (Tk_Window tkwin, int aboveBelow, Tk_Window other)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tk_RestrictEvents) (Tk_RestrictProc *proc, ClientData arg, ClientData *prevArgPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_RestrictProc"
            }, {
              fpointer = 1,
              name = "(*tk_SafeInit) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*tk_SetAppName) (Tk_Window tkwin, CONST char *name)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST char"
            }, {
              fpointer = 1,
              name = "(*tk_SetBackgroundFromBorder) (Tk_Window tkwin, Tk_3DBorder border)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_SetClass) (Tk_Window tkwin, CONST char *className)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_SetGrid) (Tk_Window tkwin, int reqWidth, int reqHeight, int gridWidth, int gridHeight)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_SetInternalBorder) (Tk_Window tkwin, int width)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_SetWindowBackground) (Tk_Window tkwin, unsigned long pixel)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_SetWindowBackgroundPixmap) (Tk_Window tkwin, Pixmap pixmap)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_SetWindowBorder) (Tk_Window tkwin, unsigned long pixel)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_SetWindowBorderWidth) (Tk_Window tkwin, int width)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_SetWindowBorderPixmap) (Tk_Window tkwin, Pixmap pixmap)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_SetWindowColormap) (Tk_Window tkwin, Colormap colormap)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_SetWindowVisual) (Tk_Window tkwin, Visual *visual, int depth, Colormap colormap)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_SizeOfBitmap) (Display *display, Pixmap bitmap, int *widthPtr, int *heightPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_SizeOfImage) (Tk_Image image, int *widthPtr, int *heightPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_StrictMotif) (Tk_Window tkwin)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_TextLayoutToPostscript) (Tcl_Interp *interp, Tk_TextLayout layout)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_TextWidth) (Tk_Font font, CONST char *str, int numBytes)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_UndefineCursor) (Tk_Window window)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_UnderlineChars) (Display *display, Drawable drawable, GC gc, Tk_Font tkfont, CONST char *source, int x, int y, int firstByte, int lastByte)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_UnderlineTextLayout) (Display *display, Drawable drawable, GC gc, Tk_TextLayout layout, int x, int y, int underline)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_Ungrab) (Tk_Window tkwin)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_UnmaintainGeometry) (Tk_Window slave, Tk_Window master)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_UnmapWindow) (Tk_Window tkwin)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_UnsetGrid) (Tk_Window tkwin)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_UpdatePointer) (Tk_Window tkwin, int x, int y, int state)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_AllocBitmapFromObj) (Tcl_Interp *interp, Tk_Window tkwin, Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Pixmap"
            }, {
              fpointer = 1,
              name = "(*tk_Alloc3DBorderFromObj) (Tcl_Interp *interp, Tk_Window tkwin, Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_3DBorder"
            }, {
              fpointer = 1,
              name = "* (*tk_AllocColorFromObj) (Tcl_Interp *interp, Tk_Window tkwin, Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "XColor"
            }, {
              fpointer = 1,
              name = "(*tk_AllocCursorFromObj) (Tcl_Interp *interp, Tk_Window tkwin, Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_Cursor"
            }, {
              fpointer = 1,
              name = "(*tk_AllocFontFromObj) (Tcl_Interp *interp, Tk_Window tkwin, Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_Font"
            }, {
              fpointer = 1,
              name = "(*tk_CreateOptionTable) (Tcl_Interp *interp, CONST Tk_OptionSpec *templatePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_OptionTable"
            }, {
              fpointer = 1,
              name = "(*tk_DeleteOptionTable) (Tk_OptionTable optionTable)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_Free3DBorderFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_FreeBitmapFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_FreeColorFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_FreeConfigOptions) (char *recordPtr, Tk_OptionTable optionToken, Tk_Window tkwin)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_FreeSavedOptions) (Tk_SavedOptions *savePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_FreeCursorFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_FreeFontFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_Get3DBorderFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_3DBorder"
            }, {
              fpointer = 1,
              name = "(*tk_GetAnchorFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, Tk_Anchor *anchorPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_GetBitmapFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Pixmap"
            }, {
              fpointer = 1,
              name = "* (*tk_GetColorFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "XColor"
            }, {
              fpointer = 1,
              name = "(*tk_GetCursorFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_Cursor"
            }, {
              fpointer = 1,
              name = "* (*tk_GetOptionInfo) (Tcl_Interp *interp, char *recordPtr, Tk_OptionTable optionTable, Tcl_Obj *namePtr, Tk_Window tkwin)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "* (*tk_GetOptionValue) (Tcl_Interp *interp, char *recordPtr, Tk_OptionTable optionTable, Tcl_Obj *namePtr, Tk_Window tkwin)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tcl_Obj"
            }, {
              fpointer = 1,
              name = "(*tk_GetJustifyFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, Tk_Justify *justifyPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_GetMMFromObj) (Tcl_Interp *interp, Tk_Window tkwin, Tcl_Obj *objPtr, double *doublePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_GetPixelsFromObj) (Tcl_Interp *interp, Tk_Window tkwin, Tcl_Obj *objPtr, int *intPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_GetReliefFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, int *resultPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_GetScrollInfoObj) (Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[], double *dblPtr, int *intPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_InitOptions) (Tcl_Interp *interp, char *recordPtr, Tk_OptionTable optionToken, Tk_Window tkwin)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_MainEx) (int argc, char **argv, Tcl_AppInitProc *appInitProc, Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_RestoreSavedOptions) (Tk_SavedOptions *savePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_SetOptions) (Tcl_Interp *interp, char *recordPtr, Tk_OptionTable optionTable, int objc, Tcl_Obj *CONST objv[], Tk_Window tkwin, Tk_SavedOptions *savePtr, int *maskPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_InitConsoleChannels) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_CreateConsoleWindow) (Tcl_Interp *interp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_CreateSmoothMethod) (Tcl_Interp *interp, Tk_SmoothMethod *method)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "*reserved218",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "*reserved219",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_GetDash) (Tcl_Interp *interp, CONST char *value, Tk_Dash *dash)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_CreateOutline) (Tk_Outline *outline)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_DeleteOutline) (Display *display, Tk_Outline *outline)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_ConfigOutlineGC) (XGCValues *gcValues, Tk_Canvas canvas, Tk_Item *item, Tk_Outline *outline)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_ChangeOutlineGC) (Tk_Canvas canvas, Tk_Item *item, Tk_Outline *outline)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_ResetOutlineGC) (Tk_Canvas canvas, Tk_Item *item, Tk_Outline *outline)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_CanvasPsOutline) (Tk_Canvas canvas, Tk_Item *item, Tk_Outline *outline)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_SetTSOrigin) (Tk_Window tkwin, GC gc, int x, int y)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_CanvasGetCoordFromObj) (Tcl_Interp *interp, Tk_Canvas canvas, Tcl_Obj *obj, double *doublePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_CanvasSetOffset) (Tk_Canvas canvas, GC gc, Tk_TSOffset *offset)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_DitherPhoto) (Tk_PhotoHandle handle, int x, int y, int width, int height)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_PostscriptBitmap) (Tcl_Interp *interp, Tk_Window tkwin, Tk_PostscriptInfo psInfo, Pixmap bitmap, int startX, int startY, int width, int height)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_PostscriptColor) (Tcl_Interp *interp, Tk_PostscriptInfo psInfo, XColor *colorPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_PostscriptFont) (Tcl_Interp *interp, Tk_PostscriptInfo psInfo, Tk_Font font)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_PostscriptImage) (Tk_Image image, Tcl_Interp *interp, Tk_Window tkwin, Tk_PostscriptInfo psinfo, int x, int y, int width, int height, int prepass)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_PostscriptPath) (Tcl_Interp *interp, Tk_PostscriptInfo psInfo, double *coordPtr, int numPoints)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_PostscriptStipple) (Tcl_Interp *interp, Tk_Window tkwin, Tk_PostscriptInfo psInfo, Pixmap bitmap)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_PostscriptY) (double y, Tk_PostscriptInfo psInfo)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "double"
            }, {
              fpointer = 1,
              name = "(*tk_PostscriptPhoto) (Tcl_Interp *interp, Tk_PhotoImageBlock *blockPtr, Tk_PostscriptInfo psInfo, int width, int height)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_CreateClientMessageHandler) (Tk_ClientMessageProc *proc)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_DeleteClientMessageHandler) (Tk_ClientMessageProc *proc)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_CreateAnonymousWindow) (Tcl_Interp *interp, Tk_Window parent, CONST char *screenName)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_Window"
            }, {
              fpointer = 1,
              name = "(*tk_SetClassProcs) (Tk_Window tkwin, Tk_ClassProcs *procs, ClientData instanceData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_SetInternalBorderEx) (Tk_Window tkwin, int left, int right, int top, int bottom)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_SetMinimumRequestSize) (Tk_Window tkwin, int minWidth, int minHeight)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_SetCaretPos) (Tk_Window tkwin, int x, int y, int height)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_PhotoPutBlock_Panic) (Tk_PhotoHandle handle, Tk_PhotoImageBlock *blockPtr, int x, int y, int width, int height, int compRule)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_PhotoPutZoomedBlock_Panic) (Tk_PhotoHandle handle, Tk_PhotoImageBlock *blockPtr, int x, int y, int width, int height, int zoomX, int zoomY, int subsampleX, int subsampleY, int compRule)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_CollapseMotionEvents) (Display *display, int collapse)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_RegisterStyleEngine) (CONST char *name, Tk_StyleEngine parent)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_StyleEngine"
            }, {
              fpointer = 1,
              name = "(*tk_GetStyleEngine) (CONST char *name)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_StyleEngine"
            }, {
              fpointer = 1,
              name = "(*tk_RegisterStyledElement) (Tk_StyleEngine engine, Tk_ElementSpec *templatePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_GetElementId) (CONST char *name)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_CreateStyle) (CONST char *name, Tk_StyleEngine engine, ClientData clientData)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_Style"
            }, {
              fpointer = 1,
              name = "(*tk_GetStyle) (Tcl_Interp *interp, CONST char *name)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_Style"
            }, {
              fpointer = 1,
              name = "(*tk_FreeStyle) (Tk_Style style)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*tk_NameOfStyle) (Tk_Style style)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "CONST char"
            }, {
              fpointer = 1,
              name = "(*tk_AllocStyleFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_Style"
            }, {
              fpointer = 1,
              name = "(*tk_GetStyleFromObj) (Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_Style"
            }, {
              fpointer = 1,
              name = "(*tk_FreeStyleFromObj) (Tcl_Obj *objPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_GetStyledElement) (Tk_Style style, int elementId, Tk_OptionTable optionTable)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Tk_StyledElement"
            }, {
              fpointer = 1,
              name = "(*tk_GetElementSize) (Tk_Style style, Tk_StyledElement element, char *recordPtr, Tk_Window tkwin, int width, int height, int inner, int *widthPtr, int *heightPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_GetElementBox) (Tk_Style style, Tk_StyledElement element, char *recordPtr, Tk_Window tkwin, int x, int y, int width, int height, int inner, int *xPtr, int *yPtr, int *widthPtr, int *heightPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_GetElementBorderWidth) (Tk_Style style, Tk_StyledElement element, char *recordPtr, Tk_Window tkwin)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_DrawElement) (Tk_Style style, Tk_StyledElement element, char *recordPtr, Tk_Window tkwin, Drawable d, int x, int y, int width, int height, int state)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_PhotoExpand) (Tcl_Interp *interp, Tk_PhotoHandle handle, int width, int height)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_PhotoPutBlock) (Tcl_Interp *interp, Tk_PhotoHandle handle, Tk_PhotoImageBlock *blockPtr, int x, int y, int width, int height, int compRule)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_PhotoPutZoomedBlock) (Tcl_Interp *interp, Tk_PhotoHandle handle, Tk_PhotoImageBlock *blockPtr, int x, int y, int width, int height, int zoomX, int zoomY, int subsampleX, int subsampleY, int compRule)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_PhotoSetSize) (Tcl_Interp *interp, Tk_PhotoHandle handle, int width, int height)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tk_GetUserInactiveTime) (Display *dpy)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "long"
            }, {
              fpointer = 1,
              name = "(*tk_ResetUserInactiveTime) (Display *dpy)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*tk_Interp) (Tk_Window tkwin)",
              pointer = 1,
              s = 1,
              t = 0,
              type = "Tcl_Interp"
            }, {
              fpointer = 1,
              name = "(*tk_CreateOldImageType) (Tk_ImageType *typePtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tk_CreateOldPhotoImageFormat) (Tk_PhotoImageFormat *formatPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            } },
          print = <function 534>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "stringlist.h",
        linedef = 44,
        name = "_stringlist",
        structs = <table 1>,
        typedef = 1,
        typedname = "StringList",
        vars = {
          add = <function 535>,
          init = <function 536>,
          list = { {
              fpointer = 0,
              name = "**sl_str",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "sl_max",
              pointer = 0,
              s = 0,
              t = 0,
              type = "size_t"
            }, {
              fpointer = 0,
              name = "sl_cur",
              pointer = 0,
              s = 0,
              t = 0,
              type = "size_t"
            } },
          print = <function 537>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ifaddrs.h",
        linedef = 33,
        name = "ifaddrs",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 538>,
          init = <function 539>,
          list = { {
              fpointer = 0,
              name = "*ifa_next",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct ifaddrs"
            }, {
              fpointer = 0,
              name = "*ifa_name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "ifa_flags",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned int"
            }, {
              fpointer = 0,
              name = "*ifa_addr",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct sockaddr"
            }, {
              fpointer = 0,
              name = "*ifa_netmask",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct sockaddr"
            }, {
              fpointer = 0,
              name = "*ifa_dstaddr",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct sockaddr"
            }, {
              fpointer = 0,
              name = "*ifa_data",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            } },
          print = <function 540>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ifaddrs.h",
        linedef = 51,
        name = "ifmaddrs",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 541>,
          init = <function 542>,
          list = { {
              fpointer = 0,
              name = "*ifma_next",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct ifmaddrs"
            }, {
              fpointer = 0,
              name = "*ifma_name",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct sockaddr"
            }, {
              fpointer = 0,
              name = "*ifma_addr",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct sockaddr"
            }, {
              fpointer = 0,
              name = "*ifma_lladdr",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct sockaddr"
            } },
          print = <function 543>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "sqlite3ext.h",
        linedef = 34,
        name = "sqlite3_api_routines",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 544>,
          init = <function 545>,
          list = { {
              fpointer = 1,
              name = "* (*aggregate_context)(sqlite3_context*,int nBytes)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*aggregate_count)(sqlite3_context*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*bind_blob)(sqlite3_stmt*,int,const void*,int n,void(*)(void*))",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*bind_double)(sqlite3_stmt*,int,double)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*bind_int)(sqlite3_stmt*,int,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*bind_int64)(sqlite3_stmt*,int,sqlite_int64)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*bind_null)(sqlite3_stmt*,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*bind_parameter_count)(sqlite3_stmt*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*bind_parameter_index)(sqlite3_stmt*,const char*zName)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*bind_parameter_name)(sqlite3_stmt*,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 1,
              name = "(*bind_text)(sqlite3_stmt*,int,const char*,int n,void(*)(void*))",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*bind_text16)(sqlite3_stmt*,int,const void*,int,void(*)(void*))",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*bind_value)(sqlite3_stmt*,int,const sqlite3_value*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*busy_handler)(sqlite3*,int(*)(void*,int),void*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*busy_timeout)(sqlite3*,int ms)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*changes)(sqlite3*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*close)(sqlite3*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "eTextRep,const char*))",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "eTextRep,const void*))",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*column_blob)(sqlite3_stmt*,int iCol)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const void"
            }, {
              fpointer = 1,
              name = "(*column_bytes)(sqlite3_stmt*,int iCol)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*column_bytes16)(sqlite3_stmt*,int iCol)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*column_count)(sqlite3_stmt*pStmt)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*column_database_name)(sqlite3_stmt*,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 1,
              name = "* (*column_database_name16)(sqlite3_stmt*,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const void"
            }, {
              fpointer = 1,
              name = "* (*column_decltype)(sqlite3_stmt*,int i)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 1,
              name = "* (*column_decltype16)(sqlite3_stmt*,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const void"
            }, {
              fpointer = 1,
              name = "(*column_double)(sqlite3_stmt*,int iCol)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "double"
            }, {
              fpointer = 1,
              name = "(*column_int)(sqlite3_stmt*,int iCol)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*column_int64)(sqlite3_stmt*,int iCol)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "sqlite_int64"
            }, {
              fpointer = 1,
              name = "* (*column_name)(sqlite3_stmt*,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 1,
              name = "* (*column_name16)(sqlite3_stmt*,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const void"
            }, {
              fpointer = 1,
              name = "* (*column_origin_name)(sqlite3_stmt*,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 1,
              name = "* (*column_origin_name16)(sqlite3_stmt*,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const void"
            }, {
              fpointer = 1,
              name = "* (*column_table_name)(sqlite3_stmt*,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 1,
              name = "* (*column_table_name16)(sqlite3_stmt*,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const void"
            }, {
              fpointer = 1,
              name = "* (*column_text)(sqlite3_stmt*,int iCol)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const unsigned char"
            }, {
              fpointer = 1,
              name = "* (*column_text16)(sqlite3_stmt*,int iCol)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const void"
            }, {
              fpointer = 1,
              name = "(*column_type)(sqlite3_stmt*,int iCol)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "sqlite3_value* (*column_value)(sqlite3_stmt*,int iCol)",
              pointer = 1,
              s = 0,
              t = 0,
              type = ""
            }, {
              fpointer = 1,
              name = "* (*commit_hook)(sqlite3*,int(*)(void*),void*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*complete)(const char*sql)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*complete16)(const void*sql)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "int(*)(void*,int,const void*,int,const void*))",
              pointer = 1,
              s = 0,
              t = 0,
              type = ""
            }, {
              fpointer = 1,
              name = "int(*)(void*,int,const void*,int,const void*))",
              pointer = 1,
              s = 0,
              t = 0,
              type = ""
            }, {
              fpointer = 1,
              name = "(*xFinal)(sqlite3_context*))",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xFinal)(sqlite3_context*))",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*create_module)(sqlite3*,const char*,const sqlite3_module*,void*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*data_count)(sqlite3_stmt*pStmt)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*db_handle)(sqlite3_stmt*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "sqlite3"
            }, {
              fpointer = 1,
              name = "(*declare_vtab)(sqlite3*,const char*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*enable_shared_cache)(int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*errcode)(sqlite3*db)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*errmsg)(sqlite3*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 1,
              name = "* (*errmsg16)(sqlite3*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const void"
            }, {
              fpointer = 1,
              name = "(*exec)(sqlite3*,const char*,sqlite3_callback,void*,char**)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*expired)(sqlite3_stmt*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*finalize)(sqlite3_stmt*pStmt)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*free)(void*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*free_table)(char**result)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*get_autocommit)(sqlite3*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*get_auxdata)(sqlite3_context*,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*get_table)(sqlite3*,const char*,char***,int*,int*,char**)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*global_recover)(void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*interruptx)(sqlite3*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*last_insert_rowid)(sqlite3*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "sqlite_int64"
            }, {
              fpointer = 1,
              name = "* (*libversion)(void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 1,
              name = "(*libversion_number)(void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "*(*malloc)(int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*mprintf)(const char*,...)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "(*open)(const char*,sqlite3**)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*open16)(const void*,sqlite3**)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*prepare)(sqlite3*,const char*,int,sqlite3_stmt**,const char**)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*prepare16)(sqlite3*,const void*,int,sqlite3_stmt**,const void**)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*profile)(sqlite3*,void(*)(void*,const char*,sqlite_uint64),void*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*progress_handler)(sqlite3*,int,int(*)(void*),void*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "*(*realloc)(void*,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*reset)(sqlite3_stmt*pStmt)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*result_blob)(sqlite3_context*,const void*,int,void(*)(void*))",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*result_double)(sqlite3_context*,double)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*result_error)(sqlite3_context*,const char*,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*result_error16)(sqlite3_context*,const void*,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*result_int)(sqlite3_context*,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*result_int64)(sqlite3_context*,sqlite_int64)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*result_null)(sqlite3_context*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*result_text)(sqlite3_context*,const char*,int,void(*)(void*))",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*result_text16)(sqlite3_context*,const void*,int,void(*)(void*))",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*result_text16be)(sqlite3_context*,const void*,int,void(*)(void*))",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*result_text16le)(sqlite3_context*,const void*,int,void(*)(void*))",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*result_value)(sqlite3_context*,sqlite3_value*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*rollback_hook)(sqlite3*,void(*)(void*),void*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "char*,const char*),void*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const"
            }, {
              fpointer = 1,
              name = "(*set_auxdata)(sqlite3_context*,int,void*,void (*)(void*))",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*snprintf)(int,char*,const char*,...)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "(*step)(sqlite3_stmt*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "const**,char const**,int*,int*,int*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "(*thread_cleanup)(void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*total_changes)(sqlite3*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*trace)(sqlite3*,void(*xTrace)(void*,const char*),void*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*transfer_bindings)(sqlite3_stmt*,sqlite3_stmt*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "sqlite_int64),void*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = ""
            }, {
              fpointer = 1,
              name = "* (*user_data)(sqlite3_context*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*value_blob)(sqlite3_value*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const void"
            }, {
              fpointer = 1,
              name = "(*value_bytes)(sqlite3_value*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*value_bytes16)(sqlite3_value*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*value_double)(sqlite3_value*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "double"
            }, {
              fpointer = 1,
              name = "(*value_int)(sqlite3_value*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*value_int64)(sqlite3_value*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "sqlite_int64"
            }, {
              fpointer = 1,
              name = "(*value_numeric_type)(sqlite3_value*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "* (*value_text)(sqlite3_value*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const unsigned char"
            }, {
              fpointer = 1,
              name = "* (*value_text16)(sqlite3_value*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const void"
            }, {
              fpointer = 1,
              name = "* (*value_text16be)(sqlite3_value*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const void"
            }, {
              fpointer = 1,
              name = "* (*value_text16le)(sqlite3_value*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const void"
            }, {
              fpointer = 1,
              name = "(*value_type)(sqlite3_value*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "*(*vmprintf)(const char*,va_list)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "(*overload_function)(sqlite3*, const char *zFuncName, int nArg)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*prepare_v2)(sqlite3*,const char*,int,sqlite3_stmt**,const char**)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*prepare16_v2)(sqlite3*,const void*,int,sqlite3_stmt**,const void**)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*clear_bindings)(sqlite3_stmt*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xDestroy)(void *))",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*bind_zeroblob)(sqlite3_stmt*,int,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*blob_bytes)(sqlite3_blob*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*blob_close)(sqlite3_blob*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "int,sqlite3_blob**)",
              pointer = 1,
              s = 0,
              t = 0,
              type = ""
            }, {
              fpointer = 1,
              name = "(*blob_read)(sqlite3_blob*,void*,int,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*blob_write)(sqlite3_blob*,const void*,int,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "void(*)(void*))",
              pointer = 1,
              s = 0,
              t = 0,
              type = ""
            }, {
              fpointer = 1,
              name = "(*file_control)(sqlite3*,const char*,int,void*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*memory_highwater)(int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "sqlite3_int64"
            }, {
              fpointer = 1,
              name = "(*memory_used)(void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "sqlite3_int64"
            }, {
              fpointer = 1,
              name = "*(*mutex_alloc)(int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "sqlite3_mutex"
            }, {
              fpointer = 1,
              name = "(*mutex_enter)(sqlite3_mutex*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*mutex_free)(sqlite3_mutex*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*mutex_leave)(sqlite3_mutex*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*mutex_try)(sqlite3_mutex*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*open_v2)(const char*,sqlite3**,int,const char*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*release_memory)(int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*result_error_nomem)(sqlite3_context*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*result_error_toobig)(sqlite3_context*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*sleep)(int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*soft_heap_limit)(int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "*(*vfs_find)(const char*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "sqlite3_vfs"
            }, {
              fpointer = 1,
              name = "(*vfs_register)(sqlite3_vfs*,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*vfs_unregister)(sqlite3_vfs*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xthreadsafe)(void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*result_zeroblob)(sqlite3_context*,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*result_error_code)(sqlite3_context*,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*test_control)(int, ...)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*randomness)(int,void*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "*(*context_db_handle)(sqlite3_context*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "sqlite3"
            }, {
              fpointer = 1,
              name = "(*extended_result_codes)(sqlite3*,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*limit)(sqlite3*,int,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "*(*next_stmt)(sqlite3*,sqlite3_stmt*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "sqlite3_stmt"
            }, {
              fpointer = 1,
              name = "*(*sql)(sqlite3_stmt*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 1,
              name = "(*status)(int,int*,int*,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*backup_finish)(sqlite3_backup*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "*(*backup_init)(sqlite3*,const char*,sqlite3*,const char*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "sqlite3_backup"
            }, {
              fpointer = 1,
              name = "(*backup_pagecount)(sqlite3_backup*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*backup_remaining)(sqlite3_backup*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*backup_step)(sqlite3_backup*,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "*(*compileoption_get)(int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 1,
              name = "(*compileoption_used)(const char*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "void(*xDestroy)(void*))",
              pointer = 1,
              s = 0,
              t = 0,
              type = ""
            }, {
              fpointer = 1,
              name = "(*db_config)(sqlite3*,int,...)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "*(*db_mutex)(sqlite3*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "sqlite3_mutex"
            }, {
              fpointer = 1,
              name = "(*db_status)(sqlite3*,int,int*,int*,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*extended_errcode)(sqlite3*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*log)(int,const char*,...)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*soft_heap_limit64)(sqlite3_int64)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "sqlite3_int64"
            }, {
              fpointer = 1,
              name = "*(*sourceid)(void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 1,
              name = "(*stmt_status)(sqlite3_stmt*,int,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*strnicmp)(const char*,const char*,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*unlock_notify)(sqlite3*,void(*)(void**,int),void*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*wal_autocheckpoint)(sqlite3*,int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*wal_checkpoint)(sqlite3*,const char*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "*(*wal_hook)(sqlite3*,int(*)(void*,sqlite3*,const char*,int),void*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*blob_reopen)(sqlite3_blob*,sqlite3_int64)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*vtab_config)(sqlite3*,int op,...)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*vtab_on_conflict)(sqlite3*)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 546>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "menu.h",
        linedef = 69,
        name = "tagITEM",
        structs = <table 1>,
        typedef = 1,
        typedname = "ITEM",
        vars = {
          add = <function 547>,
          init = <function 548>,
          list = { {
              fpointer = 0,
              name = "name",
              pointer = 0,
              s = 0,
              t = 0,
              type = "TEXT"
            }, {
              fpointer = 0,
              name = "description",
              pointer = 0,
              s = 0,
              t = 0,
              type = "TEXT"
            }, {
              fpointer = 0,
              name = "*imenu",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct tagMENU"
            }, {
              fpointer = 0,
              name = "*userptr",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "opt",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Item_Options"
            }, {
              fpointer = 0,
              name = "index",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "y",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "x",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "value",
              pointer = 0,
              s = 0,
              t = 0,
              type = "bool"
            }, {
              fpointer = 0,
              name = "*left",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct tagITEM"
            }, {
              fpointer = 0,
              name = "*right",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct tagITEM"
            }, {
              fpointer = 0,
              name = "*up",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct tagITEM"
            }, {
              fpointer = 0,
              name = "*down",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct tagITEM"
            } },
          print = <function 549>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "menu.h",
        linedef = 90,
        name = "tagMENU",
        structs = <table 1>,
        typedef = 1,
        typedname = "MENU",
        vars = {
          add = <function 550>,
          init = <function 551>,
          list = { {
              fpointer = 0,
              name = "height",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "width",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "rows",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "cols",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "frows",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "fcols",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "arows",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "namelen",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "desclen",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "marklen",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "itemlen",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "spc_desc",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "spc_cols",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "spc_rows",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "*pattern",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "pindex",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "*win",
              pointer = 1,
              s = 0,
              t = 0,
              type = "WINDOW"
            }, {
              fpointer = 0,
              name = "*sub",
              pointer = 1,
              s = 0,
              t = 0,
              type = "WINDOW"
            }, {
              fpointer = 0,
              name = "*userwin",
              pointer = 1,
              s = 0,
              t = 0,
              type = "WINDOW"
            }, {
              fpointer = 0,
              name = "*usersub",
              pointer = 1,
              s = 0,
              t = 0,
              type = "WINDOW"
            }, {
              fpointer = 0,
              name = "**items",
              pointer = 1,
              s = 1,
              t = 0,
              type = "ITEM"
            }, {
              fpointer = 0,
              name = "nitems",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "*curitem",
              pointer = 1,
              s = 1,
              t = 0,
              type = "ITEM"
            }, {
              fpointer = 0,
              name = "toprow",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "fore",
              pointer = 0,
              s = 0,
              t = 0,
              type = "chtype"
            }, {
              fpointer = 0,
              name = "back",
              pointer = 0,
              s = 0,
              t = 0,
              type = "chtype"
            }, {
              fpointer = 0,
              name = "grey",
              pointer = 0,
              s = 0,
              t = 0,
              type = "chtype"
            }, {
              fpointer = 0,
              name = "pad",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned char"
            }, {
              fpointer = 0,
              name = "menuinit",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Menu_Hook"
            }, {
              fpointer = 0,
              name = "menuterm",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Menu_Hook"
            }, {
              fpointer = 0,
              name = "iteminit",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Menu_Hook"
            }, {
              fpointer = 0,
              name = "itemterm",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Menu_Hook"
            }, {
              fpointer = 0,
              name = "*userptr",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "*mark",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "opt",
              pointer = 0,
              s = 0,
              t = 0,
              type = "Menu_Options"
            }, {
              fpointer = 0,
              name = "status",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned short"
            } },
          print = <function 552>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "lber.h",
        linedef = 126,
        name = "lber_memory_fns",
        structs = <table 1>,
        typedef = 1,
        typedname = "BerMemoryFunctions",
        vars = {
          add = <function 553>,
          init = <function 554>,
          list = { {
              fpointer = 0,
              name = "*bmf_malloc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "BER_MEMALLOC_FN"
            }, {
              fpointer = 0,
              name = "*bmf_calloc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "BER_MEMCALLOC_FN"
            }, {
              fpointer = 0,
              name = "*bmf_realloc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "BER_MEMREALLOC_FN"
            }, {
              fpointer = 0,
              name = "*bmf_free",
              pointer = 1,
              s = 0,
              t = 0,
              type = "BER_MEMFREE_FN"
            } },
          print = <function 555>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "lber.h",
        linedef = 177,
        name = "sockbuf_io_desc",
        structs = <table 1>,
        typedef = 1,
        typedname = "Sockbuf_IO_Desc",
        vars = {
          add = <function 556>,
          init = <function 557>,
          list = { {
              fpointer = 0,
              name = "sbiod_level",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*sbiod_sb",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Sockbuf"
            }, {
              fpointer = 0,
              name = "*sbiod_io",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Sockbuf_IO"
            }, {
              fpointer = 0,
              name = "*sbiod_pvt",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "*sbiod_next",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct sockbuf_io_desc"
            } },
          print = <function 558>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "lber.h",
        linedef = 186,
        name = "sockbuf_io",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 559>,
          init = <function 560>,
          list = { {
              fpointer = 1,
              name = "(*sbi_setup)( Sockbuf_IO_Desc *sbiod, void *arg )",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*sbi_remove)( Sockbuf_IO_Desc *sbiod )",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*sbi_ctrl)( Sockbuf_IO_Desc *sbiod, int opt, void *arg)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = ")",
              pointer = 0,
              s = 0,
              t = 0,
              type = "ber_len_t len"
            }, {
              fpointer = 0,
              name = ")",
              pointer = 0,
              s = 0,
              t = 0,
              type = "ber_len_t len"
            }, {
              fpointer = 1,
              name = "(*sbi_close)( Sockbuf_IO_Desc *sbiod )",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 561>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "lber.h",
        linedef = 212,
        name = "berval",
        structs = <table 1>,
        typedef = 1,
        typedname = "BerValue",
        vars = {
          add = <function 562>,
          init = <function 563>,
          list = { {
              fpointer = 0,
              name = "bv_len",
              pointer = 0,
              s = 0,
              t = 0,
              type = "ber_len_t"
            }, {
              fpointer = 0,
              name = "*bv_val",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            } },
          print = <function 564>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "com_err.h",
        linedef = 69,
        name = "error_table",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 565>,
          init = <function 566>,
          list = { {
              fpointer = 0,
              name = "* const * const messages",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 0,
              name = "base",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int32_t"
            }, {
              fpointer = 0,
              name = "count",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int32_t"
            } },
          print = <function 567>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "resolv.h",
        linedef = 148,
        name = "res_sym",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 568>,
          init = <function 569>,
          list = { {
              fpointer = 0,
              name = "number",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*\tname",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 0,
              name = "*\thumanname",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            } },
          print = <function 570>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "resolv.h",
        linedef = 175,
        name = "__res_state",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 571>,
          init = <function 572>,
          list = { {
              fpointer = 0,
              name = "retrans",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "retry",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "options",
              pointer = 0,
              s = 0,
              t = 0,
              type = "u_int"
            }, {
              fpointer = 0,
              name = "options",
              pointer = 0,
              s = 0,
              t = 0,
              type = "u_long"
            }, {
              fpointer = 0,
              name = "nscount",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "nsaddr_list[MAXNS]",
              pointer = 0,
              s = 0,
              t = 1,
              type = ""
            }, {
              fpointer = 0,
              name = "id",
              pointer = 0,
              s = 0,
              t = 0,
              type = "u_short"
            }, {
              fpointer = 0,
              name = "*dnsrch[MAXDNSRCH+1]",
              pointer = 1,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "defdname[256]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "pfcode",
              pointer = 0,
              s = 0,
              t = 0,
              type = "u_int"
            }, {
              fpointer = 0,
              name = "pfcode",
              pointer = 0,
              s = 0,
              t = 0,
              type = "u_long"
            }, {
              fpointer = 0,
              name = "ndots:4",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned"
            }, {
              fpointer = 0,
              name = "nsort:4",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned"
            }, {
              fpointer = 0,
              name = "unused[3]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "addr",
              pointer = 0,
              s = 1,
              t = 0,
              type = "struct in_addr"
            }, {
              fpointer = 0,
              name = "mask",
              pointer = 0,
              s = 0,
              t = 0,
              type = "u_int32_t"
            } },
          print = <function 573>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "resolv.h",
        linedef = 184,
        name = "sockaddr_in",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 574>,
          init = <function 575>,
          list = { {
              fpointer = 0,
              name = "nsaddr_list[MAXNS]",
              pointer = 0,
              s = 0,
              t = 1,
              type = ""
            }, {
              fpointer = 0,
              name = "id",
              pointer = 0,
              s = 0,
              t = 0,
              type = "u_short"
            }, {
              fpointer = 0,
              name = "*dnsrch[MAXDNSRCH+1]",
              pointer = 1,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "defdname[256]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "pfcode",
              pointer = 0,
              s = 0,
              t = 0,
              type = "u_int"
            }, {
              fpointer = 0,
              name = "pfcode",
              pointer = 0,
              s = 0,
              t = 0,
              type = "u_long"
            }, {
              fpointer = 0,
              name = "ndots:4",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned"
            }, {
              fpointer = 0,
              name = "nsort:4",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned"
            }, {
              fpointer = 0,
              name = "unused[3]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "addr",
              pointer = 0,
              s = 1,
              t = 0,
              type = "struct in_addr"
            }, {
              fpointer = 0,
              name = "mask",
              pointer = 0,
              s = 0,
              t = 0,
              type = "u_int32_t"
            } },
          print = <function 576>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ranlib.h",
        linedef = 94,
        name = "ranlib",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 577>,
          init = <function 578>,
          list = { {
              fpointer = 0,
              name = "ran_strx",
              pointer = 0,
              s = 0,
              t = 0,
              type = "off_t"
            }, {
              fpointer = 0,
              name = "*ran_name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            } },
          print = <function 579>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "bootparams.h",
        linedef = 39,
        name = "bootparamsent",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 580>,
          init = <function 581>,
          list = { {
              fpointer = 0,
              name = "*bp_name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**bp_bootparams",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            } },
          print = <function 582>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ldap_schema.h",
        linedef = 43,
        name = "ldap_schema_extension_item",
        structs = <table 1>,
        typedef = 1,
        typedname = "LDAPSchemaExtensionItem",
        vars = {
          add = <function 583>,
          init = <function 584>,
          list = { {
              fpointer = 0,
              name = "*lsei_name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**lsei_values",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            } },
          print = <function 585>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ldap_schema.h",
        linedef = 48,
        name = "ldap_syntax",
        structs = <table 1>,
        typedef = 1,
        typedname = "LDAPSyntax",
        vars = {
          add = <function 586>,
          init = <function 587>,
          list = { {
              fpointer = 0,
              name = "*syn_oid",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**syn_names",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*syn_desc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**syn_extensions",
              pointer = 1,
              s = 1,
              t = 0,
              type = "LDAPSchemaExtensionItem"
            } },
          print = <function 588>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ldap_schema.h",
        linedef = 55,
        name = "ldap_matchingrule",
        structs = <table 1>,
        typedef = 1,
        typedname = "LDAPMatchingRule",
        vars = {
          add = <function 589>,
          init = <function 590>,
          list = { {
              fpointer = 0,
              name = "*mr_oid",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**mr_names",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*mr_desc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "mr_obsolete",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*mr_syntax_oid",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**mr_extensions",
              pointer = 1,
              s = 1,
              t = 0,
              type = "LDAPSchemaExtensionItem"
            } },
          print = <function 591>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ldap_schema.h",
        linedef = 64,
        name = "ldap_matchingruleuse",
        structs = <table 1>,
        typedef = 1,
        typedname = "LDAPMatchingRuleUse",
        vars = {
          add = <function 592>,
          init = <function 593>,
          list = { {
              fpointer = 0,
              name = "*mru_oid",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**mru_names",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*mru_desc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "mru_obsolete",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "**mru_applies_oids",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**mru_extensions",
              pointer = 1,
              s = 1,
              t = 0,
              type = "LDAPSchemaExtensionItem"
            } },
          print = <function 594>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ldap_schema.h",
        linedef = 73,
        name = "ldap_attributetype",
        structs = <table 1>,
        typedef = 1,
        typedname = "LDAPAttributeType",
        vars = {
          add = <function 595>,
          init = <function 596>,
          list = { {
              fpointer = 0,
              name = "*at_oid",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**at_names",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*at_desc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "at_obsolete",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*at_sup_oid",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*at_equality_oid",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*at_ordering_oid",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*at_substr_oid",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*at_syntax_oid",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "at_syntax_len",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "at_single_value",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "at_collective",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "at_no_user_mod",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "at_usage",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "**at_extensions",
              pointer = 1,
              s = 1,
              t = 0,
              type = "LDAPSchemaExtensionItem"
            } },
          print = <function 597>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ldap_schema.h",
        linedef = 92,
        name = "ldap_objectclass",
        structs = <table 1>,
        typedef = 1,
        typedname = "LDAPObjectClass",
        vars = {
          add = <function 598>,
          init = <function 599>,
          list = { {
              fpointer = 0,
              name = "*oc_oid",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**oc_names",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*oc_desc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "oc_obsolete",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "**oc_sup_oids",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "oc_kind",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "**oc_at_oids_must",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**oc_at_oids_may",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**oc_extensions",
              pointer = 1,
              s = 1,
              t = 0,
              type = "LDAPSchemaExtensionItem"
            } },
          print = <function 600>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ldap_schema.h",
        linedef = 104,
        name = "ldap_contentrule",
        structs = <table 1>,
        typedef = 1,
        typedname = "LDAPContentRule",
        vars = {
          add = <function 601>,
          init = <function 602>,
          list = { {
              fpointer = 0,
              name = "*cr_oid",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**cr_names",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*cr_desc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**cr_sup_oids",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "cr_obsolete",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "**cr_oc_oids_aux",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**cr_at_oids_must",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**cr_at_oids_may",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**cr_at_oids_not",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**cr_extensions",
              pointer = 1,
              s = 1,
              t = 0,
              type = "LDAPSchemaExtensionItem"
            } },
          print = <function 603>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ldap_schema.h",
        linedef = 117,
        name = "ldap_nameform",
        structs = <table 1>,
        typedef = 1,
        typedname = "LDAPNameForm",
        vars = {
          add = <function 604>,
          init = <function 605>,
          list = { {
              fpointer = 0,
              name = "*nf_oid",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**nf_names",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*nf_desc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "nf_obsolete",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*nf_objectclass",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**nf_at_oids_must",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**nf_at_oids_may",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**nf_extensions",
              pointer = 1,
              s = 1,
              t = 0,
              type = "LDAPSchemaExtensionItem"
            } },
          print = <function 606>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ldap_schema.h",
        linedef = 128,
        name = "ldap_structurerule",
        structs = <table 1>,
        typedef = 1,
        typedname = "LDAPStructureRule",
        vars = {
          add = <function 607>,
          init = <function 608>,
          list = { {
              fpointer = 0,
              name = "sr_ruleid",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "**sr_names",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*sr_desc",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "sr_obsolete",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*sr_nameform",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "sr_nsup_ruleids",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*sr_sup_ruleids",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "**sr_extensions",
              pointer = 1,
              s = 1,
              t = 0,
              type = "LDAPSchemaExtensionItem"
            } },
          print = <function 609>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "tkIntXlibDecls.h",
        linedef = 1194,
        name = "TkIntXlibStubs",
        structs = <table 1>,
        typedef = 1,
        typedname = "TkIntXlibStubs",
        vars = {
          add = <function 610>,
          init = <function 611>,
          list = { {
              fpointer = 0,
              name = "magic",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*hooks",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct TkIntXlibStubHooks"
            }, {
              fpointer = 1,
              name = "(*xSetDashes) (Display *display, GC gc, int dash_offset, _Xconst char *dash_list, int n)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*xGetModifierMapping) (Display *d)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "XModifierKeymap"
            }, {
              fpointer = 1,
              name = "* (*xCreateImage) (Display *d, Visual *v, unsigned int ui1, int i1, int i2, char *cp, unsigned int ui2, unsigned int ui3, int i3, int i4)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "XImage"
            }, {
              fpointer = 1,
              name = "* (*xGetImage) (Display *d, Drawable dr, int i1, int i2, unsigned int ui1, unsigned int ui2, unsigned long ul, int i3)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "XImage"
            }, {
              fpointer = 1,
              name = "* (*xGetAtomName) (Display *d, Atom a)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "* (*xKeysymToString) (KeySym k)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "(*xCreateColormap) (Display *d, Window w, Visual *v, int i)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Colormap"
            }, {
              fpointer = 1,
              name = "(*xCreatePixmapCursor) (Display *d, Pixmap p1, Pixmap p2, XColor *x1, XColor *x2, unsigned int ui1, unsigned int ui2)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Cursor"
            }, {
              fpointer = 1,
              name = "(*xCreateGlyphCursor) (Display *d, Font f1, Font f2, unsigned int ui1, unsigned int ui2, XColor *x1, XColor *x2)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Cursor"
            }, {
              fpointer = 1,
              name = "(*xGContextFromGC) (GC g)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "GContext"
            }, {
              fpointer = 1,
              name = "* (*xListHosts) (Display *d, int *i, Bool *b)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "XHostAddress"
            }, {
              fpointer = 1,
              name = "(*xKeycodeToKeysym) (Display *d, unsigned int k, int i)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "KeySym"
            }, {
              fpointer = 1,
              name = "(*xStringToKeysym) (_Xconst char *c)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "KeySym"
            }, {
              fpointer = 1,
              name = "(*xRootWindow) (Display *d, int i)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Window"
            }, {
              fpointer = 1,
              name = "(*xSetErrorHandler) (XErrorHandler x)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "XErrorHandler"
            }, {
              fpointer = 1,
              name = "(*xIconifyWindow) (Display *d, Window w, int i)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Status"
            }, {
              fpointer = 1,
              name = "(*xWithdrawWindow) (Display *d, Window w, int i)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Status"
            }, {
              fpointer = 1,
              name = "(*xGetWMColormapWindows) (Display *d, Window w, Window **wpp, int *ip)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Status"
            }, {
              fpointer = 1,
              name = "(*xAllocColor) (Display *d, Colormap c, XColor *xp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Status"
            }, {
              fpointer = 1,
              name = "(*xBell) (Display *d, int i)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xChangeProperty) (Display *d, Window w, Atom a1, Atom a2, int i1, int i2, _Xconst unsigned char *c, int i3)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xChangeWindowAttributes) (Display *d, Window w, unsigned long ul, XSetWindowAttributes *x)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xClearWindow) (Display *d, Window w)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xConfigureWindow) (Display *d, Window w, unsigned int i, XWindowChanges *x)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xCopyArea) (Display *d, Drawable dr1, Drawable dr2, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xCopyPlane) (Display *d, Drawable dr1, Drawable dr2, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4, unsigned long ul)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xCreateBitmapFromData) (Display *display, Drawable d, _Xconst char *data, unsigned int width, unsigned int height)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Pixmap"
            }, {
              fpointer = 1,
              name = "(*xDefineCursor) (Display *d, Window w, Cursor c)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xDeleteProperty) (Display *d, Window w, Atom a)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xDestroyWindow) (Display *d, Window w)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xDrawArc) (Display *d, Drawable dr, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xDrawLines) (Display *d, Drawable dr, GC g, XPoint *x, int i1, int i2)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xDrawRectangle) (Display *d, Drawable dr, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xFillArc) (Display *d, Drawable dr, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xFillPolygon) (Display *d, Drawable dr, GC g, XPoint *x, int i1, int i2, int i3)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xFillRectangles) (Display *d, Drawable dr, GC g, XRectangle *x, int i)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xForceScreenSaver) (Display *d, int i)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xFreeColormap) (Display *d, Colormap c)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xFreeColors) (Display *d, Colormap c, unsigned long *ulp, int i, unsigned long ul)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xFreeCursor) (Display *d, Cursor c)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xFreeModifiermap) (XModifierKeymap *x)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xGetGeometry) (Display *d, Drawable dr, Window *w, int *i1, int *i2, unsigned int *ui1, unsigned int *ui2, unsigned int *ui3, unsigned int *ui4)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Status"
            }, {
              fpointer = 1,
              name = "(*xGetInputFocus) (Display *d, Window *w, int *i)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xGetWindowProperty) (Display *d, Window w, Atom a1, long l1, long l2, Bool b, Atom a2, Atom *ap, int *ip, unsigned long *ulp1, unsigned long *ulp2, unsigned char **cpp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xGetWindowAttributes) (Display *d, Window w, XWindowAttributes *x)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Status"
            }, {
              fpointer = 1,
              name = "(*xGrabKeyboard) (Display *d, Window w, Bool b, int i1, int i2, Time t)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xGrabPointer) (Display *d, Window w1, Bool b, unsigned int ui, int i1, int i2, Window w2, Cursor c, Time t)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xKeysymToKeycode) (Display *d, KeySym k)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "KeyCode"
            }, {
              fpointer = 1,
              name = "(*xLookupColor) (Display *d, Colormap c1, _Xconst char *c2, XColor *x1, XColor *x2)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Status"
            }, {
              fpointer = 1,
              name = "(*xMapWindow) (Display *d, Window w)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xMoveResizeWindow) (Display *d, Window w, int i1, int i2, unsigned int ui1, unsigned int ui2)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xMoveWindow) (Display *d, Window w, int i1, int i2)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xNextEvent) (Display *d, XEvent *x)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xPutBackEvent) (Display *d, XEvent *x)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xQueryColors) (Display *d, Colormap c, XColor *x, int i)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xQueryPointer) (Display *d, Window w1, Window *w2, Window *w3, int *i1, int *i2, int *i3, int *i4, unsigned int *ui)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Bool"
            }, {
              fpointer = 1,
              name = "(*xQueryTree) (Display *d, Window w1, Window *w2, Window *w3, Window **w4, unsigned int *ui)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Status"
            }, {
              fpointer = 1,
              name = "(*xRaiseWindow) (Display *d, Window w)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xRefreshKeyboardMapping) (XMappingEvent *x)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xResizeWindow) (Display *d, Window w, unsigned int ui1, unsigned int ui2)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSelectInput) (Display *d, Window w, long l)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSendEvent) (Display *d, Window w, Bool b, long l, XEvent *x)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Status"
            }, {
              fpointer = 1,
              name = "(*xSetCommand) (Display *d, Window w, CONST char **c, int i)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetIconName) (Display *d, Window w, _Xconst char *c)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetInputFocus) (Display *d, Window w, int i, Time t)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetSelectionOwner) (Display *d, Atom a, Window w, Time t)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetWindowBackground) (Display *d, Window w, unsigned long ul)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetWindowBackgroundPixmap) (Display *d, Window w, Pixmap p)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetWindowBorder) (Display *d, Window w, unsigned long ul)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetWindowBorderPixmap) (Display *d, Window w, Pixmap p)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetWindowBorderWidth) (Display *d, Window w, unsigned int ui)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetWindowColormap) (Display *d, Window w, Colormap c)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xTranslateCoordinates) (Display *d, Window w1, Window w2, int i1, int i2, int *i3, int *i4, Window *w3)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Bool"
            }, {
              fpointer = 1,
              name = "(*xUngrabKeyboard) (Display *d, Time t)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xUngrabPointer) (Display *d, Time t)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xUnmapWindow) (Display *d, Window w)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xWindowEvent) (Display *d, Window w, long l, XEvent *x)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xDestroyIC) (XIC x)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xFilterEvent) (XEvent *x, Window w)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Bool"
            }, {
              fpointer = 1,
              name = "(*xmbLookupString) (XIC xi, XKeyPressedEvent *xk, char *c, int i, KeySym *k, Status *s)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*tkPutImage) (unsigned long *colors, int ncolors, Display *display, Drawable d, GC gc, XImage *image, int src_x, int src_y, int dest_x, int dest_y, unsigned int width, unsigned int height)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "*reserved81",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xParseColor) (Display *display, Colormap map, _Xconst char *spec, XColor *colorPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Status"
            }, {
              fpointer = 1,
              name = "(*xCreateGC) (Display *display, Drawable d, unsigned long valuemask, XGCValues *values)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "GC"
            }, {
              fpointer = 1,
              name = "(*xFreeGC) (Display *display, GC gc)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xInternAtom) (Display *display, _Xconst char *atom_name, Bool only_if_exists)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Atom"
            }, {
              fpointer = 1,
              name = "(*xSetBackground) (Display *display, GC gc, unsigned long foreground)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetForeground) (Display *display, GC gc, unsigned long foreground)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetClipMask) (Display *display, GC gc, Pixmap pixmap)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetClipOrigin) (Display *display, GC gc, int clip_x_origin, int clip_y_origin)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetTSOrigin) (Display *display, GC gc, int ts_x_origin, int ts_y_origin)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xChangeGC) (Display *d, GC gc, unsigned long mask, XGCValues *values)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetFont) (Display *display, GC gc, Font font)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetArcMode) (Display *display, GC gc, int arc_mode)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetStipple) (Display *display, GC gc, Pixmap stipple)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetFillRule) (Display *display, GC gc, int fill_rule)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetFillStyle) (Display *display, GC gc, int fill_style)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetFunction) (Display *display, GC gc, int function)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetLineAttributes) (Display *display, GC gc, unsigned int line_width, int line_style, int cap_style, int join_style)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*_XInitImageFuncPtrs) (XImage *image)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xCreateIC) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "XIC"
            }, {
              fpointer = 1,
              name = "* (*xGetVisualInfo) (Display *display, long vinfo_mask, XVisualInfo *vinfo_template, int *nitems_return)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "XVisualInfo"
            }, {
              fpointer = 1,
              name = "(*xSetWMClientMachine) (Display *display, Window w, XTextProperty *text_prop)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xStringListToTextProperty) (char **list, int count, XTextProperty *text_prop_return)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Status"
            }, {
              fpointer = 1,
              name = "(*xDrawLine) (Display *d, Drawable dr, GC g, int x1, int y1, int x2, int y2)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xWarpPointer) (Display *d, Window s, Window dw, int sx, int sy, unsigned int sw, unsigned int sh, int dx, int dy)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xFillRectangle) (Display *display, Drawable d, GC gc, int x, int y, unsigned int width, unsigned int height)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetDashes) (Display *display, GC gc, int dash_offset, _Xconst char *dash_list, int n)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "* (*xGetModifierMapping) (Display *d)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "XModifierKeymap"
            }, {
              fpointer = 1,
              name = "* (*xCreateImage) (Display *d, Visual *v, unsigned int ui1, int i1, int i2, char *cp, unsigned int ui2, unsigned int ui3, int i3, int i4)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "XImage"
            }, {
              fpointer = 1,
              name = "* (*xGetImage) (Display *d, Drawable dr, int i1, int i2, unsigned int ui1, unsigned int ui2, unsigned long ul, int i3)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "XImage"
            }, {
              fpointer = 1,
              name = "* (*xGetAtomName) (Display *d, Atom a)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "* (*xKeysymToString) (KeySym k)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 1,
              name = "(*xCreateColormap) (Display *d, Window w, Visual *v, int i)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Colormap"
            }, {
              fpointer = 1,
              name = "(*xGContextFromGC) (GC g)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "GContext"
            }, {
              fpointer = 1,
              name = "(*xKeycodeToKeysym) (Display *d, KeyCode k, int i)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "KeySym"
            }, {
              fpointer = 1,
              name = "(*xStringToKeysym) (_Xconst char *c)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "KeySym"
            }, {
              fpointer = 1,
              name = "(*xRootWindow) (Display *d, int i)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Window"
            }, {
              fpointer = 1,
              name = "(*xSetErrorHandler) (XErrorHandler x)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "XErrorHandler"
            }, {
              fpointer = 1,
              name = "(*xAllocColor) (Display *d, Colormap c, XColor *xp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Status"
            }, {
              fpointer = 1,
              name = "(*xBell) (Display *d, int i)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xChangeProperty) (Display *d, Window w, Atom a1, Atom a2, int i1, int i2, _Xconst unsigned char *c, int i3)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xChangeWindowAttributes) (Display *d, Window w, unsigned long ul, XSetWindowAttributes *x)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xConfigureWindow) (Display *d, Window w, unsigned int i, XWindowChanges *x)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xCopyArea) (Display *d, Drawable dr1, Drawable dr2, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xCopyPlane) (Display *d, Drawable dr1, Drawable dr2, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4, unsigned long ul)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xCreateBitmapFromData) (Display *display, Drawable d, _Xconst char *data, unsigned int width, unsigned int height)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Pixmap"
            }, {
              fpointer = 1,
              name = "(*xDefineCursor) (Display *d, Window w, Cursor c)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xDestroyWindow) (Display *d, Window w)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xDrawArc) (Display *d, Drawable dr, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xDrawLines) (Display *d, Drawable dr, GC g, XPoint *x, int i1, int i2)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xDrawRectangle) (Display *d, Drawable dr, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xFillArc) (Display *d, Drawable dr, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xFillPolygon) (Display *d, Drawable dr, GC g, XPoint *x, int i1, int i2, int i3)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xFillRectangles) (Display *d, Drawable dr, GC g, XRectangle *x, int i)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xFreeColormap) (Display *d, Colormap c)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xFreeColors) (Display *d, Colormap c, unsigned long *ulp, int i, unsigned long ul)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xFreeModifiermap) (XModifierKeymap *x)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xGetGeometry) (Display *d, Drawable dr, Window *w, int *i1, int *i2, unsigned int *ui1, unsigned int *ui2, unsigned int *ui3, unsigned int *ui4)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Status"
            }, {
              fpointer = 1,
              name = "(*xGetWindowProperty) (Display *d, Window w, Atom a1, long l1, long l2, Bool b, Atom a2, Atom *ap, int *ip, unsigned long *ulp1, unsigned long *ulp2, unsigned char **cpp)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xGrabKeyboard) (Display *d, Window w, Bool b, int i1, int i2, Time t)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xGrabPointer) (Display *d, Window w1, Bool b, unsigned int ui, int i1, int i2, Window w2, Cursor c, Time t)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xKeysymToKeycode) (Display *d, KeySym k)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "KeyCode"
            }, {
              fpointer = 1,
              name = "(*xMapWindow) (Display *d, Window w)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xMoveResizeWindow) (Display *d, Window w, int i1, int i2, unsigned int ui1, unsigned int ui2)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xMoveWindow) (Display *d, Window w, int i1, int i2)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xQueryPointer) (Display *d, Window w1, Window *w2, Window *w3, int *i1, int *i2, int *i3, int *i4, unsigned int *ui)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Bool"
            }, {
              fpointer = 1,
              name = "(*xRaiseWindow) (Display *d, Window w)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xRefreshKeyboardMapping) (XMappingEvent *x)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xResizeWindow) (Display *d, Window w, unsigned int ui1, unsigned int ui2)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSelectInput) (Display *d, Window w, long l)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSendEvent) (Display *d, Window w, Bool b, long l, XEvent *x)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Status"
            }, {
              fpointer = 1,
              name = "(*xSetIconName) (Display *d, Window w, _Xconst char *c)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetInputFocus) (Display *d, Window w, int i, Time t)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetSelectionOwner) (Display *d, Atom a, Window w, Time t)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetWindowBackground) (Display *d, Window w, unsigned long ul)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetWindowBackgroundPixmap) (Display *d, Window w, Pixmap p)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetWindowBorder) (Display *d, Window w, unsigned long ul)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetWindowBorderPixmap) (Display *d, Window w, Pixmap p)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetWindowBorderWidth) (Display *d, Window w, unsigned int ui)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetWindowColormap) (Display *d, Window w, Colormap c)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xUngrabKeyboard) (Display *d, Time t)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xUngrabPointer) (Display *d, Time t)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xUnmapWindow) (Display *d, Window w)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*tkPutImage) (unsigned long *colors, int ncolors, Display *display, Drawable d, GC gc, XImage *image, int src_x, int src_y, int dest_x, int dest_y, unsigned int width, unsigned int height)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xParseColor) (Display *display, Colormap map, _Xconst char *spec, XColor *colorPtr)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Status"
            }, {
              fpointer = 1,
              name = "(*xCreateGC) (Display *display, Drawable d, unsigned long valuemask, XGCValues *values)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "GC"
            }, {
              fpointer = 1,
              name = "(*xFreeGC) (Display *display, GC gc)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xInternAtom) (Display *display, _Xconst char *atom_name, Bool only_if_exists)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Atom"
            }, {
              fpointer = 1,
              name = "(*xSetBackground) (Display *display, GC gc, unsigned long foreground)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetForeground) (Display *display, GC gc, unsigned long foreground)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetClipMask) (Display *display, GC gc, Pixmap pixmap)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetClipOrigin) (Display *display, GC gc, int clip_x_origin, int clip_y_origin)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetTSOrigin) (Display *display, GC gc, int ts_x_origin, int ts_y_origin)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xChangeGC) (Display *d, GC gc, unsigned long mask, XGCValues *values)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetFont) (Display *display, GC gc, Font font)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetArcMode) (Display *display, GC gc, int arc_mode)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetStipple) (Display *display, GC gc, Pixmap stipple)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetFillRule) (Display *display, GC gc, int fill_rule)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetFillStyle) (Display *display, GC gc, int fill_style)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetFunction) (Display *display, GC gc, int function)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xSetLineAttributes) (Display *display, GC gc, unsigned int line_width, int line_style, int cap_style, int join_style)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*_XInitImageFuncPtrs) (XImage *image)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*xCreateIC) (void)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "XIC"
            }, {
              fpointer = 1,
              name = "* (*xGetVisualInfo) (Display *display, long vinfo_mask, XVisualInfo *vinfo_template, int *nitems_return)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "XVisualInfo"
            }, {
              fpointer = 1,
              name = "(*xSetWMClientMachine) (Display *display, Window w, XTextProperty *text_prop)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xStringListToTextProperty) (char **list, int count, XTextProperty *text_prop_return)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Status"
            }, {
              fpointer = 1,
              name = "(*xDrawSegments) (Display *display, Drawable d, GC gc, XSegment *segments, int nsegments)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xForceScreenSaver) (Display *display, int mode)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xDrawLine) (Display *d, Drawable dr, GC g, int x1, int y1, int x2, int y2)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xFillRectangle) (Display *display, Drawable d, GC gc, int x, int y, unsigned int width, unsigned int height)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xClearWindow) (Display *d, Window w)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xDrawPoint) (Display *display, Drawable d, GC gc, int x, int y)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xDrawPoints) (Display *display, Drawable d, GC gc, XPoint *points, int npoints, int mode)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xWarpPointer) (Display *display, Window src_w, Window dest_w, int src_x, int src_y, unsigned int src_width, unsigned int src_height, int dest_x, int dest_y)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xQueryColor) (Display *display, Colormap colormap, XColor *def_in_out)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xQueryColors) (Display *display, Colormap colormap, XColor *defs_in_out, int ncolors)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*xQueryTree) (Display *d, Window w1, Window *w2, Window *w3, Window **w4, unsigned int *ui)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "Status"
            }, {
              fpointer = 1,
              name = "(*xSync) (Display *display, Bool flag)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 612>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "curses.h",
        linedef = 365,
        name = "_win_st",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 613>,
          init = <function 614>,
          list = { {
              fpointer = 0,
              name = "_cury, _curx",
              pointer = 0,
              s = 0,
              t = 0,
              type = "NCURSES_SIZE_T"
            }, {
              fpointer = 0,
              name = "_maxy, _maxx",
              pointer = 0,
              s = 0,
              t = 0,
              type = "NCURSES_SIZE_T"
            }, {
              fpointer = 0,
              name = "_begy, _begx",
              pointer = 0,
              s = 0,
              t = 0,
              type = "NCURSES_SIZE_T"
            }, {
              fpointer = 0,
              name = "_flags",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "_attrs",
              pointer = 0,
              s = 0,
              t = 0,
              type = "attr_t"
            }, {
              fpointer = 0,
              name = "_bkgd",
              pointer = 0,
              s = 0,
              t = 0,
              type = "chtype"
            }, {
              fpointer = 0,
              name = "_notimeout",
              pointer = 0,
              s = 0,
              t = 0,
              type = "bool"
            }, {
              fpointer = 0,
              name = "_clear",
              pointer = 0,
              s = 0,
              t = 0,
              type = "bool"
            }, {
              fpointer = 0,
              name = "_leaveok",
              pointer = 0,
              s = 0,
              t = 0,
              type = "bool"
            }, {
              fpointer = 0,
              name = "_scroll",
              pointer = 0,
              s = 0,
              t = 0,
              type = "bool"
            }, {
              fpointer = 0,
              name = "_idlok",
              pointer = 0,
              s = 0,
              t = 0,
              type = "bool"
            }, {
              fpointer = 0,
              name = "_idcok",
              pointer = 0,
              s = 0,
              t = 0,
              type = "bool"
            }, {
              fpointer = 0,
              name = "_immed",
              pointer = 0,
              s = 0,
              t = 0,
              type = "bool"
            }, {
              fpointer = 0,
              name = "_sync",
              pointer = 0,
              s = 0,
              t = 0,
              type = "bool"
            }, {
              fpointer = 0,
              name = "_use_keypad",
              pointer = 0,
              s = 0,
              t = 0,
              type = "bool"
            }, {
              fpointer = 0,
              name = "_delay",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*_line",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct ldat"
            }, {
              fpointer = 0,
              name = "_regtop",
              pointer = 0,
              s = 0,
              t = 0,
              type = "NCURSES_SIZE_T"
            }, {
              fpointer = 0,
              name = "_regbottom",
              pointer = 0,
              s = 0,
              t = 0,
              type = "NCURSES_SIZE_T"
            }, {
              fpointer = 0,
              name = "_parx",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "_pary",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*_parent",
              pointer = 1,
              s = 0,
              t = 0,
              type = "WINDOW"
            }, {
              fpointer = 0,
              name = "_pad_y,      _pad_x",
              pointer = 0,
              s = 0,
              t = 0,
              type = "NCURSES_SIZE_T"
            }, {
              fpointer = 0,
              name = "_pad_top,    _pad_left",
              pointer = 0,
              s = 0,
              t = 0,
              type = "NCURSES_SIZE_T"
            }, {
              fpointer = 0,
              name = "_pad_bottom, _pad_right",
              pointer = 0,
              s = 0,
              t = 0,
              type = "NCURSES_SIZE_T"
            } },
          print = <function 615>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "curses.h",
        linedef = 403,
        name = "pdat",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 616>,
          init = <function 617>,
          list = { {
              fpointer = 0,
              name = "_pad_y,      _pad_x",
              pointer = 0,
              s = 0,
              t = 0,
              type = "NCURSES_SIZE_T"
            }, {
              fpointer = 0,
              name = "_pad_top,    _pad_left",
              pointer = 0,
              s = 0,
              t = 0,
              type = "NCURSES_SIZE_T"
            }, {
              fpointer = 0,
              name = "_pad_bottom, _pad_right",
              pointer = 0,
              s = 0,
              t = 0,
              type = "NCURSES_SIZE_T"
            } },
          print = <function 618>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "netdb.h",
        linedef = 112,
        name = "hostent",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 619>,
          init = <function 620>,
          list = { {
              fpointer = 0,
              name = "*h_name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**h_aliases",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "h_addrtype",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "h_length",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "**h_addr_list",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            } },
          print = <function 621>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "netdb.h",
        linedef = 127,
        name = "netent",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 622>,
          init = <function 623>,
          list = { {
              fpointer = 0,
              name = "*n_name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**n_aliases",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "n_addrtype",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "n_net",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uint32_t"
            } },
          print = <function 624>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "netdb.h",
        linedef = 134,
        name = "servent",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 625>,
          init = <function 626>,
          list = { {
              fpointer = 0,
              name = "*s_name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**s_aliases",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "s_port",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*s_proto",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            } },
          print = <function 627>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "netdb.h",
        linedef = 141,
        name = "protoent",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 628>,
          init = <function 629>,
          list = { {
              fpointer = 0,
              name = "*p_name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**p_aliases",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "p_proto",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 630>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "netdb.h",
        linedef = 147,
        name = "addrinfo",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 631>,
          init = <function 632>,
          list = { {
              fpointer = 0,
              name = "ai_flags",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "ai_family",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "ai_socktype",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "ai_protocol",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "ai_addrlen",
              pointer = 0,
              s = 0,
              t = 0,
              type = "socklen_t"
            }, {
              fpointer = 0,
              name = "*ai_canonname",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*ai_addr",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct\tsockaddr"
            }, {
              fpointer = 0,
              name = "*ai_next",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct\taddrinfo"
            } },
          print = <function 633>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "netdb.h",
        linedef = 159,
        name = "rpcent",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 634>,
          init = <function 635>,
          list = { {
              fpointer = 0,
              name = "*r_name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "**r_aliases",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "r_number",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 636>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "histedit.h",
        linedef = 62,
        name = "lineinfo",
        structs = <table 1>,
        typedef = 1,
        typedname = "LineInfo",
        vars = {
          add = <function 637>,
          init = <function 638>,
          list = { {
              fpointer = 0,
              name = "*buffer",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 0,
              name = "*cursor",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            }, {
              fpointer = 0,
              name = "*lastchar",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            } },
          print = <function 639>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "histedit.h",
        linedef = 186,
        name = "HistEvent",
        structs = <table 1>,
        typedef = 1,
        typedname = "HistEvent",
        vars = {
          add = <function 640>,
          init = <function 641>,
          list = { {
              fpointer = 0,
              name = "num",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*str",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const char"
            } },
          print = <function 642>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "histedit.h",
        linedef = 265,
        name = "lineinfow",
        structs = <table 1>,
        typedef = 1,
        typedname = "LineInfoW",
        vars = {
          add = <function 643>,
          init = <function 644>,
          list = { {
              fpointer = 0,
              name = "*buffer",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const wchar_t"
            }, {
              fpointer = 0,
              name = "*cursor",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const wchar_t"
            }, {
              fpointer = 0,
              name = "*lastchar",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const wchar_t"
            } },
          print = <function 645>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "histedit.h",
        linedef = 287,
        name = "histeventW",
        structs = <table 1>,
        typedef = 1,
        typedname = "HistEventW",
        vars = {
          add = <function 646>,
          init = <function 647>,
          list = { {
              fpointer = 0,
              name = "num",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*str",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const wchar_t"
            } },
          print = <function 648>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "db.h",
        linedef = 101,
        name = "__db",
        structs = <table 1>,
        typedef = 1,
        typedname = "DB",
        vars = {
          add = <function 649>,
          init = <function 650>,
          list = { {
              fpointer = 0,
              name = "type",
              pointer = 0,
              s = 0,
              t = 0,
              type = "DBTYPE"
            }, {
              fpointer = 1,
              name = "(*close)(struct __db *)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*del)(const struct __db *, const DBT *, unsigned int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*get)(const struct __db *, const DBT *, DBT *, unsigned int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*put)(const struct __db *, DBT *, const DBT *, unsigned int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*seq)(const struct __db *, DBT *, DBT *, unsigned int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*sync)(const struct __db *, unsigned int)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*internal",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*fd)(const struct __db *)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 651>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ncurses.h",
        linedef = 365,
        name = "_win_st",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 652>,
          init = <function 653>,
          list = { {
              fpointer = 0,
              name = "_cury, _curx",
              pointer = 0,
              s = 0,
              t = 0,
              type = "NCURSES_SIZE_T"
            }, {
              fpointer = 0,
              name = "_maxy, _maxx",
              pointer = 0,
              s = 0,
              t = 0,
              type = "NCURSES_SIZE_T"
            }, {
              fpointer = 0,
              name = "_begy, _begx",
              pointer = 0,
              s = 0,
              t = 0,
              type = "NCURSES_SIZE_T"
            }, {
              fpointer = 0,
              name = "_flags",
              pointer = 0,
              s = 0,
              t = 0,
              type = "short"
            }, {
              fpointer = 0,
              name = "_attrs",
              pointer = 0,
              s = 0,
              t = 0,
              type = "attr_t"
            }, {
              fpointer = 0,
              name = "_bkgd",
              pointer = 0,
              s = 0,
              t = 0,
              type = "chtype"
            }, {
              fpointer = 0,
              name = "_notimeout",
              pointer = 0,
              s = 0,
              t = 0,
              type = "bool"
            }, {
              fpointer = 0,
              name = "_clear",
              pointer = 0,
              s = 0,
              t = 0,
              type = "bool"
            }, {
              fpointer = 0,
              name = "_leaveok",
              pointer = 0,
              s = 0,
              t = 0,
              type = "bool"
            }, {
              fpointer = 0,
              name = "_scroll",
              pointer = 0,
              s = 0,
              t = 0,
              type = "bool"
            }, {
              fpointer = 0,
              name = "_idlok",
              pointer = 0,
              s = 0,
              t = 0,
              type = "bool"
            }, {
              fpointer = 0,
              name = "_idcok",
              pointer = 0,
              s = 0,
              t = 0,
              type = "bool"
            }, {
              fpointer = 0,
              name = "_immed",
              pointer = 0,
              s = 0,
              t = 0,
              type = "bool"
            }, {
              fpointer = 0,
              name = "_sync",
              pointer = 0,
              s = 0,
              t = 0,
              type = "bool"
            }, {
              fpointer = 0,
              name = "_use_keypad",
              pointer = 0,
              s = 0,
              t = 0,
              type = "bool"
            }, {
              fpointer = 0,
              name = "_delay",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*_line",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct ldat"
            }, {
              fpointer = 0,
              name = "_regtop",
              pointer = 0,
              s = 0,
              t = 0,
              type = "NCURSES_SIZE_T"
            }, {
              fpointer = 0,
              name = "_regbottom",
              pointer = 0,
              s = 0,
              t = 0,
              type = "NCURSES_SIZE_T"
            }, {
              fpointer = 0,
              name = "_parx",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "_pary",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*_parent",
              pointer = 1,
              s = 0,
              t = 0,
              type = "WINDOW"
            }, {
              fpointer = 0,
              name = "_pad_y,      _pad_x",
              pointer = 0,
              s = 0,
              t = 0,
              type = "NCURSES_SIZE_T"
            }, {
              fpointer = 0,
              name = "_pad_top,    _pad_left",
              pointer = 0,
              s = 0,
              t = 0,
              type = "NCURSES_SIZE_T"
            }, {
              fpointer = 0,
              name = "_pad_bottom, _pad_right",
              pointer = 0,
              s = 0,
              t = 0,
              type = "NCURSES_SIZE_T"
            } },
          print = <function 654>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "ncurses.h",
        linedef = 403,
        name = "pdat",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 655>,
          init = <function 656>,
          list = { {
              fpointer = 0,
              name = "_pad_y,      _pad_x",
              pointer = 0,
              s = 0,
              t = 0,
              type = "NCURSES_SIZE_T"
            }, {
              fpointer = 0,
              name = "_pad_top,    _pad_left",
              pointer = 0,
              s = 0,
              t = 0,
              type = "NCURSES_SIZE_T"
            }, {
              fpointer = 0,
              name = "_pad_bottom, _pad_right",
              pointer = 0,
              s = 0,
              t = 0,
              type = "NCURSES_SIZE_T"
            } },
          print = <function 657>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "nameser.h",
        linedef = 120,
        name = "__ns_msg",
        structs = <table 1>,
        typedef = 1,
        typedname = "ns_msg",
        vars = {
          add = <function 658>,
          init = <function 659>,
          list = { {
              fpointer = 0,
              name = "*_msg, *_eom",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const u_char"
            }, {
              fpointer = 0,
              name = "_id, _flags, _counts[ns_s_max]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "u_int16_t"
            }, {
              fpointer = 0,
              name = "*_sections[ns_s_max]",
              pointer = 1,
              s = 0,
              t = 1,
              type = "const u_char"
            }, {
              fpointer = 0,
              name = "_sect",
              pointer = 0,
              s = 0,
              t = 0,
              type = "ns_sect"
            }, {
              fpointer = 0,
              name = "_rrnum",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*_msg_ptr",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const u_char"
            } },
          print = <function 660>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "nameser.h",
        linedef = 147,
        name = "__ns_rr",
        structs = <table 1>,
        typedef = 1,
        typedname = "ns_rr",
        vars = {
          add = <function 661>,
          init = <function 662>,
          list = { {
              fpointer = 0,
              name = "name[NS_MAXDNAME]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "type",
              pointer = 0,
              s = 0,
              t = 0,
              type = "u_int16_t"
            }, {
              fpointer = 0,
              name = "rr_class",
              pointer = 0,
              s = 0,
              t = 0,
              type = "u_int16_t"
            }, {
              fpointer = 0,
              name = "ttl",
              pointer = 0,
              s = 0,
              t = 0,
              type = "u_int32_t"
            }, {
              fpointer = 0,
              name = "rdlength",
              pointer = 0,
              s = 0,
              t = 0,
              type = "u_int16_t"
            }, {
              fpointer = 0,
              name = "*\trdata",
              pointer = 1,
              s = 0,
              t = 0,
              type = "const u_char"
            } },
          print = <function 663>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "nameser.h",
        linedef = 236,
        name = "ns_tsig_key",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 664>,
          init = <function 665>,
          list = { {
              fpointer = 0,
              name = "name[NS_MAXDNAME], alg[NS_MAXDNAME]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "char"
            }, {
              fpointer = 0,
              name = "*data",
              pointer = 1,
              s = 0,
              t = 0,
              type = "unsigned char"
            }, {
              fpointer = 0,
              name = "len",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 666>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "nameser.h",
        linedef = 247,
        name = "ns_tcp_tsig_state",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 667>,
          init = <function 668>,
          list = { {
              fpointer = 0,
              name = "counter",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "*key",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct dst_key"
            }, {
              fpointer = 0,
              name = "*ctx",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "sig[NS_PACKETSZ]",
              pointer = 0,
              s = 0,
              t = 1,
              type = "unsigned char"
            }, {
              fpointer = 0,
              name = "siglen",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            } },
          print = <function 669>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "time.h",
        linedef = 75,
        name = "tm",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 670>,
          init = <function 671>,
          list = { {
              fpointer = 0,
              name = "tm_sec",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "tm_min",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "tm_hour",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "tm_mday",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "tm_mon",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "tm_year",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "tm_wday",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "tm_yday",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "tm_isdst",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 0,
              name = "tm_gmtoff",
              pointer = 0,
              s = 0,
              t = 0,
              type = "long"
            }, {
              fpointer = 0,
              name = "*tm_zone",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            } },
          print = <function 672>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "cache.h",
        linedef = 402,
        name = "cache_attributes_s",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 673>,
          init = <function 674>,
          list = { {
              fpointer = 0,
              name = "version",
              pointer = 0,
              s = 0,
              t = 0,
              type = "uint32_t"
            }, {
              fpointer = 0,
              name = "key_hash_cb",
              pointer = 0,
              s = 0,
              t = 0,
              type = "cache_key_hash_cb_t"
            }, {
              fpointer = 0,
              name = "key_is_equal_cb",
              pointer = 0,
              s = 0,
              t = 0,
              type = "cache_key_is_equal_cb_t"
            }, {
              fpointer = 0,
              name = "key_retain_cb",
              pointer = 0,
              s = 0,
              t = 0,
              type = "cache_key_retain_cb_t"
            }, {
              fpointer = 0,
              name = "key_release_cb",
              pointer = 0,
              s = 0,
              t = 0,
              type = "cache_release_cb_t"
            }, {
              fpointer = 0,
              name = "value_release_cb",
              pointer = 0,
              s = 0,
              t = 0,
              type = "cache_release_cb_t"
            }, {
              fpointer = 0,
              name = "value_make_nonpurgeable_cb",
              pointer = 0,
              s = 0,
              t = 0,
              type = "cache_value_make_nonpurgeable_cb_t"
            }, {
              fpointer = 0,
              name = "value_make_purgeable_cb",
              pointer = 0,
              s = 0,
              t = 0,
              type = "cache_value_make_purgeable_cb_t"
            }, {
              fpointer = 0,
              name = "*user_data",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "value_retain_cb",
              pointer = 0,
              s = 0,
              t = 0,
              type = "cache_value_retain_cb_t"
            } },
          print = <function 675>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "expat.h",
        linedef = 137,
        name = "XML_cp",
        structs = <table 1>,
        typedef = 0,
        vars = {
          add = <function 676>,
          init = <function 677>,
          list = { {
              fpointer = 0,
              name = "type",
              pointer = 0,
              s = 0,
              t = 0,
              type = "enum XML_Content_Type"
            }, {
              fpointer = 0,
              name = "quant",
              pointer = 0,
              s = 0,
              t = 0,
              type = "enum XML_Content_Quant"
            }, {
              fpointer = 0,
              name = "*                    name",
              pointer = 1,
              s = 0,
              t = 0,
              type = "XML_Char"
            }, {
              fpointer = 0,
              name = "numchildren",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned int"
            }, {
              fpointer = 0,
              name = "*                 children",
              pointer = 1,
              s = 0,
              t = 0,
              type = "XML_Content"
            } },
          print = <function 678>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "mpool.h",
        linedef = 53,
        name = "_bkt",
        structs = <table 1>,
        typedef = 1,
        typedname = "BKT",
        vars = {
          add = <function 679>,
          init = <function 680>,
          list = { {
              fpointer = 0,
              name = "*page",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "pgno",
              pointer = 0,
              s = 0,
              t = 0,
              type = "pgno_t"
            }, {
              fpointer = 0,
              name = "flags",
              pointer = 0,
              s = 0,
              t = 0,
              type = "u_int8_t"
            } },
          print = <function 681>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "mpool.h",
        linedef = 64,
        name = "MPOOL",
        structs = <table 1>,
        typedef = 1,
        typedname = "MPOOL",
        vars = {
          add = <function 682>,
          init = <function 683>,
          list = { {
              fpointer = 0,
              name = "curcache",
              pointer = 0,
              s = 0,
              t = 0,
              type = "pgno_t"
            }, {
              fpointer = 0,
              name = "maxcache",
              pointer = 0,
              s = 0,
              t = 0,
              type = "pgno_t"
            }, {
              fpointer = 0,
              name = "npages",
              pointer = 0,
              s = 0,
              t = 0,
              type = "pgno_t"
            }, {
              fpointer = 0,
              name = "pagesize",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned long"
            }, {
              fpointer = 0,
              name = "fd",
              pointer = 0,
              s = 0,
              t = 0,
              type = "int"
            }, {
              fpointer = 1,
              name = "(*pgin)(void *, pgno_t, void *)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 1,
              name = "(*pgout)(void *, pgno_t, void *)",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "*pgcookie",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "cachehit",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned long"
            }, {
              fpointer = 0,
              name = "cachemiss",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned long"
            }, {
              fpointer = 0,
              name = "pagealloc",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned long"
            }, {
              fpointer = 0,
              name = "pageflush",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned long"
            }, {
              fpointer = 0,
              name = "pageget",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned long"
            }, {
              fpointer = 0,
              name = "pagenew",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned long"
            }, {
              fpointer = 0,
              name = "pageput",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned long"
            }, {
              fpointer = 0,
              name = "pageread",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned long"
            }, {
              fpointer = 0,
              name = "pagewrite",
              pointer = 0,
              s = 0,
              t = 0,
              type = "unsigned long"
            } },
          print = <function 684>,
          struct = <table 1>
        },
        write_new = <function 12>
      }, {
        header = "strhash.h",
        linedef = 40,
        name = "_node",
        structs = <table 1>,
        typedef = 1,
        typedname = "hash_node",
        vars = {
          add = <function 685>,
          init = <function 686>,
          list = { {
              fpointer = 0,
              name = "*key",
              pointer = 1,
              s = 0,
              t = 0,
              type = "char"
            }, {
              fpointer = 0,
              name = "*data",
              pointer = 1,
              s = 0,
              t = 0,
              type = "void"
            }, {
              fpointer = 0,
              name = "*next",
              pointer = 1,
              s = 1,
              t = 0,
              type = "struct _node"
            } },
          print = <function 687>,
          struct = <table 1>
        },
        write_new = <function 12>
      } },
    print = <function 688>
  },
  write_structs = <function 689>
}